#!/usr/bin/env python3
"""
Bandcamp Player - A standalone mini player for Bandcamp
Proof of concept using PyQt6 with QWebEngineView
"""

# Application version (update this when releasing)
__version__ = "2.0.0"

# Release name / edition label (optional)
__edition__ = "BeanbagBeni Edition"

import sys
import os
import subprocess
import json
import random
import math
import logging
import time
import webbrowser
from pathlib import Path
import urllib.request
import urllib.error
from urllib.parse import urlparse

# Windows-specific imports for media key support (safe import)
_HAS_CTYPES = False
if sys.platform == 'win32':
    try:
        import ctypes
        from ctypes import wintypes
        _HAS_CTYPES = True
    except ImportError:
        _HAS_CTYPES = False

# Note: Console window hiding is deferred until after initialization
# This ensures errors are visible if something fails early

# ============================================================================
# CONSTANTS
# ============================================================================

# Window constants
WINDOW_DEFAULT_WIDTH = 260
WINDOW_DEFAULT_HEIGHT = 640
WINDOW_MIN_WIDTH = 260
WINDOW_MIN_HEIGHT = 150
WINDOW_MAX_WIDTH = 260

# Playlist constants
PLAYLIST_MIN_HEIGHT = 100
PLAYLIST_MAX_HEIGHT = 600
PLAYLIST_DEFAULT_HEIGHT = 250

# Timer intervals (milliseconds)
PLAYBACK_CHECK_INTERVAL = 1000  # 1 second
ADDRESS_BAR_HIDE_DELAY = 150
ADDRESS_BAR_SHOW_DELAY = 600
OVERLAY_FADE_DURATION = 150
PAGE_FADE_DURATION = 150

# Animation durations (milliseconds)
LOADING_ANIMATION_DURATION = 1500
PULSE_ANIMATION_DURATION = 1500

# ============================================================================
# LOGGING SETUP
# ============================================================================

# Set up logging - wrap in try-except for Windows 10 compatibility
try:
    log_level = logging.DEBUG if os.environ.get('DEBUG') else logging.INFO
    
    # Create logs directory if it doesn't exist
    script_dir = Path(__file__).parent if __file__ else Path.cwd()
    logs_dir = script_dir / "Logs"
    logs_dir.mkdir(exist_ok=True)
    
    # Set up file handler for error logging
    log_file = logs_dir / "error_log.txt"
    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setLevel(logging.ERROR)  # Only log errors and above to file
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s\n%(pathname)s:%(lineno)d\n',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    file_handler.setFormatter(file_formatter)
    
    # Set up console handler (only if not in launcher mode or if console is available)
    # In launcher mode, console is freed, so stdout/stderr may be None
    launcher_mode = os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1'
    if not launcher_mode and sys.stdout and sys.stderr:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(log_level)
        console_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%H:%M:%S')
        console_handler.setFormatter(console_formatter)
        console_handler.stream = sys.stdout  # Explicitly set to stdout
    else:
        # In launcher mode or if stdout/stderr are None, skip console handler
        console_handler = None
    
    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    if console_handler:
        root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)
    
    logger = logging.getLogger(__name__)
except Exception as e:
    # If logging setup fails, create a basic logger
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    if not logger.handlers:
        # Only add console handler if stdout/stderr are available
        if sys.stdout and sys.stderr:
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
            logger.addHandler(handler)
    # Only print to stderr if it's available (not None after FreeConsole)
    if sys.stderr:
        try:
            print(f"Warning: Could not set up file logging: {e}", file=sys.stderr)
        except (AttributeError, OSError):
            pass  # stderr is None or not writable

# PyQt6 imports
from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
                              QPushButton, QLineEdit, QListWidget, QListWidgetItem,
                              QMenu, QSystemTrayIcon, QMessageBox, QSizePolicy,
                              QApplication, QLabel, QDialog, QTextEdit, QFrame,
                              QStyledItemDelegate, QStyleOptionViewItem, QStyleOptionButton, QToolTip, QSlider,
                              QFileDialog, QInputDialog, QWidgetAction, QSizeGrip)
from PyQt6.QtWebEngineWidgets import QWebEngineView
from PyQt6.QtWebEngineCore import QWebEnginePage, QWebEngineProfile, QWebEngineSettings
from PyQt6.QtCore import Qt, QUrl, pyqtSignal, QSize, QPoint, QPropertyAnimation, QEasingCurve, QTimer, pyqtProperty, QRect, QMimeData, QByteArray, QEvent, QThread, QAbstractNativeEventFilter, QObject
from PyQt6.QtNetwork import QLocalServer, QLocalSocket, QNetworkAccessManager, QNetworkRequest, QNetworkReply
from PyQt6.QtGui import QIcon, QAction, QKeySequence, QShortcut, QColor, QPainter, QBrush, QPen, QPainterPath, QConicalGradient, QRegion, QDragEnterEvent, QDropEvent, QTextCharFormat, QTextCursor, QTextFormat, QFont, QDesktopServices, QPixmap, QCursor, QFontMetrics, QScreen
from PyQt6.QtWidgets import QStyle
from PyQt6.QtWidgets import QGraphicsOpacityEffect
from PyQt6.QtWidgets import QGraphicsBlurEffect
from PyQt6.QtWidgets import QGraphicsDropShadowEffect

# ============================================================================
# FONTAWESOME ICONS
# ============================================================================
# FontAwesome icons via qtawesome library
# 
# ICON STYLES (FontAwesome 5):
#   - fa5.* = Solid (bold, filled) - most common
#   - fa5r.* = Regular (outline, lighter weight)
#   - fa5b.* = Brands (logos like GitHub, Twitter, etc.)
# 
# FINDING ICONS:
#   1. FontAwesome website: https://fontawesome.com/icons
#      - Search for icon name (e.g., "play", "trash", "cog")
#      - Click icon to see name (e.g., "play" icon = fa-play)
#      - Use with style prefix: fa5.play, fa5r.play, etc.
#   
#   2. qtawesome documentation: https://qtawesome.readthedocs.io/
#      - Lists available icon sets and names
#   
#   3. Common icons used in this app:
#      - fa5.cog (settings/gear)
#      - fa5.trash (delete)
#      - fa5.play (play)
#      - fa5.step-backward, fa5.step-forward (previous/next)
#      - fa5.random (shuffle)
#      - fa5.redo (repeat)
#      - fa5.paste, fa5.copy (clipboard)
#      - fa5.list (playlist)
#      - fa5.external-link-alt (open in browser)
#      - fa5.times (close/X)
#      - fa5.minus, fa5.square (minimize/maximize)
#      - fa5.thumbtack (pin/always on top)
# 
# PERFORMANCE:
#   - Icons are pre-loaded at startup to avoid delays
#   - Helper function get_icon() provides fallback to emojis
#   - If qtawesome fails, app gracefully falls back to emoji icons
# ============================================================================

# FontAwesome icons - auto-install if missing, detect after QApplication exists
try:
    import qtawesome as qta
    HAS_QT_AWESOME = True
    FA_PREFIX = None  # Will be detected lazily after QApplication is created
    _FA_PREFIX_DETECTED = False
except ImportError:
    HAS_QT_AWESOME = False
    FA_PREFIX = None
    _FA_PREFIX_DETECTED = False
    # Try to auto-install qtawesome
    try:
        logger.info("qtawesome not found - attempting automatic installation...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", "qtawesome>=1.2.0", "--quiet", "--disable-pip-version-check"])
        import qtawesome as qta
        HAS_QT_AWESOME = True
        logger.info("qtawesome installed successfully!")
    except Exception as e:
        logger.warning(f"Could not auto-install qtawesome: {e} - falling back to emoji icons")
        HAS_QT_AWESOME = False

def _detect_fontawesome_prefix():
    """Detect which FontAwesome version is available (call after QApplication exists)"""
    global FA_PREFIX, _FA_PREFIX_DETECTED
    
    if _FA_PREFIX_DETECTED or not HAS_QT_AWESOME:
        return FA_PREFIX
    
    # Check if QApplication exists
    try:
        from PyQt6.QtWidgets import QApplication
        app = QApplication.instance()
        if app is None:
            # QApplication not created yet - return None, will detect later
            return None
    except (AttributeError, TypeError, ValueError):
        return None
    
    # Now safe to detect - QApplication exists
    try:
        # Try FontAwesome 5 solid first
        try:
            test_icon = qta.icon('fa5s.cog')
            FA_PREFIX = 'fa5s'
            logger.info("Detected FontAwesome 5 solid (fa5s)")
            _FA_PREFIX_DETECTED = True
            return FA_PREFIX
        except Exception as e:
            logger.debug(f"fa5s not available: {e}")
            # Try FontAwesome 5 regular
            try:
                test_icon = qta.icon('fa5.cog')
                FA_PREFIX = 'fa5'
                logger.info("Detected FontAwesome 5 (fa5)")
                _FA_PREFIX_DETECTED = True
                return FA_PREFIX
            except Exception as e:
                logger.debug(f"fa5 not available: {e}")
                # Fall back to FontAwesome 4
                try:
                    test_icon = qta.icon('fa.cog')
                    FA_PREFIX = 'fa'
                    logger.info("Detected FontAwesome 4 (fa)")
                    _FA_PREFIX_DETECTED = True
                    return FA_PREFIX
                except Exception as e:
                    logger.warning(f"Could not detect FontAwesome version: {e} - using 'fa' as fallback")
                    FA_PREFIX = 'fa'  # Default fallback
                    _FA_PREFIX_DETECTED = True
                    return FA_PREFIX
    except Exception as e:
        logger.warning(f"Error detecting FontAwesome prefix: {e}")
        FA_PREFIX = 'fa'  # Default fallback
        _FA_PREFIX_DETECTED = True
        return FA_PREFIX

# Helper function for faster icon creation (with caching)
def get_icon(icon_name, color='#e0e0e0'):
    """Get FontAwesome icon with fallback to emoji
    
    Returns QIcon if successful, None if not available.
    Always check HAS_QT_AWESOME before calling setIcon() with the result.
    """
    if not HAS_QT_AWESOME:
        return None
    
    # Detect prefix if not already detected (lazy detection after QApplication exists)
    if not _FA_PREFIX_DETECTED:
        _detect_fontawesome_prefix()
    
    if not FA_PREFIX:
        return None
    
    try:
        # If icon_name already has a prefix (fa, mdi, ph, msc, ei, etc.), use it as-is
        if '.' in icon_name and (icon_name.startswith('fa') or icon_name.startswith('mdi') or icon_name.startswith('ph') or icon_name.startswith('msc') or icon_name.startswith('ei')):
            # Already has prefix, use as-is
            full_name = icon_name
        else:
            # No prefix, add detected prefix
            full_name = f'{FA_PREFIX}.{icon_name}'
        icon = qta.icon(full_name, color=color)
        if icon and not icon.isNull():
            return icon
        else:
            logger.debug(f"Icon {full_name} returned null or empty")
            # Try with 'fa' prefix as fallback (only for non-prefixed icons)
            if FA_PREFIX != 'fa' and not ('.' in icon_name and (icon_name.startswith('fa') or icon_name.startswith('mdi') or icon_name.startswith('ph') or icon_name.startswith('msc') or icon_name.startswith('ei'))):
                try:
                    fallback_icon = qta.icon(f'fa.{icon_name}', color=color)
                    if fallback_icon and not fallback_icon.isNull():
                        return fallback_icon
                except:
                    pass
            return None
    except Exception as e:
        logger.debug(f"Failed to create icon {icon_name} with prefix {FA_PREFIX}: {e}")
        # Try with 'fa' prefix as fallback (only for non-prefixed icons)
        if FA_PREFIX != 'fa' and not ('.' in icon_name and (icon_name.startswith('fa') or icon_name.startswith('mdi') or icon_name.startswith('ph') or icon_name.startswith('msc') or icon_name.startswith('ei'))):
            try:
                fallback_icon = qta.icon(f'fa.{icon_name}', color=color)
                if fallback_icon and not fallback_icon.isNull():
                    return fallback_icon
            except:
                pass
        return None

def safe_getattr(obj, attr_name, default=None):
    """Safely get attribute from object, returning default if not found or None.
    
    This is a convenience function to reduce hasattr() usage patterns.
    Use this when you want to check if an attribute exists and is not None.
    
    Args:
        obj: Object to get attribute from
        attr_name: Name of attribute to get
        default: Default value if attribute doesn't exist or is None
        
    Returns:
        Attribute value if it exists and is not None, otherwise default
    """
    try:
        value = getattr(obj, attr_name, default)
        return value if value is not None else default
    except (AttributeError, TypeError):
        return default

def set_icon_safe(widget, icon_name, color='#e0e0e0', fallback_text=None):
    """Safely set icon on widget, falling back to text if icon fails"""
    if HAS_QT_AWESOME:
        icon = get_icon(icon_name, color=color)
        if icon:
            widget.setIcon(icon)
            return True
    # Fallback to text if icon not available
    if fallback_text:
        widget.setText(fallback_text)
    return False

# Required Python version
REQUIRED_PYTHON_VERSION = (3, 11, 6)


# ============================================================================
# CSS INJECTOR CLASS
# ============================================================================

class CSSInjector:
    """Handles CSS injection for compact and bandcamp modes"""
    
    def __init__(self):
        # Lazy load CSS - only generate when first needed
        self._base_css = None
        self._compact_css = None
        self._dark_css = None
        self._bandcamp_css = None
        self._mini_mode_css = None
    
    def get_css(self, compact=False, bandcamp_mode=False, mini_mode_state=0, webview_scrollbar_visible=False):
        """Get combined CSS based on modes (lazy-loaded)
        
        Args:
            compact: Enable compact mode
            bandcamp_mode: Enable bandcamp mode
            mini_mode_state: 0 = Regular, 1 = Mini (cover art), 2 = Micro (player only)
            webview_scrollbar_visible: Show minimalist scrollbar in webview
        """
        # Lazy load CSS only when needed
        if self._base_css is None:
            self._base_css = self.get_base_css()
        if self._compact_css is None:
            self._compact_css = self.get_compact_css()
        if self._bandcamp_css is None:
            self._bandcamp_css = self.get_bandcamp_css()
        if self._mini_mode_css is None:
            self._mini_mode_css = self.get_mini_mode_css()
        
        css_parts = [self._base_css]
        
        if bandcamp_mode:
            css_parts.append(self._bandcamp_css)
        
        if compact:
            css_parts.append(self._compact_css)
        
        # Add mini mode CSS based on state
        if mini_mode_state == 1:
            # Mini mode: overlay player on cover art
            css_parts.append(self._mini_mode_css)
        elif mini_mode_state == 2:
            # Micro mode: show only player
            css_parts.append(self._mini_mode_css)
        
        # Add scrollbar CSS based on setting
        if webview_scrollbar_visible:
            css_parts.append(self._get_scrollbar_css())
        else:
            css_parts.append(self._get_hidden_scrollbar_css())
        
        return "\n\n".join(css_parts)
    
    def get_base_css(self):
        """Base CSS for enhanced button interactions and hover effects"""
        return """
/* Disable text and image selection in web interface */
* {
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
}

/* Disable image dragging */
img {
    -webkit-user-drag: none !important;
    -khtml-user-drag: none !important;
    -moz-user-drag: none !important;
    -o-user-drag: none !important;
    user-drag: none !important;
    pointer-events: auto !important; /* Keep images clickable but not draggable */
}

/* Allow selection in input fields and textareas for functionality */
input, textarea, [contenteditable="true"], [contenteditable="true"] * {
    -webkit-user-select: text !important;
    -moz-user-select: text !important;
    -ms-user-select: text !important;
    user-select: text !important;
}

/* Cover Art Modal - ensure it works on both light and dark pages */
#bandcamp-player-cover-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 10000 !important;
    cursor: pointer;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    /* Ensure modal is always on top, regardless of page type */
    pointer-events: auto !important;
}

/* Ensure modal works correctly on dark pages */
body.dark-page #bandcamp-player-cover-modal,
body:not(.light-page) #bandcamp-player-cover-modal {
    z-index: 10000 !important;
    position: fixed !important;
    pointer-events: auto !important;
}

#bandcamp-player-cover-modal.active {
    display: flex !important;
    z-index: 10000 !important;
    position: fixed !important;
    pointer-events: auto !important;
}

/* Ensure active modal works on dark pages */
body.dark-page #bandcamp-player-cover-modal.active,
body:not(.light-page) #bandcamp-player-cover-modal.active {
    display: flex !important;
    z-index: 10000 !important;
    position: fixed !important;
    pointer-events: auto !important;
}

#bandcamp-player-cover-modal-content {
    max-width: 90vw;
    max-height: 90vh;
    object-fit: contain;
    cursor: zoom-in;
    pointer-events: auto !important;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    border-radius: 4px;
    transition: transform 0.1s ease-out;
    transform-origin: center center;
    /* Ensure image is visible on both light and dark pages */
    z-index: 10001 !important;
    position: relative !important;
}

/* Ensure modal content works on dark pages */
body.dark-page #bandcamp-player-cover-modal-content,
body:not(.light-page) #bandcamp-player-cover-modal-content {
    pointer-events: auto !important;
    z-index: 10001 !important;
    position: relative !important;
}

#bandcamp-player-cover-modal-close {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    color: white;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    z-index: 10002 !important;
    pointer-events: auto !important;
}

/* Ensure close button works on dark pages */
body.dark-page #bandcamp-player-cover-modal-close,
body:not(.light-page) #bandcamp-player-cover-modal-close {
    z-index: 10002 !important;
    pointer-events: auto !important;
    position: absolute !important;
}

#bandcamp-player-cover-modal-close:hover {
    background-color: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
    transform: scale(1.1);
}

/* Make cover art clickable - ensure it works on both light and dark pages */
#tralbum-art-carousel,
#tralbum-art-carousel img,
.tralbum-art-carousel-container,
.tralbum-art-carousel-container img {
    cursor: zoom-in !important;
    pointer-events: auto !important;
}

/* Ensure cover art is clickable on dark pages */
body.dark-page #tralbum-art-carousel,
body.dark-page #tralbum-art-carousel img,
body.dark-page .tralbum-art-carousel-container,
body.dark-page .tralbum-art-carousel-container img,
body:not(.light-page) #tralbum-art-carousel,
body:not(.light-page) #tralbum-art-carousel img,
body:not(.light-page) .tralbum-art-carousel-container,
body:not(.light-page) .tralbum-art-carousel-container img {
    cursor: zoom-in !important;
    pointer-events: auto !important;
}

/* Disable zoom-in cursor when menu or volume popup is open */
#tralbum-art-carousel.cursor-disabled,
#tralbum-art-carousel.cursor-disabled img,
.tralbum-art-carousel-container.cursor-disabled,
.tralbum-art-carousel-container.cursor-disabled img {
    cursor: default !important;
}

/* Enhanced Button Hover Styles - only for actually clickable/interactive elements */
.play-btn, .pause-btn, .next-btn, .prev-btn,
.play_cell, .pause_cell, .next_cell, .prev_cell,
.playbutton, .prevbutton, .nextbutton,
.playButton, .prevButton, .nextButton,
button[title*="play"], button[title*="Play"],
button[title*="pause"], button[title*="Pause"],
button[title*="next"], button[title*="Next"],
button[title*="previous"], button[title*="Previous"],
.player-controls button,
.transport-controls button,
.control-button,
[class*="play"]:not([class*="track"]):not([class*="Track"]), 
[class*="Play"]:not([class*="track"]):not([class*="Track"]),
[class*="pause"]:not([class*="track"]):not([class*="Track"]), 
[class*="Pause"]:not([class*="track"]):not([class*="Track"]),
[class*="next"]:not([class*="track"]):not([class*="Track"]), 
[class*="Next"]:not([class*="track"]):not([class*="Track"]),
[class*="prev"]:not([class*="track"]):not([class*="Track"]), 
[class*="Prev"]:not([class*="track"]):not([class*="Track"]),
.clickable, .interactive, .hoverable,
[onclick], [role="button"],
.inline_player .playbutton,
.progbar, .time_elapsed, .time_total,
.prev_button, .next_button, .play_pause_button,
a, button, input[type="button"], input[type="submit"] {
    cursor: pointer !important;
    transition: all 0.2s ease !important;
}

/* Tracks are clickable, so they get pointer cursor */
.track, .tracklist-item, .playlist-item,
.track-item, .song-item, .music-item,
.track_row_view, .track_list .track,
.scrobbler-track, .lastfm-track {
    cursor: pointer !important;
    transition: all 0.2s ease !important;
}

/* Hover effects - subtle, no zoom */
.play-btn:hover, .pause-btn:hover, .next-btn:hover, .prev-btn:hover,
.play_cell:hover, .pause_cell:hover, .next_cell:hover, .prev_cell:hover,
.playbutton:hover, .prevbutton:hover, .nextbutton:hover,
.playButton:hover, .prevButton:hover, .nextButton:hover,
button[title*="play"]:hover, button[title*="Play"]:hover,
button[title*="pause"]:hover, button[title*="Pause"]:hover,
button[title*="next"]:hover, button[title*="Next"]:hover,
button[title*="previous"]:hover, button[title*="Previous"]:hover,
.player-controls button:hover,
.transport-controls button:hover,
.control-button:hover,
[class*="play"]:hover, [class*="Play"]:hover,
[class*="pause"]:hover, [class*="Pause"]:hover,
[class*="next"]:hover, [class*="Next"]:hover,
[class*="prev"]:hover, [class*="Prev"]:hover {
    opacity: 0.9 !important;
    filter: brightness(1.1) !important;
}

/* Override body hover effects - prevent unwanted opacity/brightness changes */
/* Place AFTER other hover rules and use high specificity to ensure these rules always apply */
html body:hover,
body:hover,
body[class]:hover,
body[class*="webkit"]:hover,
body[class*="safari"]:hover,
body[class*="safariLte14"]:hover,
body[class*="tralbum"]:hover,
body[class*="tralbum-page"]:hover,
body[class*="dynamic"]:hover,
body[class*="dynamic-cart"]:hover,
body[class*="enable"]:hover,
body[class*="enable-cookie-control"]:hover,
body[class*="vue"]:hover,
body[class*="vue-prevent-scroll"]:hover,
body[class*="light"]:hover,
body[class*="light-page"]:hover {
    opacity: 1 !important;
    filter: brightness(1) !important;
}

/* Remove pointer cursor from body to allow native cursor states */
/* Place AFTER other cursor rules and use high specificity to ensure this rule always applies */
html body,
body,
body[class],
body[class*="webkit"],
body[class*="safari"],
body[class*="safariLte14"],
body[class*="tralbum"],
body[class*="tralbum-page"],
body[class*="dynamic"],
body[class*="dynamic-cart"],
body[class*="enable"],
body[class*="enable-cookie-control"],
body[class*="vue"],
body[class*="vue-prevent-scroll"],
body[class*="light"],
body[class*="light-page"] {
    cursor: default !important;
}

/* Prevent tracklist container from highlighting on hover */
#tracklist:hover,
.tracklist:hover,
[class*="tracklist"]:hover:not([class*="track"]):not([class*="item"]) {
    background-color: transparent !important;
    backdrop-filter: none !important;
}

/* Playlist/track item hover effects - only for individual tracks */
.track:hover,
.tracklist-item:hover,
.playlist-item:hover,
.track-item:hover,
.song-item:hover,
.music-item:hover,
.scrobbler-track:hover,
.lastfm-track:hover,
.track_row_view:hover,
.track_list .track:hover,
[class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks),
[class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks),
[class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks),
[class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks) {
    background-color: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    /* Use pseudo-element for full-width background to avoid affecting content position */
    position: relative !important;
}

/* Full-width hover background using pseudo-element - keeps content in place */
.track:hover::before,
.tracklist-item:hover::before,
.playlist-item:hover::before,
.track-item:hover::before,
.song-item:hover::before,
.music-item:hover::before,
.scrobbler-track:hover::before,
.lastfm-track:hover::before,
.track_row_view:hover::before,
.track_list .track:hover::before,
[class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
[class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
[class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
[class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before {
    content: '' !important;
    position: absolute !important;
    top: 0 !important;
    /* Base track has margin-left: 2px, so extend 22px left (2px margin + 20px extension) to reach container edge */
    left: -22px !important;
    /* Extend all the way to the right edge - account for margin-right: -2px */
    right: 0px !important;
    bottom: 0 !important;
    background-color: rgba(255, 255, 255, 0.05) !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    z-index: -1 !important;
    pointer-events: none !important;
}

/* Base track styles - applied in all modes */
.track, .tracklist-item {
    padding: 4px 0px 4px 5px !important;
    margin: 2px -2px 0px 2px !important;
}

/* Ensure track-num doesn't inherit or get affected by parent padding/margin */
.track .track-num,
.track .track-number,
.tracklist-item .track-num,
.tracklist-item .track-number,
[class*="track"] .track-num:not([class*="tracklist"]),
[class*="track"] .track-number:not([class*="tracklist"]) {
    padding: 0 !important;
    margin: 0 !important;
    margin-right: 8px !important; /* Add space between track number and track name */
    position: relative !important;
    transform: none !important;
    transition: none !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
    white-space: nowrap !important; /* Prevent track number from wrapping */
    display: inline-block !important; /* Ensure it stays inline */
}

/* Ensure track-num doesn't move when parent track is hovered */
.track:hover .track-num,
.track:hover .track-number,
.tracklist-item:hover .track-num,
.tracklist-item:hover .track-number,
[class*="track"]:hover .track-num:not([class*="tracklist"]),
[class*="track"]:hover .track-number:not([class*="tracklist"]) {
    padding: 0 !important;
    margin: 0 !important;
    margin-right: 8px !important; /* Maintain spacing */
    position: relative !important;
    transform: none !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
    white-space: nowrap !important; /* Prevent track number from wrapping */
    display: inline-block !important; /* Ensure it stays inline */
}

/* Disable all hover effects on track numbers in the player (all modes) */
#player .track-number:hover,
#player .track-num:hover,
#player:hover .track-number,
#player:hover .track-num,
.player-container .track-number:hover,
.player-container .track-num:hover,
.player-container:hover .track-number,
.player-container:hover .track-num,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-number,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-num {
    background-color: transparent !important;
    background: transparent !important;
    color: inherit !important;
    opacity: 1 !important;
    filter: none !important;
    transform: none !important;
    padding: 0 !important;
    margin: 0 !important;
    margin-right: 8px !important;
    border: none !important;
    box-shadow: none !important;
    text-decoration: none !important;
    transition: none !important;
}

/* Prevent track-action button from moving on hover */
.track .track-action,
.track button.track-action,
.tracklist-item .track-action,
.tracklist-item button.track-action,
[class*="track"] .track-action:not([class*="tracklist"]),
[class*="track"] button.track-action:not([class*="tracklist"]) {
    position: relative !important;
    margin: 0 !important;
    padding: 0 !important;
    transform: none !important;
    transition: none !important;
}

/* Ensure track-action doesn't move when parent track is hovered */
.track:hover .track-action,
.track:hover button.track-action,
.tracklist-item:hover .track-action,
.tracklist-item:hover button.track-action,
[class*="track"]:hover .track-action:not([class*="tracklist"]),
[class*="track"]:hover button.track-action:not([class*="tracklist"]) {
    position: relative !important;
    margin: 0 !important;
    padding: 0 !important;
    transform: none !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
}

/* Disable hover effects for track-info elements */
.track-info:hover,
.track-info:focus,
.track-info:focus-within {
    background-color: transparent !important;
    backdrop-filter: none !important;
    border-radius: 0 !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
}

/* Currently playing track highlighting */
.track.playing, .tracklist-item.playing, .playlist-item.playing,
.track-item.playing, .song-item.playing, .music-item.playing,
.track.current, .tracklist-item.current, .playlist-item.current,
.track-item.current, .song-item.current, .music-item.current,
.track.active, .tracklist-item.active, .playlist-item.active,
.track-item.active, .song-item.active, .music-item.active,
[class*="track"].playing, [class*="Track"].playing,
[class*="song"].playing, [class*="Song"].playing,
[class*="track"].current, [class*="Track"].current,
[class*="song"].current, [class*="Song"].current,
[class*="track"].active, [class*="Track"].active,
[class*="song"].active, [class*="Song"].active,
.track_row_view.playing, .track_list .track.playing,
.scrobbler-track.playing, .lastfm-track.playing,
[aria-current="true"], [data-playing="true"],
.now-playing, .currently-playing, .is-playing {
    position: relative !important;
    background-color: transparent !important;
    background: transparent !important;
    /* Keep content in place - don't change padding/margin */
}

/* Full-width highlight background for currently playing track using pseudo-element */
.track.playing::before, .tracklist-item.playing::before, .playlist-item.playing::before,
.track-item.playing::before, .song-item.playing::before, .music-item.playing::before,
.track.current::before, .tracklist-item.current::before, .playlist-item.current::before,
.track-item.current::before, .song-item.current::before, .music-item.current::before,
.track.active::before, .tracklist-item.active::before, .playlist-item.active::before,
.track-item.active::before, .song-item.active::before, .music-item.active::before,
[class*="track"].playing::before, [class*="Track"].playing::before,
[class*="song"].playing::before, [class*="Song"].playing::before,
[class*="track"].current::before, [class*="Track"].current::before,
[class*="song"].current::before, [class*="Song"].current::before,
[class*="track"].active::before, [class*="Track"].active::before,
[class*="song"].active::before, [class*="Song"].active::before,
.track_row_view.playing::before, .track_list .track.playing::before,
.scrobbler-track.playing::before, .lastfm-track.playing::before,
[aria-current="true"]::before, [data-playing="true"]::before,
.now-playing::before, .currently-playing::before, .is-playing::before {
    content: '' !important;
    position: absolute !important;
    top: 0 !important;
    /* Extend to full viewport width: left edge at viewport left, width spans full viewport */
    left: calc(-50vw + 50%) !important;
    width: 100vw !important;
    height: 100% !important;
    background: linear-gradient(90deg, 
        rgba(255, 215, 0, 0.15) 0%, 
        rgba(255, 215, 0, 0.08) 50%, 
        rgba(255, 215, 0, 0.15) 100%) !important;
    border-left: 3px solid rgba(255, 215, 0, 0.6) !important;
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.2) !important;
    border-radius: 4px !important;
    animation: currentTrackPulse 2s ease-in-out infinite alternate !important;
    z-index: 0 !important;
    pointer-events: none !important;
}

@keyframes currentTrackPulse {
    0% { 
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.2) !important;
    }
    100% { 
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.4) !important;
    }
}

/* Darker hover and currently playing track styles for light-colored pages */
/* Uses .light-page class added by JavaScript detection - applies to ALL modes (regular, mini, micro) */
body.light-page .track:hover::before,
body.light-page.mini-mode .track:hover::before,
body.light-page.micro-mode .track:hover::before,
body.light-page .tracklist-item:hover::before,
body.light-page.mini-mode .tracklist-item:hover::before,
body.light-page.micro-mode .tracklist-item:hover::before,
body.light-page .playlist-item:hover::before,
body.light-page.mini-mode .playlist-item:hover::before,
body.light-page.micro-mode .playlist-item:hover::before,
body.light-page .track-item:hover::before,
body.light-page.mini-mode .track-item:hover::before,
body.light-page.micro-mode .track-item:hover::before,
body.light-page .song-item:hover::before,
body.light-page.mini-mode .song-item:hover::before,
body.light-page.micro-mode .song-item:hover::before,
body.light-page .music-item:hover::before,
body.light-page.mini-mode .music-item:hover::before,
body.light-page.micro-mode .music-item:hover::before,
body.light-page .scrobbler-track:hover::before,
body.light-page.mini-mode .scrobbler-track:hover::before,
body.light-page.micro-mode .scrobbler-track:hover::before,
body.light-page .lastfm-track:hover::before,
body.light-page.mini-mode .lastfm-track:hover::before,
body.light-page.micro-mode .lastfm-track:hover::before,
body.light-page .track_row_view:hover::before,
body.light-page.mini-mode .track_row_view:hover::before,
body.light-page.micro-mode .track_row_view:hover::before,
body.light-page .track_list .track:hover::before,
body.light-page.mini-mode .track_list .track:hover::before,
body.light-page.micro-mode .track_list .track:hover::before,
body.light-page [class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.mini-mode [class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.micro-mode [class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page [class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.mini-mode [class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.micro-mode [class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page [class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.mini-mode [class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.micro-mode [class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page [class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.mini-mode [class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.micro-mode [class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before {
    background-color: rgba(0, 0, 0, 0.15) !important;
}

/* Darker currently playing track for light pages - applies to ALL modes (regular, mini, micro) */
body.light-page .track.playing::before,
body.light-page.mini-mode .track.playing::before,
body.light-page.micro-mode .track.playing::before,
body.light-page .tracklist-item.playing::before,
body.light-page.mini-mode .tracklist-item.playing::before,
body.light-page.micro-mode .tracklist-item.playing::before,
body.light-page .playlist-item.playing::before,
body.light-page.mini-mode .playlist-item.playing::before,
body.light-page.micro-mode .playlist-item.playing::before,
body.light-page .track-item.playing::before,
body.light-page.mini-mode .track-item.playing::before,
body.light-page.micro-mode .track-item.playing::before,
body.light-page .song-item.playing::before,
body.light-page.mini-mode .song-item.playing::before,
body.light-page.micro-mode .song-item.playing::before,
body.light-page .music-item.playing::before,
body.light-page.mini-mode .music-item.playing::before,
body.light-page.micro-mode .music-item.playing::before,
body.light-page .track.current::before,
body.light-page.mini-mode .track.current::before,
body.light-page.micro-mode .track.current::before,
body.light-page .tracklist-item.current::before,
body.light-page.mini-mode .tracklist-item.current::before,
body.light-page.micro-mode .tracklist-item.current::before,
body.light-page .playlist-item.current::before,
body.light-page.mini-mode .playlist-item.current::before,
body.light-page.micro-mode .playlist-item.current::before,
body.light-page .track-item.current::before,
body.light-page.mini-mode .track-item.current::before,
body.light-page.micro-mode .track-item.current::before,
body.light-page .song-item.current::before,
body.light-page.mini-mode .song-item.current::before,
body.light-page.micro-mode .song-item.current::before,
body.light-page .music-item.current::before,
body.light-page.mini-mode .music-item.current::before,
body.light-page.micro-mode .music-item.current::before,
body.light-page .track.active::before,
body.light-page.mini-mode .track.active::before,
body.light-page.micro-mode .track.active::before,
body.light-page .tracklist-item.active::before,
body.light-page.mini-mode .tracklist-item.active::before,
body.light-page.micro-mode .tracklist-item.active::before,
body.light-page .playlist-item.active::before,
body.light-page.mini-mode .playlist-item.active::before,
body.light-page.micro-mode .playlist-item.active::before,
body.light-page .track-item.active::before,
body.light-page.mini-mode .track-item.active::before,
body.light-page.micro-mode .track-item.active::before,
body.light-page .song-item.active::before,
body.light-page.mini-mode .song-item.active::before,
body.light-page.micro-mode .song-item.active::before,
body.light-page .music-item.active::before,
body.light-page.mini-mode .music-item.active::before,
body.light-page.micro-mode .music-item.active::before,
body.light-page [class*="track"].playing::before,
body.light-page.mini-mode [class*="track"].playing::before,
body.light-page.micro-mode [class*="track"].playing::before,
body.light-page [class*="Track"].playing::before,
body.light-page.mini-mode [class*="Track"].playing::before,
body.light-page.micro-mode [class*="Track"].playing::before,
body.light-page [class*="song"].playing::before,
body.light-page.mini-mode [class*="song"].playing::before,
body.light-page.micro-mode [class*="song"].playing::before,
body.light-page [class*="Song"].playing::before,
body.light-page.mini-mode [class*="Song"].playing::before,
body.light-page.micro-mode [class*="Song"].playing::before,
body.light-page [class*="track"].current::before,
body.light-page.mini-mode [class*="track"].current::before,
body.light-page.micro-mode [class*="track"].current::before,
body.light-page [class*="Track"].current::before,
body.light-page.mini-mode [class*="Track"].current::before,
body.light-page.micro-mode [class*="Track"].current::before,
body.light-page [class*="song"].current::before,
body.light-page.mini-mode [class*="song"].current::before,
body.light-page.micro-mode [class*="song"].current::before,
body.light-page [class*="Song"].current::before,
body.light-page.mini-mode [class*="Song"].current::before,
body.light-page.micro-mode [class*="Song"].current::before,
body.light-page [class*="track"].active::before,
body.light-page.mini-mode [class*="track"].active::before,
body.light-page.micro-mode [class*="track"].active::before,
body.light-page [class*="Track"].active::before,
body.light-page.mini-mode [class*="Track"].active::before,
body.light-page.micro-mode [class*="Track"].active::before,
body.light-page [class*="song"].active::before,
body.light-page.mini-mode [class*="song"].active::before,
body.light-page.micro-mode [class*="song"].active::before,
body.light-page [class*="Song"].active::before,
body.light-page.mini-mode [class*="Song"].active::before,
body.light-page.micro-mode [class*="Song"].active::before,
body.light-page .track_row_view.playing::before,
body.light-page.mini-mode .track_row_view.playing::before,
body.light-page.micro-mode .track_row_view.playing::before,
body.light-page .track_list .track.playing::before,
body.light-page.mini-mode .track_list .track.playing::before,
body.light-page.micro-mode .track_list .track.playing::before,
body.light-page .scrobbler-track.playing::before,
body.light-page.mini-mode .scrobbler-track.playing::before,
body.light-page.micro-mode .scrobbler-track.playing::before,
body.light-page .lastfm-track.playing::before,
body.light-page.mini-mode .lastfm-track.playing::before,
body.light-page.micro-mode .lastfm-track.playing::before,
body.light-page [aria-current="true"]::before,
body.light-page.mini-mode [aria-current="true"]::before,
body.light-page.micro-mode [aria-current="true"]::before,
body.light-page [data-playing="true"]::before,
body.light-page.mini-mode [data-playing="true"]::before,
body.light-page.micro-mode [data-playing="true"]::before,
body.light-page .now-playing::before,
body.light-page.mini-mode .now-playing::before,
body.light-page.micro-mode .now-playing::before,
body.light-page .currently-playing::before,
body.light-page.mini-mode .currently-playing::before,
body.light-page.micro-mode .currently-playing::before,
body.light-page .is-playing::before,
body.light-page.mini-mode .is-playing::before,
body.light-page.micro-mode .is-playing::before {
    background: linear-gradient(90deg, 
        rgba(255, 165, 0, 0.35) 0%, 
        rgba(255, 165, 0, 0.25) 50%, 
        rgba(255, 165, 0, 0.35) 100%) !important;
    border-left: 3px solid rgba(255, 140, 0, 0.8) !important;
    box-shadow: 0 0 10px rgba(255, 140, 0, 0.4) !important;
    animation: currentTrackPulseLight 2s ease-in-out infinite alternate !important;
}

/* Darker pulse animation for light pages */
@keyframes currentTrackPulseLight {
    0% { 
        box-shadow: 0 0 10px rgba(255, 140, 0, 0.4) !important;
    }
    100% { 
        box-shadow: 0 0 15px rgba(255, 140, 0, 0.6) !important;
    }
}

/* Progress bar hover effects */
.progbar:hover, .progress-bar:hover, .seek-bar:hover,
[class*="progress"]:hover, [class*="Progress"]:hover,
[class*="seek"]:hover, [class*="Seek"]:hover {
    cursor: pointer !important;
    filter: brightness(1.3) !important;
}

/* Disable "Go to track page" disclose links - keep visible but not clickable */
a.disclose,
a[class*="disclose"],
a[aria-label*="Go to track page"],
a[aria-label*="go to track page"],
a[href*="/track/"].disclose {
    pointer-events: none !important;
    cursor: default !important;
    opacity: 0.5 !important; /* Make it visually distinct that it's disabled */
}

/* Make disclose arrow darker on light pages for better contrast - applies to ALL modes (regular, mini, micro) */
body.light-page a.disclose,
body.light-page.mini-mode a.disclose,
body.light-page.micro-mode a.disclose,
body.light-page a[class*="disclose"],
body.light-page.mini-mode a[class*="disclose"],
body.light-page.micro-mode a[class*="disclose"],
body.light-page a[aria-label*="Go to track page"],
body.light-page.mini-mode a[aria-label*="Go to track page"],
body.light-page.micro-mode a[aria-label*="Go to track page"],
body.light-page a[aria-label*="go to track page"],
body.light-page.mini-mode a[aria-label*="go to track page"],
body.light-page.micro-mode a[aria-label*="go to track page"],
body.light-page a[href*="/track/"].disclose,
body.light-page.mini-mode a[href*="/track/"].disclose,
body.light-page.micro-mode a[href*="/track/"].disclose,
body.light-page a.disclose .goto-icon,
body.light-page.mini-mode a.disclose .goto-icon,
body.light-page.micro-mode a.disclose .goto-icon,
body.light-page a.disclose svg,
body.light-page.mini-mode a.disclose svg,
body.light-page.micro-mode a.disclose svg,
body.light-page a[class*="disclose"] .goto-icon,
body.light-page.mini-mode a[class*="disclose"] .goto-icon,
body.light-page.micro-mode a[class*="disclose"] .goto-icon,
body.light-page a[class*="disclose"] svg,
body.light-page.mini-mode a[class*="disclose"] svg,
body.light-page.micro-mode a[class*="disclose"] svg {
    opacity: 0.7 !important; /* Slightly more visible on light pages */
    filter: brightness(0) !important; /* Make it black/dark instead of white */
}

/* Hide disclose link icon for currently playing track */
.track.playing a.disclose,
.track.playing a[class*="disclose"],
.track.playing a[aria-label*="Go to track page"],
.track.playing a[aria-label*="go to track page"],
.track.playing a[href*="/track/"].disclose,
.tracklist-item.playing a.disclose,
.tracklist-item.playing a[class*="disclose"],
.tracklist-item.playing a[aria-label*="Go to track page"],
.tracklist-item.playing a[aria-label*="go to track page"],
.tracklist-item.playing a[href*="/track/"].disclose,
[class*="track"].playing a.disclose,
[class*="track"].playing a[class*="disclose"],
[class*="track"].playing a[aria-label*="Go to track page"],
[class*="track"].playing a[aria-label*="go to track page"],
[class*="track"].playing a[href*="/track/"].disclose {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    width: 0 !important;
    height: 0 !important;
    overflow: hidden !important;
}
"""
    
    def get_compact_css(self):
        """CSS for compact mode - hides non-essential elements"""
        return """
/* Compact Mode - Hide non-essential elements */
.header, .site-header, .page-header,
.footer, .site-footer, .page-footer,
.sidebar, .navigation, nav,
.comments, .comment-section,
.share-buttons, .social-share,
.related-albums, .recommendations,
.bio, .artist-bio, .description-text {
    display: none !important;
}

/* Compact player controls */
.inline_player, .player-container {
    padding: 5px !important;
    margin: 5px !important;
}

/* Reduce spacing */
.track, .tracklist-item {
    padding: 4px 0px 4px 5px !important;
    margin: 2px -2px 0px 2px !important;
}

/* Compact album art */
.album-art, .cover-art, img[class*="art"] {
    max-width: 100px !important;
    max-height: 100px !important;
}
"""
    
    def get_dark_css(self):
        """CSS for dark mode"""
        return """
/* Dark Mode */
body, html {
    background-color: #1a1a1a !important;
    color: #e0e0e0 !important;
}

/* Dark backgrounds */
.container, .content, .main-content,
.album, .track-list, .playlist {
    background-color: #1a1a1a !important;
    color: #e0e0e0 !important;
}

/* Dark cards/panels */
.card, .panel, .box, .item {
    background-color: #2a2a2a !important;
    color: #e0e0e0 !important;
    border-color: #3a3a3a !important;
}

/* Dark links */
a, a:link, a:visited {
    color: #4a9eff !important;
}

a:hover, a:active {
    color: #6bb3ff !important;
}

/* Dark buttons */
button, .button, .btn {
    background-color: #3a3a3a !important;
    color: #e0e0e0 !important;
    border-color: #4a4a4a !important;
}

button:hover, .button:hover, .btn:hover {
    background-color: #4a4a4a !important;
}

/* Dark inputs */
input, textarea, select {
    background-color: #2a2a2a !important;
    color: #e0e0e0 !important;
    border-color: #3a3a3a !important;
}
"""
    
    def get_bandcamp_css(self):
        """CSS for Bandcamp mode - hides unwanted elements, shows only essential player content"""
        return """
/* Bandcamp Mode - Hide unwanted elements, show only essential player content */

/* Ensure scrolling still works with smooth behavior */
html, body {
    overflow-x: hidden !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important; /* Smooth scrolling on iOS/WebKit */
    scroll-behavior: smooth !important; /* Smooth scrolling for programmatic scrolling */
}

/* Hide the annoying sticky player overlay in all modes */
#sticky-player,
.sticky-player-container,
#sticky-player-marker {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    z-index: -1 !important;
    position: absolute !important;
    top: -9999px !important;
    left: -9999px !important;
    transform: translateX(-9999px) !important;
}

/* Override all possible sticky player states */
#sticky-player.sliding,
#sticky-player.visible,
#sticky-player.sliding.visible,
.sticky-player-container.sliding,
.sticky-player-container.visible,
.sticky-player-container.sliding.visible {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    z-index: -1 !important;
    position: absolute !important;
    top: -9999px !important;
    left: -9999px !important;
    transform: translateX(-9999px) !important;
}

/* Hide specific unwanted elements */
nav#menubar.logged-in,
header#tralbum-header.tralbum-header,
div#tralbum-actions.tralbum-actions-container.desktop-right,
div#tralbum-digital-only.tralbum-digital-only-container.desktop-left,
section#supporters.supporters-container.desktop-right,
section#tags.tags-container.desktop-left,
section#artist-profile.desktop-sidebar.artist-profile-container,
section#recommendations-footer.recommendations-footer-container.desktop-footer,
section#tralbum-credits,
section#purchase-options,
div#TralbumPage {
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
    margin: 0 !important;
    padding: 0 !important;
}

/* Ensure our 4 key sections remain visible */
#tralbum-art-carousel,
#player,
#tracklist,
#about-tralbum {
    visibility: visible !important;
}

/* Hide carousel controls/indicators */
.carousel-indication,
[role="tablist"][data-tabroot="tralbum-art-carousel"],
.img-indicator,
button[role="tab"][data-tabroot="tralbum-art-carousel"],
button[aria-label*="View carousel panel"],
button[aria-label*="carousel panel"] {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    width: 0 !important;
    height: 0 !important;
    overflow: hidden !important;
}

/* Responsive cover art - scales to fit window */
#tralbum-art-carousel {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

#tralbum-art-carousel img {
    margin: 0 auto !important;
    display: block !important;
    max-width: 100% !important;
    height: auto !important;
    width: auto !important;
}

.p-tralbum-page-container .tralbum-art-carousel-container {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

.p-tralbum-page-container .tralbum-art-carousel-container .carousel {
    width: 100% !important;
    max-width: 100% !important;
}

.p-tralbum-page-container .tralbum-art-carousel-container .carousel .carousel-item {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

.p-tralbum-page-container .tralbum-art-carousel-container .carousel .carousel-item img {
    width: 100% !important;
    max-width: 100% !important;
    height: auto !important;
    object-fit: contain !important;
}

.p-tralbum-page-container .player-container .progress-container {
    margin-top: 12px !important;    
}

/* Fix white background at bottom of page in Bandcamp mode */
body {
    background-color: #212121 !important;
    /* Prevent extra height that could show dark background block */
    min-height: auto !important;
    height: auto !important;
    /* Ensure body only shows background where there's actual content */
    overflow-y: auto !important;
}

/* CRITICAL: Hide player in webview when in micro mode (Qt widget is used instead) */
body.micro-mode #player {
    display: none !important;
    visibility: hidden !important;
}

/* Override dark body background for light pages in micro mode - keep tracklist readable */
/* This must be more specific than the general body rule above */
body.micro-mode.light-page,
body.micro-mode.light-page html {
    background-color: transparent !important;
    background: transparent !important;
}

/* Override dark page container backgrounds for light pages in micro mode */
body.micro-mode.light-page #pgBd,
body.micro-mode.light-page .p-tralbum-page-container,
body.micro-mode.light-page .leftColumn,
body.micro-mode.light-page .rightColumn {
    background-color: transparent !important;
    background: transparent !important;
}

/* Prevent dark block at bottom - ensure html doesn't have extra height */
html {
    height: auto !important;
    min-height: auto !important;
    overflow-y: auto !important;
}

/* Additional safeguard: ensure page container doesn't create extra space */
#pgBd,
.p-tralbum-page-container {
    min-height: auto !important;
    height: auto !important;
}

/* Responsive container - scales with window */
#pgBd,
.p-tralbum-page-container,
.leftColumn,
.rightColumn {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* Responsive player */
#player {
    width: 100% !important;
    max-width: 100% !important;
    margin-bottom: 5px !important;
    box-sizing: border-box !important;
    /* Ensure player is NOT absolutely positioned unless in mini/micro mode */
    position: relative !important;
}

/* Explicitly reset player positioning when NOT in mini/micro mode (but preserve spacing) */
body:not(.mini-mode):not(.micro-mode) #player {
    position: relative !important;
    bottom: auto !important;
    left: auto !important;
    right: auto !important;
    z-index: auto !important;
    /* Don't remove margin/padding - preserve spacing in regular mode */
}

/* Additional safeguard: prevent any absolute positioning on player container when not in mini mode */
body:not(.mini-mode):not(.micro-mode) .player-container {
    position: relative !important;
    bottom: auto !important;
}

#player * {
    max-width: 90% !important;
    box-sizing: border-box !important;
}

/* Next/Previous controls sizing - ensure buttons maintain their size */
/* These rules must come after #player * and have higher specificity */
#player .next-prev-controls,
#player .next-prev-controls *,
.next-prev-controls,
.next-prev-controls * {
    min-width: auto !important;
    width: auto !important;
    max-width: none !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    box-sizing: border-box !important;
}

/* Ensure the container itself maintains proper display */
#player .next-prev-controls {
    display: inline-flex !important;
    align-items: center !important;
}

/* Ensure next/previous track buttons are always visible and maintain default size */
/* Use both #player prefix and no prefix to match micro mode pattern */
.next-prev-controls button,
.next-prev-controls button[aria-label*="Skip to previous"],
.next-prev-controls button[aria-label*="Skip to next"],
.next-prev-controls button[aria-label*="previous"],
.next-prev-controls button[aria-label*="next"],
#player .next-prev-controls button,
#player .next-prev-controls button[aria-label*="Skip to previous"],
#player .next-prev-controls button[aria-label*="Skip to next"],
#player .next-prev-controls button[aria-label*="previous"],
#player .next-prev-controls button[aria-label*="next"] {
    min-width: 24px !important;
    width: 24px !important;
    height: 24px !important;
    min-height: 24px !important;
    max-width: 24px !important;
    max-height: 24px !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    visibility: visible !important;
    display: inline-block !important;
    opacity: 1 !important;
    pointer-events: auto !important;
    position: relative !important;
    margin: 0 2px !important;
    padding: 0 !important;
}

.next-prev-controls svg,
.next-prev-controls button svg,
#player .next-prev-controls svg,
#player .next-prev-controls button svg {
    width: 16px !important;
    height: 16px !important;
    min-width: 16px !important;
    min-height: 16px !important;
    max-width: 16px !important;
    max-height: 16px !important;
    flex-shrink: 0 !important;
}

/* Responsive tracklist */
#tracklist {
    width: 100% !important;
    max-width: 100% !important;
    margin-top: 5px !important;
    padding-top: 3px !important;
    box-sizing: border-box !important;
}

/* Tracklist arrow/goto icon styling for better visibility */
#tracklist .goto-icon,
#tracklist svg[class*="arrow"],
#tracklist svg[class*="goto"],
#tracklist svg[class*="chevron"] {
    filter: brightness(0) invert(1) !important;
}

/* Make goto icon darker on light pages for better contrast - applies to ALL modes (regular, mini, micro) */
body.light-page #tracklist .goto-icon,
body.light-page.mini-mode #tracklist .goto-icon,
body.light-page.micro-mode #tracklist .goto-icon,
body.light-page #tracklist svg[class*="arrow"],
body.light-page.mini-mode #tracklist svg[class*="arrow"],
body.light-page.micro-mode #tracklist svg[class*="arrow"],
body.light-page #tracklist svg[class*="goto"],
body.light-page.mini-mode #tracklist svg[class*="goto"],
body.light-page.micro-mode #tracklist svg[class*="goto"],
body.light-page #tracklist svg[class*="chevron"],
body.light-page.mini-mode #tracklist svg[class*="chevron"],
body.light-page.micro-mode #tracklist svg[class*="chevron"],
body.light-page .goto-icon,
body.light-page.mini-mode .goto-icon,
body.light-page.micro-mode .goto-icon,
body.light-page svg[class*="arrow"],
body.light-page.mini-mode svg[class*="arrow"],
body.light-page.micro-mode svg[class*="arrow"],
body.light-page svg[class*="goto"],
body.light-page.mini-mode svg[class*="goto"],
body.light-page.micro-mode svg[class*="goto"],
body.light-page svg[class*="chevron"],
body.light-page.mini-mode svg[class*="chevron"],
body.light-page.micro-mode svg[class*="chevron"] {
    filter: brightness(0) !important; /* Make it black/dark instead of white on light pages */
}

#tracklist * {
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* Tracklist ol.tracks styling for regular mode */
ol.tracks {
    background-color: transparent !important;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    margin-left: -20px !important;
    margin-right: 0px !important;
    padding-left: 20px !important;
    padding-right: 0px !important;
}

/* Override track number calculation in grid */
:where(.p-tralbum-page-container) section.tracklist-container ol.tracks li.track,
.p-tralbum-page-container section.tracklist-container ol.tracks li.track,
section.tracklist-container ol.tracks li.track,
ol.tracks li.track {
    grid-template-columns: calc(1rem + var(--track-num-padding)) minmax(0, 1fr) auto min-content !important;
}

/* Responsive about section */
#about-tralbum {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

#about-tralbum * {
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* Ensure images don't overflow */
img {
    max-width: 100% !important;
    height: auto !important;
    object-fit: contain !important;
}

/* Enhanced minimize mode - hide everything except player */
body.bandcamp-minimized {
    background-color: #212121 !important;
}

body.bandcamp-minimized #tralbum-art-carousel,
body.bandcamp-minimized #tracklist,
body.bandcamp-minimized #about-tralbum {
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
    margin: 0 !important;
    padding: 0 !important;
}

body.bandcamp-minimized #player {
    visibility: visible !important;
}
"""
    
    def _get_hidden_scrollbar_css(self):
        """CSS to hide scrollbars completely"""
        return """
/* Hide scrollbars but keep scrolling functionality */
::-webkit-scrollbar {
    width: 0px !important;
    height: 0px !important;
    background: transparent !important;
}

::-webkit-scrollbar-track {
    background: transparent !important;
}

::-webkit-scrollbar-thumb {
    background: transparent !important;
}

/* Hide scrollbars for Firefox */
* {
    scrollbar-width: none !important;
    -ms-overflow-style: none !important;
}
"""
    
    def _get_scrollbar_css(self):
        """CSS for minimalist, unobtrusive scrollbar (similar to playlist style)"""
        return """
/* Minimalist scrollbar - thin, unobtrusive, similar to playlist style */
/* Style both vertical and horizontal scrollbars to match */
/* Base rule - applies to all scrollbars - MUST come first */
::-webkit-scrollbar,
*::-webkit-scrollbar,
html::-webkit-scrollbar,
body::-webkit-scrollbar,
#pgBd::-webkit-scrollbar,
.p-tralbum-page-container::-webkit-scrollbar {
    width: 10px !important;
    height: 10px !important; /* Match vertical scrollbar thickness - CRITICAL for horizontal */
    background: transparent !important;
}

/* Vertical scrollbar track */
::-webkit-scrollbar:vertical {
    width: 10px !important;
    background: transparent !important;
}

/* Horizontal scrollbar track - match vertical thickness */
/* Use more specific selectors to ensure it applies everywhere */
::-webkit-scrollbar:horizontal,
*::-webkit-scrollbar:horizontal,
html::-webkit-scrollbar:horizontal,
body::-webkit-scrollbar:horizontal {
    height: 10px !important; /* Match vertical scrollbar width (10px) */
    background: transparent !important;
    width: auto !important;
}

::-webkit-scrollbar-track {
    background: transparent !important;
    border-radius: 5px !important;
}

/* Ensure horizontal scrollbar track matches vertical - dark grey background */
::-webkit-scrollbar-track:horizontal,
*::-webkit-scrollbar-track:horizontal,
html::-webkit-scrollbar-track:horizontal,
body::-webkit-scrollbar-track:horizontal,
#tralbum-art-carousel::-webkit-scrollbar-track:horizontal,
.tralbum-art-carousel-container::-webkit-scrollbar-track:horizontal,
#tralbum-art-carousel *::-webkit-scrollbar-track:horizontal,
.tralbum-art-carousel-container *::-webkit-scrollbar-track:horizontal {
    background: rgba(43, 43, 43, 0.8) !important; /* Dark grey background to match vertical */
    border-radius: 5px !important;
    height: 10px !important;
}

/* Vertical scrollbar thumb */
::-webkit-scrollbar-thumb:vertical {
    background-color: rgba(74, 74, 74, 0.5) !important;
    border-radius: 5px !important;
    border: 2px solid transparent !important;
    background-clip: padding-box !important;
    min-height: 20px !important;
    transition: background-color 0.15s ease !important; /* Faster transition for responsiveness */
    /* Hardware acceleration for smooth scrolling */
    will-change: background-color, transform !important;
    transform: translateZ(0) !important;
    /* Ensure smooth scrolling performance */
    -webkit-font-smoothing: antialiased !important;
    backface-visibility: hidden !important;
}

/* Horizontal scrollbar thumb - match vertical styling */
::-webkit-scrollbar-thumb:horizontal {
    background-color: rgba(74, 74, 74, 0.5) !important;
    border-radius: 5px !important;
    border: 2px solid transparent !important;
    background-clip: padding-box !important;
    min-width: 20px !important; /* Use min-width for horizontal */
    transition: background-color 0.15s ease !important;
    /* Hardware acceleration for smooth scrolling */
    will-change: background-color, transform !important;
    transform: translateZ(0) !important;
    -webkit-font-smoothing: antialiased !important;
    backface-visibility: hidden !important;
}

/* Fallback for any scrollbar thumb (for compatibility) */
::-webkit-scrollbar-thumb {
    background-color: rgba(74, 74, 74, 0.5) !important;
    border-radius: 5px !important;
    border: 2px solid transparent !important;
    background-clip: padding-box !important;
    transition: background-color 0.15s ease !important;
    will-change: background-color, transform !important;
    transform: translateZ(0) !important;
    -webkit-font-smoothing: antialiased !important;
    backface-visibility: hidden !important;
}

/* Hover states for both vertical and horizontal */
::-webkit-scrollbar-thumb:hover,
::-webkit-scrollbar-thumb:vertical:hover,
::-webkit-scrollbar-thumb:horizontal:hover {
    background-color: rgba(90, 90, 90, 0.7) !important;
}

/* Active states for both vertical and horizontal */
::-webkit-scrollbar-thumb:active,
::-webkit-scrollbar-thumb:vertical:active,
::-webkit-scrollbar-thumb:horizontal:active {
    background-color: rgba(106, 106, 106, 0.9) !important;
}

/* Ensure smooth scrolling behavior */
html, body {
    scroll-behavior: smooth !important;
    -webkit-overflow-scrolling: touch !important; /* Smooth scrolling on iOS/WebKit */
    overflow-x: hidden !important; /* Hide horizontal scrolling */
    overflow-y: auto !important; /* Allow vertical scrolling */
}

/* Firefox scrollbar styling - dark grey background to match vertical scrollbar */
* {
    scrollbar-width: thin !important;
    scrollbar-color: rgba(74, 74, 74, 0.5) #212121 !important; /* Dark grey background instead of transparent */
}

/* Hide horizontal scrolling on main containers, but allow carousels to work */
body, html, #pgBd, .p-tralbum-page-container, .leftColumn, .rightColumn {
    overflow-x: hidden !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* IMPORTANT: Don't force overflow-x: hidden on carousel containers */
/* Carousels use CSS transforms/positioning to show only the active image */
/* Forcing overflow-x: hidden breaks the carousel's display mechanism */
/* Let Bandcamp's own carousel CSS handle the overflow properly */
#tralbum-art-carousel,
.tralbum-art-carousel-container {
    /* Don't override carousel's overflow - let it handle its own display */
    /* Just ensure it doesn't exceed container width */
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* Hide horizontal scrollbar on carousel completely to prevent crashes */
/* This prevents the horizontal scrollbar from appearing and causing issues */
#tralbum-art-carousel::-webkit-scrollbar:horizontal,
.tralbum-art-carousel-container::-webkit-scrollbar:horizontal,
#tralbum-art-carousel *::-webkit-scrollbar:horizontal,
.tralbum-art-carousel-container *::-webkit-scrollbar:horizontal,
.carousel::-webkit-scrollbar:horizontal,
.carousel *::-webkit-scrollbar:horizontal,
[class*="carousel"]::-webkit-scrollbar:horizontal,
[class*="carousel"] *::-webkit-scrollbar:horizontal {
    height: 0px !important;
    max-height: 0px !important;
    min-height: 0px !important;
    background: transparent !important;
    display: none !important;
}

/* Hide horizontal scrollbar thumb on carousel */
#tralbum-art-carousel::-webkit-scrollbar-thumb:horizontal,
.tralbum-art-carousel-container::-webkit-scrollbar-thumb:horizontal,
#tralbum-art-carousel *::-webkit-scrollbar-thumb:horizontal,
.tralbum-art-carousel-container *::-webkit-scrollbar-thumb:horizontal,
.carousel::-webkit-scrollbar-thumb:horizontal,
.carousel *::-webkit-scrollbar-thumb:horizontal,
[class*="carousel"]::-webkit-scrollbar-thumb:horizontal,
[class*="carousel"] *::-webkit-scrollbar-thumb:horizontal {
    display: none !important;
    height: 0px !important;
    width: 0px !important;
}

/* Hide additional carousel items beyond the first one */
/* Show only the first image, hide the rest */
.p-tralbum-page-container .tralbum-art-carousel-container .carousel .carousel-item:not(:first-child) {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    width: 0 !important;
    height: 0 !important;
    overflow: hidden !important;
}

/* Ensure first carousel item is visible and properly sized */
.p-tralbum-page-container .tralbum-art-carousel-container .carousel .carousel-item:first-child {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    width: 100% !important;
    max-width: 100% !important;
}

/* Prevent horizontal scrolling on carousel container */
/* This ensures the carousel doesn't create a horizontal scrollbar */
#tralbum-art-carousel,
.tralbum-art-carousel-container,
.p-tralbum-page-container .tralbum-art-carousel-container .carousel {
    overflow-x: hidden !important;
    overflow-y: visible !important;
}
"""
    
    def get_mini_mode_css(self):
        """CSS for mini mode - overlays player on cover art, keeps tracklist scrollable"""
        return """
/* Mini Mode - Overlay player on cover art (state 1) */
/* Window height = image height, player overlays image, tracklist scrollable below */
body.mini-mode #tralbum-art-carousel {
    position: relative !important;
    z-index: 1 !important;
    margin: 0 !important;
    padding: 0 !important;
}

/* Keep original page background - only darken the player itself */
/* Removed page container darkening to preserve tracklist readability */

body.mini-mode #player {
    position: absolute !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    z-index: 1000 !important;
    margin: 0 !important;
    padding: 15px !important;
    border-radius: 8px 8px 0 0 !important;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3) !important;
    background-color: rgba(20, 20, 20, 0.7) !important; /* Slightly more transparent */
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    width: 108% !important;
    max-width: 110% !important;
    /* Ensure player is visible on both light and dark pages */
    pointer-events: auto !important;
}

/* Ensure mini player works correctly on dark pages */
body.dark-page.mini-mode #player,
body:not(.light-page).mini-mode #player {
    z-index: 1000 !important;
    position: absolute !important;
    pointer-events: auto !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* Force player background to always be transparent in mini mode */
body.mini-mode #player,
body.mini-mode #player:hover,
body.mini-mode #player:focus,
body.mini-mode #player:active,
body.mini-mode .player-container,
body.mini-mode .player-container:hover,
body.mini-mode .player-container:focus,
body.mini-mode .player-container:active {
    background-color: rgba(20, 20, 20, 0.7) !important; /* Slightly more transparent */
    background: rgba(20, 20, 20, 0.7) !important;
}

/* Ensure all player child elements have transparent backgrounds but full opacity for text/UI */
body.mini-mode #player *,
body.mini-mode .player-container * {
    background-color: transparent !important;
    background: transparent !important;
}

/* Force all text and UI elements to be bright white in mini mode (like dark-themed pages) */
body.mini-mode #player span,
body.mini-mode #player div,
body.mini-mode #player p,
body.mini-mode #player .tralbum-name,
body.mini-mode #player .tralbum-name *,
body.mini-mode #player .tralbum-artist,
body.mini-mode #player .tralbum-artist *,
body.mini-mode #player .current-track,
body.mini-mode #player .current-track *,
body.mini-mode #player .track-info,
body.mini-mode #player .track-info *,
body.mini-mode #player .track-number,
body.mini-mode #player .time_elapsed,
body.mini-mode #player .time_total,
body.mini-mode #player .duration-text {
    opacity: 1 !important;
    color: #ffffff !important;
}

/* Force all SVG icons and buttons to be bright white in mini mode */
body.mini-mode #player svg,
body.mini-mode #player button svg,
body.mini-mode #player .next-prev-controls svg,
body.mini-mode #player .play-pause-button svg,
body.mini-mode #player .playbutton svg,
body.mini-mode #player .pausebutton svg {
    fill: #ffffff !important;
    stroke: #ffffff !important;
    color: #ffffff !important;
    opacity: 1 !important;
}

/* Force button elements to have white/bright styling */
body.mini-mode #player button,
body.mini-mode #player .play-pause-button,
body.mini-mode #player .playbutton,
body.mini-mode #player .pausebutton,
body.mini-mode #player .next-prev-controls button {
    color: #ffffff !important;
    opacity: 1 !important;
}

/* Force play button outline/border to be white in mini mode */
body.mini-mode #player button[aria-label*="Play"],
body.mini-mode #player button[aria-label*="play"],
body.mini-mode #player button[aria-label*="Pause"],
body.mini-mode #player button[aria-label*="pause"],
body.mini-mode #player .play-pause-button,
body.mini-mode #player .playbutton,
body.mini-mode #player .pausebutton,
body.mini-mode #player button[class*="play"],
body.mini-mode #player button[class*="Play"],
body.mini-mode #player button[class*="pause"],
body.mini-mode #player button[class*="Pause"],
body.mini-mode #player button[title*="Play"],
body.mini-mode #player button[title*="play"],
body.mini-mode #player button[title*="Pause"],
body.mini-mode #player button[title*="pause"] {
    border-color: #ffffff !important;
    outline-color: #ffffff !important;
    outline: 2px solid #ffffff !important;
    outline-offset: 0 !important;
}

/* Constrain text elements to single line with truncation in mini mode */
body.mini-mode .tralbum-name,
body.mini-mode .tralbum-name *,
body.mini-mode #player .tralbum-name,
body.mini-mode #player .tralbum-name * {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 100% !important;
    width: auto !important;
    display: block !important;
    line-height: 1.2 !important;
    box-sizing: border-box !important;
    min-width: 0 !important;
    flex: 0 1 auto !important;
    /* Ensure it doesn't overflow past the player edge */
    padding-right: 0 !important;
    margin-right: 0 !important;
}

body.mini-mode .tralbum-artist,
body.mini-mode .tralbum-artist *,
body.mini-mode #player .tralbum-artist,
body.mini-mode #player .tralbum-artist * {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 100% !important;
    width: auto !important;
    display: block !important;
    line-height: 1.2 !important;
    box-sizing: border-box !important;
    min-width: 0 !important;
    flex: 0 1 auto !important;
    padding-right: 0 !important;
    margin-right: 0 !important;
}

/* Hide track info button in mini mode to keep player size consistent */
body.mini-mode .track-action.track-info.player-action,
body.mini-mode button.track-action.track-info[aria-label*="track info"],
body.mini-mode button.track-action.track-info[aria-label*="View track info"],
body.mini-mode #player .track-action.track-info.player-action,
body.mini-mode #player button.track-action.track-info[aria-label*="track info"],
body.mini-mode #player button.track-action.track-info[aria-label*="View track info"] {
    display: none !important;
    visibility: hidden !important;
    width: 0 !important;
    height: 0 !important;
    opacity: 0 !important;
    pointer-events: none !important;
}

/* Ensure the track-info container allows truncation in mini mode */
body.mini-mode .track-info {
    overflow: hidden !important; /* Allow truncation */
    max-width: 100% !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

/* Exception: text elements that should truncate need hidden overflow in mini mode */
body.mini-mode #player .tralbum-name,
body.mini-mode #player .tralbum-name *,
body.mini-mode #player .tralbum-artist,
body.mini-mode #player .tralbum-artist * {
    overflow: hidden !important;
    max-width: 100% !important;
}

/* Disable hover effects for track title in mini mode */
body.mini-mode #player .current-track:hover,
body.mini-mode #player .current-track:hover *:not(.track-number):not(.track-num),
body.mini-mode #player .track-info .current-track:hover,
body.mini-mode #player .track-info .current-track:hover *:not(.track-number):not(.track-num),
body.mini-mode #player .current-track span:hover,
body.mini-mode #player .current-track span[data-bind*="currentTrack().title"]:hover,
body.mini-mode #player .current-track span[data-bind*="title"]:hover {
    background-color: transparent !important;
    backdrop-filter: none !important;
    border-radius: 0 !important;
}

/* Disable hover effects on track-number in mini mode (fully visible, not autohide) */
body.mini-mode:not(.mini-mode-autohide) #player .track-number:hover,
body.mini-mode:not(.mini-mode-autohide) #player .track-num:hover,
body.mini-mode:not(.mini-mode-autohide) #player:hover .track-number,
body.mini-mode:not(.mini-mode-autohide) #player:hover .track-num,
body.mini-mode:not(.mini-mode-autohide) #player .current-track:hover .track-number,
body.mini-mode:not(.mini-mode-autohide) #player .current-track:hover .track-num,
body.mini-mode:not(.mini-mode-autohide) #player .current-track:hover * .track-number,
body.mini-mode:not(.mini-mode-autohide) #player .current-track:hover * .track-num {
    background-color: transparent !important;
    background: transparent !important;
    color: inherit !important;
    opacity: 1 !important;
    filter: none !important;
    transform: none !important;
    padding: 0 !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
    margin: 0 !important;
    margin-left: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    margin-right: 8px !important;
    border: none !important;
    box-shadow: none !important;
    text-decoration: none !important;
    transition: none !important;
}

/* Make progress bar visible in mini mode (same as micro mode) */
body.mini-mode .progress-container {
    width: 100% !important;
    max-width: 100% !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
    box-sizing: border-box !important;
}

body.mini-mode .progress-bar,
body.mini-mode .progress-container .progress-bar {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
}

/* Make progress bar line/track visible in mini mode */
body.mini-mode input[type="range"],
body.mini-mode input.progress,
body.mini-mode .progbar,
body.mini-mode .progress-bar input,
body.mini-mode .progress-container input[type="range"],
body.mini-mode .progress-container .progbar {
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
    background-color: rgba(255, 255, 255, 0.3) !important;
    -webkit-appearance: none !important;
    appearance: none !important;
    height: 4px !important;
    width: 100% !important;
    cursor: pointer !important;
}

/* Progress bar track (the line) */
body.mini-mode input[type="range"]::-webkit-slider-runnable-track,
body.mini-mode input.progress::-webkit-slider-runnable-track,
body.mini-mode .progbar::-webkit-slider-runnable-track {
    background-color: rgba(255, 255, 255, 0.3) !important;
    height: 4px !important;
    opacity: 1 !important;
    visibility: visible !important;
}

body.mini-mode input[type="range"]::-moz-range-track,
body.mini-mode input.progress::-moz-range-track,
body.mini-mode .progbar::-moz-range-track {
    background-color: rgba(255, 255, 255, 0.3) !important;
    height: 4px !important;
    opacity: 1 !important;
    visibility: visible !important;
}

/* Progress bar thumb (the handle) */
body.mini-mode input[type="range"]::-webkit-slider-thumb,
body.mini-mode input.progress::-webkit-slider-thumb,
body.mini-mode .progbar::-webkit-slider-thumb {
    -webkit-appearance: none !important;
    appearance: none !important;
    width: 12px !important;
    height: 12px !important;
    background-color: #ffffff !important;
    border-radius: 50% !important;
    cursor: pointer !important;
    opacity: 1 !important;
    visibility: visible !important;
    margin-top: -4px !important;
}

body.mini-mode input[type="range"]::-moz-range-thumb,
body.mini-mode input.progress::-moz-range-thumb,
body.mini-mode .progbar::-moz-range-thumb {
    width: 12px !important;
    height: 12px !important;
    background-color: #ffffff !important;
    border-radius: 50% !important;
    cursor: pointer !important;
    opacity: 1 !important;
    visibility: visible !important;
    border: none !important;
}

/* Ensure next/previous track buttons are always visible and maintain default size in mini mode */
/* Exception: next-prev-controls should not be constrained by any max-width rules */
body.mini-mode #player .next-prev-controls,
body.mini-mode #player .next-prev-controls *,
body.mini-mode .next-prev-controls,
body.mini-mode .next-prev-controls * {
    min-width: auto !important;
    width: auto !important;
    max-width: none !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    left: -6px !important;
}

/* Ensure the container itself maintains proper display in mini mode */
body.mini-mode #player .next-prev-controls,
body.mini-mode .next-prev-controls {
    display: inline-flex !important;
    align-items: center !important;
    position: relative !important;
    left: -10px !important;
    top: 12px !important;
}

body.mini-mode #player .next-prev-controls button,
body.mini-mode #player .next-prev-controls button[aria-label*="Skip to previous"],
body.mini-mode #player .next-prev-controls button[aria-label*="Skip to next"],
body.mini-mode #player .next-prev-controls button[aria-label*="previous"],
body.mini-mode #player .next-prev-controls button[aria-label*="next"],
body.mini-mode .next-prev-controls button,
body.mini-mode .next-prev-controls button[aria-label*="Skip to previous"],
body.mini-mode .next-prev-controls button[aria-label*="Skip to next"],
body.mini-mode .next-prev-controls button[aria-label*="previous"],
body.mini-mode .next-prev-controls button[aria-label*="next"] {
    min-width: 24px !important;
    width: 24px !important;
    height: 24px !important;
    min-height: 24px !important;
    max-width: 24px !important;
    max-height: 24px !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    visibility: visible !important;
    display: inline-block !important;
    opacity: 1 !important;
    pointer-events: auto !important;
    position: relative !important;
    margin: 0 2px !important;
    padding: 0 !important;
}

body.mini-mode #player .next-prev-controls svg,
body.mini-mode #player .next-prev-controls button svg,
body.mini-mode .next-prev-controls svg,
body.mini-mode .next-prev-controls button svg {
    width: 16px !important;
    height: 16px !important;
    min-width: 16px !important;
    min-height: 16px !important;
    max-width: 16px !important;
    max-height: 16px !important;
    flex-shrink: 0 !important;
}

/* Keep tracklist in DOM but position it below viewport - scrollable */
/* Use transform instead of display/visibility to avoid re-render issues */
body.mini-mode #tracklist,
body.mini-mode #about-tralbum {
    position: relative !important;
    z-index: 0 !important;
    /* Keep in layout but below the visible area - user can scroll to see it */
    margin-top: 0 !important;
    padding-top: 10px !important;
}

/* Tracklist ol.tracks styling for mini mode */
body.mini-mode ol.tracks {
    background-color: transparent !important;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    margin-left: -20px !important;
    margin-right: 0px !important;
    padding-left: 20px !important;
    padding-right: 0px !important;
}

/* Override track number calculation in grid for mini mode */
body.mini-mode :where(.p-tralbum-page-container) section.tracklist-container ol.tracks li.track,
body.mini-mode .p-tralbum-page-container section.tracklist-container ol.tracks li.track,
body.mini-mode section.tracklist-container ol.tracks li.track,
body.mini-mode ol.tracks li.track {
    grid-template-columns: calc(1rem + var(--track-num-padding)) minmax(0, 1fr) auto min-content !important;
}

/* Ensure cover art is visible in mini mode and remove extra space */
body.mini-mode #tralbum-art-carousel {
    height: auto !important;
    min-height: 0 !important;
    max-height: none !important;
    overflow: visible !important;
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
}

body.mini-mode #tralbum-art-carousel img {
    display: block !important;
    visibility: visible !important;
    margin: 0 auto !important;
}

/* Ensure cover art is visible in micro mode and remove extra space (same as mini mode) */
body.micro-mode #tralbum-art-carousel {
    height: auto !important;
    min-height: 0 !important;
    max-height: none !important;
    overflow: visible !important;
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
}

body.micro-mode #tralbum-art-carousel img {
    display: block !important;
    visibility: visible !important;
    margin: 0 auto !important;
}

/* Hide any extra spacing or padding in mini mode */
body.mini-mode .p-tralbum-page-container,
body.mini-mode #pgBd {
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
}

/* Mini Mode Player Autohide - Hide player when idle, show on hover */
/* CRITICAL: Keep pointer-events enabled so hover can be detected */
body.mini-mode.mini-mode-autohide #player {
    opacity: 0 !important;
    transition: opacity 250ms ease-in-out !important;
    /* Must keep pointer-events enabled for hover to work */
    pointer-events: auto !important;
    visibility: visible !important;
    /* Hardware acceleration for smooth transitions */
    will-change: opacity !important;
    transform: translateZ(0) !important;
    backface-visibility: hidden !important;
}

/* Override general mini-mode opacity rules for child elements when autohide is enabled */
/* In idle state: explicitly set to 0 to override general mini-mode opacity: 1 rules */
body.mini-mode.mini-mode-autohide #player span,
body.mini-mode.mini-mode-autohide #player div,
body.mini-mode.mini-mode-autohide #player p,
body.mini-mode.mini-mode-autohide #player button,
body.mini-mode.mini-mode-autohide #player svg,
body.mini-mode.mini-mode-autohide #player .tralbum-name,
body.mini-mode.mini-mode-autohide #player .tralbum-name *,
body.mini-mode.mini-mode-autohide #player .tralbum-artist,
body.mini-mode.mini-mode-autohide #player .tralbum-artist *,
body.mini-mode.mini-mode-autohide #player .current-track,
body.mini-mode.mini-mode-autohide #player .current-track *,
body.mini-mode.mini-mode-autohide #player .track-info,
body.mini-mode.mini-mode-autohide #player .track-info *,
body.mini-mode.mini-mode-autohide #player .track-number,
body.mini-mode.mini-mode-autohide #player .time_elapsed,
body.mini-mode.mini-mode-autohide #player .time_total,
body.mini-mode.mini-mode-autohide #player .duration-text,
body.mini-mode.mini-mode-autohide #player .next-prev-controls,
body.mini-mode.mini-mode-autohide #player .next-prev-controls *,
body.mini-mode.mini-mode-autohide #player .play-pause-button,
body.mini-mode.mini-mode-autohide #player .playbutton,
body.mini-mode.mini-mode-autohide #player .pausebutton,
body.mini-mode.mini-mode-autohide #player .progress-container,
body.mini-mode.mini-mode-autohide #player .progress-bar,
body.mini-mode.mini-mode-autohide #player .progbar,
body.mini-mode.mini-mode-autohide #player input,
body.mini-mode.mini-mode-autohide #player * {
    opacity: 0 !important;
    transition: opacity 250ms ease-in-out !important;
    pointer-events: auto !important;
}

/* Show player when hovering - use class-based approach for reliable hover detection */
body.mini-mode.mini-mode-autohide #player.player-hovered {
    opacity: 1 !important;
    /* Ensure smooth transition when showing */
    will-change: opacity !important;
}

/* Player visibility toggle button - top center in mini mode */
/* Hidden by default - only shown in mini mode */
#bandcamp-player-visibility-toggle {
    position: fixed !important;
    top: 8px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: 24px !important;
    height: 24px !important;
    background-color: rgba(21, 21, 21, 0.4) !important;
    border: 1px solid rgba(176, 176, 176, 0.2) !important;
    border-radius: 12px !important;
    cursor: pointer !important;
    z-index: 10001 !important;
    display: none !important;
    align-items: center !important;
    justify-content: center !important;
    color: #b0b0b0 !important;
    font-size: 14px !important;
    font-weight: bold !important;
    filter: grayscale(100%) !important;
    transition: background-color 200ms ease, border-color 200ms ease, color 200ms ease, filter 200ms ease !important;
    pointer-events: none !important;
    opacity: 0 !important;
    visibility: hidden !important;
}

#bandcamp-player-visibility-toggle:hover {
    background-color: rgba(43, 43, 43, 0.7) !important;
    border-color: rgba(176, 176, 176, 0.5) !important;
    color: #e0e0e0 !important;
    filter: grayscale(100%) !important;
}

/* Ensure toggle button is always visible, even when player is hidden */
/* Use fixed positioning so it's always in view and not affected by player visibility */
/* Only show in mini mode, hide in micro mode */
/* This rule ensures the button is always visible in mini mode */
body.mini-mode:not(.micro-mode) #bandcamp-player-visibility-toggle {
    opacity: 1 !important;
    visibility: visible !important;
    pointer-events: auto !important;
    z-index: 10002 !important;
    position: fixed !important;
    display: flex !important;
    /* Position relative to viewport, not player - top center */
    top: 8px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
}

/* Hide button in regular mode (not mini-mode and not micro-mode) */
body:not(.mini-mode):not(.micro-mode) #bandcamp-player-visibility-toggle {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    display: none !important;
}

/* Hide button in micro mode */
body.micro-mode #bandcamp-player-visibility-toggle {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    display: none !important;
}

/* Button is always visible in mini mode, regardless of autohide or hidden state */
body.mini-mode.mini-mode-autohide #bandcamp-player-visibility-toggle {
    opacity: 1 !important;
    visibility: visible !important;
    pointer-events: auto !important;
    display: flex !important;
}

    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    display: none !important;
}

/* When player is completely hidden, button should still be visible */
body.mini-mode.mini-mode-player-hidden #bandcamp-player-visibility-toggle {
    opacity: 0.8 !important;
    visibility: visible !important;
    pointer-events: auto !important;
    z-index: 10002 !important;
    filter: grayscale(100%) !important;
}

/* When player is hidden completely (separate from autohide) */
body.mini-mode.mini-mode-player-hidden #player {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

body.mini-mode.mini-mode-player-hidden #player * {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

/* When both hidden and autohide are enabled, hidden takes precedence */
body.mini-mode.mini-mode-player-hidden.mini-mode-autohide #player {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

body.mini-mode.mini-mode-player-hidden.mini-mode-autohide #player.player-hovered {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

/* CRITICAL: On hover (using class), override ALL child element opacity rules - must come after idle rules */
/* Use maximum specificity to ensure these rules win over everything */
body.mini-mode.mini-mode-autohide #player.player-hovered span,
body.mini-mode.mini-mode-autohide #player.player-hovered div,
body.mini-mode.mini-mode-autohide #player.player-hovered p,
body.mini-mode.mini-mode-autohide #player.player-hovered button,
body.mini-mode.mini-mode-autohide #player.player-hovered svg,
body.mini-mode.mini-mode-autohide #player.player-hovered .tralbum-name,
body.mini-mode.mini-mode-autohide #player.player-hovered .tralbum-name *,
body.mini-mode.mini-mode-autohide #player.player-hovered .tralbum-artist,
body.mini-mode.mini-mode-autohide #player.player-hovered .tralbum-artist *,
body.mini-mode.mini-mode-autohide #player.player-hovered .current-track,
body.mini-mode.mini-mode-autohide #player.player-hovered .current-track *,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-info,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-info *,
body.mini-mode.mini-mode-autohide #player.player-hovered .time_elapsed,
body.mini-mode.mini-mode-autohide #player.player-hovered .time_total,
body.mini-mode.mini-mode-autohide #player.player-hovered .duration-text,
body.mini-mode.mini-mode-autohide #player.player-hovered .next-prev-controls,
body.mini-mode.mini-mode-autohide #player.player-hovered .next-prev-controls *,
body.mini-mode.mini-mode-autohide #player.player-hovered .next-prev-controls button,
body.mini-mode.mini-mode-autohide #player.player-hovered .play-pause-button,
body.mini-mode.mini-mode-autohide #player.player-hovered .playbutton,
body.mini-mode.mini-mode-autohide #player.player-hovered .pausebutton,
body.mini-mode.mini-mode-autohide #player.player-hovered .pausebutton svg,
body.mini-mode.mini-mode-autohide #player.player-hovered .progress-container,
body.mini-mode.mini-mode-autohide #player.player-hovered .progress-bar,
body.mini-mode.mini-mode-autohide #player.player-hovered .progbar,
body.mini-mode.mini-mode-autohide #player.player-hovered input,
body.mini-mode.mini-mode-autohide #player.player-hovered button[title*="pause"],
body.mini-mode.mini-mode-autohide #player.player-hovered button.track-action,
body.mini-mode.mini-mode-autohide #player.player-hovered * {
    opacity: 1 !important;
}

/* Ensure track number doesn't change on hover in mini mode autohide */
body.mini-mode.mini-mode-autohide #player.player-hovered .track-number,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-num {
    opacity: 1 !important;
    padding: 0 !important;
    margin: 0 !important;
    margin-right: 8px !important;
    transform: none !important;
    background-color: transparent !important;
    color: inherit !important;
}

/* EXTRA CATCH-ALL: Ensure ALL descendants are visible when player is hovered */
/* This rule should catch any elements not covered by the specific rules above */
body.mini-mode.mini-mode-autohide #player.player-hovered,
body.mini-mode.mini-mode-autohide #player.player-hovered *,
body.mini-mode.mini-mode-autohide #player.player-hovered * *,
body.mini-mode.mini-mode-autohide #player.player-hovered * * * {
    opacity: 1 !important;
}

/* Micro Mode - Qt Widget Implementation Only (state 2) */
/* All CSS-based micro mode code has been removed - micro mode now uses pure Qt widgets */
/* See MicroPlayerWidget class and _apply_mini_mode_qt_widgets() for implementation */
"""


# ============================================================================
# PLAYLIST MANAGER CLASS
# ============================================================================

def sanitize_filename(name):
    """Sanitize a filename by removing invalid characters"""
    import re
    # Remove invalid characters for Windows/Linux/Mac
    # Invalid: < > : " / \ | ? * and control characters
    invalid_chars = r'[<>:"/\\|?*\x00-\x1f]'
    sanitized = re.sub(invalid_chars, '', name)
    # Remove leading/trailing spaces and dots (Windows doesn't allow these)
    sanitized = sanitized.strip(' .')
    # Replace multiple spaces with single space
    sanitized = re.sub(r'\s+', ' ', sanitized)
    # If empty after sanitization, use default name
    if not sanitized:
        sanitized = "playlist"
    # Limit length to 255 characters (common filesystem limit)
    if len(sanitized) > 255:
        sanitized = sanitized[:255]
    return sanitized


class PlaylistManager:
    """Manages the playlist of Bandcamp URLs"""
    
    def __init__(self, base_path=None, playlist_file=None):
        if base_path is None:
            base_path = Path(__file__).parent
        self.base_path = base_path
        self.playlists_dir = base_path / "Playlists"
        # Create Playlists directory if it doesn't exist
        self.playlists_dir.mkdir(exist_ok=True)
        
        # Migrate old playlist.json from root to Playlists/Default.json if it exists
        old_playlist_file = base_path / "playlist.json"
        default_playlist_file = self.playlists_dir / "Default.json"
        # Also check for old lowercase default.json and migrate it
        old_default_file = self.playlists_dir / "default.json"
        if old_default_file.exists() and not default_playlist_file.exists():
            try:
                import shutil
                shutil.copy2(old_default_file, default_playlist_file)
                logger.info(f"Migrated old default.json to Default.json")
            except Exception as e:
                logger.warning(f"Failed to migrate old default.json: {e}")
        if old_playlist_file.exists() and not default_playlist_file.exists():
            try:
                # Copy old playlist to new location
                import shutil
                shutil.copy2(old_playlist_file, default_playlist_file)
                logger.info(f"Migrated old playlist.json to Playlists/Default.json")
                # Optionally remove old file (commented out for safety)
                # old_playlist_file.unlink()
            except Exception as e:
                logger.warning(f"Failed to migrate old playlist.json: {e}")
        
        # If playlist_file is provided, use it; otherwise use Default
        if playlist_file:
            self.playlist_file = Path(playlist_file)
            # If relative path, make it relative to playlists_dir
            if not self.playlist_file.is_absolute():
                self.playlist_file = self.playlists_dir / self.playlist_file.name
        else:
            # Default playlist location (capitalized)
            self.playlist_file = self.playlists_dir / "Default.json"
        
        self.playlist = self.load_playlist()
    
    def get_playlist_directory(self):
        """Get the Playlists directory path"""
        return self.playlists_dir
    
    def list_playlist_files(self):
        """List all playlist files in the Playlists directory"""
        playlists = []
        if self.playlists_dir.exists():
            for file_path in sorted(self.playlists_dir.glob("*.json")):
                playlists.append({
                    "name": file_path.stem,  # filename without extension
                    "path": str(file_path),
                    "file": file_path
                })
        return playlists
    
    def load_playlist(self, file_path=None):
        """Load playlist from file (defaults to current playlist_file)"""
        if file_path is None:
            file_path = self.playlist_file
        else:
            file_path = Path(file_path)
            # If relative path, make it relative to playlists_dir
            if not file_path.is_absolute():
                file_path = self.playlists_dir / file_path.name
        
        if file_path.exists():
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    urls = data.get("urls", [])
                    # Support both old format (list of strings) and new format (list of objects)
                    # Convert to new format if needed
                    converted = []
                    for item in urls:
                        if isinstance(item, str):
                            # Old format: just URL string
                            converted.append({"url": item, "display_text": None})
                        elif isinstance(item, dict):
                            # New format: object with url and optional display_text
                            converted.append({"url": item.get("url", ""), "display_text": item.get("display_text")})
                    return converted
            except Exception as e:
                logger.warning(f"Failed to load playlist from {file_path}: {e}")
                return []
        return []
    
    def save_playlist(self, file_path=None):
        """Save playlist to file (defaults to current playlist_file)"""
        if file_path is None:
            file_path = self.playlist_file
        else:
            file_path = Path(file_path)
            # If relative path, make it relative to playlists_dir
            if not file_path.is_absolute():
                file_path = self.playlists_dir / file_path.name
        
        try:
            # Ensure directory exists
            file_path.parent.mkdir(parents=True, exist_ok=True)
            # Save in new format with metadata
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump({"urls": self.playlist}, f, indent=2)
            # Update current playlist_file if saving to a different file
            if file_path != self.playlist_file:
                self.playlist_file = file_path
            return True
        except Exception as e:
            logger.error(f"Failed to save playlist to {file_path}: {e}")
            return False
    
    def save_playlist_as(self, name):
        """Save playlist to a new file with the given name"""
        sanitized_name = sanitize_filename(name)
        if not sanitized_name:
            sanitized_name = "playlist"
        file_path = self.playlists_dir / f"{sanitized_name}.json"
        return self.save_playlist(file_path)
    
    def set_playlist_file(self, file_path):
        """Set the current playlist file and load it"""
        file_path = Path(file_path)
        # If relative path, make it relative to playlists_dir
        if not file_path.is_absolute():
            file_path = self.playlists_dir / file_path.name
        
        if file_path.exists():
            self.playlist_file = file_path
            self.playlist = self.load_playlist()
            return True
        return False
    
    def get_current_playlist_name(self):
        """Get the name of the current playlist (without extension)"""
        return self.playlist_file.stem if self.playlist_file else "Default"
    
    def delete_playlist_file(self, playlist_name):
        """Delete a playlist file by name
        
        Args:
            playlist_name: Name of playlist to delete (without .json extension)
            
        Returns:
            True if deleted successfully, False otherwise
        """
        try:
            playlist_path = self.playlists_dir / f"{playlist_name}.json"
            if playlist_path.exists():
                playlist_path.unlink()
                logger.info(f"Deleted playlist: {playlist_name}")
                return True
            return False
        except Exception as e:
            logger.error(f"Failed to delete playlist {playlist_name}: {e}")
            return False
    
    def ensure_default_playlist_exists(self):
        """Ensure Default.json playlist exists (create empty if it doesn't)"""
        default_path = self.playlists_dir / "Default.json"
        if not default_path.exists():
            try:
                # Create empty default playlist
                with open(default_path, 'w', encoding='utf-8') as f:
                    json.dump({"urls": []}, f, indent=2)
                logger.info("Created empty Default.json playlist")
                return True
            except Exception as e:
                logger.error(f"Failed to create Default.json: {e}")
                return False
        return True
    
    def get_playlist(self):
        """Get the current playlist (returns list of URL strings for backward compatibility)"""
        # Return just URLs for backward compatibility
        return [item["url"] if isinstance(item, dict) else item for item in self.playlist]
    
    def get_playlist_with_metadata(self):
        """Get the current playlist with metadata"""
        return self.playlist.copy()
    
    def add_url(self, url, display_text=None):
        """Add a URL to the playlist (if not already present)"""
        # Normalize URL
        url = url.strip().rstrip('/')
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
        
        # Check if URL already exists
        url_exists = any(item.get("url") == url if isinstance(item, dict) else item == url for item in self.playlist)
        
        if not url_exists:
            self.playlist.append({"url": url, "display_text": display_text})
            self.save_playlist()
    
    def remove_url(self, url):
        """Remove a URL from the playlist (with URL normalization for matching)"""
        # Normalize the URL to remove for matching (same logic as update_url_metadata)
        def normalize_url_for_match(u):
            if not u:
                return ""
            u = u.strip().rstrip('/')
            if u.startswith('http://'):
                u = 'https://' + u[7:]
            return u.lower()
        
        normalized_target = normalize_url_for_match(url)
        
        # Remove items where the normalized URL matches
        original_count = len(self.playlist)
        self.playlist = [item for item in self.playlist 
                        if normalize_url_for_match(item.get("url") if isinstance(item, dict) else item) != normalized_target]
        
        # Only save if something was actually removed
        if len(self.playlist) < original_count:
            self.save_playlist()
    
    def update_url_metadata(self, url, display_text):
        """Update the display text (metadata) for a URL in the playlist"""
        # Normalize URL for comparison (remove trailing slashes, normalize scheme, strip query params for matching)
        def normalize_url_for_match(u):
            if not u:
                return ""
            u = u.strip().rstrip('/')
            # Remove query parameters for matching (URLs with different query params should match)
            if '?' in u:
                u = u.split('?')[0]
            if u.startswith('http://'):
                u = 'https://' + u[7:]
            return u.lower()
        
        normalized_url = normalize_url_for_match(url)
        
        for item in self.playlist:
            item_url = item.get("url") if isinstance(item, dict) else item
            normalized_item_url = normalize_url_for_match(item_url)
            if normalized_item_url == normalized_url:
                if isinstance(item, dict):
                    item["display_text"] = display_text
                else:
                    # Convert old format to new format
                    index = self.playlist.index(item)
                    self.playlist[index] = {"url": item, "display_text": display_text}
                self.save_playlist()
                logger.debug(f"Updated metadata for URL: {item_url} -> {display_text}")
                return
        
        # If no match found, log for debugging
        logger.debug(f"Could not find URL in playlist to update metadata: {url} (normalized: {normalized_url})")
    
    def get_url_metadata(self, url):
        """Get the stored display text (metadata) for a URL"""
        # Normalize URL for comparison (remove trailing slashes, normalize scheme, strip query params for matching)
        def normalize_url_for_match(u):
            if not u:
                return ""
            u = u.strip().rstrip('/')
            # Remove query parameters for matching (URLs with different query params should match)
            if '?' in u:
                u = u.split('?')[0]
            if u.startswith('http://'):
                u = 'https://' + u[7:]
            return u.lower()
        
        normalized_url = normalize_url_for_match(url)
        
        for item in self.playlist:
            item_url = item.get("url") if isinstance(item, dict) else item
            normalized_item_url = normalize_url_for_match(item_url)
            if normalized_item_url == normalized_url:
                if isinstance(item, dict):
                    return item.get("display_text")
        return None
    
    def get_url_display_text(self, url):
        """Get display text for a URL - returns stored metadata or extracts from URL (Album by Artist format)"""
        # First try to get stored metadata (preferred - has correct formatting from page)
        stored_metadata = self.get_url_metadata(url)
        if stored_metadata:
            # If stored metadata is in "Artist - Album" format (old format), convert to "Album by Artist"
            if ' - ' in stored_metadata and ' by ' not in stored_metadata:
                parts = stored_metadata.split(' - ', 1)
                if len(parts) == 2:
                    artist = parts[0].strip()
                    album = parts[1].strip()
                    return f"{album} by {artist}"
            # Already in "Album by Artist" format or other format - return as-is (preserves formatting)
            return stored_metadata
        
        # If no stored metadata, return None (caller should use extract_artist_album_from_url)
        return None
    
    def clear_playlist(self):
        """Clear the entire playlist"""
        self.playlist = []
        self.save_playlist()
    
    def reorder_playlist(self, new_order):
        """Reorder the playlist (new_order is list of URL strings)"""
        # Create a mapping of URL to full item data
        url_to_item = {}
        for item in self.playlist:
            item_url = item.get("url") if isinstance(item, dict) else item
            url_to_item[item_url] = item
        
        # Reorder based on new_order
        reordered = []
        for url in new_order:
            if url in url_to_item:
                reordered.append(url_to_item[url])
        
        # Validate that all URLs in new_order are in current playlist
        if len(reordered) == len(self.playlist) and set(new_order) == set(url_to_item.keys()):
            self.playlist = reordered
            self.save_playlist()


# ============================================================================
# ANIMATED LOADING OVERLAY CLASS
# ============================================================================

class AnimatedLoadingOverlay(QWidget):
    """Animated loading overlay with spinning loader and pulsing text"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Set widget to be opaque
        self.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, True)
        # Note: We don't use WA_AlwaysStackOnTop so playlist can be raised above overlay
        # Stacking order will be controlled via raise_() calls
        # Enable mouse tracking to intercept all mouse events
        self.setMouseTracking(True)
        self.setAttribute(Qt.WidgetAttribute.WA_NoMouseReplay, True)
        self.setStyleSheet("""
            QWidget {
                background-color: rgb(21, 21, 21);
            }
        """)
        
        # Load Bandcamp logo
        logo_path = Path(__file__).parent / "Logo" / "bandcamp-button-circle-line-aqua-128.png"
        if logo_path.exists():
            self.logo_pixmap = QPixmap(str(logo_path))
            # Scale logo to ~50px to fit nicely inside the spinner (which is 60px diameter)
            self.logo_pixmap = self.logo_pixmap.scaled(50, 50, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
        else:
            self.logo_pixmap = None
        
        # Animation properties (use private attributes for pyqtProperty)
        self._rotation_angle = 0
        self._pulse_opacity = 1.0
        
        # Setup rotation animation
        self.rotation_animation = QPropertyAnimation(self, b"rotation_angle")
        self.rotation_animation.setDuration(1500)  # 1.5 seconds per rotation
        self.rotation_animation.setStartValue(0)
        self.rotation_animation.setEndValue(360)
        self.rotation_animation.setLoopCount(-1)  # Infinite loop
        self.rotation_animation.setEasingCurve(QEasingCurve.Type.Linear)
        
        # Setup pulse animation for text - fade in and out continuously
        self.pulse_animation = QPropertyAnimation(self, b"pulse_opacity")
        self.pulse_animation.setDuration(1500)  # 1.5 seconds to fade in
        self.pulse_animation.setStartValue(0.4)
        self.pulse_animation.setEndValue(1.0)
        self.pulse_animation.setLoopCount(1)  # Run once, then chain to reverse
        # Use InOutSine for smooth fade in and out
        self.pulse_animation.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        # Create a second animation that reverses to create continuous fade in/out
        self.pulse_animation_reverse = QPropertyAnimation(self, b"pulse_opacity")
        self.pulse_animation_reverse.setDuration(1500)  # 1.5 seconds to fade out
        self.pulse_animation_reverse.setStartValue(1.0)
        self.pulse_animation_reverse.setEndValue(0.4)
        self.pulse_animation_reverse.setLoopCount(1)  # Run once, then chain back to forward
        self.pulse_animation_reverse.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        # Chain animations together for continuous fade in/out
        self.pulse_animation.finished.connect(self.pulse_animation_reverse.start)
        self.pulse_animation_reverse.finished.connect(self.pulse_animation.start)
        
        # Connect rotation animation to repaint
        self.rotation_animation.valueChanged.connect(self.update)
        self.pulse_animation.valueChanged.connect(self.update)
        self.pulse_animation_reverse.valueChanged.connect(self.update)
    
    def get_rotation_angle(self):
        return self._rotation_angle
    
    def set_rotation_angle(self, value):
        self._rotation_angle = value
        self.update()
    
    def get_pulse_opacity(self):
        return self._pulse_opacity
    
    def set_pulse_opacity(self, value):
        self._pulse_opacity = value
        self.update()
    
    rotation_angle = pyqtProperty(float, get_rotation_angle, set_rotation_angle)
    pulse_opacity = pyqtProperty(float, get_pulse_opacity, set_pulse_opacity)
    
    def showEvent(self, event):
        """Start animations when shown"""
        super().showEvent(event)
        self.rotation_animation.start()
        self.pulse_animation.start()
    
    def hideEvent(self, event):
        """Stop animations when hidden"""
        super().hideEvent(event)
        self.rotation_animation.stop()
        self.pulse_animation.stop()
        self.pulse_animation_reverse.stop()
    
    def contextMenuEvent(self, event):
        """Prevent right-click context menu during loading overlay"""
        # Block all context menu events on the loading overlay
        event.accept()
    
    def mousePressEvent(self, event):
        """Block all mouse press events during loading overlay"""
        event.accept()
    
    def mouseReleaseEvent(self, event):
        """Block all mouse release events during loading overlay"""
        event.accept()
    
    def mouseMoveEvent(self, event):
        """Block all mouse move events during loading overlay"""
        event.accept()
    
    def paintEvent(self, event):
        """Custom paint event for animated loader"""
        
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Fill the entire background with solid color
        painter.fillRect(self.rect(), QColor(21, 21, 21))
        
        # Get center of widget
        center_x = self.width() / 2
        center_y = self.height() / 2
        
        # Draw spinning circle loader
        loader_radius = 30
        loader_width = 4
        
        # Create gradient for loader
        gradient = QPainterPath()
        gradient.addEllipse(
            center_x - loader_radius,
            center_y - loader_radius - 20,  # Offset up a bit
            loader_radius * 2,
            loader_radius * 2
        )
        
        # Draw spinning arc
        pen = QPen()
        pen.setWidth(loader_width)
        pen.setCapStyle(Qt.PenCapStyle.RoundCap)
        
        # Create colorful gradient for the spinner using shades of #1da0c3
        conical_gradient = QConicalGradient(center_x, center_y - 20, self._rotation_angle)
        # Base color: #1da0c3 (RGB: 29, 160, 195)
        conical_gradient.setColorAt(0.0, QColor(29, 160, 195))   # Base cyan
        conical_gradient.setColorAt(0.25, QColor(20, 140, 175))  # Darker shade
        conical_gradient.setColorAt(0.5, QColor(15, 120, 155))   # Darkest shade
        conical_gradient.setColorAt(0.75, QColor(20, 140, 175))  # Darker shade
        conical_gradient.setColorAt(1.0, QColor(29, 160, 195))    # Base cyan
        
        pen.setBrush(conical_gradient)
        painter.setPen(pen)
        
        # Draw arc (270 degrees, leaving a gap)
        rect = QRect(
            int(center_x - loader_radius),
            int(center_y - loader_radius - 20),
            int(loader_radius * 2),
            int(loader_radius * 2)
        )
        
        start_angle = int(self._rotation_angle * 16)  # Qt uses 1/16th degree units
        span_angle = int(270 * 16)  # 270 degree arc
        
        painter.drawArc(rect, start_angle, span_angle)
        
        # Draw Bandcamp logo in the center of the spinner
        if self.logo_pixmap and not self.logo_pixmap.isNull():
            logo_size = self.logo_pixmap.size()
            logo_x = int(center_x - logo_size.width() / 2)
            logo_y = int(center_y - 20 - logo_size.height() / 2)  # Center at spinner center
            painter.drawPixmap(logo_x, logo_y, self.logo_pixmap)
        
        # Draw pulsing "Loading..." text
        painter.setPen(QColor(220, 220, 220))
        font = painter.font()
        font.setPointSize(14)
        font.setBold(True)
        painter.setFont(font)
        
        # Apply pulse opacity
        text_color = QColor(220, 220, 220)
        text_color.setAlphaF(self._pulse_opacity)
        painter.setPen(text_color)
        
        text = "Loading..."
        text_rect = painter.fontMetrics().boundingRect(text)
        text_x = int(center_x - text_rect.width() / 2)
        text_y = int(center_y + loader_radius + 30)
        
        painter.drawText(text_x, text_y, text)
        
        # Draw three pulsing dots below text
        dot_radius = 4
        dot_spacing = 12
        dots_start_x = center_x - (dot_spacing * 1.5)
        dots_y = center_y + loader_radius + 50
        
        for i in range(3):
            dot_x = dots_start_x + (i * dot_spacing)
            # Stagger the pulse for each dot
            dot_opacity = max(0.3, self._pulse_opacity - (i * 0.2))
            # Use shades of #1da0c3 for dots (lighter shades for variety)
            base_color = QColor(29, 160, 195)  # Base #1da0c3
            # Make each dot slightly lighter for visual variety
            dot_brightness = 1.0 + (i * 0.15)  # Increase brightness for each dot
            dot_color = QColor(
                min(255, int(base_color.red() * dot_brightness)),
                min(255, int(base_color.green() * dot_brightness)),
                min(255, int(base_color.blue() * dot_brightness))
            )
            dot_color.setAlphaF(dot_opacity)
            painter.setBrush(QBrush(dot_color))
            painter.setPen(Qt.PenStyle.NoPen)
            painter.drawEllipse(
                int(dot_x - dot_radius),
                int(dots_y - dot_radius),
                int(dot_radius * 2),
                int(dot_radius * 2)
            )

# ============================================================================
# COVER ART LOADING WIDGET CLASS
# ============================================================================

class CoverArtLoadingWidget(QWidget):
    """Loading animation widget for nano mode cover art area."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Set widget to be transparent and positioned over cover art
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)  # Don't block clicks
        self.setAttribute(Qt.WidgetAttribute.WA_NoSystemBackground, True)
        
        # Animation properties
        self._rotation_angle = 0
        self._pulse_opacity = 1.0
        
        # Setup rotation animation (clockwise: 360 to 0)
        self.rotation_animation = QPropertyAnimation(self, b"rotation_angle")
        self.rotation_animation.setDuration(1500)  # 1.5 seconds per rotation
        self.rotation_animation.setStartValue(360)
        self.rotation_animation.setEndValue(0)
        self.rotation_animation.setLoopCount(-1)  # Infinite loop
        self.rotation_animation.setEasingCurve(QEasingCurve.Type.Linear)
        
        # Setup pulse animation for subtle feedback
        self.pulse_animation = QPropertyAnimation(self, b"pulse_opacity")
        self.pulse_animation.setDuration(1200)  # 1.2 second cycle
        self.pulse_animation.setStartValue(0.7)
        self.pulse_animation.setEndValue(1.0)
        self.pulse_animation.setLoopCount(1)
        self.pulse_animation.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        # Reverse pulse animation
        self.pulse_animation_reverse = QPropertyAnimation(self, b"pulse_opacity")
        self.pulse_animation_reverse.setDuration(1200)
        self.pulse_animation_reverse.setStartValue(1.0)
        self.pulse_animation_reverse.setEndValue(0.7)
        self.pulse_animation_reverse.setLoopCount(1)
        self.pulse_animation_reverse.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        # Chain animations
        self.pulse_animation.finished.connect(self.pulse_animation_reverse.start)
        self.pulse_animation_reverse.finished.connect(self.pulse_animation.start)
        
        # Connect animations to repaint
        self.rotation_animation.valueChanged.connect(self.update)
        self.pulse_animation.valueChanged.connect(self.update)
        self.pulse_animation_reverse.valueChanged.connect(self.update)
    
    def get_rotation_angle(self):
        return self._rotation_angle
    
    def set_rotation_angle(self, value):
        self._rotation_angle = value
        self.update()
    
    def get_pulse_opacity(self):
        return self._pulse_opacity
    
    def set_pulse_opacity(self, value):
        self._pulse_opacity = value
        self.update()
    
    rotation_angle = pyqtProperty(float, get_rotation_angle, set_rotation_angle)
    pulse_opacity = pyqtProperty(float, get_pulse_opacity, set_pulse_opacity)
    
    def showEvent(self, event):
        """Start animations when shown."""
        super().showEvent(event)
        self.rotation_animation.start()
        self.pulse_animation.start()
    
    def hideEvent(self, event):
        """Stop animations when hidden."""
        super().hideEvent(event)
        self.rotation_animation.stop()
        self.pulse_animation.stop()
        self.pulse_animation_reverse.stop()
    
    def paintEvent(self, event):
        """Paint loading animation with spinning circle."""
        if not self.isVisible():
            return
        
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Get center of widget (cover art area)
        center_x = self.width() / 2
        center_y = self.height() / 2
        
        # Draw spinning circle loader (smaller for 50px cover art)
        loader_radius = 15  # Smaller radius for compact space
        loader_width = 2
        
        # Create pen for spinner
        pen = QPen()
        pen.setWidth(loader_width)
        pen.setCapStyle(Qt.PenCapStyle.RoundCap)
        
        # Create colorful gradient for the spinner using shades of #1da0c3
        conical_gradient = QConicalGradient(center_x, center_y, self._rotation_angle)
        # Base color: #1da0c3 (RGB: 29, 160, 195)
        conical_gradient.setColorAt(0.0, QColor(29, 160, 195))   # Base cyan
        conical_gradient.setColorAt(0.25, QColor(20, 140, 175))  # Darker shade
        conical_gradient.setColorAt(0.5, QColor(15, 120, 155))   # Darkest shade
        conical_gradient.setColorAt(0.75, QColor(20, 140, 175))  # Darker shade
        conical_gradient.setColorAt(1.0, QColor(29, 160, 195))    # Base cyan
        
        pen.setBrush(conical_gradient)
        painter.setPen(pen)
        
        # Draw arc (270 degrees, leaving a gap)
        rect = QRect(
            int(center_x - loader_radius),
            int(center_y - loader_radius),
            int(loader_radius * 2),
            int(loader_radius * 2)
        )
        
        start_angle = int(self._rotation_angle * 16)  # Qt uses 1/16th degree units
        span_angle = int(270 * 16)  # 270 degree arc
        
        painter.drawArc(rect, start_angle, span_angle)

# ============================================================================
# ANIMATED PLAY BUTTON CLASS
# ============================================================================

class AnimatedPlayButton(QPushButton):
    """Play/Pause button with animated border when buffering."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._is_buffering = False
        
        # Animation properties
        self._rotation_angle = 0
        self._pulse_opacity = 1.0
        
        # Setup rotation animation (clockwise: 360 to 0)
        self.rotation_animation = QPropertyAnimation(self, b"rotation_angle")
        self.rotation_animation.setDuration(1500)  # 1.5 seconds per rotation
        self.rotation_animation.setStartValue(360)
        self.rotation_animation.setEndValue(0)
        self.rotation_animation.setLoopCount(-1)  # Infinite loop
        self.rotation_animation.setEasingCurve(QEasingCurve.Type.Linear)
        
        # Setup pulse animation for subtle feedback
        self.pulse_animation = QPropertyAnimation(self, b"pulse_opacity")
        self.pulse_animation.setDuration(1200)  # 1.2 second cycle
        self.pulse_animation.setStartValue(0.7)
        self.pulse_animation.setEndValue(1.0)
        self.pulse_animation.setLoopCount(1)
        self.pulse_animation.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        # Reverse pulse animation
        self.pulse_animation_reverse = QPropertyAnimation(self, b"pulse_opacity")
        self.pulse_animation_reverse.setDuration(1200)
        self.pulse_animation_reverse.setStartValue(1.0)
        self.pulse_animation_reverse.setEndValue(0.7)
        self.pulse_animation_reverse.setLoopCount(1)
        self.pulse_animation_reverse.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        # Chain animations
        self.pulse_animation.finished.connect(self.pulse_animation_reverse.start)
        self.pulse_animation_reverse.finished.connect(self.pulse_animation.start)
        
        # Connect animations to repaint
        self.rotation_animation.valueChanged.connect(self.update)
        self.pulse_animation.valueChanged.connect(self.update)
        self.pulse_animation_reverse.valueChanged.connect(self.update)
    
    def get_rotation_angle(self):
        return self._rotation_angle
    
    def set_rotation_angle(self, value):
        self._rotation_angle = value
        self.update()
    
    def get_pulse_opacity(self):
        return self._pulse_opacity
    
    def set_pulse_opacity(self, value):
        self._pulse_opacity = value
        self.update()
    
    rotation_angle = pyqtProperty(float, get_rotation_angle, set_rotation_angle)
    pulse_opacity = pyqtProperty(float, get_pulse_opacity, set_pulse_opacity)
    
    def set_buffering(self, is_buffering):
        """Set buffering state and start/stop animations."""
        if is_buffering != self._is_buffering:
            self._is_buffering = is_buffering
            if is_buffering:
                self.rotation_animation.start()
                self.pulse_animation.start()
            else:
                self.rotation_animation.stop()
                self.pulse_animation.stop()
                self.pulse_animation_reverse.stop()
                self._pulse_opacity = 1.0  # Reset to full opacity
            self.update()
    
    def paintEvent(self, event):
        """Paint button with animated border when buffering."""
        # First, paint the button normally
        super().paintEvent(event)
        
        # If buffering, draw animated border
        if self._is_buffering:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Get button rectangle
            rect = self.rect()
            
            # Draw animated border (rotating arc)
            border_width = 2
            border_radius = min(rect.width(), rect.height()) / 2 - border_width / 2
            
            # Center of button
            center_x = rect.width() / 2
            center_y = rect.height() / 2
            
            # Create pen for animated border
            pen = QPen()
            pen.setWidth(border_width)
            pen.setCapStyle(Qt.PenCapStyle.RoundCap)
            
            # Use theme color (#4a90e2) with pulse opacity
            base_color = QColor(74, 144, 226)  # #4a90e2
            base_color.setAlphaF(self._pulse_opacity)
            
            # Create conical gradient for rotating border
            conical_gradient = QConicalGradient(center_x, center_y, self._rotation_angle)
            # Gradient from bright to dim for smooth rotation effect
            bright_color = QColor(74, 144, 226, int(255 * self._pulse_opacity))
            dim_color = QColor(74, 144, 226, int(255 * self._pulse_opacity * 0.3))
            conical_gradient.setColorAt(0.0, bright_color)
            conical_gradient.setColorAt(0.5, dim_color)
            conical_gradient.setColorAt(1.0, bright_color)
            
            pen.setBrush(conical_gradient)
            painter.setPen(pen)
            
            # Draw arc (270 degrees, leaving a gap) around button border
            arc_rect = QRect(
                int(center_x - border_radius),
                int(center_y - border_radius),
                int(border_radius * 2),
                int(border_radius * 2)
            )
            
            start_angle = int(self._rotation_angle * 16)  # Qt uses 1/16th degree units
            span_angle = int(270 * 16)  # 270 degree arc (3/4 circle)
            
            painter.drawArc(arc_rect, start_angle, span_angle)

# ============================================================================
# PLAYLIST ITEM DELEGATE CLASS
# ============================================================================

class PlaylistItemDelegate(QStyledItemDelegate):
    """Custom delegate for playlist items to handle current item highlighting"""
    
    def helpEvent(self, event, view, option, index):
        """Show tooltip with full album name only if text is truncated"""
        if event.type() == QEvent.Type.ToolTip:
            # Get the display text (album name)
            display_text = index.data(Qt.ItemDataRole.DisplayRole) or ''
            if display_text:
                # Check if text is truncated by comparing displayed text with available width
                font = option.font
                metrics = QFontMetrics(font)
                # Calculate available width (accounting for padding: 0px 6px from stylesheet)
                text_rect = option.rect.adjusted(6, 0, -6, 0)
                available_width = text_rect.width()
                
                # Check if the displayed text ends with ellipsis (definitely truncated)
                if display_text.endswith('...'):
                    # Definitely truncated - show tooltip with full text
                    QToolTip.showText(event.globalPos(), display_text, view)
                    return True
                
                # Check if full text width exceeds available width (would be truncated)
                full_text_width = metrics.horizontalAdvance(display_text)
                if full_text_width > available_width:
                    # Text would be truncated - show tooltip
                    QToolTip.showText(event.globalPos(), display_text, view)
                    return True
        
        return super().helpEvent(event, view, option, index)
    
    def paint(self, painter, option, index):
        """Paint the item with custom colors for current item"""
        # Check if this is the current item (using custom data role)
        is_current = index.data(Qt.ItemDataRole.UserRole + 1)  # Custom role for current item
        
        if is_current:
            # Current item: blue text only, no background (matches selected track style)
            # Clear any selection state to prevent default highlighting/borders
            option.state &= ~QStyle.StateFlag.State_Selected
            option.state &= ~QStyle.StateFlag.State_HasFocus
            
            # Paint default background (match list background #2b2b2b)
            painter.fillRect(option.rect, QColor(43, 43, 43))  # Match list background #2b2b2b
            
            # Paint blue text with elision
            text = index.data(Qt.ItemDataRole.DisplayRole)
            if text:
                painter.setPen(QColor(74, 144, 226))  # Blue text #4a90e2
                # Use the same font as the list widget
                font = option.font
                painter.setFont(font)
                # Calculate text rect with padding (matching stylesheet padding: 0px 6px)
                text_rect = option.rect.adjusted(6, 0, -6, 0)
                # Elide text if it's too long
                metrics = QFontMetrics(font)
                elided_text = metrics.elidedText(str(text), Qt.TextElideMode.ElideRight, text_rect.width())
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)
            return  # Don't call parent paint - we've painted everything ourselves
        else:
            # Regular item: allow selection highlight if user clicked on it
            # Check if item is actually selected (user clicked on it)
            is_user_selected = option.state & QStyle.StateFlag.State_Selected
            
            if is_user_selected:
                # User-selected item: let stylesheet handle the highlight (light gray background)
                # Set text color to slightly lighter gray for better contrast
                option.palette.setColor(option.palette.ColorRole.Text, QColor(224, 224, 224))  # Light gray text (#e0e0e0)
                # Keep selected state so stylesheet applies the background
                # Clear focus state to prevent white border/focus rectangle
                option.state &= ~QStyle.StateFlag.State_HasFocus
            else:
                # Not selected: light gray text, no background (match tracks list color)
                option.palette.setColor(option.palette.ColorRole.Text, QColor(200, 200, 200))  # #c8c8c8 - same as tracks list
                # Don't clear selected state here - let Qt handle it naturally
            
            # Enable text elision for regular items
            option.textElideMode = Qt.TextElideMode.ElideRight
        
        # Call parent paint method (will use our modified palette and state)
        super().paint(painter, option, index)


class NanoMenuDelegate(QStyledItemDelegate):
    """Custom delegate for nano player track/album menus - blue text for current item (no background)"""
    
    def helpEvent(self, event, view, option, index):
        """Show tooltip with full album/track name only if text is truncated"""
        if event.type() == QEvent.Type.ToolTip:
            logger.debug(f"[ALBUMLIST TOOLTIP] helpEvent called - view={view}, index={index.row() if index.isValid() else 'invalid'}")
            
            # Get the full text - check UserRole + 2 first (stored separately for albumlist),
            # then fall back to DisplayRole (which should have the full text)
            full_text = index.data(Qt.ItemDataRole.UserRole + 2)
            logger.debug(f"[ALBUMLIST TOOLTIP] UserRole + 2 = {full_text}")
            
            if not full_text:
                # Fall back to DisplayRole if UserRole + 2 is not set or empty
                full_text = index.data(Qt.ItemDataRole.DisplayRole) or ''
                logger.debug(f"[ALBUMLIST TOOLTIP] Fallback to DisplayRole = {full_text}")
            else:
                full_text = str(full_text)
            
            # Get display text for comparison
            display_text = str(index.data(Qt.ItemDataRole.DisplayRole) or '')
            logger.debug(f"[ALBUMLIST TOOLTIP] display_text = '{display_text}', full_text = '{full_text}'")
            
            if full_text:
                # Check if text is truncated by comparing full text width with available width
                # Note: DisplayRole won't have ellipsis - Qt adds that during paint, not in stored text
                font = option.font
                metrics = QFontMetrics(font)
                
                # Use viewport width instead of option.rect.width() to account for scrollbars
                # Get the actual visible width of the list widget
                if hasattr(view, 'viewport'):
                    viewport_width = view.viewport().width()
                else:
                    viewport_width = view.width()
                
                # Calculate available width - match paint method exactly
                # Paint method uses: option.rect.adjusted(8, 2, -8, -2) for current items (8px horizontal padding)
                # For regular items, Qt uses stylesheet padding (0px 8px or 2px 8px) - always 8px horizontal
                # Use 8px horizontal padding on each side (16px total)
                # Also account for potential scrollbar (typically ~15-20px) by using viewport width
                available_width = viewport_width - 16  # 8px padding on each side
                
                # Also try eliding the text to see if it would be different (more reliable check)
                elided_text = metrics.elidedText(full_text, Qt.TextElideMode.ElideRight, available_width)
                would_be_truncated = (elided_text != full_text)
                
                # Check if full text width exceeds available width (would be truncated)
                # Add a small tolerance buffer (2px) to account for rendering differences
                full_text_width = metrics.horizontalAdvance(full_text)
                width_check = full_text_width > (available_width - 2)
                
                # Also check if display_text is shorter than full_text (another indicator of truncation)
                display_text_str = str(display_text)
                length_check = len(display_text_str) < len(full_text)
                
                logger.debug(f"[ALBUMLIST TOOLTIP] Width check: full_text='{full_text}', full_text_width={full_text_width}, available_width={available_width}, viewport_width={viewport_width}, elided='{elided_text}', would_be_truncated={would_be_truncated}, width_check={width_check}, length_check={length_check}, rect={option.rect}")
                
                # Show tooltip if text would be truncated (use elided text check as primary, width as secondary, length as tertiary)
                if would_be_truncated or width_check or length_check:
                    # Text would be truncated - show tooltip with full text
                    logger.debug(f"[ALBUMLIST TOOLTIP] Showing tooltip (truncated): '{full_text}'")
                    QToolTip.showText(event.globalPos(), full_text, view)
                    return True
                else:
                    logger.debug(f"[ALBUMLIST TOOLTIP] Text fits, not showing tooltip (full_text_width={full_text_width} <= available_width={available_width})")
            else:
                logger.debug(f"[ALBUMLIST TOOLTIP] No full_text available")
        
        logger.debug(f"[ALBUMLIST TOOLTIP] Calling super().helpEvent()")
        return super().helpEvent(event, view, option, index)
    
    def paint(self, painter, option, index):
        """Paint the item with blue text for current item"""
        # Check if this is the current item (using custom data role)
        is_current = index.data(Qt.ItemDataRole.UserRole + 1)  # Custom role for current item
        # Ensure boolean evaluation (handle None, False, True explicitly)
        is_current = bool(is_current) if is_current is not None else False
        
        if is_current:
            # Current item: blue text, no background, no border/outline
            # Clear any selection state to prevent default highlighting/borders
            option.state &= ~QStyle.StateFlag.State_Selected
            option.state &= ~QStyle.StateFlag.State_HasFocus
            
            # Paint default background (match list background #2b2b2b)
            painter.fillRect(option.rect, QColor(43, 43, 43))  # Match list background #2b2b2b
            
            # Paint blue text
            text = index.data(Qt.ItemDataRole.DisplayRole)
            if text:
                painter.setPen(QColor(74, 144, 226))  # Blue text #4a90e2
                # Use the same font as the list widget
                font = option.font
                painter.setFont(font)
                # Calculate text rect with padding (matching stylesheet padding: 2px 8px)
                text_rect = option.rect.adjusted(8, 2, -8, -2)
                # Elide text if it's too long
                metrics = QFontMetrics(font)
                elided_text = metrics.elidedText(str(text), Qt.TextElideMode.ElideRight, text_rect.width())
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)
            return  # Don't call parent paint - we've painted everything ourselves
        else:
            # Regular item: use default styling (light gray text from stylesheet)
            # Clear any selection state to prevent ugly borders on non-current items
            option.state &= ~QStyle.StateFlag.State_Selected
            option.state &= ~QStyle.StateFlag.State_HasFocus
            # Enable text elision for regular items
            option.textElideMode = Qt.TextElideMode.ElideRight
        
        # Call parent paint method (will use default stylesheet colors)
        super().paint(painter, option, index)


class TracklistDelegate(QStyledItemDelegate):
    """Custom delegate for regular mode tracklist - two columns: track title on left, duration on right"""
    
    def helpEvent(self, event, view, option, index):
        """Show tooltip with full track name only if text is truncated"""
        if event.type() == QEvent.Type.ToolTip:
            # DEBUG: Log that helpEvent was called for tracklist
            logger.debug(f"[TRACKLIST TOOLTIP] helpEvent called - view={view}, index={index.row() if index.isValid() else 'invalid'}")
            
            # Get track data
            track_data = index.data(Qt.ItemDataRole.UserRole)
            logger.debug(f"[TRACKLIST TOOLTIP] track_data = {track_data}")
            
            if track_data:
                full_title = track_data.get('fullTitle', '')
                display_text = index.data(Qt.ItemDataRole.DisplayRole) or ''
                logger.debug(f"[TRACKLIST TOOLTIP] full_title = '{full_title}', display_text = '{display_text}'")
                
                if full_title and full_title != display_text:
                    # Extract just the title part from display_text (remove track number prefix like "01. ")
                    import re as _re
                    title_match = _re.match(r'^\d{2}\.\s*(.+)$', display_text)
                    if title_match:
                        displayed_title = title_match.group(1)
                        # Only show tooltip if the displayed title ends with ellipsis (definitely truncated)
                        # or if the full title is significantly longer (likely truncated)
                        if displayed_title.endswith('...'):
                            # Definitely truncated - show tooltip
                            logger.debug(f"[TRACKLIST TOOLTIP] Showing tooltip (ellipsis detected): '{full_title}'")
                            QToolTip.showText(event.globalPos(), full_title, view)
                            return True
                        # Check if text would be truncated by comparing with available width
                        # Get font metrics to check actual text width
                        font = option.font
                        metrics = QFontMetrics(font)
                        # Calculate available width for title (similar to paint method)
                        left_padding = 8
                        right_padding = 4
                        text_rect = option.rect.adjusted(left_padding, 2, -right_padding, -2)
                        duration = track_data.get('duration', '')
                        if duration:
                            actual_duration_width = metrics.horizontalAdvance(duration)
                            min_duration_width = metrics.horizontalAdvance("12:34:0")
                            duration_width = max(actual_duration_width, min_duration_width) + 2
                            duration_right = text_rect.right()
                            duration_left = duration_right - duration_width
                            available_width = duration_left - text_rect.left() - 8
                        else:
                            available_width = text_rect.width()
                        
                        # Check if full title would be truncated
                        full_title_width = metrics.horizontalAdvance(full_title)
                        if full_title_width > available_width:
                            # Text would be truncated - show tooltip
                            logger.debug(f"[TRACKLIST TOOLTIP] Showing tooltip (width check): '{full_title}' (width: {full_title_width} > {available_width})")
                            QToolTip.showText(event.globalPos(), full_title, view)
                            return True
                else:
                    logger.debug(f"[TRACKLIST TOOLTIP] full_title matches display_text or is empty, not showing tooltip")
            else:
                logger.debug(f"[TRACKLIST TOOLTIP] No track_data available")
        
        logger.debug(f"[TRACKLIST TOOLTIP] Calling super().helpEvent()")
        return super().helpEvent(event, view, option, index)
    
    def paint(self, painter, option, index):
        """Paint the item with two columns: title on left, duration on right"""
        # Check if this is the current item (using custom data role)
        is_current = index.data(Qt.ItemDataRole.UserRole + 1)  # Custom role for current item
        
        # Check if item is being hovered
        is_hovered = option.state & QStyle.StateFlag.State_MouseOver
        
        # Get track data
        track_data = index.data(Qt.ItemDataRole.UserRole)
        duration = track_data.get('duration', '') if track_data else ''
        display_text = index.data(Qt.ItemDataRole.DisplayRole) or ''
        
        # Clear selection state to prevent default highlighting
        option.state &= ~QStyle.StateFlag.State_Selected
        option.state &= ~QStyle.StateFlag.State_HasFocus
        
        # Paint background
        bg_color = QColor(43, 43, 43)  # Match list background #2b2b2b
        if is_hovered and not is_current:
            # Hover state: match albums list hover color for consistency
            bg_color = QColor(58, 58, 58)  # #3a3a3a - same as albums list hover
        painter.fillRect(option.rect, bg_color)
        
        # Set up text color
        if is_current:
            text_color = QColor(74, 144, 226)  # Blue text #4a90e2 for current track
        else:
            text_color = QColor(200, 200, 200)  # Light gray for regular tracks
        
        painter.setPen(text_color)
        font = option.font
        painter.setFont(font)
        metrics = QFontMetrics(font)
        
        # Calculate padding - reduced right padding to give more space to track name
        left_padding = 8
        right_padding = 4  # Reduced from 8 to 4 to minimize space on right side of duration
        text_rect = option.rect.adjusted(left_padding, 2, -right_padding, -2)
        
        # If we have duration, split into two columns
        if duration:
            # Calculate actual duration width
            actual_duration_width = metrics.horizontalAdvance(duration)
            # Reserve minimum width for duration (enough for "12:34:56" format)
            min_duration_width = metrics.horizontalAdvance("12:34:0")
            # Use actual width with minimal padding
            duration_width = max(actual_duration_width, min_duration_width) + 2  # Minimal padding for duration
            
            # Position duration column - minimal gap from title
            # Right edge of duration column (flush with reduced right padding)
            duration_right = text_rect.right()
            duration_left = duration_right - duration_width
            
            # Left column: track title (reduced gap from 20px to 8px to make track name wider)
            left_rect = QRect(text_rect.left(), text_rect.top(), 
                            duration_left - text_rect.left() - 8, text_rect.height())  # Reduced gap from 20px to 8px
            elided_title = metrics.elidedText(display_text, Qt.TextElideMode.ElideRight, left_rect.width())
            painter.drawText(left_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_title)
            
            # Right column: duration (right-aligned, flush with reduced right padding)
            right_rect = QRect(duration_left, text_rect.top(), 
                             duration_width, text_rect.height())
            painter.drawText(right_rect, Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter, duration)
        else:
            # No duration - just show title (full width)
            elided_text = metrics.elidedText(display_text, Qt.TextElideMode.ElideRight, text_rect.width())
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)


# ============================================================================
# CUSTOM VOLUME SLIDER CLASS
# ============================================================================

class VolumeSlider(QWidget):
    """Custom vertical volume slider that fills from bottom up"""
    valueChanged = pyqtSignal(int)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._value = 0
        self._minimum = 0
        self._maximum = 100
        self._is_dragging = False
        self.setFixedSize(20, 120)
        self.setMinimumSize(20, 120)
        self.setMaximumSize(20, 120)
    
    def setMinimum(self, value):
        self._minimum = value
    
    def setMaximum(self, value):
        self._maximum = value
    
    def setValue(self, value):
        if value != self._value:
            self._value = max(self._minimum, min(self._maximum, value))
            self.update()
            self.valueChanged.emit(self._value)
    
    def value(self):
        return self._value
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Use fixed width to prevent resizing (always accommodate 100%)
        width = 20  # Fixed width
        height = self.height()
        
        # Calculate fill height (from bottom up)
        fill_height = int((self._value - self._minimum) / (self._maximum - self._minimum) * height)
        
        # Draw background (unfilled area at top)
        painter.fillRect(0, 0, width, height - fill_height, QColor("#2b2b2b"))
        
        # Draw filled area (blue, from bottom)
        painter.fillRect(0, height - fill_height, width, fill_height, QColor("#4a90e2"))
        
        # Handle is hidden - no circle drawn
    
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self._is_dragging = True
            self._update_value_from_pos(event.position().y())
    
    def mouseMoveEvent(self, event):
        if self._is_dragging:
            self._update_value_from_pos(event.position().y())
    
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self._is_dragging = False
    
    def _update_value_from_pos(self, y):
        height = self.height()
        # Invert y: bottom is 0, top is height
        normalized = 1.0 - (y / height)
        normalized = max(0.0, min(1.0, normalized))
        value = int(self._minimum + normalized * (self._maximum - self._minimum))
        self.setValue(value)

# ============================================================================
# PLAYLIST SIDEBAR CLASS
# ============================================================================

class PlaylistSidebar(QWidget):
    """Integrated sidebar playlist widget - PotPlayer style"""
    
    def __init__(self, parent, playlist_manager, resolve_url_redirects_func, load_url_func):
        super().__init__(parent)
        self.playlist_manager = playlist_manager
        self.resolve_url_redirects = resolve_url_redirects_func
        self.load_url_func = load_url_func
        self.current_item = None  # Track currently playing item
        
        # Undo/redo history
        self.undo_history = []  # List of playlist states (list of dicts with url and display_text)
        self.redo_history = []  # List of playlist states for redo
        self.max_history_size = 50  # Limit history size to prevent memory issues
        self.is_undoing_redoing = False  # Flag to prevent saving history during undo/redo
        self._suppress_history_save = False  # Flag to prevent saving history when called as part of another operation
        self._reorder_save_timer = None  # Timer to debounce drag-and-drop reordering
        
        # Repeat and shuffle state - restore from settings if available
        parent = self.parent()
        while parent and not isinstance(parent, QWidget):
            parent = parent.parent()
        # Read from centralized state in PlayerWindow (if available)
        # Otherwise fall back to settings
        if parent and hasattr(parent, 'shuffle_mode') and hasattr(parent, 'repeat_mode'):
            # Use centralized state from PlayerWindow
            self.shuffle_mode = parent.shuffle_mode
            self.repeat_mode = parent.repeat_mode
        elif parent and hasattr(parent, 'settings'):
            # Convert old boolean settings to new mode-based system
            # 0=off, 1=mode1, 2=mode2, 3=mode3
            old_repeat = parent.settings.get('repeat_on', False)
            old_shuffle = parent.settings.get('shuffle_on', False)
            # Migrate: True -> 1, False -> 0
            self.repeat_mode = parent.settings.get('repeat_mode', 1 if old_repeat else 1)  # Default to mode 1 (continuous)
            self.shuffle_mode = parent.settings.get('shuffle_mode', 1 if old_shuffle else 0)
            # Also update PlayerWindow's centralized state
            if hasattr(parent, 'shuffle_mode'):
                parent.shuffle_mode = self.shuffle_mode
                parent.repeat_mode = self.repeat_mode
        else:
            self.repeat_mode = 1  # 0=off, 1=continuous, 2=album, 3=track (default to continuous)
            self.shuffle_mode = 0  # 0=off, 1=tracks, 2=albums, 3=super
        
        # Shuffle Tracks mode: shuffled track list for current album
        self._shuffled_track_list = None  # List of track numbers in shuffled order
        self._shuffled_track_index = 0  # Current position in shuffled list
        self._shuffled_track_album_url = None  # URL of album for which we have shuffled list
        
        # Super Shuffle mode: track last 3 played combinations to avoid repeats
        self._super_shuffle_history = []  # List of tuples: [(album_url, track_number), ...] - last 3 played
        self._super_shuffle_max_history = 3  # Maximum number of recent tracks to avoid
        
        self.setup_ui()
        self.load_playlist()
        
        # Enable drag and drop on the entire sidebar widget
        self.setAcceptDrops(True)
        
        # Restore button states (after setup_ui creates the buttons)
        QTimer.singleShot(0, self._restore_button_states)
        
        # Save initial state to history
        QTimer.singleShot(100, self._save_state_to_history)
        
        # Hook into page load events to update tracklist when album loads
        # Get parent window to connect to page load events
        def setup_page_load_hook():
            parent = self.parent()
            while parent and not isinstance(parent, QMainWindow):
                parent = parent.parent()
            if parent and hasattr(parent, 'web_view') and parent.web_view:
                # Connect to page load finished signal
                if hasattr(parent.web_view, 'page') and parent.web_view.page():
                    parent.web_view.page().loadFinished.connect(self._on_page_loaded_for_tracklist)
        
        # Setup hook after a delay to ensure parent window is ready
        QTimer.singleShot(500, setup_page_load_hook)
    
    def _restore_button_states(self):
        """Restore repeat and shuffle button states from settings"""
        if hasattr(self, 'repeat_btn'):
            self._update_repeat_button_ui()
        if hasattr(self, 'shuffle_btn'):
            self._update_shuffle_button_ui()
        
        # Restore active tab from settings
        parent = self.parent()
        while parent and not isinstance(parent, QWidget):
            parent = parent.parent()
        if parent and hasattr(parent, 'settings'):
            saved_tab = parent.settings.get('playlist_active_tab', 'albums')
            if saved_tab in ['albums', 'tracks']:
                self._switch_tab(saved_tab, restore=True)
    
    def _switch_tab(self, tab_name, restore=False):
        """Switch between Albums and Tracks tabs"""
        if tab_name not in ['albums', 'tracks']:
            return
        
        # Automatically expand playlist if it's minimized when switching tabs
        if self.is_minimized:
            self._toggle_minimize_state()
        
        # Update active tab
        self.active_tab = tab_name
        
        # Update button states
        if hasattr(self, 'albums_tab_btn') and hasattr(self, 'tracks_tab_btn'):
            self.albums_tab_btn.setChecked(tab_name == 'albums')
            self.tracks_tab_btn.setChecked(tab_name == 'tracks')
        
        # Also update detached window tab buttons if they exist and are still valid
        # Check if we're in a detached window (QDialog) or attached (QMainWindow)
        parent_window = self.parent()
        while parent_window:
            if isinstance(parent_window, QMainWindow):
                # We're attached - check if detached window exists and update its buttons
                # Also verify the buttons are still valid (not deleted)
                try:
                    if (hasattr(parent_window, '_detached_albums_tab_btn') and 
                        hasattr(parent_window, '_detached_tracks_tab_btn') and
                        parent_window._detached_albums_tab_btn is not None and
                        parent_window._detached_tracks_tab_btn is not None):
                        # Check if detached playlist window still exists
                        if hasattr(parent_window, 'detached_playlist_window') and parent_window.detached_playlist_window:
                            parent_window._detached_albums_tab_btn.setChecked(tab_name == 'albums')
                            parent_window._detached_tracks_tab_btn.setChecked(tab_name == 'tracks')
                except (RuntimeError, AttributeError):
                    # Buttons were deleted, ignore
                    pass
                break
            elif isinstance(parent_window, QDialog):
                # We're in detached window - find the main window to update detached buttons
                # The main window stores the detached button references
                main_window = None
                for widget in QApplication.allWidgets():
                    if isinstance(widget, QMainWindow) and hasattr(widget, 'playlist_sidebar') and widget.playlist_sidebar == self:
                        main_window = widget
                        break
                try:
                    if (main_window and 
                        hasattr(main_window, '_detached_albums_tab_btn') and 
                        hasattr(main_window, '_detached_tracks_tab_btn') and
                        main_window._detached_albums_tab_btn is not None and
                        main_window._detached_tracks_tab_btn is not None):
                        # Check if detached playlist window still exists
                        if hasattr(main_window, 'detached_playlist_window') and main_window.detached_playlist_window:
                            main_window._detached_albums_tab_btn.setChecked(tab_name == 'albums')
                            main_window._detached_tracks_tab_btn.setChecked(tab_name == 'tracks')
                except (RuntimeError, AttributeError):
                    # Buttons were deleted, ignore
                    pass
                break
            parent_window = parent_window.parent()
        
        # Switch widget visibility (but respect minimized state - if minimized, hide both)
        if hasattr(self, 'list_widget') and hasattr(self, 'tracklist_widget'):
            if self.is_minimized:
                # When minimized, hide both widgets (only title bar should be visible)
                self.list_widget.setVisible(False)
                self.tracklist_widget.setVisible(False)
            elif tab_name == 'albums':
                self.list_widget.setVisible(True)
                self.tracklist_widget.setVisible(False)
            else:  # tracks
                self.list_widget.setVisible(False)
                self.tracklist_widget.setVisible(True)
                # Ensure tracklist widget can receive focus and clicks
                self.tracklist_widget.setEnabled(True)
                self.tracklist_widget.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
                # Update tracklist when switching to tracks tab
                QTimer.singleShot(100, self._update_playlist_tracklist)
                # Give focus to tracklist widget so it can receive clicks
                QTimer.singleShot(150, lambda: self.tracklist_widget.setFocus() if self.tracklist_widget.isVisible() else None)
        
        # Save to settings (unless this is a restore operation)
        if not restore:
            parent = self.parent()
            while parent and not isinstance(parent, QWidget):
                parent = parent.parent()
            if parent and hasattr(parent, 'settings'):
                parent.settings['playlist_active_tab'] = tab_name
                if hasattr(parent, 'save_settings'):
                    parent.save_settings()
    
    def _update_playlist_tracklist(self):
        """Update tracklist widget in playlist sidebar with tracks from current album."""
        if not hasattr(self, 'tracklist_widget') or not self.tracklist_widget:
            return
        
        # Get parent window - handle both attached (QMainWindow) and detached (QDialog) cases
        parent = self.parent()
        parent_window = None
        
        # Check if we're in a detached window (QDialog)
        while parent:
            if isinstance(parent, QMainWindow):
                # We're attached - this is the main window
                parent_window = parent
                break
            elif isinstance(parent, QDialog):
                # We're in detached window - need to find the main window that owns this playlist
                # Search all widgets to find the QMainWindow that has this playlist_sidebar
                for widget in QApplication.allWidgets():
                    if isinstance(widget, QMainWindow) and hasattr(widget, 'playlist_sidebar') and widget.playlist_sidebar == self:
                        parent_window = widget
                        break
                break
            parent = parent.parent()
        
        if not parent_window or not hasattr(parent_window, 'web_view') or not parent_window.web_view or not parent_window.web_view.page():
            self.tracklist_widget.clear()
            placeholder_item = QListWidgetItem("No Bandcamp page loaded")
            placeholder_item.setForeground(QColor("#888888"))
            placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
            self.tracklist_widget.addItem(placeholder_item)
            return
        
        # Check if we're on a valid Bandcamp page
        current_url = parent_window.web_view.url().toString()
        if not current_url or current_url == "about:blank" or "bandcamp.com" not in current_url:
            self.tracklist_widget.clear()
            placeholder_item = QListWidgetItem("No album loaded")
            placeholder_item.setForeground(QColor("#888888"))
            placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
            self.tracklist_widget.addItem(placeholder_item)
            return
        
        # Check if page is still loading
        page = parent_window.web_view.page()
        if page and hasattr(page, 'isLoading') and page.isLoading():
            self.tracklist_widget.clear()
            placeholder_item = QListWidgetItem("Page loading...")
            placeholder_item.setForeground(QColor("#888888"))
            placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
            self.tracklist_widget.addItem(placeholder_item)
            QTimer.singleShot(500, self._update_playlist_tracklist)
            return
        
        self.tracklist_widget.clear()
        
        # Use the same JavaScript code as RegularPlayerWidget
        js_code = """
        (function() {
            function cleanTrackTitle(text) {
                if (!text) return '';
                text = text.replace(/\\s*\\d{1,2}:\\d{2}(?::\\d{2})?\\s*/g, ' ');
                text = text.replace(/\\s*lyrics\\s*/gi, ' ');
                text = text.replace(/^\\d+\\.\\s*/, '');
                text = text.replace(/\\s+/g, ' ').trim();
                var originalText = text;
                var parts = text.split(/\\s*[-]\\s*/);
                if (parts.length === 2) {
                    var part1 = parts[0].trim();
                    var part2 = parts[1].trim();
                    if (part1.toLowerCase() === part2.toLowerCase() && part1.length > 0) {
                        text = part1;
                    }
                }
                return text;
            }
            
            var tracks = [];
            var tracklist = document.querySelector('#tracklist');
            if (tracklist) {
                var trackElements = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                
                trackElements.forEach(function(trackEl, index) {
                    var trackNum = trackEl.getAttribute('data-num');
                    var trackIndex = trackNum ? parseInt(trackNum) - 1 : index;
                    
                    var infoDiv = trackEl.querySelector('.info');
                    var title = null;
                    
                    if (infoDiv) {
                        var titleSpan = infoDiv.querySelector('.title, span.title, a.title');
                        if (titleSpan) {
                            title = titleSpan.textContent.trim();
                            title = cleanTrackTitle(title);
                        } else {
                            var infoText = infoDiv.textContent.trim();
                            title = cleanTrackTitle(infoText);
                        }
                    }
                    
                    if (!title || title.length === 0) {
                        var titleEl = trackEl.querySelector('.track-title, .track_title, .title');
                        if (titleEl) {
                            title = titleEl.textContent.trim();
                            title = cleanTrackTitle(title);
                        }
                    }
                    
                    if (!title || title.length === 0) {
                        var clone = trackEl.cloneNode(true);
                        var playBtn = clone.querySelector('.playbutton, button');
                        if (playBtn) playBtn.remove();
                        var timeEls = clone.querySelectorAll('.time, .duration, [class*="time"], [class*="duration"]');
                        timeEls.forEach(function(el) { el.remove(); });
                        title = clone.textContent.trim();
                        title = cleanTrackTitle(title);
                    }
                    
                    if (!title || title.length === 0) {
                        title = 'Track ' + (trackIndex + 1);
                    }
                    
                    var isPlayable = false;
                    var playStatus = trackEl.querySelector('.play_status');
                    if (!playStatus) {
                        var playCol = trackEl.querySelector('td.play-col, .play-col');
                        if (playCol) {
                            playStatus = playCol.querySelector('.play_status');
                        }
                    }
                    if (playStatus) {
                        isPlayable = !playStatus.classList.contains('disabled');
                    } else {
                        isPlayable = trackEl.classList.contains('playable') || trackEl.classList.contains('has-audio');
                    }
                    
                    // Get duration if available - specifically look for .duration class element
                    var duration = null;
                    // First try to find the .duration element specifically (as user mentioned)
                    var durationEl = trackEl.querySelector('time.duration, .duration');
                    if (durationEl) {
                        var timeText = durationEl.textContent.trim();
                        // Only use if it looks like a time (contains colon or is a short number)
                        if (timeText.indexOf(':') !== -1 || (timeText.length <= 10 && /^[\\d:\\.]+$/.test(timeText))) {
                            duration = timeText;
                        }
                    }
                    // Fallback: look for other time elements if .duration not found
                    if (!duration) {
                        var timeEl = trackEl.querySelector('.time:not(.duration), .track-length, [class*="time"]:not([class*="title"]):not(.duration)');
                        if (timeEl) {
                            var timeText = timeEl.textContent.trim();
                            // Only use if it looks like a time (contains colon or is a short number)
                            if (timeText.indexOf(':') !== -1 || (timeText.length <= 10 && /^[\\d:\\.]+$/.test(timeText))) {
                                duration = timeText;
                            }
                        }
                    }
                    
                    tracks.push({
                        index: trackIndex,
                        title: title,
                        dataNum: trackNum,
                        isPlayable: isPlayable,
                        duration: duration
                    });
                });
            }
            return tracks;
        })();
        """
        
        def on_tracks_received(result):
            if result is None or not isinstance(result, list):
                self.tracklist_widget.clear()
                placeholder_item = QListWidgetItem("Loading tracks...")
                placeholder_item.setForeground(QColor("#888888"))
                placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
                self.tracklist_widget.addItem(placeholder_item)
                QTimer.singleShot(1000, self._update_playlist_tracklist)
                return
            
            if len(result) > 0:
                for track_info in result:
                    track_index = track_info.get('index', 0)
                    track_title = track_info.get('title', 'Track')
                    data_num = track_info.get('dataNum')
                    is_playable = track_info.get('isPlayable', True)
                    duration = track_info.get('duration', '')
                    
                    # Remove duplicate title patterns
                    original_title = track_title
                    for separator in [' - ', '  ', '  ', ' -', '- ', ' ', ' ', ' ', ' ']:
                        if separator in track_title:
                            parts = track_title.split(separator, 1)
                            if len(parts) == 2:
                                part1 = parts[0].strip()
                                part2 = parts[1].strip()
                                if part1.lower() == part2.lower() and part1:
                                    track_title = part1
                                    break
                    
                    if data_num:
                        track_num = int(data_num)
                    else:
                        track_num = track_index + 1
                    
                    # Validate duration - only use if it looks like a time
                    validated_duration = None
                    if duration:
                        # Check if duration looks like a time (e.g., "3:45" or "12:34:56") or is a short number
                        is_valid_duration = (':' in duration) or (len(duration) <= 10 and duration.replace('.', '').replace(':', '').isdigit())
                        if is_valid_duration and track_title.lower() not in duration.lower():
                            validated_duration = duration
                    
                    # Display text is just the track number and title (duration will be shown in right column by delegate)
                    display_text = f"{track_num:02d}. {track_title}"
                    
                    item = QListWidgetItem(display_text)
                    # Ensure item is enabled and selectable by default (for clickable tracks)
                    item.setFlags(Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable)
                    # Store duration and full title in track_data so delegate can access it
                    track_data = {'index': track_index, 'dataNum': data_num, 'isPlayable': is_playable, 'duration': validated_duration, 'fullTitle': track_title}
                    item.setData(Qt.ItemDataRole.UserRole, track_data)
                    item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Current track marker
                    
                    if not is_playable:
                        item.setForeground(QColor("#888888"))
                        item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEnabled)
                    
                    self.tracklist_widget.addItem(item)
                
                # Add empty items at the end for scrolling
                for i in range(2):
                    empty_item = QListWidgetItem("")
                    empty_item.setFlags(Qt.ItemFlag.NoItemFlags)
                    empty_item.setForeground(QColor("#2b2b2b"))
                    self.tracklist_widget.addItem(empty_item)
                
                # Highlight current track (will be updated via _highlight_playlist_tracklist)
                self._highlight_playlist_tracklist()
            else:
                self.tracklist_widget.clear()
                placeholder_item = QListWidgetItem("No tracks found")
                placeholder_item.setForeground(QColor("#888888"))
                placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
                self.tracklist_widget.addItem(placeholder_item)
        
        try:
            parent_window.web_view.page().runJavaScript(js_code, on_tracks_received)
        except Exception as e:
            logger.error(f"_update_playlist_tracklist: Error executing JavaScript: {e}")
            self.tracklist_widget.clear()
            placeholder_item = QListWidgetItem("Error loading tracks")
            placeholder_item.setForeground(QColor("#ff6666"))
            placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
            self.tracklist_widget.addItem(placeholder_item)
    
    def _on_playlist_tracklist_item_clicked(self, item):
        """Handle tracklist item click in playlist sidebar - play track."""
        if not item:
            return
        
        # Get parent window - handle both attached (QMainWindow) and detached (QDialog) cases
        parent = self.parent()
        parent_window = None
        
        # Check if we're in a detached window (QDialog)
        while parent:
            if isinstance(parent, QMainWindow):
                # We're attached - this is the main window
                parent_window = parent
                break
            elif isinstance(parent, QDialog):
                # We're in detached window - need to find the main window that owns this playlist
                # Search all widgets to find the QMainWindow that has this playlist_sidebar
                for widget in QApplication.allWidgets():
                    if isinstance(widget, QMainWindow) and hasattr(widget, 'playlist_sidebar') and widget.playlist_sidebar == self:
                        parent_window = widget
                        break
                break
            parent = parent.parent()
        
        if not parent_window or not parent_window.web_view or not parent_window.web_view.page():
            return
        
        track_data = item.data(Qt.ItemDataRole.UserRole)
        if not track_data:
            return
        
        # Check if track is playable
        is_playable = track_data.get('isPlayable', True)
        if not is_playable:
            return
        
        track_index = track_data.get('index', 0)
        data_num = track_data.get('dataNum')
        
        # Use the exact same logic as RegularPlayerWidget._on_tracklist_item_clicked
        js_code = f"""
        (function() {{
            var tracklist = document.querySelector('#tracklist');
            if (!tracklist) {{
                return;
            }}
            
            var targetTrack = null;
            var dataNum = {repr(data_num) if data_num else 'null'};
            
            if (dataNum !== null) {{
                targetTrack = tracklist.querySelector('li.track[data-num="' + dataNum + '"]');
            }}
            
            if (!targetTrack) {{
                var tracks = tracklist.querySelectorAll('li.track');
                if (tracks.length > {track_index}) {{
                    targetTrack = tracks[{track_index}];
                }}
            }}
            
            if (targetTrack) {{
                var infoDiv = targetTrack.querySelector('.info');
                if (infoDiv) {{
                    infoDiv.click();
                }} else {{
                    targetTrack.click();
                }}
            }}
        }})();
        """
        
        try:
            parent_window.web_view.page().runJavaScript(js_code)
            # Clear selection after clicking (like regular mode does)
            # This allows the item to be clicked again and provides visual feedback
            QTimer.singleShot(100, lambda: self.tracklist_widget.clearSelection())
        except Exception as e:
            logger.error(f"_on_playlist_tracklist_item_clicked: Error playing track: {e}")
    
    def setup_ui(self):
        """Setup the sidebar UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 2, 5, 5)  # Reduced top margin to minimize border
        layout.setSpacing(5)
        # Ensure playlist sidebar doesn't exceed window width
        self.setMaximumWidth(260)  # Match window width
        
        # Title bar (clickable to minimize/restore)
        self.title_bar_widget = QWidget()
        # Ensure title bar fits within parent width (260px window - margins)
        # Account for playlist sidebar margins (5px each side = 10px total)
        self.title_bar_widget.setMaximumWidth(250)  # 260 - 10px for margins
        self.title_bar_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        self.title_bar_widget.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border: none;
            }
        """)
        title_bar = QHBoxLayout(self.title_bar_widget)
        title_bar.setContentsMargins(5, 2, 3, 2)  # Reduced left margin to fit more buttons
        title_bar.setSpacing(2)  # Reduced spacing to fit more buttons
        
        # Tab buttons - Albums and Tracks (replacing "Playlist" label)
        # Albums button (default active tab)
        self.albums_tab_btn = QPushButton("Albums")
        self.albums_tab_btn.setCheckable(True)
        self.albums_tab_btn.setChecked(True)  # Default to Albums tab
        self.albums_tab_btn.setToolTip("Show Albums Playlist")
        self.albums_tab_btn.setFixedSize(50, 22)  # Compact size to fit in title bar
        self.albums_tab_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: 1px solid transparent;
                font-size: 11px;
                padding: 2px 4px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                background-color: transparent;
                color: #4a90e2;
                border: 1px solid #4a90e2;
            }
            QPushButton:focus {
                outline: none;
            }
        """)
        # Albums tab click handler - toggle minimize if already active, otherwise switch tab
        def albums_tab_clicked():
            # Check if albums tab is already active (before switch_tab updates it)
            if hasattr(self, 'active_tab') and self.active_tab == 'albums' and not self.is_minimized:
                # Already active and expanded - toggle minimize
                self._toggle_minimize_state()
                # Re-check the button since Qt may have unchecked it when clicking a checked button
                self.albums_tab_btn.setChecked(True)
            else:
                # Not active or minimized - switch to albums tab
                self._switch_tab('albums')
        self.albums_tab_btn.clicked.connect(albums_tab_clicked)
        # Make albums tab button double-clickable to minimize/expand playlist
        def albums_tab_double_click(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.toggle_minimize(event)
        self.albums_tab_btn.mouseDoubleClickEvent = albums_tab_double_click
        title_bar.addWidget(self.albums_tab_btn)
        
        # Tracks button
        self.tracks_tab_btn = QPushButton("Tracks")
        self.tracks_tab_btn.setCheckable(True)
        self.tracks_tab_btn.setChecked(False)
        self.tracks_tab_btn.setToolTip("Show Current Album Tracks")
        self.tracks_tab_btn.setFixedSize(50, 22)  # Compact size to fit in title bar
        self.tracks_tab_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: 1px solid transparent;
                font-size: 11px;
                padding: 2px 4px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                background-color: transparent;
                color: #4a90e2;
                border: 1px solid #4a90e2;
            }
            QPushButton:focus {
                outline: none;
            }
        """)
        # Tracks tab click handler - toggle minimize if already active, otherwise switch tab
        def tracks_tab_clicked():
            # Check if tracks tab is already active (before switch_tab updates it)
            if hasattr(self, 'active_tab') and self.active_tab == 'tracks' and not self.is_minimized:
                # Already active and expanded - toggle minimize
                self._toggle_minimize_state()
                # Re-check the button since Qt may have unchecked it when clicking a checked button
                self.tracks_tab_btn.setChecked(True)
            else:
                # Not active or minimized - switch to tracks tab
                self._switch_tab('tracks')
        self.tracks_tab_btn.clicked.connect(tracks_tab_clicked)
        # Make tracks tab button double-clickable to minimize/expand playlist
        def tracks_tab_double_click(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.toggle_minimize(event)
        self.tracks_tab_btn.mouseDoubleClickEvent = tracks_tab_double_click
        title_bar.addWidget(self.tracks_tab_btn)
        
        # Store current active tab (default to 'albums')
        self.active_tab = 'albums'
        
        # Playlist menu button (to the left of add button)
        playlist_menu_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ph.dots-three-outline-vertical-fill', color='#e0e0e0')
            if icon:
                playlist_menu_btn.setIcon(icon)
            else:
                playlist_menu_btn.setText("")
        else:
            playlist_menu_btn.setText("")
        playlist_menu_btn.setToolTip("Playlist Menu")
        playlist_menu_btn.setFixedSize(22, 22)  # Match other buttons
        playlist_menu_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
                outline: none;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:focus {
                outline: none;
                border: none;
            }
            QPushButton:pressed {
                outline: none;
                border: none;
            }
        """)
        playlist_menu_btn.clicked.connect(self.show_playlist_menu)
        title_bar.addWidget(playlist_menu_btn)
        
        title_bar.addStretch()
        
        # Add URL button
        add_btn = QPushButton()
        # Use qtawesome icon if available, fallback to emoji
        if HAS_QT_AWESOME:
            icon = get_icon('plus', color='#e0e0e0')
            if icon:
                add_btn.setIcon(icon)
            else:
                add_btn.setText("")
        else:
            add_btn.setText("")
        add_btn.setToolTip("Add URL(s) From Clipboard (Supports Multiple URLs, One Per Line)")
        add_btn.setFixedSize(22, 22)  # Slightly smaller to fit more buttons
        add_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
                outline: none;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:focus {
                outline: none;
                border: none;
            }
            QPushButton:pressed {
                outline: none;
                border: none;
            }
        """)
        add_btn.clicked.connect(self.add_url)
        title_bar.addWidget(add_btn)
        
        # Detach/Attach button (changes icon based on state)
        self.detach_btn = QPushButton()
        if HAS_QT_AWESOME:
            # Try multiple icon options for detach
            icon = None
            for icon_name in ['fa5s.external-link-alt', 'fa5.external-link', 'ei.external-link', 'fa5s.window-restore']:
                try:
                    icon = get_icon(icon_name, color='#e0e0e0')
                    if icon:
                        break
                except (AttributeError, TypeError, ValueError):
                    continue
            if icon:
                self.detach_btn.setIcon(icon)
            else:
                self.detach_btn.setText("")
        else:
            self.detach_btn.setText("")
        self.detach_btn.setToolTip("Detach Playlist to Separate Window")
        self.detach_btn.setFixedSize(22, 22)
        self.detach_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        # Connect to parent window's detach method
        # Use a lambda to ensure we get the parent window at click time
        def get_parent_window():
            parent = self.parent()
            while parent and not isinstance(parent, QMainWindow):
                parent = parent.parent()
            return parent
        
        def on_detach_clicked():
            parent_window = get_parent_window()
            if parent_window and hasattr(parent_window, '_toggle_detach_playlist'):
                parent_window._toggle_detach_playlist()
        
        self.detach_btn.clicked.connect(on_detach_clicked)
        # Store detach button but don't add it yet - we'll add it in the correct order
        
        # Minimize/Maximize button (changes icon based on state) - add first
        self.minimize_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.chevron-down', color='#e0e0e0')
            if icon:
                self.minimize_btn.setIcon(icon)
            else:
                self.minimize_btn.setText("")
        else:
            self.minimize_btn.setText("")
        self.minimize_btn.setToolTip("Minimize Playlist")
        self.minimize_btn.setFixedSize(22, 22)  # Match other buttons
        self.minimize_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                color: white;
            }
        """)
        self.minimize_btn.clicked.connect(self.toggle_minimize_click)
        title_bar.addWidget(self.minimize_btn)  # Add minimize button first
        
        # Add detach button second
        title_bar.addWidget(self.detach_btn)
        
        # Close button
        close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_btn.setIcon(icon)
            else:
                close_btn.setText("")
        else:
            close_btn.setText("")
        close_btn.setToolTip("Close Playlist")
        close_btn.setFixedSize(22, 22)  # Match other buttons
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #e81123;
                color: white;
            }
        """)
        close_btn.clicked.connect(self.close_playlist)
        title_bar.addWidget(close_btn)
        self.close_btn = close_btn  # Store reference for hiding when detached
        
        # Make title bar double-clickable to minimize/restore
        def title_bar_double_click(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.toggle_minimize(event)
        
        self.title_bar_widget.mouseDoubleClickEvent = title_bar_double_click
        self.is_minimized = False
        
        layout.addWidget(self.title_bar_widget)
        
        # Detect Windows 11 for tighter spacing (used for both albums and tracks lists)
        # Windows 7, 8, and 10 should use the same spacing (not Windows 11)
        # Windows 7 will be treated the same as Windows 10
        is_windows_11 = False
        try:
            import platform
            if platform.system() == "Windows":
                version = platform.version()
                # Windows 11 is build 22000+, Windows 7 is 6.1.7600-7601, Windows 8 is 6.2.9200, Windows 10 is 10.0.10240+
                # Windows 7 and 10 will both return False (use same behavior)
                if version.startswith("10.0.22") or int(version.split('.')[0]) >= 10:
                    # Check for Windows 11 (build 22000+)
                    build = int(version.split('.')[2]) if len(version.split('.')) > 2 else 0
                    is_windows_11 = build >= 22000
        except:
            pass
        
        # List widget for playlist items
        self.list_widget = QListWidget()
        # Ensure widget always draws its background (prevents black display issue)
        self.list_widget.setAutoFillBackground(True)
        self.list_widget.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, False)  # Let Qt handle background
        # Set custom delegate for current item highlighting
        self.list_widget.setItemDelegate(PlaylistItemDelegate(self.list_widget))
        # Use same styling as tracklist for consistency
        if is_windows_11:
            albums_item_padding = "0px 8px"
            albums_item_min_height = "min-height: 18px;"
        else:
            albums_item_padding = "4px 8px"
            albums_item_min_height = ""
        
        albums_stylesheet = """
            QListWidget {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                font-size: 12px;
            }
            QListWidget::item {
                padding: """ + albums_item_padding + """;
                border: none;
                border-radius: 2px;
                """ + albums_item_min_height + """
                color: #c8c8c8;
            }
            QListWidget::item:selected {
                background-color: #3a3a3a;
                color: #e0e0e0;
            }
            QListWidget::item:hover {
                background-color: #3a3a3a;
            }
            QListWidget::item:disabled {
                color: #888888;
            }
            QScrollBar:vertical {
                background-color: #2b2b2b;
                width: 10px;
                margin: 0px;
                border: none;
            }
            QScrollBar::handle:vertical {
                background-color: #4a4a4a;
                min-height: 20px;
                border-radius: 5px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #5a5a5a;
            }
            QScrollBar::handle:vertical:pressed {
                background-color: #6a6a6a;
            }
            QScrollBar::add-line:vertical {
                height: 0px;
                subcontrol-position: bottom;
                subcontrol-origin: margin;
            }
            QScrollBar::sub-line:vertical {
                height: 0px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                background: none;
            }
        """
        self.list_widget.setStyleSheet(albums_stylesheet)
        # Enable focus for keyboard shortcuts (Delete key)
        self.list_widget.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        # Enable extended selection for Ctrl+click and Shift+click
        self.list_widget.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        # Make items more compact (reduce spacing between items)
        self.list_widget.setSpacing(0)
        self.list_widget.setUniformItemSizes(True)  # Optimize rendering for uniform item sizes
        # Hide horizontal scrollbar
        self.list_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.list_widget.setAcceptDrops(True)
        self.list_widget.setDragDropMode(QListWidget.DragDropMode.InternalMove)
        self.list_widget.itemDoubleClicked.connect(self.on_item_double_clicked)
        self.list_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.list_widget.customContextMenuRequested.connect(self.show_context_menu)
        # Save playlist when items are reordered (with debouncing to avoid multiple history entries)
        self.list_widget.model().rowsMoved.connect(self._on_rows_moved)
        # Handle drag and drop for adding URLs and Delete key
        self.list_widget.installEventFilter(self)
        
        # Create tracklist widget (similar to RegularPlayerWidget's tracklist)
        self.tracklist_widget = QListWidget()
        self.tracklist_widget.setAutoFillBackground(True)
        self.tracklist_widget.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, False)
        
        # Use same Windows 11 detection from above (is_windows_11 already defined)
        if is_windows_11:
            item_padding = "0px 8px"
            item_min_height = "min-height: 18px;"
        else:
            item_padding = "4px 8px"
            item_min_height = ""
        
        tracklist_stylesheet = """
            QListWidget {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                font-size: 12px;
            }
            QListWidget::item {
                padding: """ + item_padding + """;
                border: none;
                border-radius: 2px;
                """ + item_min_height + """
                color: #a0a0a0;
            }
            QListWidget::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QListWidget::item:hover {
                background-color: #3a3a3a;
            }
            QListWidget::item:disabled {
                color: #888888;
            }
            QScrollBar:vertical {
                background-color: #2b2b2b;
                width: 10px;
                margin: 0px;
                border: none;
            }
            QScrollBar::handle:vertical {
                background-color: #4a4a4a;
                min-height: 20px;
                border-radius: 5px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #5a5a5a;
            }
            QScrollBar::handle:vertical:pressed {
                background-color: #6a6a6a;
            }
            QScrollBar::add-line:vertical {
                height: 0px;
                subcontrol-position: bottom;
                subcontrol-origin: margin;
            }
            QScrollBar::sub-line:vertical {
                height: 0px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                background: none;
            }
        """
        self.tracklist_widget.setStyleSheet(tracklist_stylesheet)
        # Use SingleSelection mode like regular mode tracklist (allows visual selection/highlighting on click)
        # Even though we don't persist selection, this makes items feel selectable and clickable
        self.tracklist_widget.setSelectionMode(QListWidget.SelectionMode.SingleSelection)
        self.tracklist_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.tracklist_widget.setSpacing(0)
        self.tracklist_widget.setUniformItemSizes(True)
        # Enable mouse tracking for hover state detection
        self.tracklist_widget.setMouseTracking(True)
        # Enable tooltips
        self.tracklist_widget.setToolTipDuration(3000)  # Show tooltips for 3 seconds
        self.tracklist_widget.itemClicked.connect(self._on_playlist_tracklist_item_clicked)
        # Enable focus so items can be clicked and highlighted
        self.tracklist_widget.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        
        # Use TracklistDelegate for two-column layout (title on left, duration on right)
        tracklist_delegate = TracklistDelegate()
        self.tracklist_widget.setItemDelegate(tracklist_delegate)
        
        self.tracklist_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.tracklist_widget.setMinimumHeight(150)
        self.tracklist_widget.setVisible(False)  # Hidden by default (Albums tab active)
        
        # Add placeholder text
        placeholder_item = QListWidgetItem("No album loaded")
        placeholder_item.setForeground(QColor("#888888"))
        placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
        self.tracklist_widget.addItem(placeholder_item)
        
        # Create container widget to hold both list_widget and tracklist_widget
        # We'll switch visibility between them based on active tab
        self.content_container = QWidget()
        content_layout = QVBoxLayout(self.content_container)
        content_layout.setContentsMargins(0, 0, 0, 0)
        content_layout.setSpacing(0)
        
        # Add both widgets to container
        content_layout.addWidget(self.list_widget, 1)
        content_layout.addWidget(self.tracklist_widget, 1)
        
        # Add container to main layout
        layout.addWidget(self.content_container, 1)
        
        # Blank item at bottom of playlist (for visual spacing)
        self._blank_item = None
    
    def _on_page_loaded_for_tracklist(self, success):
        """Called when page finishes loading - update tracklist if tracks tab is active."""
        if success and hasattr(self, 'active_tab') and self.active_tab == 'tracks':
            # Update tracklist when page loads and tracks tab is active
            QTimer.singleShot(500, self._update_playlist_tracklist)
    
    def _highlight_playlist_tracklist(self):
        """Highlight current track in playlist sidebar tracklist."""
        if not hasattr(self, 'tracklist_widget') or not self.tracklist_widget:
            return
        
        # Get parent window to access current track number - handle both attached and detached cases
        parent = self.parent()
        parent_window = None
        
        # Check if we're in a detached window (QDialog)
        while parent:
            if isinstance(parent, QMainWindow):
                # We're attached - this is the main window
                parent_window = parent
                break
            elif isinstance(parent, QDialog):
                # We're in detached window - need to find the main window that owns this playlist
                # Search all widgets to find the QMainWindow that has this playlist_sidebar
                for widget in QApplication.allWidgets():
                    if isinstance(widget, QMainWindow) and hasattr(widget, 'playlist_sidebar') and widget.playlist_sidebar == self:
                        parent_window = widget
                        break
                break
            parent = parent.parent()
        
        if not parent_window:
            return
        
        # Get current track number from regular player widget
        current_track_number = None
        if hasattr(parent_window, 'regular_player_widget') and parent_window.regular_player_widget:
            if hasattr(parent_window.regular_player_widget, '_current_track_number'):
                current_track_number = parent_window.regular_player_widget._current_track_number
        
        # Update highlighting for all items
        for i in range(self.tracklist_widget.count()):
            item = self.tracklist_widget.item(i)
            if item:
                track_data = item.data(Qt.ItemDataRole.UserRole)
                if track_data:
                    track_index = track_data.get('index')
                    data_num = track_data.get('dataNum')
                    if current_track_number is not None:
                        # Check if this is the current track
                        if data_num and int(data_num) == current_track_number:
                            item.setData(Qt.ItemDataRole.UserRole + 1, True)  # Mark as current
                        elif track_index == current_track_number - 1:
                            item.setData(Qt.ItemDataRole.UserRole + 1, True)  # Mark as current
                        else:
                            item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Not current
                    else:
                        item.setData(Qt.ItemDataRole.UserRole + 1, False)  # No current track
        
        # Force viewport update to refresh highlighting
        self.tracklist_widget.viewport().update()
    
    def _ensure_blank_item_at_bottom(self):
        """Ensure there's always a blank item at the bottom of the playlist"""
        # Remove existing blank item if it exists
        if self._blank_item:
            try:
                row = self.list_widget.row(self._blank_item)
                if row >= 0:
                    self.list_widget.takeItem(row)
            except RuntimeError:
                # Item has been deleted (e.g., by clear()) - just clear the reference
                pass
            self._blank_item = None
        
        # Add blank item at the bottom
        blank_item = QListWidgetItem(" ")
        blank_item.setData(Qt.ItemDataRole.UserRole, None)  # No URL data
        blank_item.setFlags(Qt.ItemFlag.NoItemFlags)  # Not selectable, not editable
        blank_item.setToolTip("")
        self.list_widget.addItem(blank_item)
        self._blank_item = blank_item
    
    def load_playlist(self):
        """Load playlist URLs into the list widget and refresh all items"""
        # Ensure playlist manager is initialized (safety check for deferred init)
        if hasattr(self, 'parent_window') and self.parent_window:
            if hasattr(self.parent_window, '_ensure_playlist_manager'):
                self.parent_window._ensure_playlist_manager()
        
        # Store current item URL before clearing (to restore highlighting)
        current_url = None
        if self.current_item:
            current_url = self.current_item.data(Qt.ItemDataRole.UserRole)
        
        self.list_widget.clear()
        self.current_item = None  # Clear reference since items are cleared
        self._blank_item = None  # Clear blank item reference since items are cleared
        
        # Get playlist URLs (we'll get display text using get_url_display_text which checks saved metadata first)
        playlist = self.playlist_manager.get_playlist()
        for url in playlist:
            # Resolve URL before adding to ensure correct display
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Use get_url_display_text which checks saved metadata first (preferred - has correct formatting from page)
            display_text = self.playlist_manager.get_url_display_text(url) if hasattr(self.playlist_manager, 'get_url_display_text') else None
            if not display_text:
                # Fall back to URL parsing only if no saved metadata
                display_text = self.url_to_display(url)
                if not display_text:
                    display_text = url
            
            # Create list item
            list_item = QListWidgetItem(display_text)
            list_item.setData(Qt.ItemDataRole.UserRole, url)
            # Don't set tooltip here - let the delegate handle tooltips for truncated items only
            self.list_widget.addItem(list_item)
        
        # Add blank item at bottom
        self._ensure_blank_item_at_bottom()
        
        # Refresh all items to update display text (in case URLs were resolved)
        self.refresh_all_items()
        
        # Restore highlighting for current item if it still exists
        if current_url:
            self.update_current_item(current_url)
        else:
            # If no current URL stored, try to get it from the parent window's web view
            # This is important for startup when playlist is loaded after URL is already loaded
            parent = self.parent()
            while parent and not isinstance(parent, QMainWindow):
                parent = parent.parent()
            if parent and hasattr(parent, 'web_view') and parent.web_view:
                current_url = parent.web_view.url().toString()
                if current_url:
                    # Small delay to ensure playlist is fully rendered
                    QTimer.singleShot(100, lambda: self.update_current_item(current_url))
    
    def add_item(self, url):
        """Add a URL item to the playlist"""
        # Ensure URL is resolved first
        resolved_url = self.resolve_url_redirects(url)
        if resolved_url:
            url = resolved_url
        
        # Try to get stored metadata first, then fall back to URL parsing
        stored_metadata = self.playlist_manager.get_url_metadata(url)
        if stored_metadata:
            # Convert stored metadata from "Artist - Album" to "Album by Artist" if needed
            if ' - ' in stored_metadata and ' by ' not in stored_metadata:
                parts = stored_metadata.split(' - ', 1)
                if len(parts) == 2:
                    artist = parts[0].strip()
                    album = parts[1].strip()
                    display_text = f"{album} by {artist}"
                else:
                    display_text = stored_metadata
            else:
                display_text = stored_metadata
        else:
            display_text = self.url_to_display(url)
            if not display_text:
                display_text = url
        
        # Create list item
        item = QListWidgetItem(display_text)
        item.setData(Qt.ItemDataRole.UserRole, url)  # Store full URL as data
        item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Mark as not current (delegate will handle colors)
        # Don't set tooltip here - let the delegate handle tooltips for truncated items only
        
        # Remove blank item temporarily if it exists
        if self._blank_item:
            try:
                row = self.list_widget.row(self._blank_item)
                if row >= 0:
                    self.list_widget.takeItem(row)
            except RuntimeError:
                # Item has been deleted (e.g., by clear()) - just clear the reference
                pass
            self._blank_item = None
        
        # Add the new item
        self.list_widget.addItem(item)
        
        # Re-add blank item at bottom
        self._ensure_blank_item_at_bottom()
    
    def url_to_display(self, url):
        """Convert URL to display format (Album by Artist)"""
        # First, resolve URL redirects if needed
        resolved_url = self.resolve_url_redirects(url)
        if resolved_url:
            url = resolved_url
        
        # First try to get saved metadata from playlist manager (preferred - has correct formatting)
        if hasattr(self, 'playlist_manager') and self.playlist_manager:
            saved_display_text = self.playlist_manager.get_url_display_text(url)
            if saved_display_text:
                return saved_display_text
        
        # Use parent's method if available (returns "Album by Artist" format)
        if hasattr(self.parent(), 'extract_artist_album_from_url'):
            result = self.parent().extract_artist_album_from_url(url)
            if result:
                # extract_artist_album_from_url now returns "Album by Artist" format
                return result
        
        # Fallback: parse URL
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            path_parts = [p for p in parsed.path.split('/') if p]
            
            # Try to extract artist from subdomain
            hostname = parsed.hostname or ""
            artist = None
            if ".bandcamp.com" in hostname.lower():
                subdomain = hostname.lower().replace(".bandcamp.com", "")
                if "-" in subdomain:
                    artist = " ".join(word.capitalize() for word in subdomain.split("-"))
                else:
                    import re
                    words = re.findall(r'[a-z]+|[A-Z][a-z]*', subdomain)
                    if len(words) > 1:
                        artist = " ".join(word.capitalize() for word in words)
                    else:
                        artist = subdomain.capitalize()
            
            if artist and path_parts:
                # Extract album/track name from path
                if len(path_parts) >= 2 and path_parts[0] in ['album', 'track']:
                    name = path_parts[1]
                    name = " ".join(word.capitalize() for word in name.split("-"))
                    # Return "Album by Artist" format
                    return f"{name} by {artist}"
                elif len(path_parts) >= 1:
                    name = path_parts[0]
                    name = " ".join(word.capitalize() for word in name.split("-"))
                    # Return "Album by Artist" format
                    return f"{name} by {artist}"
            elif artist:
                return artist
        except:
            pass
        
        return None
    
    def refresh_all_items(self):
        """Refresh display text for all items (useful after URL resolution)"""
        # Store current item to preserve highlighting
        current_item_url = None
        if self.current_item:
            current_item_url = self.current_item.data(Qt.ItemDataRole.UserRole)
        
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                # Re-resolve URL if needed
                resolved_url = self.resolve_url_redirects(url)
                if resolved_url and resolved_url != url:
                    # Update stored URL to resolved version
                    item.setData(Qt.ItemDataRole.UserRole, resolved_url)
                    url = resolved_url
                
                # Use get_url_display_text which checks saved metadata first and handles format conversion
                display_text = self.playlist_manager.get_url_display_text(url) if hasattr(self, 'playlist_manager') and self.playlist_manager else None
                if not display_text:
                    # Fall back to URL parsing only if no stored metadata
                    display_text = self.url_to_display(url)
                    if not display_text:
                        display_text = url
                
                # Update display text
                item.setText(display_text)
                # Don't set tooltip here - let the delegate handle tooltips for truncated items only
                
                # Clear custom role (will be set if this is the current item)
                if item != self.current_item:
                    item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Not current
        
        # Restore highlighting for current item if it still exists
        if current_item_url:
            self.update_current_item(current_item_url)
    
    def resolve_url_redirects(self, url):
        """Resolve URL redirects - use parent's method if available"""
        if hasattr(self.parent(), 'resolve_url_redirects'):
            return self.parent().resolve_url_redirects(url)
        return url
    
    def toggle_shuffle(self):
        """Cycle through shuffle modes: 0 (off)  1 (tracks)  2 (albums)  3 (super)  0"""
        # Get parent window to access centralized state
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        # If not found and we're in a detached window, try to find main window through detached window
        if not parent_window or not isinstance(parent_window, QMainWindow):
            # Check if we're in a detached playlist window
            current_widget = self
            while current_widget:
                # Check if current widget is a QDialog (detached window)
                if isinstance(current_widget, QDialog):
                    # Try to find the main window by checking all top-level widgets
                    from PyQt6.QtWidgets import QApplication
                    app = QApplication.instance()
                    if app:
                        for widget in app.topLevelWidgets():
                            if isinstance(widget, QMainWindow) and hasattr(widget, 'web_view'):
                                parent_window = widget
                                break
                    break
                current_widget = current_widget.parent()
        
        # Use centralized state from PlayerWindow if available
        if parent_window and hasattr(parent_window, 'toggle_shuffle'):
            # Call PlayerWindow's toggle method - it will cycle the mode and sync all widgets
            parent_window.toggle_shuffle()
            # Update local state to match centralized state
            if hasattr(parent_window, 'shuffle_mode'):
                self.shuffle_mode = parent_window.shuffle_mode
            # Update JavaScript after centralized sync
            self._update_javascript_shuffle_mode()
            return
        else:
            # Fallback: cycle locally (shouldn't happen in normal operation)
            self.shuffle_mode = (self.shuffle_mode + 1) % 4
        
        # Update UI (detached buttons removed, so no need to update them)
        self._update_shuffle_button_ui()
        
        # Sync with nano player if exists
        if parent_window and hasattr(parent_window, 'nano_player_window') and parent_window.nano_player_window:
            try:
                if hasattr(parent_window.nano_player_window, 'shuffle_btn') and parent_window.nano_player_window.shuffle_btn:
                    parent_window.nano_player_window.shuffle_btn.blockSignals(True)  # Prevent recursive updates
                    is_active = self.shuffle_mode > 0
                    parent_window.nano_player_window.shuffle_btn.setChecked(is_active)
                    tooltip = self.shuffle_btn.toolTip()
                    parent_window.nano_player_window.shuffle_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if self.shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            parent_window.nano_player_window.shuffle_btn.setIcon(icon)
                    parent_window.nano_player_window.shuffle_btn.blockSignals(False)
            except (AttributeError, RuntimeError):
                pass  # Nano player might not be initialized yet
        
        # Save to settings (only if not using centralized state)
        if not (parent_window and hasattr(parent_window, 'shuffle_mode')):
            parent = self.parent()
            while parent and not isinstance(parent, QWidget):
                parent = parent.parent()
            if parent and hasattr(parent, 'settings'):
                parent.settings['shuffle_mode'] = self.shuffle_mode
                # Keep old setting for backward compatibility (but don't use it)
                parent.settings['shuffle_on'] = self.shuffle_mode > 0
                parent.save_settings()
        
        # Update JavaScript shuffle mode FIRST before handling mode-specific logic
        # This ensures the JavaScript knows the current mode immediately
        self._update_javascript_shuffle_mode()
        
        # Handle shuffle mode changes
        # Get parent window (PlayerWindow) to access web_view and methods
        # Note: parent_window was already retrieved above for detached/nano button sync
        # _shuffled_track_list is stored on PlayerWindow, not PlaylistSidebar
        
        if self.shuffle_mode == 0:
            # Shuffle disabled: Clear Python variables on PlayerWindow
            if parent_window and hasattr(parent_window, '_shuffled_track_list'):
                parent_window._shuffled_track_list = None
                parent_window._shuffled_track_index = 0
            
            # Clear pending Super Shuffle load flag
            if parent_window:
                parent_window._pending_super_shuffle_load = False
            
            # Clear JavaScript variables to stop shuffle behavior
            if parent_window and hasattr(parent_window, 'web_view') and parent_window.web_view and parent_window.web_view.page():
                clear_js = """
                (function() {
                    window.bandcampShuffledTrackList = null;
                    window.bandcampShuffledTrackIndex = 0;
                    console.log('Bandcamp Player: Cleared shuffled track list (shuffle disabled)');
                })();
                """
                parent_window.web_view.page().runJavaScript(clear_js)
                logger.debug("Shuffle disabled: Cleared JavaScript shuffled track list")
            
            # Re-setup button interception to restore normal behavior
            if parent_window and hasattr(parent_window, '_setup_next_prev_button_interception'):
                parent_window._debounced_setup_button_interception()
        
        elif self.shuffle_mode == 1:
            # Shuffle Tracks mode enabled: Create shuffled list if album is loaded
            # Clear existing Python variables first (will be recreated)
            if parent_window and hasattr(parent_window, '_shuffled_track_list'):
                parent_window._shuffled_track_list = None
                parent_window._shuffled_track_index = 0
            
            # Create shuffled list for current album if one is loaded
            if not parent_window:
                logger.warning("Shuffle Tracks enabled: Could not find parent window to create shuffled list")
            elif not hasattr(parent_window, 'web_view') or not parent_window.web_view:
                logger.warning("Shuffle Tracks enabled: Parent window has no web_view")
            else:
                current_url = parent_window.web_view.url().toString()
                if current_url and current_url.startswith('http'):
                    # Wait a bit to ensure page is ready, then create shuffled list
                    QTimer.singleShot(1000, lambda: parent_window._create_shuffled_track_list(current_url) if parent_window else None)
                    logger.debug(f"Shuffle Tracks enabled: Will create shuffled list for current album: {current_url}")
                else:
                    logger.debug("Shuffle Tracks enabled: No album loaded yet, will create list when album loads")
            
            # Re-setup button interception to ensure it's active for shuffle mode 1
            if parent_window and hasattr(parent_window, '_setup_next_prev_button_interception'):
                QTimer.singleShot(200, parent_window._setup_next_prev_button_interception)
        
        elif self.shuffle_mode == 3:
            # Super Shuffle mode enabled: Load random album and track
            # Clear shuffled track list (not used in Super Shuffle)
            if parent_window and hasattr(parent_window, '_shuffled_track_list'):
                parent_window._shuffled_track_list = None
                parent_window._shuffled_track_index = 0
            
            # Clear JavaScript variables for shuffle tracks mode (not applicable to Super Shuffle)
            if parent_window and hasattr(parent_window, 'web_view') and parent_window.web_view and parent_window.web_view.page():
                clear_js = """
                (function() {
                    window.bandcampShuffledTrackList = null;
                    window.bandcampShuffledTrackIndex = 0;
                })();
                """
                parent_window.web_view.page().runJavaScript(clear_js)
            
            # Check if a track is currently playing - if so, wait until it finishes
            if parent_window and hasattr(parent_window, 'web_view') and parent_window.web_view and parent_window.web_view.page():
                def check_playing_and_load():
                    """Check if audio is playing, and either load immediately or wait for track finish"""
                    check_js = """
                    (function() {
                        var audioElement = document.querySelector('audio');
                        if (audioElement) {
                            var isPlaying = !audioElement.paused && audioElement.currentTime > 0;
                            var currentTime = audioElement.currentTime || 0;
                            var duration = audioElement.duration || 0;
                            return {
                                isPlaying: isPlaying,
                                currentTime: currentTime,
                                duration: duration
                            };
                        }
                        return { isPlaying: false, currentTime: 0, duration: 0 };
                    })();
                    """
                    def on_result(result):
                        try:
                            if result and result.get('isPlaying', False):
                                # Track is playing - set flag to load when track finishes
                                if hasattr(parent_window, '_pending_super_shuffle_load'):
                                    parent_window._pending_super_shuffle_load = True
                                else:
                                    parent_window._pending_super_shuffle_load = True
                                logger.debug("Super Shuffle enabled: Track is playing, will load random album/track when current track finishes")
                            else:
                                # No track playing - load immediately
                                if hasattr(parent_window, '_load_super_shuffle_track'):
                                    parent_window._load_super_shuffle_track()
                                    logger.debug("Super Shuffle enabled: No track playing, loading random album and track immediately")
                        except Exception as e:
                            logger.debug(f"Error checking playback state for Super Shuffle: {e}")
                            # On error, try to load anyway
                            if hasattr(parent_window, '_load_super_shuffle_track'):
                                parent_window._load_super_shuffle_track()
                    
                    parent_window.web_view.page().runJavaScript(check_js, on_result)
                
                # Check after a short delay to ensure page is ready
                QTimer.singleShot(200, check_playing_and_load)
        
        else:
            # Other shuffle modes (2=albums): Clear shuffled track list
            if parent_window and hasattr(parent_window, '_shuffled_track_list'):
                parent_window._shuffled_track_list = None
                parent_window._shuffled_track_index = 0
            
            # Clear JavaScript variables for shuffle tracks mode (not applicable to other modes, but clean up anyway)
            if parent_window and hasattr(parent_window, 'web_view') and parent_window.web_view and parent_window.web_view.page():
                clear_js = """
                (function() {
                    window.bandcampShuffledTrackList = null;
                    window.bandcampShuffledTrackIndex = 0;
                })();
                """
                parent_window.web_view.page().runJavaScript(clear_js)
    
    def toggle_repeat(self):
        """Cycle through repeat modes: 0 (off)  1 (continuous)  2 (album)  3 (track)  0"""
        # Get parent window to access centralized state
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        # If not found and we're in a detached window, try to find main window
        if not parent_window or not isinstance(parent_window, QMainWindow):
            from PyQt6.QtWidgets import QApplication
            app = QApplication.instance()
            if app:
                for widget in app.topLevelWidgets():
                    if isinstance(widget, QMainWindow) and hasattr(widget, 'web_view'):
                        parent_window = widget
                        break
        
        # Use centralized state from PlayerWindow if available
        if parent_window and hasattr(parent_window, 'toggle_repeat'):
            # Call PlayerWindow's toggle method - it will cycle the mode and sync all widgets
            parent_window.toggle_repeat()
            # Update local state to match centralized state
            if hasattr(parent_window, 'repeat_mode'):
                self.repeat_mode = parent_window.repeat_mode
            return
        else:
            # Fallback: cycle locally (shouldn't happen in normal operation)
            self.repeat_mode = (self.repeat_mode + 1) % 4
        
        # Update UI (detached buttons removed, so no need to update them)
        self._update_repeat_button_ui()
        
        # Sync with nano player if exists
        if parent_window and hasattr(parent_window, 'nano_player_window') and parent_window.nano_player_window:
            try:
                if hasattr(parent_window.nano_player_window, 'repeat_btn') and parent_window.nano_player_window.repeat_btn:
                    parent_window.nano_player_window.repeat_btn.blockSignals(True)  # Prevent recursive updates
                    is_active = self.repeat_mode > 0
                    parent_window.nano_player_window.repeat_btn.setChecked(is_active)
                    tooltip = self.repeat_btn.toolTip()
                    parent_window.nano_player_window.repeat_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if self.repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            parent_window.nano_player_window.repeat_btn.setIcon(icon)
                    parent_window.nano_player_window.repeat_btn.blockSignals(False)
                    # Update overlay for nano player
                    if hasattr(parent_window.nano_player_window, '_update_repeat_overlay_nano'):
                        parent_window.nano_player_window._update_repeat_overlay_nano(self.repeat_mode)
            except (AttributeError, RuntimeError):
                pass  # Nano player might not be initialized yet
        
        # Save to settings (only if not using centralized state)
        if not (parent_window and hasattr(parent_window, 'repeat_mode')):
            parent = self.parent()
            while parent and not isinstance(parent, QWidget):
                parent = parent.parent()
            if parent and hasattr(parent, 'settings'):
                parent.settings['repeat_mode'] = self.repeat_mode
                # Keep old setting for backward compatibility (but don't use it)
                parent.settings['repeat_on'] = self.repeat_mode > 0
                parent.save_settings()
    
    def _update_repeat_button(self):
        """Update repeat button appearance based on current state (legacy method - redirects to new method)"""
        self._update_repeat_button_ui()
    
    def _update_repeat_button_ui(self):
        """Update repeat button appearance based on current mode"""
        if not hasattr(self, 'repeat_btn'):
            return
        
        # Mode 0=off, 1=continuous, 2=album, 3=track
        is_active = self.repeat_mode > 0
        self.repeat_btn.setChecked(is_active)
        
        # Determine tooltip and icon color based on mode
        if self.repeat_mode == 0:
            tooltip = "Repeat: Off"
            icon_color = '#a0a0a0'  # Gray
        elif self.repeat_mode == 1:
            tooltip = "Repeat: Continuous (play next album)"
            icon_color = '#4a90e2'  # Blue
        elif self.repeat_mode == 2:
            tooltip = "Repeat: Album (loop current album)"
            icon_color = '#4a90e2'  # Blue
        else:  # mode 3
            tooltip = "Repeat: Track (loop current track)"
            icon_color = '#4a90e2'  # Blue
        
        self.repeat_btn.setToolTip(tooltip)
        
        # Update icon based on mode
        if HAS_QT_AWESOME:
            if self.repeat_mode == 0:
                icon = get_icon('ei.repeat', color=icon_color)
            elif self.repeat_mode == 1:
                icon = get_icon('ei.repeat', color=icon_color)  # Keep repeat for continuous
            elif self.repeat_mode == 2:
                icon = get_icon('ei.heart', color=icon_color)  # Heart for album
            else:  # mode 3
                icon = get_icon('ei.heart', color=icon_color)  # Heart for track
            if icon:
                self.repeat_btn.setIcon(icon)
        
        # Update "1" overlay for Repeat 1 Track mode
        self._update_repeat_overlay()
        
        # Update JavaScript repeat mode
        self._update_javascript_repeat_mode()
        
        # Update JavaScript shuffle mode and set up button interception
        self._update_javascript_shuffle_mode()
    
    def _update_javascript_shuffle_mode(self):
        """Update the JavaScript shuffle mode variable when mode changes"""
        # Get parent window to access web_view
        # First try normal parent chain
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        # If not found and we're in a detached window, try to find main window through detached window
        if not parent_window or not isinstance(parent_window, QMainWindow):
            # Check if we're in a detached playlist window
            current_widget = self
            while current_widget:
                # Check if current widget is a QDialog (detached window)
                if isinstance(current_widget, QDialog):
                    # Try to find the main window by checking all top-level widgets
                    from PyQt6.QtWidgets import QApplication
                    app = QApplication.instance()
                    if app:
                        for widget in app.topLevelWidgets():
                            if isinstance(widget, QMainWindow) and hasattr(widget, 'web_view'):
                                parent_window = widget
                                break
                    break
                current_widget = current_widget.parent()

        if not parent_window or not hasattr(parent_window, 'web_view') or not parent_window.web_view or not parent_window.web_view.page():
            return

        shuffle_mode = self.shuffle_mode
        js_code = f"""
        (function() {{
            window.bandcampShuffleMode = {shuffle_mode};
            console.log('Bandcamp Player: Shuffle mode updated to {shuffle_mode}');
            
            // Remove interception attributes so buttons can be re-setup with new mode
            var nextBtn = document.querySelector('button[aria-label="Skip to next song"], .next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
            if (nextBtn) {{
                nextBtn.removeAttribute('data-bandcamp-player-intercepted');
            }}
            
            var prevBtn = document.querySelector('button[aria-label="Skip to previous song"], .next-prev-controls button[aria-label*="previous"], .next-prev-controls button[aria-label*="Previous"], button[aria-label*="Skip to previous"]');
            if (prevBtn) {{
                prevBtn.removeAttribute('data-bandcamp-player-intercepted');
            }}
        }})();
        """
        parent_window.web_view.page().runJavaScript(js_code)
        
        # If shuffle is disabled, also clear the shuffled track list variables
        if shuffle_mode == 0:
            clear_js = """
            (function() {
                window.bandcampShuffledTrackList = null;
                window.bandcampShuffledTrackIndex = 0;
                console.log('Bandcamp Player: Cleared shuffled track list (shuffle disabled)');
            })();
            """
            parent_window.web_view.page().runJavaScript(clear_js)
        
        # Re-setup button interception when shuffle mode changes (with small delay to ensure JS executed)
        if hasattr(parent_window, '_setup_next_prev_button_interception'):
            QTimer.singleShot(150, parent_window._setup_next_prev_button_interception)
    
    def _update_shuffle_button_ui(self):
        """Update shuffle button appearance based on current mode"""
        if not hasattr(self, 'shuffle_btn'):
            return
        
        # Mode 0=off, 1=tracks, 2=albums, 3=super
        is_active = self.shuffle_mode > 0
        self.shuffle_btn.setChecked(is_active)
        
        # Determine tooltip and icon color based on mode
        if self.shuffle_mode == 0:
            tooltip = "Shuffle: Off"
            icon_color = '#a0a0a0'  # Gray
        elif self.shuffle_mode == 1:
            tooltip = "Shuffle: Tracks (shuffle tracks in album)"
            icon_color = '#4a90e2'  # Blue
        elif self.shuffle_mode == 2:
            tooltip = "Shuffle: Albums (randomize album order)"
            icon_color = '#4a90e2'  # Blue
        else:  # mode 3
            tooltip = "Super Shuffle (random album & track)"
            icon_color = '#4a90e2'  # Blue
        
        self.shuffle_btn.setToolTip(tooltip)
        
        # Update icon based on mode
        if HAS_QT_AWESOME:
            if self.shuffle_mode == 0:
                icon = get_icon('random', color=icon_color)
            elif self.shuffle_mode == 1:
                icon = get_icon('random', color=icon_color)  # Keep random for tracks
            elif self.shuffle_mode == 2:
                icon = get_icon('ei.question', color=icon_color)  # Question for albums
            else:  # mode 3
                icon = get_icon('ei.asl', color=icon_color)  # ASL for super shuffle
            if icon:
                self.shuffle_btn.setIcon(icon)
    
    def _update_repeat_overlay(self):
        """Update overlay on repeat button based on mode:
        - Mode 1 (Continuous): no overlay
        - Mode 2 (Album):  overlay
        - Mode 3 (Track): "1" overlay
        """
        if not hasattr(self, 'repeat_btn'):
            return
        
        # Remove existing overlay if it exists
        if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label is not None:
            try:
                self._repeat_overlay_label.deleteLater()
            except (AttributeError, RuntimeError):
                pass  # Label might already be deleted
            self._repeat_overlay_label = None
        
        # Show overlay only for mode 3 ("1"), mode 2 has no overlay
        if self.repeat_mode == 3:
            # Create overlay label
            from PyQt6.QtWidgets import QLabel
            from PyQt6.QtCore import Qt
            
            # Set overlay text to "1" for mode 3
            overlay_text = "1"
            
            # Set overlay color: white for mode 3 (track)
            overlay_color = 'white'
            
            self._repeat_overlay_label = QLabel(overlay_text, self.repeat_btn)
            self._repeat_overlay_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self._repeat_overlay_label.setStyleSheet(f"""
                QLabel {{
                    background-color: transparent;
                    color: {overlay_color};
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                }}
            """)
            # Position will be updated when button is shown/resized
            # Use a method to update position
            def update_overlay_position():
                if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label and self.repeat_btn:
                    btn_size = self.repeat_btn.size()
                    overlay_size = 16
                    x = (btn_size.width() - overlay_size) // 2
                    y = (btn_size.height() - overlay_size) // 2
                    self._repeat_overlay_label.setGeometry(x, y, overlay_size, overlay_size)
                    self._repeat_overlay_label.show()
                    self._repeat_overlay_label.raise_()
            
            # Update position immediately and on button resize
            QTimer.singleShot(0, update_overlay_position)
            # Also update when button is resized (if button has resizeEvent, we'd need to override it)
            # For now, update on a short delay to ensure button is sized
            QTimer.singleShot(100, update_overlay_position)
        else:
            # Ensure overlay is removed for mode 0, mode 1, and mode 2
            if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label:
                self._repeat_overlay_label.hide()
    
    def _update_javascript_repeat_mode(self):
        """Update the JavaScript repeat mode variable when mode changes"""
        # Get parent window to access web_view
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        if not parent_window or not hasattr(parent_window, 'web_view') or not parent_window.web_view or not parent_window.web_view.page():
            return
        
        repeat_mode = self.repeat_mode
        js_code = f"""
        (function() {{
            window.bandcampRepeatMode = {repeat_mode};
            console.log('Bandcamp Player: Repeat mode updated to {repeat_mode}');
        }})();
        """
        parent_window.web_view.page().runJavaScript(js_code)
    
    def toggle_minimize_click(self):
        """Toggle minimize/restore playlist (called by minimize button)"""
        self._toggle_minimize_state()
    
    def toggle_minimize(self, event):
        """Toggle minimize/restore playlist (called by title bar click)"""
        if event.button() == Qt.MouseButton.LeftButton:
            # Don't minimize if clicking on buttons (right side)
            if event.pos().x() > self.title_bar_widget.width() - 80:  # Button area
                return
            
            self._toggle_minimize_state()
    
    def _update_minimize_button_icon(self):
        """Update minimize button icon based on current state and mode"""
        if not hasattr(self, 'minimize_btn'):
            return
        
        # Always clear both icon and text first to prevent showing both
        self.minimize_btn.setIcon(QIcon())
        self.minimize_btn.setText("")
        
        # Check if we're in mini/micro mode (playlist opens downward)
        # Try to find parent window (QMainWindow)
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        is_mini_mode = parent_window and hasattr(parent_window, 'mini_mode_state') and parent_window.mini_mode_state in (1, 2)
        
        # Debug output
        print(f"[ICON DEBUG] _update_minimize_button_icon: is_minimized={self.is_minimized}, is_mini_mode={is_mini_mode}, mini_mode_state={getattr(parent_window, 'mini_mode_state', 'N/A') if parent_window else 'No parent'}")
        
        # In mini mode, swap icons since playlist opens downward instead of upward
        if self.is_minimized:
            # Playlist is minimized - button should restore it
            if HAS_QT_AWESOME:
                # In mini mode: chevron-down (restore downward), regular mode: chevron-up (restore upward)
                icon_name = 'ei.chevron-down' if is_mini_mode else 'ei.chevron-up'
                icon = get_icon(icon_name, color='#e0e0e0')
                if icon:
                    self.minimize_btn.setIcon(icon)
                else:
                    self.minimize_btn.setText("")
            else:
                self.minimize_btn.setText("")  # Maximize icon
            self.minimize_btn.setToolTip("Restore Playlist")
        else:
            # Playlist is expanded - button should minimize it
            if HAS_QT_AWESOME:
                # In mini mode: chevron-up (minimize upward), regular mode: chevron-down (minimize downward)
                icon_name = 'ei.chevron-up' if is_mini_mode else 'ei.chevron-down'
                icon = get_icon(icon_name, color='#e0e0e0')
                if icon:
                    self.minimize_btn.setIcon(icon)
                else:
                    self.minimize_btn.setText("")
            else:
                self.minimize_btn.setText("")  # Minimize icon
            self.minimize_btn.setToolTip("Minimize Playlist")
    
    def _toggle_minimize_state(self):
        """Internal method to toggle minimize/restore state"""
        print(f"[DEBUG] _toggle_minimize_state called, current is_minimized={getattr(self, 'is_minimized', 'NOT SET')}")
        self.is_minimized = not self.is_minimized
        print(f"[DEBUG] _toggle_minimize_state: toggled to is_minimized={self.is_minimized}")
        # Hide both list_widget and tracklist_widget when minimized (only title bar should be visible)
        self.list_widget.setVisible(not self.is_minimized)
        if hasattr(self, 'tracklist_widget'):
            self.tracklist_widget.setVisible(False)  # Always hide tracklist when minimized
        # Also hide content_container when minimized (contains both widgets)
        if hasattr(self, 'content_container'):
            self.content_container.setVisible(not self.is_minimized)
        
        # Update minimize button icon and tooltip based on state
        self._update_minimize_button_icon()
        
        # Hide/show resize handle based on minimize state
        # Access parent window to get resize handle
        parent = self.parent()
        while parent and not isinstance(parent, QWidget):
            parent = parent.parent()
        if parent and hasattr(parent, 'playlist_resize_handle'):
            handle = parent.playlist_resize_handle
            # Hide resize handle in mini/micro mode (playlist has fixed height)
            is_visible = not self.is_minimized
            if hasattr(parent, 'mini_mode_state') and parent.mini_mode_state in (1, 2):
                is_visible = False  # Always hide in mini/micro mode
            handle.setVisible(is_visible)
            # Set height to 0 when hidden to prevent taking up space
            if is_visible:
                handle.setFixedHeight(4)
            else:
                handle.setFixedHeight(0)
        
        # If in mini/micro mode, update window size to account for playlist state change
        if parent and hasattr(parent, 'mini_mode_state') and parent.mini_mode_state in (1, 2):
            if parent.mini_mode_state == 1:
                # In mini mode, if autohide is enabled, hide the player when playlist is toggled
                # The player should only show when user hovers over the hotzone
                if hasattr(parent, 'regular_player_widget') and parent.regular_player_widget:
                    regular_widget = parent.regular_player_widget
                    if hasattr(regular_widget, '_autohide_enabled') and regular_widget._autohide_enabled:
                        # Hide player section (and blurred background) and start autohide timer
                        # Use _hide_player_section() to ensure blurred background is also hidden
                        if hasattr(regular_widget, '_hide_player_section'):
                            regular_widget._hide_player_section()
                        elif hasattr(regular_widget, 'player_section') and regular_widget.player_section:
                            regular_widget.player_section.hide()
                            if hasattr(regular_widget, '_player_section_visible'):
                                regular_widget._player_section_visible = False
                            # Also hide blurred background
                            if hasattr(regular_widget, 'blurred_cover_art_label') and regular_widget.blurred_cover_art_label:
                                regular_widget.blurred_cover_art_label.hide()
                        # Start autohide timer to keep it hidden
                        if hasattr(regular_widget, '_start_autohide_timer'):
                            QTimer.singleShot(50, regular_widget._start_autohide_timer)
                QTimer.singleShot(100, parent.resize_to_mini_mode)
            else:  # micro mode (state 2) - Qt-only
                # CRITICAL: Ensure webview stays hidden and micro player widget is not duplicated
                # This prevents duplicate player from appearing when playlist expands
                if parent.web_view:
                    print(f"[MICRO MODE DEBUG] _toggle_minimize_state: Ensuring webview is hidden (currently visible={parent.web_view.isVisible()})")
                    parent.web_view.hide()
                    # Make webview transparent to mouse events so it doesn't block clicks on cover art
                    parent.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
                if hasattr(parent, 'micro_player_widget') and parent.micro_player_widget:
                    print(f"[MICRO MODE DEBUG] _toggle_minimize_state: Micro player widget exists, visible={parent.micro_player_widget.isVisible()}")
                    # Check if it's in the layout multiple times (detect duplicates)
                    layout = parent.centralWidget().layout()
                    if layout:
                        widget_count = 0
                        for i in range(layout.count()):
                            item = layout.itemAt(i)
                            if item and item.widget() == parent.micro_player_widget:
                                widget_count += 1
                        print(f"[MICRO MODE DEBUG] _toggle_minimize_state: Micro player widget appears {widget_count} times in layout")
                        if widget_count > 1:
                            print(f"[MICRO MODE DEBUG] _toggle_minimize_state: WARNING - Micro player widget is duplicated! Removing duplicates...")
                            # Remove all instances from layout
                            for i in range(layout.count() - 1, -1, -1):
                                item = layout.itemAt(i)
                                if item and item.widget() == parent.micro_player_widget:
                                    layout.removeWidget(parent.micro_player_widget)
                            # Re-add it once
                            layout.addWidget(parent.micro_player_widget, 0, Qt.AlignmentFlag.AlignTop)
                # CRITICAL: Ensure regular player widget is hidden in micro mode
                if hasattr(parent, 'regular_player_widget') and parent.regular_player_widget:
                    if parent.regular_player_widget.isVisible():
                        print(f"[MICRO MODE DEBUG] _toggle_minimize_state: WARNING - regular_player_widget is visible! Hiding it...")
                        parent.regular_player_widget.hide()
                playlist_visible = hasattr(parent, 'playlist_sidebar') and parent.playlist_sidebar and parent.playlist_sidebar.isVisible() and not parent.playlist_detached
                # Use debounced resize (already set up above)
                if hasattr(parent, '_resize_mini_mode_timer'):
                    parent._resize_mini_mode_timer.stop()
                    parent._resize_mini_mode_timer.start(150)
        
        # Save playlist state to settings
        if parent and hasattr(parent, 'settings'):
            parent.settings['playlist_minimized'] = self.is_minimized
            # Remember the attached playlist minimized state separately so detaching can auto-expand
            # without losing the user's preferred attached state.
            try:
                if hasattr(parent, 'playlist_detached') and not parent.playlist_detached:
                    parent.settings['playlist_attached_minimized'] = self.is_minimized
            except Exception:
                pass
            # Don't save playlist height in mini or micro mode - it has fixed heights
            if hasattr(parent, 'mini_mode_state') and parent.mini_mode_state in (1, 2):
                # In mini/micro mode, don't save height changes - use fixed heights
                parent.save_settings()
                return
            # Only save height in regular mode or detached mode
            if hasattr(self, '_restore_height'):
                parent.settings['playlist_height'] = self._restore_height
                # Also save as attached height if playlist is attached (not detached)
                if not parent.playlist_detached:
                    parent.settings['playlist_attached_height'] = self._restore_height
            elif hasattr(self, 'height'):
                parent.settings['playlist_height'] = self.height()
                # Also save as attached height if playlist is attached (not detached)
                if not parent.playlist_detached:
                    parent.settings['playlist_attached_height'] = self.height()
            parent.save_settings()
        
        # Adjust sidebar size when minimized
        if self.is_minimized:
            # Collapse to just show title bar - ensure we account for layout margins
            # Get the actual title bar height plus layout margins
            title_bar_height = self.title_bar_widget.sizeHint().height()
            layout = self.layout()
            if layout:
                margins = layout.getContentsMargins()
                total_height = title_bar_height + margins[1] + margins[3]  # top + bottom margins
            else:
                total_height = title_bar_height + 10  # Add some padding
            # Store current height before minimizing (if not already minimized)
            # BUT: In micro mode, we want to preserve the 115px restore height, so don't overwrite it
            if not hasattr(self, '_restore_height') or not self._restore_height:
                current_height = self.height()
                if current_height > total_height:
                    self._restore_height = current_height
            # Check if we're in micro mode - if so, preserve the 115px restore height
            if parent and hasattr(parent, 'mini_mode_state') and parent.mini_mode_state == 2:
                # In micro mode, ensure restore height is 115 (for when expanded)
                if not hasattr(self, '_restore_height') or self._restore_height != 135:
                    self._restore_height = 135
            self.setFixedHeight(total_height)
            # Ensure full width when minimized
            if parent:
                # Get parent window width (should be 260px)
                parent_width = parent.width() if hasattr(parent, 'width') else 260
                self.setFixedWidth(parent_width)

            # Recompute minimized height after Qt has settled layout/polish (prevents extra padding after reattach)
            try:
                QTimer.singleShot(0, self._recompute_minimized_geometry_if_needed)
                QTimer.singleShot(50, self._recompute_minimized_geometry_if_needed)
            except Exception:
                pass
        else:
            # Restore to normal size (allow resizing)
            # CRITICAL: Restore correct tab visibility based on active_tab when expanding
            if hasattr(self, 'active_tab') and hasattr(self, 'list_widget') and hasattr(self, 'tracklist_widget'):
                if self.active_tab == 'albums':
                    self.list_widget.setVisible(True)
                    self.tracklist_widget.setVisible(False)
                else:  # tracks
                    self.list_widget.setVisible(False)
                    self.tracklist_widget.setVisible(True)
                    # Ensure tracklist widget can receive focus and clicks
                    self.tracklist_widget.setEnabled(True)
                    self.tracklist_widget.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
                    # Update tracklist when expanding to tracks tab
                    QTimer.singleShot(100, self._update_playlist_tracklist)
            # Also show content_container when expanding
            if hasattr(self, 'content_container'):
                self.content_container.setVisible(True)
            
            # Check if we're in mini/micro mode - if so, use fixed height
            parent = self.parent()
            while parent and not isinstance(parent, QMainWindow):
                parent = parent.parent()
            if parent and hasattr(parent, 'mini_mode_state') and parent.mini_mode_state in (1, 2):
                # In mini/micro mode, expanded playlist should always be 230px
                self.setFixedHeight(230)
                mode_name = "mini" if parent.mini_mode_state == 1 else "micro"
                print(f"[{mode_name.upper()} MODE DEBUG] Set expanded playlist height to 230px")
            else:
                # Not in mini mode - restore to normal size (allow resizing)
                self.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                self.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                # Restore to previous height if available, otherwise use default
                if hasattr(self, '_restore_height') and self._restore_height:
                    restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, self._restore_height))
                    self.setFixedHeight(restore_height)
                else:
                    # Use default height
                    self.setFixedHeight(PLAYLIST_DEFAULT_HEIGHT)
        
        # Ensure playlist stays above loading overlay when minimized/restored
        if parent and hasattr(parent, 'playlist_container') and parent.playlist_container:
            parent.playlist_container.raise_()
            # Force container to update its geometry to match playlist height
            # When minimized, ensure container doesn't reserve extra space
            if self.is_minimized:
                # Set container to match actual minimized height (title bar only)
                actual_height = self.height()
                parent.playlist_container.setMaximumHeight(actual_height)
                parent.playlist_container.setMinimumHeight(actual_height)
            else:
                # When expanded, allow container to match playlist height
                parent.playlist_container.setMaximumHeight(16777215)  # Qt's maximum
                parent.playlist_container.setMinimumHeight(0)
            parent.playlist_container.updateGeometry()
            # Force layout update to ensure container doesn't reserve extra space
            layout = parent.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            QApplication.processEvents()
        
        # Update player section position when playlist is minimized/expanded
        # This should happen regardless of whether playlist_container exists
        # Need to find the main window (QMainWindow), not just any parent widget
        print(f"[DEBUG] _toggle_minimize_state: Looking for parent_window, self.parent()={self.parent()}")
        parent_window = self.parent()
        parent_count = 0
        while parent_window and not isinstance(parent_window, QMainWindow):
            print(f"[DEBUG] _toggle_minimize_state: parent_window={parent_window}, type={type(parent_window)}")
            parent_window = parent_window.parent()
            parent_count += 1
            if parent_count > 10:  # Safety limit
                print(f"[DEBUG] _toggle_minimize_state: Reached parent lookup limit")
                break
        
        print(f"[DEBUG] _toggle_minimize_state: Final parent_window={parent_window}, is QMainWindow={isinstance(parent_window, QMainWindow) if parent_window else False}")
        # If in mini/micro mode, resize window to account for playlist minimize/expand
        if parent_window and hasattr(parent_window, 'mini_mode_state') and parent_window.mini_mode_state in (1, 2):
            # Playlist is visible (just minimized/expanded, not hidden) - always True when sidebar is visible
            playlist_visible = True
            # Use single debounced resize call instead of multiple rapid calls
            if not hasattr(parent_window, '_resize_mini_mode_timer'):
                parent_window._resize_mini_mode_timer = QTimer(parent_window)
                parent_window._resize_mini_mode_timer.setSingleShot(True)
                parent_window._resize_mini_mode_timer.timeout.connect(
                    lambda: parent_window._resize_mini_mode_for_playlist(playlist_visible) if hasattr(parent_window, '_resize_mini_mode_for_playlist') else None
                )
            parent_window._resize_mini_mode_timer.stop()
            parent_window._resize_mini_mode_timer.start(150)  # Debounce to 150ms
            
            # Also trigger resize_to_micro_mode if in micro mode
            if parent_window.mini_mode_state == 2:
                QTimer.singleShot(100, parent_window.resize_to_micro_mode)
                QTimer.singleShot(200, parent_window.resize_to_micro_mode)
            
            # CRITICAL: Update playlist position to remember collapsed position or match it when expanded
            QTimer.singleShot(50, parent_window._update_playlist_position_in_mini_mode)
            QTimer.singleShot(100, parent_window._update_playlist_position_in_mini_mode)
            QTimer.singleShot(200, parent_window._update_playlist_position_in_mini_mode)
        
        if parent_window and hasattr(parent_window, '_update_player_section_position'):
            # Only call _update_player_section_position in regular mode (state 0)
            # In mini/micro mode, skip it and ensure regular player widget stays hidden
            if hasattr(parent_window, 'mini_mode_state') and parent_window.mini_mode_state in (1, 2):
                print(f"[MICRO MODE DEBUG] _toggle_minimize_state: Skipping _update_player_section_position in mini/micro mode (state={parent_window.mini_mode_state})")
                # CRITICAL: Ensure regular player widget is hidden in micro mode
                if parent_window.mini_mode_state == 2:
                    if hasattr(parent_window, 'regular_player_widget') and parent_window.regular_player_widget:
                        if parent_window.regular_player_widget.isVisible():
                            print(f"[MICRO MODE DEBUG] _toggle_minimize_state: WARNING - regular_player_widget is visible! Hiding it...")
                            parent_window.regular_player_widget.hide()
            else:
                print(f"[DEBUG] _toggle_minimize_state: Calling _update_player_section_position, is_minimized={self.is_minimized}")
                # Call immediately and with multiple delays to ensure it catches the state change
                parent_window._update_player_section_position()
                QTimer.singleShot(10, parent_window._update_player_section_position)
                QTimer.singleShot(50, parent_window._update_player_section_position)
                QTimer.singleShot(100, parent_window._update_player_section_position)
                QTimer.singleShot(200, parent_window._update_player_section_position)
        else:
            print(f"[DEBUG] _toggle_minimize_state: Could not find parent_window with _update_player_section_position")
            print(f"[DEBUG] _toggle_minimize_state: parent_window={parent_window}")
            print(f"[DEBUG] _toggle_minimize_state: hasattr check={hasattr(parent_window, '_update_player_section_position') if parent_window else 'N/A'}")

    def _recompute_minimized_geometry_if_needed(self):
        """Recompute minimized height once UI/layout has settled (fixes extra space after reattach)."""
        try:
            if not getattr(self, 'is_minimized', False):
                return
            if not hasattr(self, 'title_bar_widget') or not self.title_bar_widget:
                return

            # Ensure style/layout is up-to-date before measuring
            try:
                self.ensurePolished()
                self.title_bar_widget.ensurePolished()
            except Exception:
                pass
            self.title_bar_widget.updateGeometry()

            title_bar_height = self.title_bar_widget.sizeHint().height()
            layout = self.layout()
            if layout:
                margins = layout.getContentsMargins()
                total_height = title_bar_height + margins[1] + margins[3]  # top + bottom
            else:
                total_height = title_bar_height + 10

            # Apply corrected minimized height
            self.setFixedHeight(total_height)

            # If attached, keep the container constrained to the minimized height
            parent = self.parent()
            while parent and not isinstance(parent, QWidget):
                parent = parent.parent()
            if parent and hasattr(parent, 'playlist_container') and parent.playlist_container and parent.playlist_container.isVisible():
                parent.playlist_container.setMaximumHeight(total_height)
                parent.playlist_container.setMinimumHeight(total_height)
                parent.playlist_container.updateGeometry()
                layout = parent.centralWidget().layout() if parent.centralWidget() else None
                if layout:
                    layout.update()
                    layout.activate()
        except Exception:
            pass
    
    def close_playlist(self):
        """Close/hide the playlist sidebar"""
        self.hide()
        
        # Get parent window to access settings and methods
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()

        # If the playlist was minimized, the attached playlist container may have been constrained
        # to the minimized title-bar height. Clear those constraints so the layout can collapse.
        if parent_window and hasattr(parent_window, 'playlist_container') and parent_window.playlist_container:
            try:
                parent_window.playlist_container.setMaximumHeight(16777215)  # Qt max
                parent_window.playlist_container.setMinimumHeight(0)
                parent_window.playlist_container.updateGeometry()
            except Exception:
                pass
        
        # Hide resize handle
        if parent_window and hasattr(parent_window, 'playlist_resize_handle'):
            handle = parent_window.playlist_resize_handle
            handle.setVisible(False)
            handle.setFixedHeight(0)
        
        # Update button state
        if parent_window:
            if hasattr(parent_window, 'playlist_btn'):
                parent_window.playlist_btn.setChecked(False)
                parent_window._update_playlist_button_icon(False)
            if hasattr(parent_window, 'show_playlist_action'):
                parent_window.show_playlist_action.setChecked(False)
            
            # Update settings
            parent_window.settings['playlist_visible'] = False
            if hasattr(self, 'is_minimized'):
                parent_window.settings['playlist_minimized'] = self.is_minimized
            # Don't save playlist height in mini or micro mode - it has fixed heights.
            # IMPORTANT: we still continue after this so micro mode can do its resize/layout recalculation.
            skip_height_save = bool(hasattr(parent_window, 'mini_mode_state') and parent_window.mini_mode_state in (1, 2))
            if not skip_height_save:
                # Only save height in regular mode or detached mode
                if hasattr(self, '_restore_height'):
                    parent_window.settings['playlist_height'] = self._restore_height
                    # Also save as attached height if playlist is attached (not detached)
                    if not parent_window.playlist_detached:
                        parent_window.settings['playlist_attached_height'] = self._restore_height
                elif self:
                    parent_window.settings['playlist_height'] = self.height()
                    # Also save as attached height if playlist is attached (not detached)
                    if not parent_window.playlist_detached:
                        parent_window.settings['playlist_attached_height'] = self.height()
            parent_window.save_settings()
            
            # Debug logging for playlist close
            print(f"[DEBUG] close_playlist: playlist_visible set to False, mini_mode_state={parent_window.mini_mode_state if hasattr(parent_window, 'mini_mode_state') else 'N/A'}")
            logger.debug(f"close_playlist: playlist_visible set to False, mini_mode_state={parent_window.mini_mode_state if hasattr(parent_window, 'mini_mode_state') else 'N/A'}")
            
            # Update player section position when playlist is closed (treat as resize event)
            # Fake a resize event by calling the update function multiple times with delays
            if hasattr(parent_window, '_update_player_section_position'):
                print(f"[DEBUG] close_playlist: Calling _update_player_section_position")
                # Call immediately and with multiple delays to ensure it catches the state change
                parent_window._update_player_section_position()
                QTimer.singleShot(10, parent_window._update_player_section_position)
                QTimer.singleShot(50, parent_window._update_player_section_position)
                QTimer.singleShot(100, parent_window._update_player_section_position)
                QTimer.singleShot(200, parent_window._update_player_section_position)
            
            # If in mini/micro mode, resize window to account for playlist being closed
            if hasattr(parent_window, 'mini_mode_state') and parent_window.mini_mode_state in (1, 2):
                mode_name = "mini" if parent_window.mini_mode_state == 1 else "micro"
                print(f"[DEBUG] close_playlist: In {mode_name} mode, resizing for playlist closed")
                # Ensure playlist container and sidebar are hidden
                if hasattr(parent_window, 'playlist_container') and parent_window.playlist_container:
                    # In mini/micro mode, hide the container when playlist is closed
                    # Don't set geometry to 0,0,0,0 as it breaks restoration
                    # Just hide it and let the resize handle the space
                    parent_window.playlist_container.hide()
                if hasattr(parent_window, 'playlist_sidebar') and parent_window.playlist_sidebar:
                    # Sidebar is already hidden by self.hide() above, but ensure it's hidden
                    parent_window.playlist_sidebar.hide()
                # Force layout update to ensure visibility changes are reflected
                layout = parent_window.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                QApplication.processEvents()
                # Use multiple delays to ensure playlist geometry is updated first
                # Check actual visibility instead of relying on parameter
                def resize_with_actual_visibility():
                    actual_visible = hasattr(parent_window, 'playlist_sidebar') and parent_window.playlist_sidebar and parent_window.playlist_sidebar.isVisible()
                    print(f"[DEBUG] close_playlist: Resize callback, actual_visible={actual_visible}")
                    parent_window._resize_mini_mode_for_playlist(actual_visible)
                    # Also trigger mode-specific resize
                    if parent_window.mini_mode_state == 1:
                        parent_window.resize_to_mini_mode()
                    else:  # micro mode
                        parent_window.resize_to_micro_mode()
                print(f"[DEBUG] close_playlist: Scheduling resize calls")
                QTimer.singleShot(10, resize_with_actual_visibility)
                QTimer.singleShot(50, resize_with_actual_visibility)
                QTimer.singleShot(100, resize_with_actual_visibility)
                QTimer.singleShot(200, resize_with_actual_visibility)
                QTimer.singleShot(300, resize_with_actual_visibility)  # Extra delay for safety
            
            # If in regular mode (state 0), ensure window resizes correctly when playlist is closed
            elif hasattr(parent_window, 'mini_mode_state') and parent_window.mini_mode_state == 0:
                # Regular mode: ensure window resizes to remove playlist space
                print(f"[DEBUG] close_playlist: In regular mode, resizing for playlist closed")
                # Ensure playlist container and sidebar are hidden
                if hasattr(parent_window, 'playlist_container') and parent_window.playlist_container:
                    parent_window.playlist_container.hide()
                if hasattr(parent_window, 'playlist_sidebar') and parent_window.playlist_sidebar:
                    parent_window.playlist_sidebar.hide()
                # Force layout update to ensure visibility changes are reflected
                layout = parent_window.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                QApplication.processEvents()
                # Use multiple delays to ensure playlist geometry is updated first
                # Check actual visibility instead of relying on parameter
                def resize_regular_mode_with_actual_visibility():
                    actual_visible = hasattr(parent_window, 'playlist_sidebar') and parent_window.playlist_sidebar and parent_window.playlist_sidebar.isVisible()
                    print(f"[DEBUG] close_playlist: Regular mode resize callback, actual_visible={actual_visible}")
                    # Update player section position when playlist is closed
                    if hasattr(parent_window, '_update_player_section_position'):
                        parent_window._update_player_section_position()
                    # Force layout update again
                    layout = parent_window.centralWidget().layout()
                    if layout:
                        layout.update()
                        layout.activate()
                        QApplication.processEvents()
                print(f"[DEBUG] close_playlist: Scheduling regular mode resize calls")
                QTimer.singleShot(10, resize_regular_mode_with_actual_visibility)
                QTimer.singleShot(50, resize_regular_mode_with_actual_visibility)
                QTimer.singleShot(100, resize_regular_mode_with_actual_visibility)
                QTimer.singleShot(200, resize_regular_mode_with_actual_visibility)
            
            # If in micro mode, resize to account for playlist visibility change
            elif hasattr(parent_window, 'mini_mode_state') and parent_window.mini_mode_state == 2:
                    # For micro mode, when closing playlist, use current window height minus 30px
                    # instead of re-measuring (which can be inaccurate due to layout reflow)
                    # Store the current height before closing
                    current_height = parent_window.height()
                    # Calculate new height: current - 30px (playlist title bar)
                    # But only if we're actually removing the playlist (not just minimizing)
                    if hasattr(parent_window, 'settings') and not parent_window.settings.get('playlist_visible', True):
                        # Playlist is being closed - calculate new height directly
                        window_padding = 0
                        if parent_window.title_bar and parent_window.title_bar.isVisible():
                            window_padding += parent_window.title_bar.height()
                        if hasattr(parent_window, 'controls_bar_widget') and parent_window.controls_bar_widget:
                            if hasattr(parent_window, 'autohide_address_bar') and not parent_window.autohide_address_bar:
                                window_padding += parent_window.controls_bar_widget.height()
                        
                        # Use saved exact_bottom if available, otherwise calculate from current height
                        if hasattr(parent_window, 'settings') and 'micro_mode_saved_height' in parent_window.settings:
                            saved_exact_bottom = parent_window.settings.get('micro_mode_saved_height', 0)
                            if saved_exact_bottom > 0:
                                # Use saved value and subtract 30px for playlist title bar
                                new_total_height = saved_exact_bottom + window_padding - 33  # -33 is the standard adjustment
                                print(f"[DEBUG] close_playlist: Using saved exact_bottom={saved_exact_bottom}, new_total_height={new_total_height}")
                                logger.debug(f"close_playlist: Using saved exact_bottom={saved_exact_bottom}, new_total_height={new_total_height}")
                                
                                # Set flag to allow programmatic resize
                                parent_window._micro_mode_resizing = True
                                original_width = WINDOW_DEFAULT_WIDTH
                                
                                # Ensure we don't go below minimum
                                if new_total_height < window_padding + 50:
                                    new_total_height = window_padding + 50
                                
                                # Resize directly
                                parent_window.resize(original_width, new_total_height)
                                parent_window.setMinimumSize(original_width, new_total_height)
                                parent_window.setMaximumSize(original_width, new_total_height)
                                
                                # Clear flag after resize
                                QTimer.singleShot(50, lambda: setattr(parent_window, '_micro_mode_resizing', False))
                                
                                print(f"[DEBUG] close_playlist: Resized directly to {original_width}x{new_total_height}, actual size: {parent_window.width()}x{parent_window.height()}")
                                logger.debug(f"close_playlist: Resized directly to {original_width}x{new_total_height}, actual size: {parent_window.width()}x{parent_window.height()}")
                                return  # Skip the normal resize path
                    
                    # Fallback to normal resize path if direct resize didn't happen
                    # Use a slightly longer delay to ensure settings are fully saved and processed
                    QTimer.singleShot(100, parent_window._resize_to_micro_mode_with_retry)

            # Keep bottom-right playlist quick button in sync (safe)
            try:
                if hasattr(parent_window, 'update_playlist_quick_btn_visibility'):
                    parent_window.update_playlist_quick_btn_visibility()
            except Exception:
                pass
    
    def get_previous_album_url(self):
        """Get the previous album URL based on shuffle and repeat settings"""
        if not self.current_item:
            return None
        
        current_index = self.list_widget.row(self.current_item)
        if current_index < 0:
            return None
        
        playlist_count = self.list_widget.count()
        if playlist_count == 0:
            return None
        
        # If shuffle mode 2 (albums) or 3 (super), pick a random album (excluding current)
        if self.shuffle_mode == 2 or self.shuffle_mode == 3:
            if playlist_count == 1:
                return None  # Only one album, can't shuffle
            # Get all indices except current
            available_indices = [i for i in range(playlist_count) if i != current_index]
            prev_index = random.choice(available_indices)
        else:
            # Sequential: previous album, wrap around if at start
            prev_index = (current_index - 1) % playlist_count
        
        prev_item = self.list_widget.item(prev_index)
        if prev_item:
            return prev_item.data(Qt.ItemDataRole.UserRole)
        return None
    
    def get_next_album_url(self):
        """Get the next album URL based on shuffle and repeat settings"""
        if not self.current_item:
            return None
        
        current_index = self.list_widget.row(self.current_item)
        if current_index < 0:
            return None
        
        playlist_count = self.list_widget.count()
        if playlist_count == 0:
            return None
        
        # If shuffle mode 2 (albums) or 3 (super), pick a random album (excluding current)
        if self.shuffle_mode == 2 or self.shuffle_mode == 3:
            if playlist_count == 1:
                return None  # Only one album, can't shuffle
            # Get all indices except current
            available_indices = [i for i in range(playlist_count) if i != current_index]
            next_index = random.choice(available_indices)
        else:
            # Sequential: next album, wrap around if at end
            next_index = (current_index + 1) % playlist_count
        
        next_item = self.list_widget.item(next_index)
        if next_item:
            return next_item.data(Qt.ItemDataRole.UserRole)
        return None
    
    def load_previous_album(self):
        """Load the previous album in the playlist (loops to last album if at first)"""
        logger.debug("load_previous_album called")
        if not self.current_item:
            logger.debug("No current item set")
            return False
        
        current_index = self.list_widget.row(self.current_item)
        if current_index < 0:
            logger.debug("Current item index is invalid")
            return False
        
        # Get only items with URLs (exclude blank item)
        valid_items = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole):  # Has URL
                valid_items.append((i, item))
        
        if len(valid_items) == 0:
            logger.debug("No valid albums in playlist")
            return False
        
        # Find current item's position in valid items
        current_valid_index = None
        for idx, (orig_idx, item) in enumerate(valid_items):
            if item == self.current_item:
                current_valid_index = idx
                break
        
        if current_valid_index is None:
            logger.debug("Current item not found in valid items")
            return False
        
        # Calculate previous index with wrap-around (only among valid items)
        # Shuffle mode 2 (albums) or 3 (super) use random album selection
        if self.shuffle_mode == 2 or self.shuffle_mode == 3:
            if len(valid_items) == 1:
                return False  # Only one album, can't shuffle
            available_indices = [i for i in range(len(valid_items)) if i != current_valid_index]
            prev_valid_index = random.choice(available_indices)
        else:
            # Sequential: previous album, wrap around to last if at first
            prev_valid_index = (current_valid_index - 1) % len(valid_items)
        
        # Get the actual item and load it
        prev_orig_index, prev_item = valid_items[prev_valid_index]
        prev_url = prev_item.data(Qt.ItemDataRole.UserRole)
        if prev_url:
            logger.debug(f"Loading previous album at index {prev_orig_index} (valid index {prev_valid_index}): {prev_item.text()}")
            self.load_url_func(prev_url)
            self.set_current_item(prev_item)
            return True
        
        logger.debug("No previous album found")
        return False
    
    def load_next_album(self):
        """Load the next album in the playlist (loops to first album if at last)"""
        logger.debug("load_next_album called")
        if not self.current_item:
            logger.debug("No current item set")
            return False
        
        current_index = self.list_widget.row(self.current_item)
        if current_index < 0:
            logger.debug("Current item index is invalid")
            return False
        
        # Get only items with URLs (exclude blank item)
        valid_items = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole):  # Has URL
                valid_items.append((i, item))
        
        if len(valid_items) == 0:
            logger.debug("No valid albums in playlist")
            return False
        
        # Find current item's position in valid items
        current_valid_index = None
        for idx, (orig_idx, item) in enumerate(valid_items):
            if item == self.current_item:
                current_valid_index = idx
                break
        
        if current_valid_index is None:
            logger.debug("Current item not found in valid items")
            return False
        
        # Calculate next index with wrap-around (only among valid items)
        # Shuffle mode 2 (albums) or 3 (super) use random album selection
        if self.shuffle_mode == 2 or self.shuffle_mode == 3:
            if len(valid_items) == 1:
                return False  # Only one album, can't shuffle
            available_indices = [i for i in range(len(valid_items)) if i != current_valid_index]
            next_valid_index = random.choice(available_indices)
        else:
            # Sequential: next album, wrap around to first if at last
            next_valid_index = (current_valid_index + 1) % len(valid_items)
        
        # Get the actual item and load it
        next_orig_index, next_item = valid_items[next_valid_index]
        next_url = next_item.data(Qt.ItemDataRole.UserRole)
        if next_url:
            logger.debug(f"Loading next album at index {next_orig_index} (valid index {next_valid_index}): {next_item.text()}")
            self.load_url_func(next_url)
            self.set_current_item(next_item)
            return True
        
        logger.debug("No next album found")
        return False
    
    def on_item_double_clicked(self, item):
        """Handle double-click on playlist item"""
        # Skip blank item
        if item == self._blank_item:
            return
        url = item.data(Qt.ItemDataRole.UserRole)
        if url:
            # Load the URL - this will trigger update_current_item via load_url
            self.load_url_func(url)
            # Also set directly as backup (load_url will call update_current_item, but this ensures immediate feedback)
            self.set_current_item(item)
    
    def set_current_item(self, item):
        """Set the currently playing item with direct color highlighting"""
        logger.debug(f"set_current_item: Called with item: {item}")
        # Clear ALL items' current item marker first (prevents accumulation from previous selections)
        # But preserve user selection (clicked items) - only clear the current item marker
        logger.debug("set_current_item: Clearing all items' current item marker")
        for i in range(self.list_widget.count()):
            try:
                list_item = self.list_widget.item(i)
                if list_item:
                    list_item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Clear current item marker
                    # Don't clear selection here - let users keep their selection highlight
            except:
                pass
        
        # Clear the current_item reference
            self.current_item = None
        
        self.current_item = item
        if item:
            try:
                item_text = item.text()
                item_url = item.data(Qt.ItemDataRole.UserRole)
                logger.debug(f"set_current_item: Setting item '{item_text}' (URL: {item_url})")
                
                # Verify item is still valid
                item_row = self.list_widget.row(item)
                logger.debug(f"set_current_item: Item row: {item_row}")
                if item_row < 0:
                    logger.warning("set_current_item: Item row is invalid, aborting")
                    self.current_item = None
                    return
                
                # Use custom data role to mark current item (delegate will handle painting)
                # Set custom role (UserRole + 1) to True for current item
                self.current_item.setData(Qt.ItemDataRole.UserRole + 1, True)
                logger.debug("set_current_item: Set custom data role (UserRole + 1) = True")
                
                # Also set selection for compatibility with stylesheet
                item.setSelected(True)
                logger.debug("set_current_item: Set selected=True")
                
                # Force update to trigger delegate repaint
                # Trigger update - just call update() without arguments to refresh the viewport
                self.list_widget.update()
                # Also explicitly update the viewport to ensure proper repaint (fixes black display in mini mode)
                self.list_widget.viewport().update()
                logger.debug("set_current_item: Called list_widget.update() and viewport().update() for item rect")
                
                # Scroll to item to make it visible
                self.list_widget.scrollToItem(item)
                logger.debug("set_current_item: Current item marked successfully")
            except RuntimeError:
                # Item was deleted between assignment and use, clear reference
                self.current_item = None
            except Exception as e:
                # Catch any other errors and log them (but don't crash)
                logger.error(f"Error setting current item colors: {e}", exc_info=True)
                self.current_item = None
    
    def process_urls(self, url_strings):
        """Process a list of URL strings and add valid Bandcamp URLs to the playlist.
        
        Args:
            url_strings: List of URL strings to process
            
        Returns:
            Tuple of (added_count, skipped_count)
        """
        if not url_strings:
            return (0, 0)
        
        # Save state to history before adding URLs
        if not self.is_undoing_redoing:
            self._save_state_to_history()
        
        # Suppress history save when we call save_playlist (we already saved above)
        self._suppress_history_save = True
        
        # Get existing URLs for duplicate checking
        existing_urls = [item.get("url") if isinstance(item, dict) else item for item in self.playlist_manager.playlist]
        
        added_count = 0
        skipped_count = 0
        
        for url_string in url_strings:
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved = self.resolve_url_redirects(url_string)
            if resolved:
                url = resolved
            else:
                # If resolution failed but it looks like a Bandcamp URL, use it as-is
                if 'bandcamp.com' in url_string.lower():
                    url = url_string
                else:
                    # Not a Bandcamp URL, skip it
                    skipped_count += 1
                    continue
            
            # Normalize URL
            url = url.strip().rstrip('/')
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            # Only add if it's a Bandcamp URL and not already in playlist
            if 'bandcamp.com' in url.lower():
                if url not in existing_urls:
                    self.playlist_manager.add_url(url)
                    self.add_item(url)
                    added_count += 1
                    existing_urls.append(url)  # Update list to avoid duplicates in same batch
                else:
                    skipped_count += 1
            else:
                skipped_count += 1
        
        # Save playlist after adding all URLs
        if added_count > 0:
            self.playlist_manager.save_playlist()
        
        # Restore history saving
        self._suppress_history_save = False
        
        # Save state to history after adding completes (so current state is in history)
        if not self.is_undoing_redoing and added_count > 0:
            QTimer.singleShot(50, self._save_state_to_history)
        
        return (added_count, skipped_count)
    
    def paste_urls_from_clipboard(self):
        """Paste URLs from clipboard (same as add_url but with tooltip feedback)"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        if not text:
            # Show feedback that clipboard is empty
            global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
            QToolTip.showText(global_pos, "Clipboard is empty", self.list_widget, QRect(), 1500)
            return
        
        # Split by newlines to handle multiple URLs
        lines = [line.strip() for line in text.split('\n') if line.strip()]
        
        if not lines:
            return
        
        # Process URLs using shared method
        added_count, skipped_count = self.process_urls(lines)
        
        # Show tooltip feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        if added_count > 0 and skipped_count > 0:
            message = f"Added {added_count} URL(s), skipped {skipped_count}"
        elif added_count > 0:
            message = f"Added {added_count} URL(s)"
        else:
            message = "No URLs added (duplicates or invalid)"
        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
    
    def save_current_playlist(self):
        """Save the current playlist to its file"""
        if self.playlist_manager.save_playlist():
            # Get parent window to save settings
            parent_window = self.parent()
            while parent_window and not isinstance(parent_window, QMainWindow):
                parent_window = parent_window.parent()
            if parent_window and hasattr(parent_window, 'save_settings'):
                parent_window.save_settings()
            
            # Show feedback
            global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
            playlist_name = self.playlist_manager.get_current_playlist_name()
            QToolTip.showText(global_pos, f"Saved: {playlist_name}", self.list_widget, QRect(), 1500)
        else:
            QMessageBox.warning(self, "Save Failed", "Failed to save playlist.")
    
    def save_playlist_as(self):
        """Save the current playlist with a new name"""
        current_name = self.playlist_manager.get_current_playlist_name()
        name, ok = QInputDialog.getText(
            self,
            "Save Playlist As",
            "Enter playlist name:",
            text=current_name
        )
        
        if ok and name:
            sanitized_name = sanitize_filename(name)
            if not sanitized_name:
                QMessageBox.warning(self, "Invalid Name", "Please enter a valid playlist name.")
                return
            
            if self.playlist_manager.save_playlist_as(sanitized_name):
                # Get parent window to save settings
                parent_window = self.parent()
                while parent_window and not isinstance(parent_window, QMainWindow):
                    parent_window = parent_window.parent()
                if parent_window and hasattr(parent_window, 'save_settings'):
                    parent_window.save_settings()
                
                # Refresh playlist display
                self.load_playlist()
                
                # Show feedback
                global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                QToolTip.showText(global_pos, f"Saved as: {sanitized_name}", self.list_widget, QRect(), 1500)
            else:
                QMessageBox.warning(self, "Save Failed", "Failed to save playlist.")
    
    def load_playlist_from_file(self, playlist_file):
        """Load a playlist from a specific file"""
        # Save current state to history before loading
        if not self.is_undoing_redoing:
            self._save_state_to_history()
        
        # Load the playlist
        if self.playlist_manager.set_playlist_file(playlist_file):
            # Refresh the display
            self.load_playlist()
            
            # Get parent window to save settings
            parent_window = self.parent()
            while parent_window and not isinstance(parent_window, QMainWindow):
                parent_window = parent_window.parent()
            if parent_window and hasattr(parent_window, 'save_settings'):
                parent_window.save_settings()
            
            # Show feedback
            global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
            playlist_name = self.playlist_manager.get_current_playlist_name()
            QToolTip.showText(global_pos, f"Loaded: {playlist_name}", self.list_widget, QRect(), 1500)
            
            # Save state to history after loading
            if not self.is_undoing_redoing:
                QTimer.singleShot(50, self._save_state_to_history)
        else:
            QMessageBox.warning(self, "Load Failed", f"Failed to load playlist from {playlist_file}.")
    
    def export_playlist_urls(self):
        """Export playlist URLs to a text file or clipboard"""
        urls = self.playlist_manager.get_playlist()
        if not urls:
            QMessageBox.information(self, "Empty Playlist", "Playlist is empty. Nothing to export.")
            return
        
        # Create menu for export options
        export_menu = QMenu(self)
        export_menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
        """)
        
        # Export to file
        file_action = QAction("Export to File...", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file', color='#e0e0e0')
            if icon:
                file_action.setIcon(icon)
        file_action.triggered.connect(self._export_to_file)
        export_menu.addAction(file_action)
        
        # Copy to clipboard
        clipboard_action = QAction("Copy to Clipboard", self)
        if HAS_QT_AWESOME:
            icon = get_icon('copy', color='#e0e0e0')
            if icon:
                clipboard_action.setIcon(icon)
        clipboard_action.triggered.connect(self._export_to_clipboard)
        export_menu.addAction(clipboard_action)
        
        # Show menu at cursor position
        export_menu.exec(QCursor.pos())
    
    def _export_to_file(self):
        """Export URLs to a text file"""
        urls = self.playlist_manager.get_playlist()
        if not urls:
            return
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Playlist URLs",
            "",
            "Text Files (*.txt);;All Files (*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(urls))
                QMessageBox.information(self, "Export Successful", f"Exported {len(urls)} URL(s) to:\n{file_path}")
            except Exception as e:
                QMessageBox.warning(self, "Export Failed", f"Failed to export URLs:\n{str(e)}")
    
    def _export_to_clipboard(self):
        """Copy URLs to clipboard"""
        urls = self.playlist_manager.get_playlist()
        if not urls:
            return
        
        clipboard = QApplication.clipboard()
        clipboard.setText('\n'.join(urls))
        
        # Show feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        QToolTip.showText(global_pos, f"Copied {len(urls)} URL(s) to clipboard", self.list_widget, QRect(), 2000)
    
    def import_playlist_urls(self):
        """Import playlist URLs from a text file or clipboard"""
        # Create menu for import options
        import_menu = QMenu(self)
        import_menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
        """)
        
        # Import from file
        file_action = QAction("Import from File...", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file', color='#e0e0e0')
            if icon:
                file_action.setIcon(icon)
        file_action.triggered.connect(self._import_from_file)
        import_menu.addAction(file_action)
        
        # Paste from clipboard
        clipboard_action = QAction("Paste from Clipboard", self)
        if HAS_QT_AWESOME:
            icon = get_icon('paste', color='#e0e0e0')
            if icon:
                clipboard_action.setIcon(icon)
        clipboard_action.triggered.connect(self._import_from_clipboard)
        import_menu.addAction(clipboard_action)
        
        # Show menu at cursor position
        import_menu.exec(QCursor.pos())
    
    def _import_from_file(self):
        """Import URLs from a text file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Import Playlist URLs",
            "",
            "Text Files (*.txt);;All Files (*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = [line.strip() for line in f.readlines() if line.strip()]
                
                if not lines:
                    QMessageBox.information(self, "Empty File", "The selected file is empty.")
                    return
                
                # Ask user: Add or Replace
                msg_box = QMessageBox(self)
                msg_box.setWindowTitle("Import URLs")
                msg_box.setText(f"Found {len(lines)} URL(s) in file.\n\nAdd to current playlist or replace it?")
                msg_box.setIcon(QMessageBox.Icon.Question)
                
                # Create custom buttons
                add_btn = msg_box.addButton("Add", QMessageBox.ButtonRole.AcceptRole)
                replace_btn = msg_box.addButton("Replace", QMessageBox.ButtonRole.AcceptRole)
                cancel_btn = msg_box.addButton("Cancel", QMessageBox.ButtonRole.RejectRole)
                msg_box.setDefaultButton(add_btn)
                
                reply = msg_box.exec()
                
                if reply == cancel_btn:
                    return
                
                if reply == replace_btn:
                    # Replace: clear current playlist first
                    self.clear_playlist()
                
                # Process URLs
                added_count, skipped_count = self.process_urls(lines)
                
                # Show feedback
                if added_count > 0:
                    message = f"Imported {added_count} URL(s)"
                    if skipped_count > 0:
                        message += f", skipped {skipped_count}"
                    QMessageBox.information(self, "Import Successful", message)
                else:
                    QMessageBox.information(self, "Import Complete", "No URLs were added (duplicates or invalid).")
            except Exception as e:
                QMessageBox.warning(self, "Import Failed", f"Failed to import URLs:\n{str(e)}")
    
    def _import_from_clipboard(self):
        """Import URLs from clipboard"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        
        if not text:
            QMessageBox.information(self, "Empty Clipboard", "Clipboard is empty.")
            return
        
        # Split by newlines
        lines = [line.strip() for line in text.split('\n') if line.strip()]
        
        if not lines:
            QMessageBox.information(self, "No URLs", "Clipboard does not contain any URLs.")
            return
        
        # Ask user: Add or Replace
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Import URLs")
        msg_box.setText(f"Found {len(lines)} URL(s) in clipboard.\n\nAdd to current playlist or replace it?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        
        # Create custom buttons
        add_btn = msg_box.addButton("Add", QMessageBox.ButtonRole.AcceptRole)
        replace_btn = msg_box.addButton("Replace", QMessageBox.ButtonRole.AcceptRole)
        cancel_btn = msg_box.addButton("Cancel", QMessageBox.ButtonRole.RejectRole)
        msg_box.setDefaultButton(add_btn)
        
        reply = msg_box.exec()
        
        if reply == cancel_btn:
            return
        
        if reply == replace_btn:
            # Replace: clear current playlist first
            self.clear_playlist()
        
        # Process URLs
        added_count, skipped_count = self.process_urls(lines)
        
        # Show feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        if added_count > 0 and skipped_count > 0:
            message = f"Imported {added_count} URL(s), skipped {skipped_count}"
        elif added_count > 0:
            message = f"Imported {added_count} URL(s)"
        else:
            message = "No URLs added (duplicates or invalid)"
        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
    
    def extract_artist_url_from_bandcamp_url(self, url):
        """Extract artist page URL from any Bandcamp URL (album, track, or artist page)
        
        Args:
            url: Any Bandcamp URL
            
        Returns:
            Artist page URL or None if extraction fails
        """
        if not url or 'bandcamp.com' not in url.lower():
            return None
        
        try:
            from urllib.parse import urlparse, urlunparse
            
            # Clean URL
            url = url.strip().rstrip('/')
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            parsed = urlparse(url)
            hostname = parsed.hostname or ""
            
            # Extract artist subdomain
            if ".bandcamp.com" in hostname.lower():
                # Format: artist.bandcamp.com
                # Return just the artist page URL
                artist_url = urlunparse((
                    parsed.scheme,
                    hostname,
                    '',  # Empty path = artist page
                    '',
                    '',
                    ''
                ))
                return artist_url.rstrip('/')
            
            return None
            
        except Exception as e:
            logger.warning(f"Error extracting artist URL from {url}: {e}")
            return None
    
    def fetch_artist_discography(self, artist_url):
        """Fetch album URLs from an artist's Bandcamp page
        
        Args:
            artist_url: Artist page URL (e.g., https://artist.bandcamp.com)
            
        Returns:
            List of album URLs, or empty list if failed
        """
        if not artist_url:
            return []
        
        try:
            import re
            
            logger.debug(f"Fetching artist page: {artist_url}")
            
            # Fetch the artist page
            req = urllib.request.Request(artist_url, headers={
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            })
            
            # Use a shorter timeout and ensure it doesn't hang
            try:
                with urllib.request.urlopen(req, timeout=10) as response:
                    html = response.read().decode('utf-8', errors='ignore')
                    logger.debug(f"Fetched {len(html)} characters of HTML")
            except urllib.error.URLError as e:
                logger.warning(f"URLError fetching {artist_url}: {e}")
                raise
            except Exception as e:
                logger.warning(f"Error fetching {artist_url}: {e}")
                raise
            
            # Parse HTML to find album links
            album_urls = []
            base_url = artist_url.rstrip('/')
            
            logger.debug("Parsing HTML for album links...")
            
            # Method 1: Find href attributes pointing to /album/ or /track/ paths
            # Pattern: href="/album/album-name" or href="/track/track-name"
            href_pattern = r'href=["\']([^"\']*(?:/album/|/track/)[^"\']*)["\']'
            matches = list(re.finditer(href_pattern, html, re.IGNORECASE))
            logger.debug(f"Method 1: Found {len(matches)} potential href matches")
            for match in matches:
                href = match.group(1)
                # Skip common non-album links
                if any(skip in href.lower() for skip in ['/music', '/merch', '/about', '/contact', '/shows', '/follow']):
                    continue
                
                # Convert relative URLs to absolute
                if href.startswith('/'):
                    full_url = base_url + href
                elif href.startswith('http'):
                    full_url = href
                else:
                    continue  # Skip malformed URLs
                
                # Normalize URL
                full_url = full_url.rstrip('/')
                
                # Only add Bandcamp album/track URLs
                if 'bandcamp.com' in full_url.lower() and ('/album/' in full_url or '/track/' in full_url):
                    if full_url not in album_urls:
                        album_urls.append(full_url)
            
            # Method 2: Find data-item-url attributes (Bandcamp uses these for album/track items)
            data_item_pattern = r'data-item-url=["\']([^"\']+)["\']'
            matches = list(re.finditer(data_item_pattern, html, re.IGNORECASE))
            logger.debug(f"Method 2: Found {len(matches)} data-item-url matches")
            for match in matches:
                item_url = match.group(1)
                if item_url.startswith('/'):
                    item_url = base_url + item_url
                elif not item_url.startswith('http'):
                    item_url = base_url + '/' + item_url
                
                item_url = item_url.rstrip('/')
                if 'bandcamp.com' in item_url.lower() and item_url not in album_urls:
                    album_urls.append(item_url)
            
            # Method 3: Find links in itemRow elements (Bandcamp's discography grid)
            # Look for <a> tags within elements that have class containing "itemRow"
            item_row_pattern = r'<a[^>]*href=["\']([^"\']*(?:/album/|/track/)[^"\']*)["\'][^>]*>'
            matches = list(re.finditer(item_row_pattern, html, re.IGNORECASE))
            logger.debug(f"Method 3: Found {len(matches)} itemRow matches")
            for match in matches:
                href = match.group(1)
                if any(skip in href.lower() for skip in ['/music', '/merch', '/about', '/contact', '/shows']):
                    continue
                
                if href.startswith('/'):
                    full_url = base_url + href
                elif href.startswith('http'):
                    full_url = href
                else:
                    continue
                
                full_url = full_url.rstrip('/')
                if 'bandcamp.com' in full_url.lower() and ('/album/' in full_url or '/track/' in full_url):
                    if full_url not in album_urls:
                        album_urls.append(full_url)
            
            # Remove duplicates while preserving order
            seen = set()
            unique_urls = []
            for url in album_urls:
                # Normalize URL for comparison (remove trailing slashes, convert to lowercase for comparison)
                normalized = url.lower().rstrip('/')
                if normalized not in seen:
                    seen.add(normalized)
                    unique_urls.append(url)
            
            logger.debug(f"Found {len(unique_urls)} unique album URLs")
            return unique_urls
            
        except urllib.error.URLError as e:
            error_msg = f"Failed to fetch artist page {artist_url}: {e}"
            logger.warning(error_msg)
            raise Exception(error_msg)  # Re-raise so it's shown to user
        except Exception as e:
            error_msg = f"Error parsing artist discography from {artist_url}: {e}"
            logger.warning(error_msg)
            import traceback
            logger.debug(traceback.format_exc())
            raise  # Re-raise so it's shown to user
    
    def load_artist_discography(self, url):
        """Load all albums from an artist's discography into the playlist"""
        # Show progress dialog with Cancel button
        progress_dialog = QMessageBox(self)
        progress_dialog.setWindowTitle("Loading Discography")
        progress_dialog.setText("Fetching Artist Discography...")
        progress_dialog.setStandardButtons(QMessageBox.StandardButton.Cancel)
        progress_dialog.setDefaultButton(QMessageBox.StandardButton.Cancel)
        # Make dialog larger to accommodate cancel button and text
        progress_dialog.setMinimumWidth(450)
        progress_dialog.setMinimumHeight(150)
        
        artist_url = None
        album_urls = []
        error_message = None
        cancelled = [False]  # Use list to allow modification in nested functions
        
        def check_cancel():
            """Check if cancel button was clicked"""
            QApplication.processEvents()
            return cancelled[0]
        
        # Connect cancel button
        def on_cancel_clicked():
            cancelled[0] = True
            progress_dialog.done(QMessageBox.StandardButton.Cancel)
        
        # Find and connect cancel button
        cancel_btn = progress_dialog.button(QMessageBox.StandardButton.Cancel)
        if cancel_btn:
            cancel_btn.clicked.connect(on_cancel_clicked)
        
        try:
            # Extract artist URL from the provided URL
            artist_url = self.extract_artist_url_from_bandcamp_url(url)
            
            if not artist_url:
                progress_dialog.close()
                progress_dialog.deleteLater()
                QApplication.processEvents()
                QMessageBox.warning(self, "Invalid URL", "Could not extract artist URL from the selected item.")
                return
            
            # Update progress dialog
            progress_dialog.setText(f"Fetching Artist Discography From:\n{artist_url}")
            QApplication.processEvents()
            
            # Check if user cancelled
            if cancelled[0]:
                return
            
            # Fetch discography
            logger.info(f"Fetching discography from {artist_url}")
            album_urls = self.fetch_artist_discography(artist_url)
            logger.info(f"Found {len(album_urls)} albums")
            
            # Check if user cancelled during fetch
            if cancelled[0]:
                return
            
        except Exception as e:
            error_message = str(e)
            logger.error(f"Error loading artist discography: {e}", exc_info=True)
        finally:
            # Always close and destroy the progress dialog
            try:
                progress_dialog.close()
                progress_dialog.deleteLater()
                QApplication.processEvents()  # Ensure UI updates immediately
            except:
                pass
        
        # If cancelled, just return
        if cancelled[0]:
            return
        
        # Handle errors
        if error_message:
            QMessageBox.warning(
                self,
                "Error Loading Discography",
                f"Failed to load artist discography:\n\n{error_message}\n\nPlease try again or check your internet connection."
            )
            return
        
        if not album_urls:
            QMessageBox.information(
                self,
                "No Albums Found",
                f"Could not find any albums in the discography.\n\nThe artist page may be empty or require login.\n\nArtist URL: {artist_url}"
            )
            return
        
        # Ensure progress dialog is fully closed before showing next dialog
        QApplication.processEvents()
        
        # Show dialog with count and Add/Replace options
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Load Artist Discography")
        msg_box.setText(f"Found {len(album_urls)} album(s).\n\nAdd to current playlist or replace it?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        
        # Create custom buttons
        add_btn = msg_box.addButton("Add", QMessageBox.ButtonRole.AcceptRole)
        replace_btn = msg_box.addButton("Replace", QMessageBox.ButtonRole.AcceptRole)
        cancel_btn = msg_box.addButton("Cancel", QMessageBox.ButtonRole.RejectRole)
        msg_box.setDefaultButton(add_btn)
        
        reply = msg_box.exec()
        
        if reply == cancel_btn:
            return
        
        if reply == replace_btn:
            # Replace: clear current playlist first
            self.clear_playlist()
        
        # Process URLs
        added_count, skipped_count = self.process_urls(album_urls)
        
        # Show feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        if added_count > 0 and skipped_count > 0:
            message = f"Added {added_count} album(s), skipped {skipped_count}"
        elif added_count > 0:
            message = f"Added {added_count} album(s)"
        else:
            message = "No albums added (duplicates or invalid)"
        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
    
    def delete_playlist(self, playlist_name):
        """Delete a playlist with confirmation"""
        # Get parent window to access playlist manager and settings
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        if not parent_window:
            QMessageBox.warning(self, "Error", "Could not access parent window.")
            return
        
        # Check if this is the only playlist
        playlists = self.playlist_manager.list_playlist_files()
        if len(playlists) <= 1:
            QMessageBox.warning(
                self,
                "Cannot Delete",
                "Cannot delete the only playlist. At least one playlist must exist."
            )
            return
        
        current_playlist_name = self.playlist_manager.get_current_playlist_name()
        is_current_playlist = (playlist_name == current_playlist_name)
        is_default = (playlist_name.lower() == "default")
        
        # Confirmation dialog
        confirm_msg = f"Are you sure you want to delete the playlist '{playlist_name}'?"
        if is_current_playlist:
            confirm_msg += "\n\nThis is the currently loaded playlist. It will be replaced with Default."
        if is_default:
            confirm_msg += "\n\nNote: Default playlist will be recreated as empty."
        
        reply = QMessageBox.question(
            self,
            "Delete Playlist",
            confirm_msg,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        # Delete the playlist file
        if not self.playlist_manager.delete_playlist_file(playlist_name):
            QMessageBox.warning(self, "Delete Failed", f"Failed to delete playlist '{playlist_name}'.")
            return
        
        # If we deleted the current playlist, switch to Default
        if is_current_playlist:
            # Ensure Default exists
            self.playlist_manager.ensure_default_playlist_exists()
            # Load Default playlist
            default_file = self.playlist_manager.playlists_dir / "Default.json"
            if default_file.exists():
                self.load_playlist_from_file(str(default_file))
                # Show feedback
                global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                QToolTip.showText(global_pos, "Switched to Default playlist", self.list_widget, QRect(), 1500)
        
        # If we deleted Default, recreate it as empty
        if is_default:
            self.playlist_manager.ensure_default_playlist_exists()
            # If it was the current playlist, load it
            if is_current_playlist:
                default_file = self.playlist_manager.playlists_dir / "Default.json"
                if default_file.exists():
                    self.load_playlist_from_file(str(default_file))
        
        # Save settings
        if parent_window and hasattr(parent_window, 'save_settings'):
            parent_window.save_settings()
        
        # Show success feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        QToolTip.showText(global_pos, f"Deleted: {playlist_name}", self.list_widget, QRect(), 1500)
    
    def migrate_default_playlist(self):
        """Migrate old lowercase default.json to Default.json"""
        old_default_file = self.playlist_manager.playlists_dir / "default.json"
        default_file = self.playlist_manager.playlists_dir / "Default.json"
        
        if old_default_file.exists() and not default_file.exists():
            try:
                import shutil
                shutil.copy2(old_default_file, default_file)
                # Optionally delete old file
                old_default_file.unlink()
                logger.info("Migrated default.json to Default.json")
                
                # Load the migrated Default playlist
                self.load_playlist_from_file(str(default_file))
                
                # Show feedback
                global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                QToolTip.showText(global_pos, "Migrated to Default playlist", self.list_widget, QRect(), 1500)
            except Exception as e:
                logger.error(f"Failed to migrate default.json: {e}")
                QMessageBox.warning(self, "Migration Failed", f"Failed to migrate default.json:\n\n{str(e)}")
    
    def show_playlist_menu(self):
        """Show playlist menu with additional options"""
        menu_btn = self.sender()
        menu = QMenu(self)
        
        # Apply dark theme styling to match the rest of the app
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        
        # Show currently loaded playlist at the top (inactive, blue text)
        current_playlist_name = self.playlist_manager.get_current_playlist_name()
        
        # Use QWidgetAction to create a styled label
        current_playlist_widget = QWidget()
        current_playlist_layout = QHBoxLayout(current_playlist_widget)
        current_playlist_layout.setContentsMargins(20, 6, 20, 6)
        current_playlist_label = QLabel(f"Current: {current_playlist_name}")
        current_playlist_label.setStyleSheet("color: #4a90e2; font-weight: normal;")
        current_playlist_layout.addWidget(current_playlist_label)
        
        current_playlist_action = QWidgetAction(self)
        current_playlist_action.setDefaultWidget(current_playlist_widget)
        current_playlist_action.setEnabled(False)
        menu.addAction(current_playlist_action)
        
        menu.addSeparator()
        
        # Save Playlist (updates current)
        save_action = QAction("Save Playlist", self)
        if HAS_QT_AWESOME:
            icon = get_icon('save', color='#e0e0e0')
            if icon:
                save_action.setIcon(icon)
        else:
            save_action.setText(" Save Playlist")
        save_action.triggered.connect(self.save_current_playlist)
        menu.addAction(save_action)
        
        # Save Playlist As...
        save_as_action = QAction("Save Playlist As...", self)
        if HAS_QT_AWESOME:
            icon = get_icon('save', color='#e0e0e0')
            if icon:
                save_as_action.setIcon(icon)
        else:
            save_as_action.setText(" Save As...")
        save_as_action.triggered.connect(self.save_playlist_as)
        menu.addAction(save_as_action)
        
        menu.addSeparator()
        
        # Load Playlist (submenu with available playlists)
        load_menu = QMenu("Load Playlist", self)
        load_menu.setStyleSheet(menu.styleSheet())
        
        # Get list of available playlists
        playlists = self.playlist_manager.list_playlist_files()
        current_playlist_name = self.playlist_manager.get_current_playlist_name()
        
        if playlists:
            for playlist_info in playlists:
                playlist_name = playlist_info["name"]
                playlist_file = playlist_info["file"]
                
                # Create action for this playlist
                playlist_action = QAction(playlist_name, self)
                # Mark current playlist with checkmark
                if playlist_name == current_playlist_name:
                    playlist_action.setText(f" {playlist_name}")
                    playlist_action.setEnabled(False)  # Disable current playlist
                playlist_action.triggered.connect(
                    lambda checked, file=playlist_file: self.load_playlist_from_file(str(file))
                )
                load_menu.addAction(playlist_action)
        
        # Also check for old lowercase "default.json" and offer to migrate it
        old_default_file = self.playlist_manager.playlists_dir / "default.json"
        if old_default_file.exists():
            # Check if Default.json already exists
            default_file = self.playlist_manager.playlists_dir / "Default.json"
            if not default_file.exists():
                # Offer to migrate
                migrate_action = QAction("default (migrate to Default)", self)
                migrate_action.triggered.connect(
                    lambda: self.migrate_default_playlist()
                )
                load_menu.addAction(migrate_action)
        else:
            # No playlists found
            no_playlists_action = QAction("No playlists found", self)
            no_playlists_action.setEnabled(False)
            load_menu.addAction(no_playlists_action)
        
        # Add Load Playlist submenu
        load_action = menu.addMenu(load_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('folder-open', color='#e0e0e0')
            if icon:
                load_action.setIcon(icon)
        else:
            load_action.setText(" Load Playlist")
        
        # Delete Playlist (submenu with available playlists)
        delete_menu = QMenu("Delete Playlist", self)
        delete_menu.setStyleSheet(menu.styleSheet())
        
        # Get list of available playlists
        playlists = self.playlist_manager.list_playlist_files()
        current_playlist_name = self.playlist_manager.get_current_playlist_name()
        
        if playlists:
            for playlist_info in playlists:
                playlist_name = playlist_info["name"]
                playlist_file = playlist_info["file"]
                
                # Create action for this playlist
                playlist_action = QAction(playlist_name, self)
                # Disable if it's the only playlist (can't delete the last playlist)
                if len(playlists) == 1:
                    playlist_action.setEnabled(False)
                    playlist_action.setText(f"{playlist_name} (cannot delete only playlist)")
                playlist_action.triggered.connect(
                    lambda checked, name=playlist_name: self.delete_playlist(name)
                )
                delete_menu.addAction(playlist_action)
        else:
            # No playlists found
            no_playlists_action = QAction("No playlists found", self)
            no_playlists_action.setEnabled(False)
            delete_menu.addAction(no_playlists_action)
        
        # Add Delete Playlist submenu
        delete_action = menu.addMenu(delete_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('trash', color='#e0e0e0')
            if icon:
                delete_action.setIcon(icon)
        else:
            delete_action.setText(" Delete Playlist")
        
        menu.addSeparator()
        
        # Export Playlist URLs
        export_action = QAction("Export Playlist URLs", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file-export', color='#e0e0e0')
            if icon:
                export_action.setIcon(icon)
        else:
            export_action.setText(" Export Playlist URLs")
        export_action.triggered.connect(self.export_playlist_urls)
        menu.addAction(export_action)
        
        # Import Playlist URLs
        import_action = QAction("Import Playlist URLs", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file-import', color='#e0e0e0')
            if icon:
                import_action.setIcon(icon)
        else:
            import_action.setText(" Import Playlist URLs")
        import_action.triggered.connect(self.import_playlist_urls)
        menu.addAction(import_action)
        
        menu.addSeparator()
        
        # Clear Playlist (already exists as button, but useful in menu too)
        clear_action = QAction("Clear Playlist", self)
        if HAS_QT_AWESOME:
            icon = get_icon('trash', color='#e0e0e0')
            if icon:
                clear_action.setIcon(icon)
        else:
            clear_action.setText(" Clear Playlist")
        clear_action.triggered.connect(self.clear_playlist)
        menu.addAction(clear_action)
        
        menu.addSeparator()
        
        # Close Menu
        close_menu_action = QAction("Close Menu", self)
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_menu_action.setIcon(icon)
        else:
            close_menu_action.setText(" Close Menu")
        close_menu_action.triggered.connect(lambda: menu.close())
        menu.addAction(close_menu_action)
        
        # Show menu at button position
        global_pos = menu_btn.mapToGlobal(menu_btn.rect().bottomLeft())
        menu.exec(global_pos)
    
    def show_context_menu(self, position):
        """Show context menu for playlist item(s) - adapts to single or multiple selection"""
        # Get selected items (if right-clicked on selected item, use all selected; otherwise use clicked item)
        selected_items = self.list_widget.selectedItems()
        clicked_item = self.list_widget.itemAt(position)
        
        # Check if right-clicked on empty area
        if not clicked_item:
            # Right-clicked on empty area - show paste menu
            menu = QMenu(self)
            menu.setStyleSheet("""
                QMenu {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: 1px solid #3a3a3a;
                    border-radius: 4px;
                    padding: 2px;
                }
                QMenu::item {
                    padding: 6px 20px;
                    border-radius: 2px;
                }
                QMenu::item:selected {
                    background-color: #4a90e2;
                    color: #ffffff;
                }
                QMenu::separator {
                    height: 1px;
                    background-color: #3a3a3a;
                    margin: 4px 8px;
                }
            """)
            
            # Paste URLs action
            paste_action = QAction("Paste URL(s)", self)
            if HAS_QT_AWESOME:
                icon = get_icon('paste', color='#e0e0e0')
                if icon:
                    paste_action.setIcon(icon)
            else:
                paste_action.setText(" Paste URL(s)")
            paste_action.triggered.connect(self.paste_urls_from_clipboard)
            menu.addAction(paste_action)
            
            menu.exec(self.list_widget.mapToGlobal(position))
            return
        
        # If clicked item is not in selection, select only it
        if clicked_item and clicked_item not in selected_items:
            self.list_widget.clearSelection()
            clicked_item.setSelected(True)
            selected_items = [clicked_item]
        
        # If no items selected, try to use clicked item
        if not selected_items and clicked_item:
            selected_items = [clicked_item]
        
        if not selected_items:
            return
        
        menu = QMenu(self)
        # Add hover states to context menu
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        
        is_multiple = len(selected_items) > 1
        
        # Paste URLs action (always available)
        paste_action = QAction("Paste URL(s)", self)
        if HAS_QT_AWESOME:
            icon = get_icon('paste', color='#e0e0e0')
            if icon:
                paste_action.setIcon(icon)
        else:
            paste_action.setText(" Paste URL(s)")
        paste_action.triggered.connect(self.paste_urls_from_clipboard)
        menu.addAction(paste_action)
        
        menu.addSeparator()
        
        # Load/Play action - only enabled for single selection
        if is_multiple:
            load_action = QAction("Load in Player", self)
            if HAS_QT_AWESOME:
                icon = get_icon('play', color='#666666')
                if icon:
                    load_action.setIcon(icon)
            else:
                load_action.setText(" Load in Player")
            load_action.setEnabled(False)  # Disabled for multiple selection
            menu.addAction(load_action)
        else:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            if url:
                load_action = QAction("Load in Player", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('play', color='#e0e0e0')
                    if icon:
                        load_action.setIcon(icon)
                else:
                    load_action.setText(" Load in Player")
                load_action.triggered.connect(lambda: self.load_url_func(url))
                menu.addAction(load_action)
        
        menu.addSeparator()
        
        # Load Artist Discography - only for single selection
        if not is_multiple:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            if url and 'bandcamp.com' in url.lower():
                discography_action = QAction("Load Artist Discography", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('list', color='#e0e0e0')
                    if icon:
                        discography_action.setIcon(icon)
                else:
                    discography_action.setText(" Load Artist Discography")
                discography_action.triggered.connect(lambda: self.load_artist_discography(url))
                menu.addAction(discography_action)
                menu.addSeparator()
        
        # Open in browser - works for single or multiple
        if is_multiple:
            open_action = QAction(f"Open {len(selected_items)} URLs in Browser", self)
            if HAS_QT_AWESOME:
                icon = get_icon('external-link-alt', color='#e0e0e0')
                if icon:
                    open_action.setIcon(icon)
            else:
                open_action.setText(f" Open {len(selected_items)} URLs in Browser")
            open_action.triggered.connect(lambda: self.open_multiple_urls_in_browser(selected_items))
            menu.addAction(open_action)
        else:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            if url:
                open_action = QAction("Open in Browser", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('external-link-alt', color='#e0e0e0')
                if icon:
                    open_action.setIcon(icon)
                else:
                    open_action.setText(" Open in Browser")
                open_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl(url)))
                menu.addAction(open_action)
        
        # Copy URL(s) - works for single or multiple
        if is_multiple:
            copy_action = QAction(f"Copy {len(selected_items)} URLs", self)
            if HAS_QT_AWESOME:
                icon = get_icon('copy', color='#e0e0e0')
                if icon:
                    copy_action.setIcon(icon)
            else:
                copy_action.setText(f" Copy {len(selected_items)} URLs")
            copy_action.triggered.connect(lambda: self.copy_multiple_urls(selected_items))
            menu.addAction(copy_action)
        else:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            if url:
                copy_action = QAction("Copy URL", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('copy', color='#e0e0e0')
                if icon:
                    copy_action.setIcon(icon)
                else:
                    copy_action.setText(" Copy URL")
                def copy_with_feedback():
                    QApplication.clipboard().setText(url)
                    global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                    QToolTip.showText(global_pos, "URL copied", self.list_widget, QRect(), 1500)
                copy_action.triggered.connect(copy_with_feedback)
                menu.addAction(copy_action)
        
        menu.addSeparator()
        
        # Delete - works for single or multiple
        if is_multiple:
            delete_action = QAction(f"Delete {len(selected_items)} Items", self)
            if HAS_QT_AWESOME:
                icon = get_icon('trash', color='#e0e0e0')
                if icon:
                    delete_action.setIcon(icon)
            else:
                delete_action.setText(f" Delete {len(selected_items)} Items")
            delete_action.triggered.connect(lambda: self.delete_selected_items())
        else:
            delete_action = QAction("Delete", self)
            if HAS_QT_AWESOME:
                icon = get_icon('trash', color='#e0e0e0')
                if icon:
                    delete_action.setIcon(icon)
            else:
                delete_action.setText(" Delete")
            delete_action.triggered.connect(lambda: self.delete_item(selected_items[0]))
        menu.addAction(delete_action)
        
        menu.exec(self.list_widget.mapToGlobal(position))
    
    def open_multiple_urls_in_browser(self, items):
        """Open multiple URLs in browser"""
        urls = []
        for item in items:
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                urls.append(url)
        
        # Open each URL
        for url in urls:
            QDesktopServices.openUrl(QUrl(url))
    
    def copy_multiple_urls(self, items):
        """Copy multiple URLs to clipboard (one per line)"""
        urls = []
        for item in items:
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                urls.append(url)
        
        if urls:
            QApplication.clipboard().setText('\n'.join(urls))
            # Show tooltip feedback
            count = len(urls)
            message = f"{count} URL{'s' if count > 1 else ''} copied" if count > 0 else "URLs copied"
            # Show tooltip at mouse position or list widget center
            global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
            QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)  # 2 second duration
    
    def eventFilter(self, obj, event):
        """Event filter to handle Delete key, Ctrl+C for copy, and drag/drop"""
        # Handle keyboard shortcuts on list widget
        if obj == self.list_widget:
            if event.type() == QEvent.Type.KeyPress:
                # Delete key - remove selected items
                if event.key() == Qt.Key.Key_Delete:
                    self.delete_selected_items()
                    return True
                # Ctrl+C - copy selected URLs to clipboard
                elif event.key() == Qt.Key.Key_C and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    selected_items = self.list_widget.selectedItems()
                    if selected_items:
                        self.copy_multiple_urls(selected_items)
                        return True
                # Ctrl+X - cut selected URLs (copy and delete)
                elif event.key() == Qt.Key.Key_X and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    selected_items = self.list_widget.selectedItems()
                    if selected_items:
                        # Copy URLs first
                        self.copy_multiple_urls(selected_items)
                        # Then delete the items
                        self.delete_selected_items()
                        # Show feedback
                        count = len(selected_items)
                        message = f"{count} item{'s' if count > 1 else ''} cut"
                        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
                        return True
                # Ctrl+V - paste URLs from clipboard
                elif event.key() == Qt.Key.Key_V and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    self.paste_urls_from_clipboard()
                    return True
                # Shift+Ctrl+Z - redo (check this first before Ctrl+Z)
                elif event.key() == Qt.Key.Key_Z and event.modifiers() == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.ShiftModifier):
                    self.redo_playlist_change()
                    return True
                # Ctrl+Z - undo
                elif event.key() == Qt.Key.Key_Z and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    self.undo_playlist_change()
                    return True
        
        # Handle drag and drop for adding URLs
        if obj == self.list_widget:
            if event.type() == QEvent.Type.DragEnter:
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                    return True
            elif event.type() == QEvent.Type.Drop:
                # Extract all URLs from drag event - handle multiple URLs
                url_strings = []
                
                # Get URLs from text (most reliable for multiple URLs)
                if event.mimeData().hasText():
                    text = event.mimeData().text().strip()
                    if text:
                        # Split by newlines first (same as paste handler)
                        lines = [line.strip() for line in text.split('\n') if line.strip()]
                        
                        # If we got multiple lines, use them directly
                        if len(lines) > 1:
                            url_strings.extend(lines)
                        else:
                            # Single line - check if it contains multiple concatenated URLs
                            single_line = lines[0] if lines else text
                            if single_line.count('https://') > 1 or single_line.count('http://') > 1:
                                # Extract concatenated URLs
                                extracted = self.extract_urls_from_text(single_line)
                                url_strings.extend(extracted)
                            else:
                                # Single URL
                                url_strings.append(single_line)
                
                # Also get URLs from hasUrls() - each QUrl becomes a separate entry
                if event.mimeData().hasUrls():
                    url_list = event.mimeData().urls()
                    for url in url_list:
                        url_str = url.toString()
                        # Check if this URL string contains multiple concatenated URLs
                        if url_str.count('https://') > 1 or url_str.count('http://') > 1:
                            # Extract all URLs from this concatenated string
                            extracted = self.extract_urls_from_text(url_str)
                            for extracted_url in extracted:
                                if extracted_url not in url_strings:
                                    url_strings.append(extracted_url)
                        else:
                            # Single URL, add it directly
                            if url_str not in url_strings:
                                url_strings.append(url_str)
                
                if not url_strings:
                    event.ignore()
                    return True
                
                # Process all URLs using the same method as paste handler
                added_count, skipped_count = self.process_urls(url_strings)
                
                # Show feedback (same as paste handler)
                global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                if added_count > 0 and skipped_count > 0:
                    message = f"Added {added_count} URL(s), skipped {skipped_count}"
                elif added_count > 0:
                    message = f"Added {added_count} URL(s)"
                else:
                    message = "No URLs added (duplicates or invalid)"
                QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
                
                event.acceptProposedAction()
                return True
        
        return super().eventFilter(obj, event)
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event on the playlist sidebar - add to playlist instead of loading"""
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def extract_urls_from_text(self, text):
        """Extract all Bandcamp URLs from text, handling various formats.
        
        Handles:
        - URLs separated by newlines
        - URLs separated by spaces
        - URLs concatenated without separators
        - Mixed formats
        """
        import re
        urls = []
        
        if not text:
            return urls
        
        # Handle concatenated URLs by splitting on https:// and http:// patterns
        # This is the most reliable way to extract URLs even when they're concatenated
        url_parts = re.split(r'(https?://)', text, flags=re.IGNORECASE)
        found_urls = []
        
        # Reconstruct URLs from the split parts
        for i in range(1, len(url_parts), 2):  # Start at index 1 (first https://), step by 2
            if i + 1 < len(url_parts):
                protocol = url_parts[i]  # https:// or http://
                url_body = url_parts[i + 1]  # rest of URL
                
                # Find where this URL ends:
                # 1. Next https:// or http:// (for concatenated URLs)
                # 2. Whitespace
                # 3. Special characters that shouldn't be in URLs
                # 4. End of string
                
                # Check for next URL start
                next_https = url_body.find('https://')
                next_http = url_body.find('http://')
                next_url_start = -1
                if next_https >= 0 and next_http >= 0:
                    next_url_start = min(next_https, next_http)
                elif next_https >= 0:
                    next_url_start = next_https
                elif next_http >= 0:
                    next_url_start = next_http
                
                # Find first whitespace or invalid char
                invalid_chars = re.search(r'[\s<>"{}|\\^`\[\]]', url_body)
                invalid_pos = invalid_chars.start() if invalid_chars else len(url_body)
                
                # Take the URL up to the earliest stopping point
                if next_url_start >= 0:
                    url_body = url_body[:min(next_url_start, invalid_pos)]
                else:
                    url_body = url_body[:invalid_pos]
                
                # Construct full URL
                full_url = protocol + url_body.rstrip('/')
                
                # Only add if it's a Bandcamp URL
                if 'bandcamp.com' in full_url.lower():
                    found_urls.append(full_url)
        
        if found_urls:
            # Found URLs using regex (handles concatenated case)
            urls.extend(found_urls)
        else:
            # Fallback: try splitting by newlines first (most common)
            lines = [line.strip() for line in text.split('\n') if line.strip()]
            
            for line in lines:
                if 'bandcamp.com' in line.lower():
                    # Try splitting by spaces (handles space-separated URLs)
                    space_split = [url.strip() for url in line.split() if url.strip() and 'bandcamp.com' in url.lower()]
                    if space_split:
                        urls.extend(space_split)
                    else:
                        # If no spaces, might be a single URL - add it as-is
                        urls.append(line)
        
        # Remove duplicates while preserving order
        seen = set()
        unique_urls = []
        for url in urls:
            # Normalize URL for comparison (remove trailing slashes)
            normalized = url.rstrip('/')
            if normalized not in seen:
                seen.add(normalized)
                unique_urls.append(url)  # Keep original with/without trailing slash
        
        return unique_urls
    
    def dropEvent(self, event: QDropEvent):
        """Handle drop event on the playlist sidebar - take first valid URL only"""
        url = None
        
        # Get first URL from drag event - prioritize URLs list, then text
        if event.mimeData().hasUrls():
            url_list = event.mimeData().urls()
            if url_list:
                url = url_list[0].toString()
        
        # If no URL from list, try text
        if not url and event.mimeData().hasText():
            text = event.mimeData().text().strip()
            if text:
                # Take first line if multiple lines, or entire text if single
                lines = [line.strip() for line in text.split('\n') if line.strip()]
                if lines:
                    url = lines[0]
        
        if not url:
            event.ignore()
            return
        
        # Process single URL using the same method as paste handler
        added_count, skipped_count = self.process_urls([url])
        
        # Show feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        if added_count > 0:
            message = "URL added to playlist"
        else:
            message = "URL not added (duplicate or invalid)"
        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
        
        event.acceptProposedAction()
    
    def delete_selected_items(self):
        """Delete all selected items from the playlist"""
        selected_items = self.list_widget.selectedItems()
        if not selected_items:
            return
        
        # Save state to history before deleting
        if not self.is_undoing_redoing:
            self._save_state_to_history()
        
        # Suppress history save when we call save_playlist (we already saved above)
        self._suppress_history_save = True
        
        # Get URLs to remove (skip blank item)
        urls_to_remove = []
        items_to_remove = []
        for item in selected_items:
            # Skip blank item
            if item == self._blank_item:
                continue
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                urls_to_remove.append(url)
                items_to_remove.append(item)
        
        # Remove from playlist manager - remove_url handles URL normalization internally
        for url in urls_to_remove:
            self.playlist_manager.remove_url(url)
        
        # Remove from list widget (in reverse order to maintain indices)
        items_to_remove.sort(key=lambda item: self.list_widget.row(item), reverse=True)
        for item in items_to_remove:
            row = self.list_widget.row(item)
            self.list_widget.takeItem(row)
            
            # Clear current item reference if it was deleted
            if self.current_item == item:
                self.current_item = None
        
        # Save playlist (remove_url already saves, but ensure it's saved after all removals)
        self.playlist_manager.save_playlist()
        
        # Restore history saving
        self._suppress_history_save = False
        
        # Ensure blank item is at bottom after deletion
        self._ensure_blank_item_at_bottom()
        
        # Save state to history after deletion completes (so current state is in history)
        if not self.is_undoing_redoing:
            QTimer.singleShot(50, self._save_state_to_history)
    
    def delete_item(self, item):
        """Delete an item from the playlist (backward compatibility - now uses delete_selected_items)"""
        # Skip blank item
        if item == self._blank_item:
            return
        
        # If multiple items are selected, delete all selected
        selected_items = self.list_widget.selectedItems()
        if len(selected_items) > 1:
            self.delete_selected_items()
        else:
            # Single item deletion - save state to history
            if not self.is_undoing_redoing:
                self._save_state_to_history()
            
            # Suppress history save when we call save_playlist (we already saved above)
            self._suppress_history_save = True
            
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                self.playlist_manager.remove_url(url)
                self.playlist_manager.save_playlist()
            
            row = self.list_widget.row(item)
            self.list_widget.takeItem(row)
            
            if self.current_item == item:
                self.current_item = None
            
            # Ensure blank item is at bottom after deletion
            self._ensure_blank_item_at_bottom()
            
            # Restore history saving
            self._suppress_history_save = False
            
            # Save state to history after deletion completes (so current state is in history)
            if not self.is_undoing_redoing:
                QTimer.singleShot(50, self._save_state_to_history)
    
    def add_url(self):
        """Add URL(s) from clipboard - supports multiple URLs (one per line)"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        if not text:
            return
        
        # Split by newlines to handle multiple URLs
        lines = [line.strip() for line in text.split('\n') if line.strip()]
        
        if not lines:
            return
        
        # Get existing URLs for duplicate checking
        existing_urls = [item.get("url") if isinstance(item, dict) else item for item in self.playlist_manager.playlist]
        
        added_count = 0
        skipped_count = 0
        
        for line in lines:
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved = self.resolve_url_redirects(line)
            if resolved:
                url = resolved
            else:
                # If resolution failed but it looks like a Bandcamp URL, use it as-is
                if 'bandcamp.com' in line.lower():
                    url = line
                else:
                    # Not a Bandcamp URL, skip it
                    skipped_count += 1
                    continue
            
            # Normalize URL
            url = url.strip().rstrip('/')
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            # Only add if it's a Bandcamp URL and not already in playlist
            if 'bandcamp.com' in url.lower():
                if url not in existing_urls:
                    self.playlist_manager.add_url(url)
                    self.add_item(url)
                    added_count += 1
                    existing_urls.append(url)  # Update list to avoid duplicates in same batch
                else:
                    skipped_count += 1
            else:
                skipped_count += 1
        
        # Save playlist after adding all URLs
        if added_count > 0:
            self.playlist_manager.save_playlist()
        
        # Show feedback if multiple URLs were processed
        if len(lines) > 1:
            from PyQt6.QtWidgets import QMessageBox
            msg = QMessageBox(self)
            msg.setWindowTitle("Add URLs")
            if added_count > 0 and skipped_count > 0:
                msg.setText(f"Added {added_count} URL(s) to playlist.\nSkipped {skipped_count} (duplicates or invalid).")
            elif added_count > 0:
                msg.setText(f"Added {added_count} URL(s) to playlist.")
            else:
                msg.setText(f"No URLs added. All were duplicates or invalid.")
            msg.setStyleSheet("""
                QMessageBox {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                }
                QMessageBox QLabel {
                    color: #e0e0e0;
                    background-color: transparent;
                }
                QMessageBox QPushButton {
                    background-color: #3a3a3a;
                    color: #e0e0e0;
                    border: 1px solid #4a4a4a;
                    border-radius: 4px;
                    padding: 5px 15px;
                    min-width: 60px;
                }
                QMessageBox QPushButton:hover {
                    background-color: #4a4a4a;
                    border: 1px solid #5a5a5a;
                }
                QMessageBox QPushButton:pressed {
                    background-color: #2a2a2a;
                }
            """)
            msg.exec()
    
    def clear_playlist(self):
        """Clear the playlist"""
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Clear Playlist")
        msg_box.setText("Are you sure you want to clear all URLs from the playlist?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        
        # Apply styling to ensure readable text on Windows 10
        msg_box.setStyleSheet("""
            QMessageBox {
                background-color: #2b2b2b;
                color: #e0e0e0;
            }
            QMessageBox QLabel {
                color: #e0e0e0;
                background-color: transparent;
            }
            QMessageBox QPushButton {
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 5px 15px;
                min-width: 60px;
            }
            QMessageBox QPushButton:hover {
                background-color: #4a4a4a;
                border: 1px solid #5a5a5a;
            }
            QMessageBox QPushButton:pressed {
                background-color: #2a2a2a;
            }
        """)
        
        reply = msg_box.exec()
        
        if reply == QMessageBox.StandardButton.Yes:
            # Save state to history before clearing
            if not self.is_undoing_redoing:
                self._save_state_to_history()
            
            # Suppress history save (we already saved above)
            self._suppress_history_save = True
            
            self.list_widget.clear()
            self.current_item = None
            self._blank_item = None  # Clear blank item reference
            self.playlist_manager.clear_playlist()
            
            # Add blank item at bottom after clearing
            self._ensure_blank_item_at_bottom()
            
            # Restore history saving
            self._suppress_history_save = False
            
            # Save state to history after clearing completes (so current state is in history)
            if not self.is_undoing_redoing:
                QTimer.singleShot(50, self._save_state_to_history)
    
    def _save_state_to_history(self):
        """Save current playlist state to undo history"""
        if self.is_undoing_redoing:
            return
        
        # Get current playlist state
        playlist_items = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                display_text = item.text()
                playlist_items.append({"url": url, "display_text": display_text})
        
        # Only save if state actually changed
        if self.undo_history and self.undo_history[-1] == playlist_items:
            return
        
        # Add to undo history
        self.undo_history.append(playlist_items)
        
        # Limit history size
        if len(self.undo_history) > self.max_history_size:
            self.undo_history.pop(0)
        
        # Clear redo history when new action is performed
        self.redo_history.clear()
    
    def undo_playlist_change(self):
        """Undo the last playlist change"""
        if not self.undo_history or len(self.undo_history) <= 1:
            # No history or only initial state
            return
        
        # Get previous state (second to last, since last is current)
        previous_state = self.undo_history[-2]
        
        # Save current state to redo history
        current_state = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                display_text = item.text()
                current_state.append({"url": url, "display_text": display_text})
        self.redo_history.append(current_state)
        
        # Remove current state from undo history
        self.undo_history.pop()
        
        # Restore previous state
        self.is_undoing_redoing = True
        self._restore_playlist_state(previous_state)
        self.is_undoing_redoing = False
    
    def redo_playlist_change(self):
        """Redo the last undone playlist change"""
        if not self.redo_history:
            return
        
        # Get state to restore
        state_to_restore = self.redo_history.pop()
        
        # Save current state to undo history
        current_state = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                display_text = item.text()
                current_state.append({"url": url, "display_text": display_text})
        self.undo_history.append(current_state)
        
        # Restore state
        self.is_undoing_redoing = True
        self._restore_playlist_state(state_to_restore)
        self.is_undoing_redoing = False
    
    def _restore_playlist_state(self, state):
        """Restore playlist to a given state"""
        # Store current item URL to restore highlighting
        current_url = None
        if self.current_item:
            current_url = self.current_item.data(Qt.ItemDataRole.UserRole)
        
        # Clear list widget
        self.list_widget.clear()
        self.current_item = None
        
        # Add items from state
        for item_data in state:
            url = item_data.get("url", "")
            display_text = item_data.get("display_text")
            if url:
                # Create list item
                item = QListWidgetItem(display_text if display_text else self.url_to_display(url))
                item.setData(Qt.ItemDataRole.UserRole, url)
                item.setData(Qt.ItemDataRole.UserRole + 1, False)
                item.setToolTip(url)
                self.list_widget.addItem(item)
        
        # Update playlist manager
        self.playlist_manager.playlist = state.copy()
        self.playlist_manager.save_playlist()
        
        # Restore current item highlighting if it still exists
        if current_url:
            QTimer.singleShot(100, lambda: self.update_current_item(current_url))
    
    def _on_rows_moved(self):
        """Handle rows moved signal with debouncing to save history only once per drag operation"""
        # Cancel any existing timer
        if self._reorder_save_timer:
            self._reorder_save_timer.stop()
        
        # Debounce the save - wait 300ms after last move before saving
        # This ensures we only save once per drag operation, not on every intermediate move
        self._reorder_save_timer = QTimer(self)
        self._reorder_save_timer.setSingleShot(True)
        self._reorder_save_timer.timeout.connect(self._save_playlist_after_reorder)
        self._reorder_save_timer.start(300)
    
    def _save_playlist_after_reorder(self):
        """Save playlist after reorder is complete"""
        # Save state to history once when drag completes
        if not self.is_undoing_redoing and not self._suppress_history_save:
            self._save_state_to_history()
        
        # Suppress history save when calling save_playlist (we already saved above)
        self._suppress_history_save = True
        self.save_playlist()
        self._suppress_history_save = False
    
    def save_playlist(self):
        """Save playlist from list widget (with metadata)"""
        # Save state to history before saving (if not undoing/redoing and not suppressed)
        if not self.is_undoing_redoing and not self._suppress_history_save:
            self._save_state_to_history()
        
        playlist_items = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                # Get display text from the item
                display_text = item.text()
                playlist_items.append({"url": url, "display_text": display_text})
        
        self.playlist_manager.playlist = playlist_items
        self.playlist_manager.save_playlist()
    
    def normalize_url(self, url):
        """Normalize URL for comparison (remove trailing slashes, normalize scheme)"""
        if not url:
            return None
        url = url.strip().rstrip('/')
        # Normalize http to https
        if url.startswith('http://'):
            url = 'https://' + url[7:]
        return url.lower()
    
    def get_url_path(self, url):
        """Extract path portion of URL for flexible matching"""
        if not url:
            return None
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            # Get path and remove leading/trailing slashes
            path = parsed.path.strip('/')
            # Include query string if present (for some Bandcamp URLs)
            if parsed.query:
                path = path + '?' + parsed.query
            return path.lower()
        except:
            return None
    
    def update_current_item(self, url):
        """Update the current item based on URL"""
        if not url:
            logger.debug("update_current_item: No URL provided")
            return
            
        logger.debug(f"update_current_item: Looking for URL: {url}")
        
        # Resolve URL to match against stored URLs (in case URL was resolved)
        resolved_url = self.resolve_url_redirects(url)
        if resolved_url:
            logger.debug(f"update_current_item: Resolved URL: {resolved_url}")
            url = resolved_url
        
        # Normalize the URL for comparison
        normalized_url = self.normalize_url(url)
        url_path = self.get_url_path(url)
        logger.debug(f"update_current_item: Normalized URL: {normalized_url}")
        logger.debug(f"update_current_item: URL path: {url_path}")
        logger.debug(f"update_current_item: Playlist has {self.list_widget.count()} items")
        
        # Try to find item by URL match (with normalization)
        best_match = None
        for i in range(self.list_widget.count()):
            try:
                item = self.list_widget.item(i)
                if not item:
                    continue
                    
                item_url = item.data(Qt.ItemDataRole.UserRole)
                if not item_url:
                    continue
                
                logger.debug(f"update_current_item: Item {i}: {item_url}")
                
                # Normalize stored URL
                normalized_item_url = self.normalize_url(item_url)
                logger.debug(f"update_current_item:   Normalized: {normalized_item_url}")
                
                # Also check resolved version of stored URL
                resolved_item_url = self.resolve_url_redirects(item_url) if item_url else None
                if resolved_item_url:
                    logger.debug(f"update_current_item:   Resolved: {resolved_item_url}")
                normalized_resolved_item_url = self.normalize_url(resolved_item_url) if resolved_item_url else None
                
                # Exact match (highest priority)
                if (normalized_item_url == normalized_url or 
                    (normalized_resolved_item_url and normalized_resolved_item_url == normalized_url)):
                    logger.debug(f"update_current_item: EXACT MATCH FOUND at index {i}!")
                    self.set_current_item(item)
                    # Force playlist repaint after setting current item (fixes black display in mini mode when switching URLs)
                    if hasattr(self, 'list_widget') and self.list_widget:
                        self.list_widget.viewport().update()
                        self.list_widget.update()
                    return
                
                # Path-based match (fallback for URLs with different schemes or trailing slashes)
                if url_path:
                    item_path = self.get_url_path(item_url)
                    resolved_item_path = self.get_url_path(resolved_item_url) if resolved_item_url else None
                    if (item_path and item_path == url_path) or (resolved_item_path and resolved_item_path == url_path):
                        logger.debug(f"update_current_item: PATH MATCH FOUND at index {i} (path: {item_path})")
                        best_match = item  # Store as best match, but continue looking for exact match
            except RuntimeError:
                # Item was deleted during iteration, skip it
                continue
        
        # If no exact match found, use best path-based match
        if best_match:
            logger.debug("update_current_item: Using best path-based match")
            self.set_current_item(best_match)
            # Force playlist repaint after setting current item (fixes black display in mini mode when switching URLs)
            if hasattr(self, 'list_widget') and self.list_widget:
                self.list_widget.viewport().update()
                self.list_widget.update()
        else:
            logger.warning(f"update_current_item: NO MATCH FOUND for URL: {url}")
            # Even if no match found, force repaint to ensure playlist displays correctly
            if hasattr(self, 'list_widget') and self.list_widget:
                self.list_widget.viewport().update()
                self.list_widget.update()
    
    def update_item_display(self, url, display_text):
        """Update the display text for a playlist item by URL"""
        if not url or not display_text:
            return
        
        # Normalize the URL for comparison
        normalized_url = self.normalize_url(url)
        url_path = self.get_url_path(url)
        
        # Try to find item by URL match
        for i in range(self.list_widget.count()):
            try:
                item = self.list_widget.item(i)
                if not item:
                    continue
                    
                item_url = item.data(Qt.ItemDataRole.UserRole)
                if not item_url:
                    continue
                
                # Normalize stored URL
                normalized_item_url = self.normalize_url(item_url)
                
                # Also check resolved version of stored URL
                resolved_item_url = self.resolve_url_redirects(item_url) if item_url else None
                normalized_resolved_item_url = self.normalize_url(resolved_item_url) if resolved_item_url else None
                
                # Exact match (highest priority)
                if (normalized_item_url == normalized_url or 
                    (normalized_resolved_item_url and normalized_resolved_item_url == normalized_url)):
                    item.setText(display_text)
                    item.setToolTip(url)
                    logger.debug(f"Updated playlist item display: {url} -> {display_text}")
                    return
                
                # Path-based match (fallback)
                if url_path:
                    item_path = self.get_url_path(item_url)
                    resolved_item_path = self.get_url_path(resolved_item_url) if resolved_item_url else None
                    if (item_path and item_path == url_path) or (resolved_item_path and resolved_item_path == url_path):
                        item.setText(display_text)
                        item.setToolTip(url)
                        logger.debug(f"Updated playlist item display (path match): {url} -> {display_text}")
                        return
            except RuntimeError:
                # Item was deleted during iteration, skip it
                continue

# ============================================================================
# KEYBOARD SHORTCUTS DIALOG
# ============================================================================

class KeyboardShortcutsDialog(QDialog):
    """Dialog for customizing keyboard shortcuts"""
    
    # Default shortcuts
    DEFAULT_SHORTCUTS = {
        "play_pause": "Ctrl+Alt+Space",
        "next_track": "Ctrl+Alt+Right",
        "previous_track": "Ctrl+Alt+Left",
        "next_album": "Ctrl+Shift+Alt+Right",
        "previous_album": "Ctrl+Shift+Alt+Left",
        "volume_up": "Ctrl+Shift+Up",
        "volume_down": "Ctrl+Shift+Down",
        "mute": "Ctrl+Shift+M",
        "toggle_playlist": "Ctrl+Alt+P",
        "toggle_playlist_expand": "Ctrl+Shift+Alt+P",
        "cycle_app_mode": "Ctrl+Alt+M",
        "save_playlist": "Ctrl+S",
    }
    
    def __init__(self, parent=None, current_shortcuts=None):
        super().__init__(parent)
        self.setWindowTitle("Keyboard Shortcuts")
        self.setMinimumSize(600, 500)
        
        # Apply dark theme
        self.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
                color: #e0e0e0;
            }
            QLabel {
                color: #e0e0e0;
            }
            QLineEdit {
                background-color: #1e1e1e;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 4px;
            }
            QLineEdit:focus {
                border: 1px solid #4a90e2;
            }
            QPushButton {
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #4a4a4a;
            }
            QPushButton:pressed {
                background-color: #2a2a2a;
            }
        """)
        
        layout = QVBoxLayout(self)
        
        # Description
        desc_label = QLabel("Customize keyboard shortcuts. Click on a shortcut field and press the desired key combination.")
        desc_label.setWordWrap(True)
        desc_label.setStyleSheet("color: #999; padding: 10px;")
        layout.addWidget(desc_label)
        
        # Shortcuts table
        self.shortcut_widgets = {}
        shortcuts_layout = QVBoxLayout()
        
        # Define shortcuts with labels
        shortcuts_def = [
            ("play_pause", "Play/Pause"),
            ("next_track", "Next Track"),
            ("previous_track", "Previous Track"),
            ("next_album", "Next Album"),
            ("previous_album", "Previous Album"),
            ("volume_up", "Volume Up"),
            ("volume_down", "Volume Down"),
            ("mute", "Mute"),
            ("toggle_playlist", "Toggle Playlist"),
            ("toggle_playlist_expand", "Expand/Collapse Playlist"),
            ("cycle_app_mode", "Cycle App Mode"),
            ("save_playlist", "Save Playlist"),
        ]
        
        for key, label in shortcuts_def:
            row_layout = QHBoxLayout()
            
            # Label
            label_widget = QLabel(label + ":")
            label_widget.setMinimumWidth(150)
            row_layout.addWidget(label_widget)
            
            # Shortcut input
            shortcut_input = QLineEdit()
            shortcut_input.setPlaceholderText("Press keys...")
            shortcut_input.setReadOnly(True)
            shortcut_input.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
            
            # Load current shortcut
            if current_shortcuts and key in current_shortcuts:
                shortcut_input.setText(current_shortcuts[key])
            elif key in self.DEFAULT_SHORTCUTS:
                shortcut_input.setText(self.DEFAULT_SHORTCUTS[key])
            
            # Install event filter to capture key presses
            shortcut_input.installEventFilter(self)
            shortcut_input.setProperty("shortcut_key", key)
            
            row_layout.addWidget(shortcut_input)
            
            # Clear button
            clear_btn = QPushButton("Clear")
            clear_btn.clicked.connect(lambda checked, k=key: self.clear_shortcut(k))
            row_layout.addWidget(clear_btn)
            
            shortcuts_layout.addLayout(row_layout)
            self.shortcut_widgets[key] = shortcut_input
        
        layout.addLayout(shortcuts_layout)
        layout.addStretch()
        
        # Buttons
        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()
        
        reset_btn = QPushButton("Reset to Defaults")
        reset_btn.clicked.connect(self.reset_to_defaults)
        buttons_layout.addWidget(reset_btn)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(cancel_btn)
        
        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self.accept)
        ok_btn.setDefault(True)
        buttons_layout.addWidget(ok_btn)
        
        layout.addLayout(buttons_layout)
        
        self.current_shortcuts = current_shortcuts or {}
    
    def eventFilter(self, obj, event):
        """Capture key presses in shortcut input fields"""
        if event.type() == QEvent.Type.KeyPress:
            key = obj.property("shortcut_key")
            if key:
                # Build key sequence from event
                modifiers = []
                if event.modifiers() & Qt.KeyboardModifier.ControlModifier:
                    modifiers.append("Ctrl")
                if event.modifiers() & Qt.KeyboardModifier.ShiftModifier:
                    modifiers.append("Shift")
                if event.modifiers() & Qt.KeyboardModifier.AltModifier:
                    modifiers.append("Alt")
                if event.modifiers() & Qt.KeyboardModifier.MetaModifier:
                    modifiers.append("Meta")
                
                # Get the key
                key_name = QKeySequence(event.key()).toString()
                if key_name:
                    if modifiers:
                        key_sequence = "+".join(modifiers) + "+" + key_name
                    else:
                        key_sequence = key_name
                    
                    obj.setText(key_sequence)
                    return True  # Consume the event
        
        return super().eventFilter(obj, event)
    
    def clear_shortcut(self, key):
        """Clear a shortcut"""
        if key in self.shortcut_widgets:
            self.shortcut_widgets[key].setText("")
    
    def reset_to_defaults(self):
        """Reset all shortcuts to defaults"""
        for key, widget in self.shortcut_widgets.items():
            if key in self.DEFAULT_SHORTCUTS:
                widget.setText(self.DEFAULT_SHORTCUTS[key])
            else:
                widget.setText("")
    
    def get_shortcuts(self):
        """Get current shortcuts as a dictionary"""
        shortcuts = {}
        for key, widget in self.shortcut_widgets.items():
            text = widget.text().strip()
            if text:
                shortcuts[key] = text
        return shortcuts

# ============================================================================
# MEDIA KEY NATIVE EVENT FILTER
# ============================================================================

class MediaKeyEventFilter(QAbstractNativeEventFilter):
    """Native event filter to intercept WM_APPCOMMAND for next/previous media keys
    Also handles custom Windows messages from AutoHotkey for keyboard shortcuts"""
    
    def __init__(self):
        super().__init__()
        self.media_next_callback = None
        self.media_prev_callback = None
        # Custom Windows messages for AutoHotkey communication (WM_USER + offset)
        # These allow AutoHotkey to trigger actions without window focus
        self.WM_USER = 0x0400
        self.WM_BANDCAMP_NEXT = self.WM_USER + 1
        self.WM_BANDCAMP_PREV = self.WM_USER + 2
        self.WM_BANDCAMP_PLAY_PAUSE = self.WM_USER + 3
    
    def setCallbacks(self, next_callback, prev_callback):
        """Set callbacks for media key events"""
        self.media_next_callback = next_callback
        self.media_prev_callback = prev_callback
    
    def nativeEventFilter(self, eventType, message):
        """Filter native events to catch WM_APPCOMMAND"""
        # Only process Windows messages
        if sys.platform != 'win32' or not _HAS_CTYPES or eventType != b'windows_generic_MSG':
            return False, 0
        
        try:
            import ctypes
            from ctypes import wintypes
            
            # Windows constants
            WM_APPCOMMAND = 0x0319
            APPCOMMAND_MEDIA_NEXT = 11
            APPCOMMAND_MEDIA_PREV = 12
            APPCOMMAND_MEDIA_PLAY_PAUSE = 14
            
            # In PyQt6, message is a pointer to MSG structure
            # We need to cast it carefully - message might be an integer pointer or a ctypes pointer
            try:
                # Try to interpret message as a pointer
                if isinstance(message, int):
                    # It's a pointer address
                    msg_ptr = ctypes.cast(message, ctypes.POINTER(wintypes.MSG))
                else:
                    # It might already be a pointer-like object
                    msg_ptr = ctypes.cast(ctypes.c_void_p(message), ctypes.POINTER(wintypes.MSG))
                
                msg = msg_ptr.contents
            except (ValueError, TypeError, AttributeError, ctypes.ArgumentError):
                # If we can't cast, just pass through (not a message we can handle)
                return False, 0
            
            # Process WM_APPCOMMAND messages (media keys) and WM_COPYDATA (AutoHotkey IPC)
            WM_APPCOMMAND = 0x0319
            WM_COPYDATA = 0x004A
            
            # Handle WM_COPYDATA messages from AutoHotkey (works without focus)
            if msg.message == WM_COPYDATA:
                try:
                    # WM_COPYDATA structure: lParam points to COPYDATASTRUCT
                    # COPYDATASTRUCT: dwData (ULONG_PTR), cbData (DWORD), lpData (PVOID)
                    # ULONG_PTR size depends on architecture (4 bytes on 32-bit, 8 bytes on 64-bit)
                    import struct
                    is_64bit = struct.calcsize("P") == 8
                    
                    if is_64bit:
                        # 64-bit: dwData (8 bytes), cbData (4 bytes), lpData (8 bytes) = 20 bytes
                        class COPYDATASTRUCT(ctypes.Structure):
                            _fields_ = [("dwData", ctypes.c_ulonglong),  # ULONG_PTR on 64-bit
                                       ("cbData", ctypes.c_ulong),        # DWORD
                                       ("lpData", ctypes.c_void_p)]       # PVOID
                    else:
                        # 32-bit: dwData (4 bytes), cbData (4 bytes), lpData (4 bytes) = 12 bytes
                        class COPYDATASTRUCT(ctypes.Structure):
                            _fields_ = [("dwData", ctypes.c_ulong),      # ULONG_PTR on 32-bit
                                       ("cbData", ctypes.c_ulong),        # DWORD
                                       ("lpData", ctypes.c_void_p)]       # PVOID
                    
                    copy_data = ctypes.cast(msg.lParam, ctypes.POINTER(COPYDATASTRUCT)).contents
                    command_id = copy_data.dwData
                    
                    # Command IDs: 1=Next, 2=Prev, 3=PlayPause
                    if command_id == 1:  # Next track
                        logger.info("WM_COPYDATA: Next track from AutoHotkey")
                        if self.media_next_callback:
                            QTimer.singleShot(0, self.media_next_callback)
                            return True, 0  # Handled
                    elif command_id == 2:  # Previous track
                        logger.info("WM_COPYDATA: Previous track from AutoHotkey")
                        if self.media_prev_callback:
                            QTimer.singleShot(0, self.media_prev_callback)
                            return True, 0  # Handled
                    elif command_id == 3:  # Play/Pause
                        logger.debug("WM_COPYDATA: Play/Pause from AutoHotkey")
                        # Could add callback here if needed
                        return False, 0  # Let Qt handle it for now
                except Exception as e:
                    logger.warning(f"Error processing WM_COPYDATA: {e}")
                    import traceback
                    logger.debug(traceback.format_exc())
                    return False, 0
            
            # Only process WM_APPCOMMAND messages
            if msg.message != WM_APPCOMMAND:
                return False, 0
            
            # Extract command from lParam (high word)
            cmd = (msg.lParam >> 16) & 0x7FFF
            logger.info(f"Media key event filter: Received WM_APPCOMMAND, command={cmd} (hwnd={msg.hwnd})")
            
            if cmd == APPCOMMAND_MEDIA_NEXT:
                logger.info("Media key: Next track detected (nativeEventFilter)")
                if self.media_next_callback:
                    # Use QTimer to call in main thread safely
                    QTimer.singleShot(0, self.media_next_callback)
                    return True, 0  # Handled
                else:
                    logger.warning("Media key: Next callback not set!")
            elif cmd == APPCOMMAND_MEDIA_PREV:
                logger.info("Media key: Previous track detected (nativeEventFilter)")
                if self.media_prev_callback:
                    # Use QTimer to call in main thread safely
                    QTimer.singleShot(0, self.media_prev_callback)
                    return True, 0  # Handled
                else:
                    logger.warning("Media key: Previous callback not set!")
            elif cmd == APPCOMMAND_MEDIA_PLAY_PAUSE:
                # Let Qt handle play/pause (don't intercept)
                logger.debug(f"Media key: Play/Pause detected (letting Qt handle it)")
            
        except Exception as e:
            # Only log unexpected errors (not casting errors which are normal)
            if "cast" not in str(e).lower() and "argument" not in str(e).lower():
                logger.warning(f"Error in nativeEventFilter: {e}")
        
        # Let Qt handle everything else (including play/pause)
        return False, 0

# ============================================================================
# MEDIA KEY LISTENER THREAD (fallback - kept for compatibility)
# ============================================================================

class MediaKeyListenerThread(QThread):
    """Thread to listen for media keys using a Windows message-only window (safer than nativeEvent)"""
    media_next = pyqtSignal()
    media_prev = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.running = True
        self.hwnd = None
    
    def run(self):
        """Run the media key listener using a Windows message-only window"""
        if sys.platform != 'win32' or not _HAS_CTYPES:
            logger.info("Media key listener: Not on Windows or ctypes unavailable, skipping")
            return
        
        try:
            import ctypes
            from ctypes import wintypes
            
            # Windows constants
            WM_APPCOMMAND = 0x0319
            APPCOMMAND_MEDIA_NEXT = 11
            APPCOMMAND_MEDIA_PREV = 12
            HWND_MESSAGE = -3  # Message-only window
            
            # Windows API functions
            user32 = ctypes.windll.user32
            
            # Window class name
            class_name = "BandcampPlayerMediaKeyWindow"
            
            # Define WNDPROC callback
            WNDPROC = ctypes.WINFUNCTYPE(
                wintypes.LPARAM,  # Return type
                wintypes.HWND,    # hwnd
                wintypes.UINT,    # uMsg
                wintypes.WPARAM,  # wParam
                wintypes.LPARAM   # lParam
            )
            
            def window_proc(hwnd, uMsg, wParam, lParam):
                """Window procedure to handle WM_APPCOMMAND"""
                if uMsg == WM_APPCOMMAND:
                    # Extract command from lParam (high word)
                    cmd = (lParam >> 16) & 0x7FFF
                    
                    if cmd == APPCOMMAND_MEDIA_NEXT:
                        logger.info("Media key: Next track detected (message window)")
                        self.media_next.emit()
                        return 1  # Handled
                    elif cmd == APPCOMMAND_MEDIA_PREV:
                        logger.info("Media key: Previous track detected (message window)")
                        self.media_prev.emit()
                        return 1  # Handled
                
                # Default window procedure
                return user32.DefWindowProcW(hwnd, uMsg, wParam, lParam)
            
            # Create window procedure
            wnd_proc = WNDPROC(window_proc)
            
            # Register window class
            wc = wintypes.WNDCLASSW()
            wc.lpfnWndProc = wnd_proc
            wc.lpszClassName = class_name
            wc.hInstance = ctypes.windll.kernel32.GetModuleHandleW(None)
            
            atom = user32.RegisterClassW(ctypes.byref(wc))
            if not atom:
                logger.warning("Failed to register window class for media keys")
                return
            
            # Create message-only window
            self.hwnd = user32.CreateWindowExW(
                0,  # dwExStyle
                class_name,
                None,  # Window name
                0,  # dwStyle
                0, 0, 0, 0,  # x, y, width, height
                HWND_MESSAGE,  # hWndParent (message-only)
                None,  # hMenu
                wc.hInstance,
                None  # lpParam
            )
            
            if not self.hwnd:
                logger.warning("Failed to create message-only window for media keys")
                user32.UnregisterClassW(class_name, wc.hInstance)
                return
            
            logger.info("Message-only window created for media key detection")
            
            # Message loop
            msg = wintypes.MSG()
            bRet = wintypes.BOOL()
            while self.running:
                bRet = user32.GetMessageW(ctypes.byref(msg), None, 0, 0)
                if bRet == 0:  # WM_QUIT
                    break
                elif bRet == -1:  # Error
                    logger.warning("GetMessage error in media key window")
                    break
                else:
                    user32.TranslateMessage(ctypes.byref(msg))
                    user32.DispatchMessageW(ctypes.byref(msg))
            
            # Cleanup
            if self.hwnd:
                user32.DestroyWindow(self.hwnd)
                self.hwnd = None
            user32.UnregisterClassW(class_name, wc.hInstance)
            
        except Exception as e:
            logger.warning(f"Media key listener error: {e}")
            import traceback
            logger.warning(traceback.format_exc())
    
    def stop(self):
        """Stop the listener thread"""
        self.running = False
        # Post a quit message to break the message loop
        if sys.platform == 'win32' and self.hwnd:
            try:
                import ctypes
                from ctypes import wintypes
                user32 = ctypes.windll.user32
                user32.PostQuitMessage(0)
            except Exception:
                pass
        self.quit()
        self.wait()

# ============================================================================
# QT-BASED PLAYER WIDGETS (Regular/Mini/Micro Modes)
# ============================================================================

class ClickableCoverArtLabel(QLabel):
    """QLabel for cover art display (no longer clickable - use image viewer button instead)."""
    # Note: Keeping the class name for backward compatibility, but it's now just a regular QLabel
    pass

class ZoomableImageViewer(QLabel):
    """QLabel with pan and zoom functionality for image viewer."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._original_pixmap = None
        self._zoom_factor = 1.0
        self._base_zoom_factor = 1.0  # Initial zoom to fill frame
        self._pan_offset = QPoint(0, 0)
        self._last_pan_point = None
        self._is_panning = False
        self._min_zoom = 1.0  # Minimum zoom is the fill size (can't zoom out)
        self._max_zoom = 5.0  # Can zoom in to 500%
        self._zoom_level = 1  # Current zoom level (1-5)
        self._click_start_pos = None  # Track click position to distinguish click from drag
        self._drag_threshold = 5  # Pixels to move before considering it a drag
        self._pan_delay_timer = None  # Timer to delay panning activation
        self._pan_delay_ms = 150  # Delay before enabling panning (ms)
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setMouseTracking(True)  # Track mouse for panning
        
    def setPixmap(self, pixmap):
        """Set the original pixmap and calculate initial fill zoom."""
        self._original_pixmap = pixmap
        # Calculate zoom factor to fill the current label size
        self._calculate_fill_zoom()
        self._zoom_factor = self._base_zoom_factor
        self._zoom_level = 1  # Reset to level 1 (fill)
        self._pan_offset = QPoint(0, 0)
        self._min_zoom = self._base_zoom_factor  # Can't zoom out below fill size
        self._update_display()
    
    def _calculate_fill_zoom(self):
        """Calculate zoom factor to fill the label while maintaining aspect ratio.
        In fullscreen mode: landscape uses 100% height, portrait uses 100% width."""
        if not self._original_pixmap or self._original_pixmap.isNull():
            self._base_zoom_factor = 1.0
            return
        
        label_size = self.size()
        if label_size.width() <= 0 or label_size.height() <= 0:
            # If label not sized yet, use pixmap size as base
            self._base_zoom_factor = 1.0
            return
        
        pixmap_size = self._original_pixmap.size()
        
        # Calculate scale factors for both dimensions
        scale_x = label_size.width() / pixmap_size.width()
        scale_y = label_size.height() / pixmap_size.height()
        
        # Check if we're in fullscreen mode by comparing label size to screen size
        is_fullscreen = False
        if hasattr(self, '_screen_ref') and self._screen_ref:
            screen_geometry = self._screen_ref.availableGeometry()
            screen_size = screen_geometry.size()
            # Consider fullscreen if label size is very close to screen size (within 10px margin)
            width_match = abs(label_size.width() - screen_size.width()) < 10
            height_match = abs(label_size.height() - screen_size.height()) < 10
            is_fullscreen = width_match and height_match
        
        if is_fullscreen:
            # Fullscreen mode: fill height in landscape, fill width in portrait
            label_is_landscape = label_size.width() > label_size.height()
            if label_is_landscape:
                # Landscape: fill height (100% of height) - black bars on sides
                self._base_zoom_factor = scale_y
            else:
                # Portrait: fill width (100% of width) - black bars on top/bottom
                self._base_zoom_factor = scale_x
        else:
            # Normal mode: use the larger scale to fill the frame (cover mode)
            self._base_zoom_factor = max(scale_x, scale_y)
    
    def _update_display(self):
        """Update the displayed pixmap based on current zoom and pan."""
        if not self._original_pixmap or self._original_pixmap.isNull():
            super().setPixmap(QPixmap())
            return
        
        # Recalculate fill zoom if label size changed
        label_size = self.size()
        if label_size.width() > 0 and label_size.height() > 0:
            old_base_zoom = self._base_zoom_factor
            self._calculate_fill_zoom()
            # Adjust current zoom proportionally if base zoom changed
            if old_base_zoom > 0 and self._base_zoom_factor != old_base_zoom:
                zoom_ratio = self._zoom_factor / old_base_zoom
                self._zoom_factor = self._base_zoom_factor * zoom_ratio
                self._min_zoom = self._base_zoom_factor
        
        # Ensure zoom is at least the minimum (fill size)
        if self._zoom_factor < self._min_zoom:
            self._zoom_factor = self._min_zoom
            self._pan_offset = QPoint(0, 0)  # Reset pan when at minimum zoom
        
        # Calculate scaled size
        scaled_size = QSize(
            int(self._original_pixmap.width() * self._zoom_factor),
            int(self._original_pixmap.height() * self._zoom_factor)
        )
        
        # Scale the pixmap
        scaled_pixmap = self._original_pixmap.scaled(
            scaled_size,
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation
        )
        
        # Create a pixmap the size of the label
        if label_size.width() <= 0 or label_size.height() <= 0:
            label_size = scaled_pixmap.size()
        
        display_pixmap = QPixmap(label_size)
        display_pixmap.fill(Qt.GlobalColor.black)  # Black background
        
        # Calculate position to draw scaled image (centered + pan offset)
        painter = QPainter(display_pixmap)
        painter.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)
        
        # Check if we're in fullscreen mode
        is_fullscreen = False
        if hasattr(self, '_screen_ref') and self._screen_ref:
            screen_geometry = self._screen_ref.availableGeometry()
            screen_size = screen_geometry.size()
            width_match = abs(label_size.width() - screen_size.width()) < 10
            height_match = abs(label_size.height() - screen_size.height()) < 10
            is_fullscreen = width_match and height_match
        
        # Calculate centered position
        center_x = (label_size.width() - scaled_pixmap.width()) // 2
        center_y = (label_size.height() - scaled_pixmap.height()) // 2
        
        # In fullscreen mode at minimum zoom, center the image (reset pan offset)
        if is_fullscreen and self._zoom_factor == self._min_zoom:
            # Reset pan offset to center the image when at minimum zoom in fullscreen
            self._pan_offset = QPoint(0, 0)
            x = center_x
            y = center_y
        else:
            # Apply pan offset for normal panning
            x = center_x + self._pan_offset.x()
            y = center_y + self._pan_offset.y()
            
            # Constrain panning to keep image visible
            x = max(min(x, 0), label_size.width() - scaled_pixmap.width())
            y = max(min(y, 0), label_size.height() - scaled_pixmap.height())
            
            # Update pan offset to constrained values
            self._pan_offset = QPoint(x - center_x, y - center_y)
        
        painter.drawPixmap(x, y, scaled_pixmap)
        painter.end()
        
        super().setPixmap(display_pixmap)
    
    def wheelEvent(self, event):
        """Handle mouse wheel for zooming (only zoom in, not out below fill size)."""
        if not self._original_pixmap or self._original_pixmap.isNull():
            return
        
        # Get mouse position relative to the label
        mouse_pos = event.position().toPoint()
        
        # Calculate zoom delta (scroll up = zoom in, scroll down = zoom out)
        zoom_delta = event.angleDelta().y() / 120.0  # Normalize to 1.0 per click
        zoom_speed = 0.1  # 10% per scroll step
        new_zoom = self._zoom_factor * (1.0 + zoom_delta * zoom_speed)
        
        # Clamp zoom factor (can't zoom out below fill size)
        old_zoom = self._zoom_factor
        self._zoom_factor = max(self._min_zoom, min(self._max_zoom, new_zoom))
        
        # If we hit the minimum zoom, reset pan
        if self._zoom_factor == self._min_zoom:
            self._pan_offset = QPoint(0, 0)
        
        if self._zoom_factor != old_zoom:
            # Zoom towards mouse position
            # Calculate the point in the original image that the mouse is over
            label_center = QPoint(self.width() // 2, self.height() // 2)
            mouse_offset = mouse_pos - label_center
            
            # Adjust pan offset to zoom towards mouse position
            zoom_ratio = self._zoom_factor / old_zoom
            self._pan_offset = QPoint(
                int((self._pan_offset.x() - mouse_offset.x()) * zoom_ratio + mouse_offset.x()),
                int((self._pan_offset.y() - mouse_offset.y()) * zoom_ratio + mouse_offset.y())
            )
            
            self._update_display()
    
    def mousePressEvent(self, event):
        """Handle mouse press for panning or zoom cycling."""
        if event.button() == Qt.MouseButton.LeftButton:
            # Track click position to distinguish click from drag
            self._click_start_pos = event.position().toPoint()
            self._is_panning = False  # Will be set to True if mouse moves after delay
            self._last_pan_point = event.position().toPoint()
            
            # Cancel any existing pan delay timer
            if self._pan_delay_timer:
                self._pan_delay_timer.stop()
            
            # Start a timer to enable panning after a delay
            # This allows quick clicks to trigger zoom without interference
            self._pan_delay_timer = QTimer(self)
            self._pan_delay_timer.setSingleShot(True)
            self._pan_delay_timer.timeout.connect(lambda: self._enable_panning())
            self._pan_delay_timer.start(self._pan_delay_ms)
            
            self.setCursor(Qt.CursorShape.ClosedHandCursor)
    
    def _enable_panning(self):
        """Enable panning after delay - only if mouse is still pressed and has moved."""
        if self._click_start_pos is not None and self._last_pan_point is not None:
            # Check if mouse moved enough to be considered a drag
            current_pos = self.mapFromGlobal(QCursor.pos())
            move_distance = (current_pos - self._click_start_pos).manhattanLength()
            if move_distance > self._drag_threshold:
                self._is_panning = True
                self._last_pan_point = current_pos
    
    def mouseMoveEvent(self, event):
        """Handle mouse move for panning."""
        if self._click_start_pos is not None:
            # Check if mouse moved enough to be considered a drag
            current_pos = event.position().toPoint()
            move_distance = (current_pos - self._click_start_pos).manhattanLength()
            # If moved significantly before delay timer fires, enable panning immediately
            if move_distance > self._drag_threshold * 2:  # Larger threshold for immediate activation
                if self._pan_delay_timer:
                    self._pan_delay_timer.stop()
                self._is_panning = True
        
        if self._is_panning and self._last_pan_point:
            current_pos = event.position().toPoint()
            delta = current_pos - self._last_pan_point
            self._pan_offset += delta
            self._last_pan_point = current_pos
            self._update_display()
    
    def mouseReleaseEvent(self, event):
        """Handle mouse release to stop panning or cycle zoom."""
        if event.button() == Qt.MouseButton.LeftButton:
            # Cancel pan delay timer if still running
            if self._pan_delay_timer:
                self._pan_delay_timer.stop()
                self._pan_delay_timer = None
            
            # If it was a click (not a drag), cycle zoom
            if not self._is_panning and self._click_start_pos is not None:
                self._cycle_zoom_level()
            
            self._is_panning = False
            self._last_pan_point = None
            self._click_start_pos = None
            self.setCursor(Qt.CursorShape.ArrowCursor)
    
    def resizeEvent(self, event):
        """Handle resize to update display."""
        super().resizeEvent(event)
        self._update_display()
    
    def _cycle_zoom_level(self):
        """Cycle through 5 zoom levels on left-click."""
        if not self._original_pixmap or self._original_pixmap.isNull():
            return
        
        # Define 5 zoom levels as multiples of base zoom
        zoom_levels = [
            1.0,    # Level 1: Fill (base zoom)
            1.5,    # Level 2: 1.5x
            2.0,    # Level 3: 2x
            3.0,    # Level 4: 3x
            5.0     # Level 5: 5x (max zoom)
        ]
        
        # Calculate what zoom levels would be in absolute terms
        absolute_zoom_levels = [self._base_zoom_factor * level for level in zoom_levels]
        
        # Find which zoom level the current zoom is closest to
        current_zoom = self._zoom_factor
        closest_level = 1
        min_diff = abs(current_zoom - absolute_zoom_levels[0])
        
        for i, level_zoom in enumerate(absolute_zoom_levels):
            diff = abs(current_zoom - level_zoom)
            if diff < min_diff:
                min_diff = diff
                closest_level = i + 1
        
        # If current zoom is between levels, check if we're closer to the next level
        # Use a threshold (10% of the gap between levels) to determine if we should advance
        if closest_level < 5:
            next_level_zoom = absolute_zoom_levels[closest_level]  # Next level (0-indexed)
            gap = next_level_zoom - absolute_zoom_levels[closest_level - 1]
            threshold = absolute_zoom_levels[closest_level - 1] + (gap * 0.1)
            
            # If we're past the threshold, consider ourselves at the next level
            if current_zoom >= threshold:
                closest_level = closest_level + 1
        
        # Cycle to next level from the closest one
        self._zoom_level = (closest_level % 5) + 1
        
        # Calculate new zoom factor
        new_zoom = self._base_zoom_factor * zoom_levels[self._zoom_level - 1]
        
        # Get mouse position for zooming towards it
        mouse_pos = self.mapFromGlobal(QCursor.pos())
        label_center = QPoint(self.width() // 2, self.height() // 2)
        mouse_offset = mouse_pos - label_center
        
        # Adjust pan offset to zoom towards mouse position
        old_zoom = self._zoom_factor
        self._zoom_factor = new_zoom
        
        if old_zoom > 0:
            zoom_ratio = self._zoom_factor / old_zoom
            self._pan_offset = QPoint(
                int((self._pan_offset.x() - mouse_offset.x()) * zoom_ratio + mouse_offset.x()),
                int((self._pan_offset.y() - mouse_offset.y()) * zoom_ratio + mouse_offset.y())
            )
        
        # Reset pan if at level 1 (fill)
        if self._zoom_level == 1:
            self._pan_offset = QPoint(0, 0)
        
        self._update_display()
    
    def reset_view(self):
        """Reset zoom and pan to default (fill frame)."""
        self._zoom_level = 1
        self._zoom_factor = self._base_zoom_factor
        self._pan_offset = QPoint(0, 0)
        self._update_display()

class BasePlayerWidget(QWidget):
    """Base class for Qt-based player widgets with shared functionality."""
    
    def __init__(self, parent_window):
        super().__init__()
        self.parent_window = parent_window
        
        # Network manager for loading cover art images
        self.network_manager = QNetworkAccessManager(self)
        self.network_manager.finished.connect(self._on_cover_art_loaded)
        
        # Track current cover art URL to avoid reloading same image
        self._current_cover_art_url = None
        
        # Store current track and album info
        self._current_track_number = None
        self._current_album_name = None
        
        # Buffering state
        self._is_buffering = False
        
        # Cache button widths to avoid unnecessary updates
        self._cached_album_button_width = None
        self._cached_track_button_width = None
        
        # Setup update timer for playback state
        self._update_timer = QTimer(self)
        self._update_timer.timeout.connect(self._update_playback_state)
        self._update_timer.setInterval(200)  # Update every 200ms
        
        # Initialize UI (to be implemented by subclasses)
        self.setup_ui()
        
        # Start update timer
        self._update_timer.start()
    
    @staticmethod
    def _detect_windows_11():
        """Detect if running on Windows 11 (build 22000 or higher)."""
        is_windows_11 = False
        if sys.platform == 'win32':
            try:
                import platform
                # Windows 11 is build 22000 or higher
                version_info = platform.version()
                # Extract build number from version string (e.g., "10.0.22000")
                try:
                    build_num = int(version_info.split('.')[-1])
                    is_windows_11 = build_num >= 22000
                except (ValueError, IndexError):
                    # Fallback: check via sys.getwindowsversion() if available
                    if hasattr(sys, 'getwindowsversion'):
                        win_ver = sys.getwindowsversion()
                        is_windows_11 = win_ver.build >= 22000
            except Exception:
                pass
        return is_windows_11
    
    def _update_album_button_width(self):
        """Update album button width to fit text content."""
        if not hasattr(self, 'album_menu_btn') or not self.album_menu_btn:
            return
        
        # Skip updates for image viewer buttons (they should maintain full width)
        if hasattr(self, '_image_viewer_album_btn') and self.album_menu_btn == self._image_viewer_album_btn:
            return
        
        # Skip updates if page is loading to avoid interfering with page load
        if self.parent_window and hasattr(self.parent_window, 'is_loading') and self.parent_window.is_loading:
            return
        
        text = self.album_menu_btn.text()
        # Ensure font is set correctly before calculating metrics (important for Windows 10)
        font = self.album_menu_btn.font()
        font.setPixelSize(11)  # Match the font size used in paint event
        font_metrics = QFontMetrics(font)
        text_width = font_metrics.horizontalAdvance(text)
        
        # Detect Windows 11 to adjust max width
        is_windows_11 = self._detect_windows_11()
        
        # Add padding: left 4px + right 15px (to match text_rect margins for truncation)
        button_width = text_width + 4 + 15
        
        # Try to get actual available width from parent layout on Windows 10
        # This might be more accurate than a fixed max
        if not is_windows_11:
            # On Windows 10, try to calculate based on actual available space
            parent_widget = self.album_menu_btn.parent()
            if parent_widget:
                parent_width = parent_widget.width()
                if parent_width > 0:
                    # Use most of the parent width (account for stretches and margins)
                    calculated_max = parent_width - 20  # 20px for margins/safety
                    # Use the larger of calculated max or fixed max
                    max_button_width = max(calculated_max, 250)
                else:
                    max_button_width = 250
            else:
                max_button_width = 250
        else:
            max_button_width = 225  # Windows 11: works perfectly with 225px
        
        button_width = min(button_width, max_button_width)
        # Ensure minimum width
        button_width = max(button_width, 80)
        
        # Debug logging (can be removed later)
        # print(f"[DEBUG Album Button] Text: '{text[:30]}...', Text width: {text_width}, Button width: {button_width}, Max: {max_button_width}, Windows 11: {is_windows_11}")
        
        # Only update if width has changed to avoid unnecessary layout recalculations
        if button_width != self._cached_album_button_width:
            self._cached_album_button_width = button_width
            self.album_menu_btn.setFixedWidth(button_width)
            # Only call updateGeometry if width actually changed
            if hasattr(self.album_menu_btn, 'updateGeometry'):
                self.album_menu_btn.updateGeometry()
            # Update tooltip after width is set (use QTimer to ensure layout is updated)
            QTimer.singleShot(0, lambda: self._update_button_tooltip(self.album_menu_btn, self.album_menu_btn.text()))
    
    def _update_button_tooltip(self, button, full_text):
        """Update button tooltip to show full text if it would be truncated."""
        if not button or not full_text:
            return
        
        try:
            # Get the button's current geometry and font
            font = button.font()
            
            # Determine font size and text rect based on button type
            # Check if this is an image viewer button (different styling)
            is_image_viewer = (hasattr(self, '_image_viewer_album_btn') and button == self._image_viewer_album_btn) or \
                             (hasattr(self, '_image_viewer_track_btn') and button == self._image_viewer_track_btn)
            
            if is_image_viewer:
                # Image viewer buttons use 12px font and 15px left/right padding
                font.setPixelSize(12)
                text_rect = button.rect().adjusted(15, 2, -15, -2)
            else:
                # Regular mode buttons use 11px font and different padding
                font.setPixelSize(11)
                is_windows_11 = self._detect_windows_11()
                right_margin = 10 if not is_windows_11 else 15
                # Check if it's track button (different bottom margin)
                is_track_btn = (hasattr(self, 'track_menu_btn') and button == self.track_menu_btn)
                bottom_margin = 8 if is_track_btn else 4
                text_rect = button.rect().adjusted(4, 4, -right_margin, -bottom_margin)
            
            # Check if text would be truncated
            font_metrics = QFontMetrics(font)
            text_width = font_metrics.horizontalAdvance(full_text)
            available_width = text_rect.width()
            
            # Also check using elided text (more reliable)
            elided_text = font_metrics.elidedText(full_text, Qt.TextElideMode.ElideRight, available_width)
            would_be_truncated = (elided_text != full_text) or (text_width > available_width)
            
            # Set tooltip to full text if truncated, otherwise clear it (use default tooltip)
            if would_be_truncated:
                button.setToolTip(full_text)
            else:
                # Restore default tooltip based on button type
                if hasattr(self, 'album_menu_btn') and button == self.album_menu_btn:
                    button.setToolTip("Select Album")
                elif hasattr(self, 'track_menu_btn') and button == self.track_menu_btn:
                    button.setToolTip("Select Track")
                elif is_image_viewer:
                    if hasattr(self, '_image_viewer_album_btn') and button == self._image_viewer_album_btn:
                        button.setToolTip("Album List")
                    elif hasattr(self, '_image_viewer_track_btn') and button == self._image_viewer_track_btn:
                        button.setToolTip("Track List")
        except Exception as e:
            # Silently fail - tooltip is not critical
            logger.debug(f"_update_button_tooltip: Error updating tooltip: {e}")
    
    def _update_track_button_width(self):
        """Update track button width to fit text content."""
        if not hasattr(self, 'track_menu_btn') or not self.track_menu_btn:
            return
        
        # Skip updates for image viewer buttons (they should maintain full width)
        if hasattr(self, '_image_viewer_track_btn') and self.track_menu_btn == self._image_viewer_track_btn:
            return
        
        # Skip updates if page is loading to avoid interfering with page load
        if self.parent_window and hasattr(self.parent_window, 'is_loading') and self.parent_window.is_loading:
            return
        
        text = self.track_menu_btn.text()
        # Ensure font is set correctly before calculating metrics (important for Windows 10)
        font = self.track_menu_btn.font()
        font.setPixelSize(11)  # Match the font size used in paint event
        font_metrics = QFontMetrics(font)
        text_width = font_metrics.horizontalAdvance(text)
        
        # Detect Windows 11 to adjust max width
        is_windows_11 = self._detect_windows_11()
        
        # Add padding: left 4px + right 15px (to match text_rect margins for truncation)
        button_width = text_width + 4 + 15
        
        # Try to get actual available width from parent layout on Windows 10
        # This might be more accurate than a fixed max
        if not is_windows_11:
            # On Windows 10, try to calculate based on actual available space
            parent_widget = self.track_menu_btn.parent()
            if parent_widget:
                parent_width = parent_widget.width()
                if parent_width > 0:
                    # Use most of the parent width (account for stretches and margins)
                    calculated_max = parent_width - 20  # 20px for margins/safety
                    # Use the larger of calculated max or fixed max
                    max_button_width = max(calculated_max, 250)
                else:
                    max_button_width = 250
            else:
                max_button_width = 250
        else:
            max_button_width = 225  # Windows 11: works perfectly with 225px
        
        button_width = min(button_width, max_button_width)
        # Ensure minimum width
        button_width = max(button_width, 80)
        
        # Debug logging (can be removed later)
        # print(f"[DEBUG Track Button] Text: '{text[:30]}...', Text width: {text_width}, Button width: {button_width}, Max: {max_button_width}, Windows 11: {is_windows_11}")
        
        # Always update width when text changes (clear cache to force recalculation)
        # This ensures shorter text doesn't get stuck with a width calculated for longer text
        if text != getattr(self, '_last_track_button_text', ''):
            self._last_track_button_text = text
            # Clear cached width to force recalculation
            self._cached_track_button_width = 0
        
        # Update if width has changed or if we cleared the cache
        if button_width != self._cached_track_button_width:
            self._cached_track_button_width = button_width
            self.track_menu_btn.setFixedWidth(button_width)
            # Only call updateGeometry if width actually changed
            if hasattr(self.track_menu_btn, 'updateGeometry'):
                self.track_menu_btn.updateGeometry()
            # Update tooltip after width is set (use QTimer to ensure layout is updated)
            QTimer.singleShot(0, lambda: self._update_button_tooltip(self.track_menu_btn, self.track_menu_btn.text()))
    
    def showEvent(self, event):
        """Handle widget show event - update button widths after layout is ready."""
        super().showEvent(event)
        # Update button widths after a short delay to ensure layout is fully calculated
        # This fixes the issue where buttons appear squished on first launch
        QTimer.singleShot(50, self._update_button_widths_on_show)
    
    def _update_button_widths_on_show(self):
        """Update button widths when widget is shown (called from showEvent)."""
        # Update track button width if it exists
        if hasattr(self, 'track_menu_btn') and self.track_menu_btn:
            self._update_track_button_width()
        # Update album button width if it exists
        if hasattr(self, 'album_menu_btn') and self.album_menu_btn:
            self._update_album_button_width()
        # Force layout activation to ensure proper spacing calculation
        # This fixes the issue where buttons appear squished on first launch
        layout = self.layout()
        if layout:
            layout.activate()
        # On Windows 10, sometimes the width calculation needs a second pass after layout is fully calculated
        # Re-update button widths after a short delay to ensure accurate width calculation
        QTimer.singleShot(100, lambda: (
            self._update_track_button_width() if hasattr(self, 'track_menu_btn') and self.track_menu_btn else None,
            self._update_album_button_width() if hasattr(self, 'album_menu_btn') and self.album_menu_btn else None
        ))
    
    def _update_buffering_state(self, is_buffering):
        """Update buffering animation on play button."""
        if not hasattr(self, 'play_pause_btn'):
            return
        
        # Only update if state changed to avoid unnecessary updates
        if is_buffering != self._is_buffering:
            self._is_buffering = is_buffering
            # Use set_buffering method if it's an AnimatedPlayButton
            if isinstance(self.play_pause_btn, AnimatedPlayButton):
                self.play_pause_btn.set_buffering(is_buffering)
            
            # Also update image viewer play button if it exists
            if hasattr(self, 'parent_window') and self.parent_window:
                if hasattr(self.parent_window, '_image_viewer_controls'):
                    image_viewer_controls = self.parent_window._image_viewer_controls
                    if 'play_pause_btn' in image_viewer_controls:
                        image_viewer_play_btn = image_viewer_controls['play_pause_btn']
                        if isinstance(image_viewer_play_btn, AnimatedPlayButton):
                            image_viewer_play_btn.set_buffering(is_buffering)
    
    def setup_ui(self):
        """Setup UI - to be implemented by subclasses."""
        raise NotImplementedError("Subclasses must implement setup_ui()")
    
    def _apply_button_glow_effect(self, button):
        """Apply glow effect to button on hover using graphics effect."""
        if not button:
            return
        
        # Create drop shadow effect for glow
        glow_effect = QGraphicsDropShadowEffect()
        glow_effect.setBlurRadius(8)
        glow_effect.setColor(QColor(74, 144, 226, 0))  # Transparent by default
        glow_effect.setOffset(0, 0)
        button.setGraphicsEffect(glow_effect)
        
        # Store reference to effect for hover state changes
        button._glow_effect = glow_effect
        
        # Install event filter to detect hover state
        class ButtonHoverFilter(QObject):
            def __init__(self, btn, effect):
                super().__init__()
                self.button = btn
                self.effect = effect
            
            def eventFilter(self, obj, event):
                if obj == self.button:
                    if event.type() == QEvent.Type.Enter:
                        # Show glow on hover
                        self.effect.setColor(QColor(74, 144, 226, 120))  # Blue glow
                    elif event.type() == QEvent.Type.Leave:
                        # Hide glow when not hovering
                        self.effect.setColor(QColor(74, 144, 226, 0))  # Transparent
                return super().eventFilter(obj, event)
        
        hover_filter = ButtonHoverFilter(button, glow_effect)
        button.installEventFilter(hover_filter)
        button._hover_filter = hover_filter  # Keep reference
    
    def setup_player_controls(self, layout):
        """Setup player controls - 4 rows: Albumlist, Tracklist, Playback controls, Progress bar with time labels."""
        # Button style (matches nano mode)
        # Updated hover states for transparent player: transparent background with glow effect
        button_style = """
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 11px;
                padding: 2px;
                outline: none;
            }
            QPushButton:hover {
                background-color: transparent;
                border: 1px solid rgba(74, 144, 226, 0.4);
                border-radius: 3px;
            }
            QPushButton:focus {
                outline: none;
            }
            QPushButton:focus:hover {
                background-color: transparent;
                border: 1px solid rgba(74, 144, 226, 0.4);
                border-radius: 3px;
            }
            QPushButton:pressed {
                outline: none;
                border: 1px solid rgba(74, 144, 226, 0.6);
                border-radius: 3px;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: transparent;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
            QPushButton:checked:hover {
                color: #4a90e2;
                background-color: transparent;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """
        
        # Row 1: Albumlist button (centered)
        albumlist_row = QHBoxLayout()
        albumlist_row.setSpacing(0)
        albumlist_row.setContentsMargins(0, 0, 0, 0)
        albumlist_row.addStretch(1)
        
        # Album menu button
        self.album_menu_btn = QPushButton()
        self.album_menu_btn.setText("Albumlist")
        self.album_menu_btn.setToolTip("Select Album")
        self.album_menu_btn.setMinimumWidth(80)
        # Size policy is Fixed - width will be dynamically updated based on text content
        self.album_menu_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        album_btn_style = button_style + """
            QPushButton {
                text-align: left;
                padding: 2px;
                font-size: 11px;
                margin-bottom: 4px;
            }
        """
        self.album_menu_btn.setStyleSheet(album_btn_style)
        self._apply_button_glow_effect(self.album_menu_btn)
        # Create a custom paint event that clips text cleanly without elision (left-aligned, overflows to right)
        def paint_album_with_clipping(event):
            painter = QPainter(self.album_menu_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            option = QStyleOptionButton()
            self.album_menu_btn.initStyleOption(option)
            # Draw button background and bevel
            self.album_menu_btn.style().drawControl(QStyle.ControlElement.CE_PushButtonBevel, option, painter, self.album_menu_btn)
            # Clip to button rectangle to hide overflow cleanly
            painter.setClipRect(self.album_menu_btn.rect())
            # Draw text with elision - adjust for uniform padding (2px) but position text as before
            # Original was: 4px left, 4px top/bottom. Now with 2px padding, add 2px to left and top/bottom
            # Use -10px right margin on Windows 10 to allow more text (Windows 11 can use -15px)
            is_windows_11 = self._detect_windows_11()
            right_margin = 10 if not is_windows_11 else 15  # Less margin on Windows 10 for more text space
            text_rect = self.album_menu_btn.rect().adjusted(4, 4, -right_margin, -4)  # Left 4px, right margin varies, top/bottom 4px
            text = self.album_menu_btn.text()
            font = self.album_menu_btn.font()
            font.setPixelSize(11)  # Match time label font size
            painter.setFont(font)
            painter.setPen(QColor("#e0e0e0"))
            # Elide text if it's too long (shows "..." when truncated)
            font_metrics = QFontMetrics(font)
            elided_text = font_metrics.elidedText(text, Qt.TextElideMode.ElideRight, text_rect.width())
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)
        self.album_menu_btn.paintEvent = paint_album_with_clipping
        self.album_menu_btn.clicked.connect(self._show_album_menu)
        self.album_menu_btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.album_menu_btn.customContextMenuRequested.connect(self._show_album_context_menu)
        albumlist_row.addWidget(self.album_menu_btn, 0)
        albumlist_row.addStretch(1)
        layout.addLayout(albumlist_row)
        
        # Row 2: Tracklist button (centered)
        tracklist_row = QHBoxLayout()
        tracklist_row.setSpacing(0)
        tracklist_row.setContentsMargins(0, 0, 0, 0)
        tracklist_row.addStretch(1)
        
        # Track menu button
        self.track_menu_btn = QPushButton()
        self.track_menu_btn.setText("Tracklist")
        self.track_menu_btn.setToolTip("Select Track")
        self.track_menu_btn.setMinimumWidth(80)
        # Size policy is Fixed - width will be dynamically updated based on text content
        self.track_menu_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.track_menu_btn.setStyleSheet(button_style + """
            QPushButton {
                text-align: left;
                padding: 2px;
                font-size: 11px;
                margin-bottom: 8px;
            }
        """)
        self._apply_button_glow_effect(self.track_menu_btn)
        # Create a custom paint event that clips text cleanly without elision (left-aligned, overflows to right)
        def paint_track_with_clipping(event):
            painter = QPainter(self.track_menu_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            option = QStyleOptionButton()
            self.track_menu_btn.initStyleOption(option)
            # Draw button background and bevel
            self.track_menu_btn.style().drawControl(QStyle.ControlElement.CE_PushButtonBevel, option, painter, self.track_menu_btn)
            # Clip to button rectangle to hide overflow cleanly
            painter.setClipRect(self.track_menu_btn.rect())
            # Draw text with elision - adjust for uniform padding (2px) but position text as before
            # Original was: 4px left, 4px top, 8px bottom. Now with 2px padding, keep same text position
            # Use -10px right margin on Windows 10 to allow more text (Windows 11 can use -15px)
            is_windows_11 = self._detect_windows_11()
            right_margin = 10 if not is_windows_11 else 15  # Less margin on Windows 10 for more text space
            text_rect = self.track_menu_btn.rect().adjusted(4, 4, -right_margin, -8)  # Left 4px, right margin varies, top 4px, bottom 8px
            text = self.track_menu_btn.text()
            font = self.track_menu_btn.font()
            font.setPixelSize(11)  # Match time label font size
            painter.setFont(font)
            painter.setPen(QColor("#e0e0e0"))
            # Elide text if it's too long (shows "..." when truncated)
            font_metrics = QFontMetrics(font)
            elided_text = font_metrics.elidedText(text, Qt.TextElideMode.ElideRight, text_rect.width())
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)
        self.track_menu_btn.paintEvent = paint_track_with_clipping
        self.track_menu_btn.clicked.connect(self._show_track_menu)
        tracklist_row.addWidget(self.track_menu_btn, 0)
        tracklist_row.addStretch(1)
        layout.addLayout(tracklist_row)
        
        # Row 3: Playback controls (centered)
        controls_row = QHBoxLayout()
        controls_row.setSpacing(1)
        controls_row.setContentsMargins(0, 0, 0, 0)
        controls_row.addStretch(1)
        
        # Previous album button
        self.prev_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-backward', color='#e0e0e0')
            if icon:
                self.prev_album_btn.setIcon(icon)
            else:
                self.prev_album_btn.setText("")
        else:
            self.prev_album_btn.setText("")
        self.prev_album_btn.setToolTip("Previous album")
        self.prev_album_btn.setFixedSize(22, 22)
        self.prev_album_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.prev_album_btn)
        self.prev_album_btn.clicked.connect(self._on_prev_album)
        controls_row.addWidget(self.prev_album_btn)
        
        # Previous track button
        self.prev_track_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('backward', color='#e0e0e0')
            if icon:
                self.prev_track_btn.setIcon(icon)
            else:
                self.prev_track_btn.setText("")
        else:
            self.prev_track_btn.setText("")
        self.prev_track_btn.setToolTip("Previous Track")
        self.prev_track_btn.setFixedSize(22, 22)
        self.prev_track_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.prev_track_btn)
        self.prev_track_btn.clicked.connect(self._on_prev_track)
        controls_row.addWidget(self.prev_track_btn)
        
        # Play/Pause button
        self.play_pause_btn = AnimatedPlayButton()
        if HAS_QT_AWESOME:
            icon = get_icon('play', color='#e0e0e0')
            if icon:
                self.play_pause_btn.setIcon(icon)
            else:
                self.play_pause_btn.setText("")
        else:
            self.play_pause_btn.setText("")
        self.play_pause_btn.setToolTip("Play/Pause")
        self.play_pause_btn.setFixedSize(22, 22)
        self.play_pause_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.play_pause_btn)
        self.play_pause_btn.clicked.connect(self._on_play_pause)
        controls_row.addWidget(self.play_pause_btn)
        
        # Next track button
        self.next_track_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('forward', color='#e0e0e0')
            if icon:
                self.next_track_btn.setIcon(icon)
            else:
                self.next_track_btn.setText("")
        else:
            self.next_track_btn.setText("")
        self.next_track_btn.setToolTip("Next Track")
        self.next_track_btn.setFixedSize(22, 22)
        self.next_track_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.next_track_btn)
        self.next_track_btn.clicked.connect(self._on_next_track)
        controls_row.addWidget(self.next_track_btn)
        
        # Next album button
        self.next_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-forward', color='#e0e0e0')
            if icon:
                self.next_album_btn.setIcon(icon)
            else:
                self.next_album_btn.setText("")
        else:
            self.next_album_btn.setText("")
        self.next_album_btn.setToolTip("Next album")
        self.next_album_btn.setFixedSize(22, 22)
        self.next_album_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.next_album_btn)
        self.next_album_btn.clicked.connect(self._on_next_album)
        controls_row.addWidget(self.next_album_btn)
        
        controls_row.addSpacing(1)
        
        # Playlist button (matches top nav playlist button)
        self.player_playlist_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('mdi6.list-box', color='#a0a0a0')
            if icon:
                self.player_playlist_btn.setIcon(icon)
            else:
                self.player_playlist_btn.setText("")
        else:
            self.player_playlist_btn.setText("")
        self.player_playlist_btn.setToolTip("Toggle Playlist")
        self.player_playlist_btn.setFixedSize(22, 22)
        self.player_playlist_btn.setCheckable(True)
        # Set initial state based on actual playlist visibility
        playlist_visible = False
        if hasattr(self, 'parent_window') and self.parent_window:
            if (hasattr(self.parent_window, 'playlist_sidebar') and 
                self.parent_window.playlist_sidebar and 
                hasattr(self.parent_window.playlist_sidebar, 'isVisible') and
                self.parent_window.playlist_sidebar.isVisible() and 
                not getattr(self.parent_window, 'playlist_detached', False)):
                playlist_visible = True
        # Ensure playlist_visible is a boolean
        playlist_visible = bool(playlist_visible)
        self.player_playlist_btn.setChecked(playlist_visible)
        self.player_playlist_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.player_playlist_btn)
        # Connect to toggle_playlist if parent_window has it
        if hasattr(self, 'parent_window') and self.parent_window:
            self.player_playlist_btn.clicked.connect(self.parent_window.toggle_playlist)
            # Update icon color to match initial state
            if HAS_QT_AWESOME:
                icon_color = '#4a90e2' if playlist_visible else '#a0a0a0'
                icon = get_icon('mdi6.list-box', color=icon_color)
                if icon:
                    self.player_playlist_btn.setIcon(icon)
        controls_row.addWidget(self.player_playlist_btn)
        
        controls_row.addSpacing(1)
        
        # Shuffle button
        self.shuffle_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('random', color='#a0a0a0')
            if icon:
                self.shuffle_btn.setIcon(icon)
            else:
                self.shuffle_btn.setText("")
        else:
            self.shuffle_btn.setText("")
        self.shuffle_btn.setToolTip("Shuffle: Off")
        self.shuffle_btn.setFixedSize(22, 22)
        self.shuffle_btn.setCheckable(True)
        self.shuffle_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.shuffle_btn)
        self.shuffle_btn.clicked.connect(self._on_shuffle)
        controls_row.addWidget(self.shuffle_btn)
        
        # Repeat button
        self.repeat_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.repeat', color='#a0a0a0')
            if icon:
                self.repeat_btn.setIcon(icon)
            else:
                self.repeat_btn.setText("")
        else:
            self.repeat_btn.setText("")
        self.repeat_btn.setToolTip("Repeat: Off")
        self.repeat_btn.setFixedSize(22, 22)
        self.repeat_btn.setCheckable(True)
        self.repeat_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.repeat_btn)
        self.repeat_btn.clicked.connect(self._on_repeat)
        controls_row.addWidget(self.repeat_btn)
        
        controls_row.addSpacing(1)
        
        # Volume button
        self.volume_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('volume-up', color='#e0e0e0')
            if icon:
                self.volume_btn.setIcon(icon)
            else:
                self.volume_btn.setText("")
        else:
            self.volume_btn.setText("")
        self.volume_btn.setToolTip("Volume")
        self.volume_btn.setFixedSize(22, 22)
        self.volume_btn.setStyleSheet(button_style)
        self._apply_button_glow_effect(self.volume_btn)
        self.volume_btn.clicked.connect(self._on_volume_click)
        controls_row.addWidget(self.volume_btn)
        
        controls_row.addStretch(1)
        layout.addLayout(controls_row)
        
        # Row 4: Progress bar with time labels (full width)
        progress_row = QHBoxLayout()
        progress_row.setSpacing(4)
        progress_row.setContentsMargins(0, 0, 0, 0)
        
        # Progress bar
        self.progress_bar = QSlider(Qt.Orientation.Horizontal)
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(1000)
        self.progress_bar.setValue(0)
        self.progress_bar.setFixedHeight(5)
        self.progress_bar.setMinimumHeight(12)
        
        # Check if we're in mini or micro mode (transparent player overlay)
        is_transparent_mode = False
        if hasattr(self, 'parent_window') and self.parent_window:
            if hasattr(self.parent_window, 'mini_mode_state'):
                is_transparent_mode = self.parent_window.mini_mode_state in (1, 2)  # Mini or micro mode
        
        # Use transparent groove in mini/micro mode to avoid black outline
        if is_transparent_mode:
            # Disable auto-fill background to prevent Qt from drawing default background
            self.progress_bar.setAutoFillBackground(False)
            # Transparent groove for mini/micro mode (matches transparent player overlay)
            # Remove all borders from QSlider widget and sub-elements
            # Make groove nearly transparent - only show progress fill and handle
            self.progress_bar.setStyleSheet("""
                QSlider {
                    background: transparent;
                    border: none;
                    outline: none;
                }
                QSlider::groove:horizontal {
                    background: rgba(150, 150, 150, 0.15);
                    height: 5px;
                    border-radius: 2px;
                    border: none;
                    outline: none;
                }
                QSlider::handle:horizontal {
                    background: #4a90e2;
                    width: 8px;
                    height: 5px;
                    border-radius: 2px;
                    margin: 0;
                    border: none;
                    outline: none;
                }
                QSlider::sub-page:horizontal {
                    background: #4a90e2;
                    border-radius: 2px;
                    border: none;
                    outline: none;
                }
                QSlider::add-page:horizontal {
                    background: transparent;
                    border: none;
                    outline: none;
                }
            """)
        else:
            # Regular mode - solid background
            self.progress_bar.setStyleSheet("""
                QSlider {
                    background: transparent;
                    border: none;
                    outline: none;
                }
                QSlider::groove:horizontal {
                    background: #3a3a3a;
                    height: 5px;
                    border-radius: 2px;
                    border: none;
                }
                QSlider::handle:horizontal {
                    background: #4a90e2;
                    width: 8px;
                    height: 5px;
                    border-radius: 2px;
                    margin: 0;
                    border: none;
                }
                QSlider::sub-page:horizontal {
                    background: #4a90e2;
                    border-radius: 2px;
                    border: none;
                }
                QSlider::add-page:horizontal {
                    background: transparent;
                    border: none;
                }
            """)
        self.progress_bar.sliderPressed.connect(self._on_progress_pressed)
        self.progress_bar.sliderReleased.connect(self._on_progress_released)
        self.progress_bar.valueChanged.connect(self._on_progress_changed)
        self._progress_dragging = False
        self._progress_seeking = False  # Flag to prevent updates during/after seeking
        
        # Custom mouse press for Windows 10 compatibility
        original_mouse_press = self.progress_bar.mousePressEvent
        def custom_mouse_press_event(event):
            if event.button() == Qt.MouseButton.LeftButton:
                # Set dragging flag FIRST to prevent updates from interfering
                self._progress_dragging = True
                pos = event.position().x() if hasattr(event, 'position') else event.x()
                slider_width = self.progress_bar.width()
                if slider_width > 0:
                    ratio = max(0.0, min(1.0, pos / slider_width))
                    new_value = int(self.progress_bar.minimum() + ratio * (self.progress_bar.maximum() - self.progress_bar.minimum()))
                    self.progress_bar.setValue(new_value)
                if original_mouse_press:
                    original_mouse_press(event)
            else:
                if original_mouse_press:
                    original_mouse_press(event)
        self.progress_bar.mousePressEvent = custom_mouse_press_event
        
        # Custom mouse move for dragging
        original_mouse_move = self.progress_bar.mouseMoveEvent
        def custom_mouse_move_event(event):
            if self._progress_dragging and event.buttons() & Qt.MouseButton.LeftButton:
                # Keep dragging flag set during move to prevent updates
                self._progress_dragging = True
                pos = event.position().x() if hasattr(event, 'position') else event.x()
                slider_width = self.progress_bar.width()
                if slider_width > 0:
                    ratio = max(0.0, min(1.0, pos / slider_width))
                    new_value = int(self.progress_bar.minimum() + ratio * (self.progress_bar.maximum() - self.progress_bar.minimum()))
                    self.progress_bar.setValue(new_value)
                if original_mouse_move:
                    original_mouse_move(event)
            else:
                if original_mouse_move:
                    original_mouse_move(event)
        self.progress_bar.mouseMoveEvent = custom_mouse_move_event
        
        # Elapsed time label (left)
        self.time_elapsed_label = QLabel("00:00")
        self.time_elapsed_label.setStyleSheet("""
            QLabel {
                color: #e0e0e0;
                font-size: 11px;
                padding: 2px 4px;
                background-color: transparent;
                border: none;
            }
            QLabel:hover {
                background-color: transparent;
                border: 1px solid rgba(74, 144, 226, 0.4);
                border-radius: 3px;
            }
        """)
        font_metrics = QFontMetrics(self.time_elapsed_label.font())
        # Account for longer times like "99:59" to prevent cutoff
        text_width = max(font_metrics.horizontalAdvance("00:00"), font_metrics.horizontalAdvance("99:59"))
        self.time_elapsed_label.setMinimumWidth(text_width + 12)  # Extra padding to prevent cutoff
        self.time_elapsed_label.setMaximumWidth(text_width + 12)
        self.time_elapsed_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.time_elapsed_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        progress_row.addWidget(self.time_elapsed_label, 0)
        
        # Progress bar (center, stretches to fill available space)
        progress_row.addWidget(self.progress_bar, 1)  # Stretch to fill space
        
        # Total/remaining time label (right) - shows only total time or remaining time (not elapsed/remaining format)
        self.time_remaining_label = QLabel("00:00")
        self.time_remaining_label.setStyleSheet("""
            QLabel {
                color: #e0e0e0;
                font-size: 11px;
                padding: 2px 4px;
                background-color: transparent;
                border: none;
            }
            QLabel:hover {
                background-color: transparent;
                border: 1px solid rgba(74, 144, 226, 0.4);
                border-radius: 3px;
            }
        """)
        text_width = max(font_metrics.horizontalAdvance("00:00"), font_metrics.horizontalAdvance("-00:00"))
        self.time_remaining_label.setMinimumWidth(text_width + 8)
        self.time_remaining_label.setMaximumWidth(text_width + 8)
        self.time_remaining_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.time_remaining_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        self.time_remaining_label.setCursor(Qt.CursorShape.PointingHandCursor)
        self.time_remaining_label.mousePressEvent = self._on_time_label_clicked
        self.time_display_mode = self.parent_window.settings.get('time_display_mode', 0) if self.parent_window else 0
        progress_row.addWidget(self.time_remaining_label, 0)
        
        layout.addLayout(progress_row)
        
        # Keep old time_label for backward compatibility (will be updated but not displayed)
        self.time_label = self.time_remaining_label
    
    # Data extraction methods (reuse nano patterns)
    def _update_cover_art(self):
        """Update cover art display by fetching image URL from page."""
        if not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            return
        
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        # Same JavaScript as nano mode
        js_code = """
        (function() {
            try {
                var albumArt = document.querySelector('#tralbum-art-carousel');
                if (!albumArt) {
                    return null;
                }
                
                var visibleImg = null;
                var activeItem = albumArt.querySelector('.carousel-item.active, [class*="active"]');
                if (activeItem) {
                    visibleImg = activeItem.querySelector('img');
                }
                
                if (!visibleImg) {
                    var allImgs = albumArt.querySelectorAll('img');
                    for (var i = 0; i < allImgs.length; i++) {
                        var img = allImgs[i];
                        var style = window.getComputedStyle(img);
                        if (style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
                            var rect = img.getBoundingClientRect();
                            if (rect && rect.width > 0 && rect.height > 0) {
                                visibleImg = img;
                                break;
                            }
                        }
                    }
                }
                
                if (!visibleImg) {
                    visibleImg = albumArt.querySelector('img');
                }
                
                if (!visibleImg) {
                    return null;
                }
                
                var imgSrc = visibleImg.getAttribute('data-src') || visibleImg.getAttribute('data-lazy-src');
                if (!imgSrc) {
                    var srcset = visibleImg.getAttribute('srcset');
                    if (srcset) {
                        var srcsetParts = srcset.split(',').map(function(s) { return s.trim(); });
                        if (srcsetParts.length > 0) {
                            var lastEntry = srcsetParts[srcsetParts.length - 1];
                            imgSrc = lastEntry.split(/\\s+/)[0];
                        }
                    }
                }
                if (!imgSrc) {
                    imgSrc = visibleImg.src || visibleImg.getAttribute('src');
                }
                
                return imgSrc;
            } catch (e) {
                console.log('Bandcamp Player: Error getting cover art URL:', e);
                return null;
            }
        })();
        """
        
        def on_url_received(url):
            if url and hasattr(self, 'cover_art_label') and self.cover_art_label:
                current_url = getattr(self, '_current_cover_art_url', None)
                if url != current_url:
                    self._current_cover_art_url = url
                    
                    # Check shared cache first
                    if (hasattr(self, 'parent_window') and self.parent_window and
                        hasattr(self.parent_window, '_cover_art_cache') and
                        url in self.parent_window._cover_art_cache):
                        # Use cached pixmap immediately, but scale it properly for this mode
                        pixmap = self.parent_window._cover_art_cache[url]
                        # For micro mode, scale to fit width (same logic as _on_cover_art_loaded)
                        if isinstance(self, MicroPlayerWidget):
                            # Ensure geometry is updated first
                            if hasattr(self, '_update_geometry'):
                                self._update_geometry()
                            label_size = self.cover_art_label.size()
                            if label_size.width() > 0:
                                # Scale to fit the label width while maintaining aspect ratio
                                scaled_pixmap = pixmap.scaledToWidth(
                                    label_size.width(),
                                    Qt.TransformationMode.SmoothTransformation
                                )
                                # If scaled pixmap is taller than label, crop from bottom to show top
                                if label_size.height() > 0 and scaled_pixmap.height() > label_size.height():
                                    cropped_pixmap = scaled_pixmap.copy(
                                        0, 0,  # Start from top-left
                                        label_size.width(),
                                        label_size.height()  # Crop to label height
                                    )
                                    self.cover_art_label.setPixmap(cropped_pixmap)
                                else:
                                    # Pixmap fits, use as-is
                                    self.cover_art_label.setPixmap(scaled_pixmap)
                                # Store original for future rescaling
                                self._original_cover_art_pixmap = pixmap
                            else:
                                # Label size not ready yet, use full pixmap temporarily
                                self.cover_art_label.setPixmap(pixmap)
                                self._original_cover_art_pixmap = pixmap
                                # Retry scaling after geometry is updated
                                QTimer.singleShot(100, lambda: self._rescale_cached_cover_art())
                        else:
                            # For other modes, use pixmap as-is
                            self.cover_art_label.setPixmap(pixmap)
                            # Store original pixmap for mini mode blur extraction
                            if isinstance(self, RegularPlayerWidget):
                                self._original_cover_art_pixmap = pixmap
                            elif isinstance(self, MiniPlayerWidget):
                                self._original_cover_art_pixmap = pixmap
                            # Update blurred cover art region for mini mode
                            if isinstance(self, RegularPlayerWidget):
                                QTimer.singleShot(100, self._update_blurred_cover_art_pixmap)
                            elif isinstance(self, MiniPlayerWidget):
                                QTimer.singleShot(100, self._update_blurred_cover_art_pixmap)
                        self.cover_art_label.update()
                        
                        # Update image viewer if it's open
                        if (hasattr(self, 'parent_window') and self.parent_window and
                            hasattr(self.parent_window, '_image_viewer_dialog') and 
                            self.parent_window._image_viewer_dialog and 
                            self.parent_window._image_viewer_dialog.isVisible() and
                            hasattr(self.parent_window, '_image_viewer_image_label') and
                            self.parent_window._image_viewer_image_label):
                            try:
                                # Update the image viewer with the new pixmap
                                self.parent_window._image_viewer_image_label.setPixmap(pixmap)
                            except RuntimeError:
                                # Widget has been deleted, clear references
                                self.parent_window._image_viewer_dialog = None
                                self.parent_window._image_viewer_image_label = None
                    else:
                        # Show loading animation and load image
                        self._load_cover_art_image(url)
            else:
                # Retry after a delay if URL not found (page might still be loading)
                if hasattr(self, 'parent_window') and self.parent_window:
                    QTimer.singleShot(1000, self._update_cover_art)
        
        self.parent_window.web_view.page().runJavaScript(js_code, on_url_received)
    
    def _load_cover_art_image(self, url):
        """Load cover art image from URL."""
        if not url or not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            return
        
        try:
            request = QNetworkRequest(QUrl(url))
            reply = self.network_manager.get(request)
            reply.setProperty('url', url)
        except Exception as e:
            logger.debug(f"Error loading cover art: {e}")
    
    def _on_cover_art_loaded(self, reply):
        """Handle cover art image loaded."""
        try:
            if reply.error() == QNetworkReply.NetworkError.NoError:
                url = reply.property('url')
                if url and hasattr(self, '_current_cover_art_url') and url == self._current_cover_art_url:
                    data = reply.readAll()
                    pixmap = QPixmap()
                    if pixmap.loadFromData(data):
                        # Store in shared cache if parent_window exists
                        if hasattr(self, 'parent_window') and self.parent_window:
                            if not hasattr(self.parent_window, '_cover_art_cache'):
                                self.parent_window._cover_art_cache = {}
                            self.parent_window._cover_art_cache[url] = pixmap
                            self.parent_window._current_cover_art_url = url
                            # Update all other modes immediately
                            self.parent_window._update_all_modes_cover_art()
                        
                        if hasattr(self, 'cover_art_label') and self.cover_art_label:
                            print(f"[COVER ART DEBUG] Setting cover art pixmap, size: {pixmap.size()}")
                            logger.debug(f"[COVER ART DEBUG] Setting cover art pixmap, size: {pixmap.size()}")
                            # Ensure label is visible and properly configured
                            self.cover_art_label.setVisible(True)
                            # Ensure label is behind player overlay (for micro mode)
                            self.cover_art_label.lower()
                            # Set pixmap - this will display the cover art
                            self.cover_art_label.setPixmap(pixmap)
                            # Store original pixmap for mini mode blur extraction
                            if isinstance(self, MiniPlayerWidget):
                                self._original_cover_art_pixmap = pixmap
                            # Update geometry to ensure it fills the widget (important for micro mode)
                            if hasattr(self, 'width') and hasattr(self, 'height'):
                                self.cover_art_label.setGeometry(0, 0, self.width(), self.height())
                            # Force update to ensure pixmap is displayed
                            self.cover_art_label.update()
                            self.cover_art_label.repaint()
                            # Update blurred cover art region for mini mode
                            if isinstance(self, MiniPlayerWidget):
                                QTimer.singleShot(100, self._update_blurred_cover_art_pixmap)
                            # For micro mode, ensure the widget itself is updated
                            if hasattr(self, 'parent_window') and self.parent_window:
                                if hasattr(self.parent_window, 'mini_mode_state') and self.parent_window.mini_mode_state == 2:
                                    self.update()
                                    self.repaint()
                            print(f"[COVER ART DEBUG] Cover art pixmap set, label visible: {self.cover_art_label.isVisible()}, geometry: {self.cover_art_label.geometry()}")
                            logger.debug(f"[COVER ART DEBUG] Cover art pixmap set, label visible: {self.cover_art_label.isVisible()}, geometry: {self.cover_art_label.geometry()}")
                            # Force playlist repaint after cover art update (fixes black display in mini mode)
                            # This is critical because setPixmap triggers a repaint that can affect playlist rendering
                            if hasattr(self, 'parent_window') and self.parent_window:
                                # Check if we're in mini mode and playlist is visible
                                if (hasattr(self.parent_window, 'mini_mode_state') and 
                                    self.parent_window.mini_mode_state == 1 and
                                    hasattr(self.parent_window, 'playlist_sidebar') and 
                                    self.parent_window.playlist_sidebar and
                                    self.parent_window.playlist_sidebar.isVisible()):
                                    print("[PLAYLIST DEBUG] In mini mode with visible playlist, applying fixes")
                                    logger.debug("[PLAYLIST DEBUG] In mini mode with visible playlist, applying fixes")
                                    # Debug: Check widget states
                                    if hasattr(self.parent_window.playlist_sidebar, 'list_widget') and self.parent_window.playlist_sidebar.list_widget:
                                        list_widget = self.parent_window.playlist_sidebar.list_widget
                                        print(f"[PLAYLIST DEBUG] list_widget visible: {list_widget.isVisible()}, "
                                                   f"geometry: {list_widget.geometry()}, "
                                                   f"size: {list_widget.size()}, "
                                                   f"is_minimized: {getattr(self.parent_window.playlist_sidebar, 'is_minimized', 'N/A')}")
                                        logger.debug(f"[PLAYLIST DEBUG] list_widget visible: {list_widget.isVisible()}, "
                                                   f"geometry: {list_widget.geometry()}, "
                                                   f"size: {list_widget.size()}, "
                                                   f"is_minimized: {getattr(self.parent_window.playlist_sidebar, 'is_minimized', 'N/A')}")
                                    if hasattr(self.parent_window, 'playlist_container') and self.parent_window.playlist_container:
                                        print(f"[PLAYLIST DEBUG] playlist_container visible: {self.parent_window.playlist_container.isVisible()}, "
                                                   f"geometry: {self.parent_window.playlist_container.geometry()}")
                                        logger.debug(f"[PLAYLIST DEBUG] playlist_container visible: {self.parent_window.playlist_container.isVisible()}, "
                                                   f"geometry: {self.parent_window.playlist_container.geometry()}")
                                    print(f"[PLAYLIST DEBUG] cover_art_label geometry: {self.cover_art_label.geometry() if hasattr(self, 'cover_art_label') else 'N/A'}")
                                    logger.debug(f"[PLAYLIST DEBUG] cover_art_label geometry: {self.cover_art_label.geometry() if hasattr(self, 'cover_art_label') else 'N/A'}")
                                    # CRITICAL FIX: Replicate what toggle_playlist does to force proper repaint
                                    # When you toggle the playlist, it works because setVisible() forces a full repaint
                                    def force_playlist_refresh():
                                        if not hasattr(self, 'parent_window') or not self.parent_window:
                                            return
                                        if not hasattr(self.parent_window, 'playlist_sidebar') or not self.parent_window.playlist_sidebar:
                                            return
                                        if not self.parent_window.playlist_sidebar.isVisible():
                                            return
                                        
                                        # Replicate toggle_playlist behavior: force geometry and layout updates
                                        if hasattr(self.parent_window, 'playlist_container') and self.parent_window.playlist_container:
                                            self.parent_window.playlist_container.updateGeometry()
                                        self.parent_window.playlist_sidebar.updateGeometry()
                                        # Force layout update (same as toggle_playlist)
                                        layout = self.parent_window.centralWidget().layout()
                                        if layout:
                                            layout.update()
                                            layout.activate()
                                        # Defer UI update instead of forcing immediate processing
                                        QTimer.singleShot(0, lambda: layout.update() if layout else None)
                                        
                                        # Fix z-order: cover art (bottom) < player overlay < playlist (top)
                                        if hasattr(self, 'cover_art_label') and self.cover_art_label:
                                            self.cover_art_label.lower()
                                        if hasattr(self, 'player_overlay') and self.player_overlay:
                                            self.player_overlay.raise_()
                                        if hasattr(self.parent_window, 'playlist_container') and self.parent_window.playlist_container:
                                            self.parent_window.playlist_container.raise_()
                                        if hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                                            self.parent_window.playlist_sidebar.raise_()
                                        
                                        # Force explicit repaint of list widget (same as what happens when shown)
                                        if hasattr(self.parent_window.playlist_sidebar, 'list_widget') and self.parent_window.playlist_sidebar.list_widget:
                                            list_widget = self.parent_window.playlist_sidebar.list_widget
                                            # Briefly hide/show to force full repaint (like toggle does)
                                            if list_widget.isVisible() and not self.parent_window.playlist_sidebar.is_minimized:
                                                list_widget.hide()
                                                # Defer show to next event loop cycle
                                                QTimer.singleShot(0, lambda: list_widget.show() if list_widget else None)
                                    # Force refresh immediately and with multiple delays
                                    force_playlist_refresh()
                                    QTimer.singleShot(1, force_playlist_refresh)
                                    QTimer.singleShot(10, force_playlist_refresh)
                                    QTimer.singleShot(50, force_playlist_refresh)
                                    QTimer.singleShot(100, force_playlist_refresh)
                                    QTimer.singleShot(200, force_playlist_refresh)
                                    # Force explicit repaint using alternative approach (fixes black display)
                                    if hasattr(self.parent_window.playlist_sidebar, 'list_widget') and self.parent_window.playlist_sidebar.list_widget:
                                        list_widget = self.parent_window.playlist_sidebar.list_widget
                                        # Ensure list widget is visible
                                        if not list_widget.isVisible() and not self.parent_window.playlist_sidebar.is_minimized:
                                            list_widget.show()
                                        # Alternative approach: Force stylesheet refresh and ensure background is drawn
                                        # Re-apply stylesheet to ensure background color is set
                                        current_stylesheet = list_widget.styleSheet()
                                        if current_stylesheet:
                                            list_widget.setStyleSheet("")  # Clear first
                                            # Defer re-application instead of forcing immediate processing
                                            QTimer.singleShot(0, lambda: list_widget.setStyleSheet(current_stylesheet) if list_widget else None)
                                        # Ensure auto-fill background is enabled
                                        list_widget.setAutoFillBackground(True)
                                        # Force geometry update
                                        list_widget.updateGeometry()
                                        self.parent_window.playlist_sidebar.updateGeometry()
                                        if hasattr(self.parent_window, 'playlist_container') and self.parent_window.playlist_container:
                                            self.parent_window.playlist_container.updateGeometry()
                                        # Explicitly repaint the entire widget area
                                        list_widget.viewport().update(list_widget.viewport().rect())
                                        list_widget.update()  # QListWidget.update() doesn't accept QRect
                                        # Force immediate repaint of entire widget
                                        list_widget.repaint(list_widget.rect())
                                        # Also repaint the sidebar and container
                                        self.parent_window.playlist_sidebar.repaint(self.parent_window.playlist_sidebar.rect())
                                        if hasattr(self.parent_window, 'playlist_container') and self.parent_window.playlist_container:
                                            self.parent_window.playlist_container.repaint(self.parent_window.playlist_container.rect())
                                        # Defer UI update instead of forcing immediate processing
                                        def update_widgets():
                                            if list_widget:
                                                list_widget.update()
                                            if self.parent_window.playlist_sidebar:
                                                self.parent_window.playlist_sidebar.update()
                                        QTimer.singleShot(0, update_widgets)
                                    # Use multiple delays to ensure repaint happens after cover art repaint completes
                                    def force_playlist_repaint():
                                        if (hasattr(self.parent_window, 'playlist_sidebar') and 
                                            self.parent_window.playlist_sidebar and
                                            hasattr(self.parent_window.playlist_sidebar, 'list_widget') and 
                                            self.parent_window.playlist_sidebar.list_widget):
                                            list_widget = self.parent_window.playlist_sidebar.list_widget
                                            # Re-raise playlist to ensure it stays on top
                                            if hasattr(self.parent_window, 'playlist_container') and self.parent_window.playlist_container:
                                                self.parent_window.playlist_container.raise_()
                                            self.parent_window.playlist_sidebar.raise_()
                                            # Force repaint with explicit rect
                                            list_widget.viewport().update(list_widget.viewport().rect())
                                            list_widget.update()  # QListWidget.update() doesn't accept QRect
                                            list_widget.repaint(list_widget.rect())
                                    QTimer.singleShot(10, force_playlist_repaint)
                                    QTimer.singleShot(50, force_playlist_repaint)
                                    QTimer.singleShot(100, force_playlist_repaint)
            else:
                # Error loading image, retry after delay
                if hasattr(self, 'parent_window') and self.parent_window:
                    QTimer.singleShot(2000, self._update_cover_art)
            reply.deleteLater()
        except Exception as e:
            logger.debug(f"Error processing cover art: {e}")
            if hasattr(reply, 'deleteLater'):
                reply.deleteLater()
    
    def _show_player_context_menu(self, position):
        """Show context menu for cover art and player section (same as nano, minus nano-specific options)."""
        menu = QMenu(self)
        
        # Paste URL
        paste_url_action = QAction("Paste URL", self)
        if HAS_QT_AWESOME:
            icon = get_icon('paste', color='#e0e0e0')
            if icon:
                paste_url_action.setIcon(icon)
        else:
            paste_url_action.setText(" Paste URL")
        paste_url_action.triggered.connect(lambda: self.parent_window.on_paste_url() if self.parent_window else None)
        menu.addAction(paste_url_action)
        
        menu.addSeparator()
        
        # Get current page URL for "Open in Browser" and "Copy URL"
        current_url = None
        if self.parent_window and hasattr(self.parent_window, 'web_view') and self.parent_window.web_view:
            current_url = self.parent_window.web_view.url().toString()
        
        if current_url and current_url != "about:blank":
            # Open in Browser
            open_browser_action = QAction("Open in Browser", self)
            if HAS_QT_AWESOME:
                icon = get_icon('external-link-alt', color='#e0e0e0')
                if icon:
                    open_browser_action.setIcon(icon)
            else:
                open_browser_action.setText(" Open in Browser")
            open_browser_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl(current_url)))
            menu.addAction(open_browser_action)
            
            # Copy URL
            copy_url_action = QAction("Copy URL", self)
            if HAS_QT_AWESOME:
                icon = get_icon('copy', color='#e0e0e0')
                if icon:
                    copy_url_action.setIcon(icon)
            else:
                copy_url_action.setText(" Copy URL")
            def copy_url_with_feedback():
                QApplication.clipboard().setText(current_url)
                # Show feedback at the position where menu was opened
                if hasattr(self, 'cover_art_label') and self.cover_art_label:
                    global_pos = self.cover_art_label.mapToGlobal(position)
                else:
                    global_pos = self.mapToGlobal(position)
                QToolTip.showText(global_pos, "URL copied", self, QRect(), 1500)
            copy_url_action.triggered.connect(copy_url_with_feedback)
            menu.addAction(copy_url_action)
            
            menu.addSeparator()
        
        # Autoplay
        autoplay_action = QAction("Autoplay", self)
        autoplay_action.setCheckable(True)
        if self.parent_window:
            autoplay_action.setChecked(self.parent_window.autoplay)
            def toggle_autoplay():
                if self.parent_window:
                    self.parent_window.autoplay = not self.parent_window.autoplay
                    if hasattr(self.parent_window, 'autoplay_action'):
                        self.parent_window.autoplay_action.setChecked(self.parent_window.autoplay)
                    self.parent_window.save_settings()
            autoplay_action.triggered.connect(toggle_autoplay)
        menu.addAction(autoplay_action)
        
        # Autoplay on Startup
        autoplay_on_startup_action = QAction("Autoplay on Startup", self)
        autoplay_on_startup_action.setCheckable(True)
        if self.parent_window:
            autoplay_on_startup_action.setChecked(self.parent_window.autoplay_on_startup)
            def toggle_autoplay_on_startup():
                if self.parent_window:
                    self.parent_window.autoplay_on_startup = not self.parent_window.autoplay_on_startup
                    if hasattr(self.parent_window, 'autoplay_on_startup_action'):
                        self.parent_window.autoplay_on_startup_action.setChecked(self.parent_window.autoplay_on_startup)
                    self.parent_window.save_settings()
            autoplay_on_startup_action.triggered.connect(toggle_autoplay_on_startup)
        menu.addAction(autoplay_on_startup_action)
        
        # Style the menu (same as nano)
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 20px 6px 30px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #3a3a3a;
            }
            QMenu::item:disabled {
                color: #666666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #4a4a4a;
                margin: 4px 0;
            }
        """)
        
        # Show menu at the position where right-click occurred
        if hasattr(self, 'cover_art_label') and self.sender() == self.cover_art_label:
            global_pos = self.cover_art_label.mapToGlobal(position)
        else:
            global_pos = self.mapToGlobal(position)
        menu.exec(global_pos)
    
    def _update_playback_state(self):
        """Update playback state, progress bar, and time display."""
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        # Skip updates during page load to avoid interfering with loading process
        if hasattr(self.parent_window, 'is_loading') and self.parent_window.is_loading:
            return
        
        # Same JavaScript as nano mode for getting playback state (including buffering detection)
        js_code = """
        (function() {
            var info = {};
            var audio = document.querySelector('audio');
            if (audio) {
                info.isPlaying = !audio.paused;
                info.currentTime = audio.currentTime || 0;
                info.duration = audio.duration || 0;
                
                // Detect buffering/seeking state (same as nano mode)
                // Buffering occurs when:
                // 1. Audio is seeking (user scrubbed or track changed)
                // 2. Audio is playing but doesn't have enough data (readyState < 4 = HAVE_ENOUGH_DATA)
                // 3. Network is actively loading (networkState === 2 = NETWORK_LOADING)
                // 4. Audio is waiting for data (readyState < 3 = HAVE_FUTURE_DATA)
                var isSeeking = audio.seeking === true;
                var hasEnoughData = audio.readyState >= 4;  // HAVE_ENOUGH_DATA
                var isNetworkLoading = audio.networkState === 2;  // NETWORK_LOADING
                var hasFutureData = audio.readyState >= 3;  // HAVE_FUTURE_DATA
                
                // Consider buffering if:
                // - Currently seeking, OR
                // - Playing but not enough data loaded, OR
                // - Network is actively loading data
                info.isBuffering = isSeeking || 
                                  (info.isPlaying && !hasEnoughData) || 
                                  (info.isPlaying && isNetworkLoading && !hasFutureData);
            } else {
                info.isPlaying = false;
                info.currentTime = 0;
                info.duration = 0;
                info.isBuffering = false;
            }
            
            // Get artist and album
            var artistEl = document.querySelector('.tralbum-artist');
            var albumEl = document.querySelector('.tralbum-name');
            if (artistEl) {
                var artistText = artistEl.textContent.trim();
                info.artist = artistText.replace(/^by\\s+/i, '');
            }
            if (albumEl) {
                info.album = albumEl.textContent.trim();
            }
            
            // Try multiple selectors to get the track title and track number (same as nano mode)
            var trackEl = null;
            var trackNumber = null;
            var currentTrack = document.querySelector('.current-track');
            if (currentTrack) {
                // Find track number span
                var trackNumEl = currentTrack.querySelector('.track-number, .track-num');
                if (trackNumEl) {
                    trackNumber = trackNumEl.textContent.trim();
                    // Remove any non-digit characters, keep just the number
                    trackNumber = trackNumber.replace(/[^\\d]/g, '');
                }
                // If no track number class, try to find it in spans
                if (!trackNumber) {
                    var spans = currentTrack.querySelectorAll('span');
                    for (var i = 0; i < spans.length; i++) {
                        var span = spans[i];
                        var text = span.textContent.trim();
                        // Check if this span is just a number (likely track number)
                        if (/^\\d+$/.test(text)) {
                            trackNumber = text;
                            break;
                        }
                    }
                }
                // Find span that's not the track number (the actual track title)
                var spans = currentTrack.querySelectorAll('span');
                for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    var classes = span.className || '';
                    var text = span.textContent.trim();
                    // Skip track number spans
                    if (!classes.includes('track-number') && 
                        !classes.includes('track-num') && 
                        text && 
                        text.length > 0 &&
                        !/^\\d+$/.test(text)) {  // Not just a number
                        trackEl = span;
                        break;
                    }
                }
            }
            // Method 2: Fallback to .track-title
            if (!trackEl) {
                trackEl = document.querySelector('.track-title');
            }
            // Method 3: Fallback to any span in .current-track (last resort)
            if (!trackEl && currentTrack) {
                trackEl = currentTrack.querySelector('span:not(.track-number):not(.track-num)');
            }
            
            if (trackEl) {
                var trackText = trackEl.textContent.trim();
                // Remove track number if it's at the start (e.g., "1. Track Name" -> "Track Name")
                trackText = trackText.replace(/^\\d+\\.?\\s*/, '');
                info.track = trackText;
            }
            // Store track number if found
            if (trackNumber) {
                info.trackNumber = trackNumber;
            }
            
            return info;
        })();
        """
        
        def on_state_received(result):
            if not result:
                return
            
            # Update play/pause button
            is_playing = result.get('isPlaying', False)
            if hasattr(self, 'play_pause_btn') and self.play_pause_btn:
                try:
                    if is_playing:
                        if HAS_QT_AWESOME:
                            icon = get_icon('pause', color='#e0e0e0')
                            if icon:
                                self.play_pause_btn.setIcon(icon)
                            else:
                                self.play_pause_btn.setText("")
                        else:
                            self.play_pause_btn.setText("")
                    else:
                        if HAS_QT_AWESOME:
                            icon = get_icon('play', color='#e0e0e0')
                            if icon:
                                self.play_pause_btn.setIcon(icon)
                            else:
                                self.play_pause_btn.setText("")
                        else:
                            self.play_pause_btn.setText("")
                except RuntimeError:
                    # Widget has been deleted (e.g., during app shutdown)
                    return
            
            # Update progress bar (only if not dragging or seeking)
            if (not self._progress_dragging and not self._progress_seeking and 
                hasattr(self, 'progress_bar') and self.progress_bar):
                try:
                    current_time = result.get('currentTime', 0)
                    duration = result.get('duration', 0)
                    if duration > 0:
                        progress = int((current_time / duration) * 1000)
                        self.progress_bar.setValue(progress)
                except RuntimeError:
                    # Widget has been deleted (e.g., during app shutdown)
                    pass
            
            # Update image viewer controls if they exist
            if (hasattr(self, 'parent_window') and self.parent_window and
                hasattr(self.parent_window, '_image_viewer_controls') and
                self.parent_window._image_viewer_controls):
                try:
                    controls = self.parent_window._image_viewer_controls
                    # Update visualization with playback state
                    if 'update_viz' in controls and controls['update_viz']:
                        current_time = result.get('currentTime', 0)
                        duration = result.get('duration', 0)
                        controls['update_viz'](current_time, duration, is_playing)
                    
                    # Update play/pause button
                    if 'play_pause_btn' in controls and controls['play_pause_btn']:
                        play_pause_btn = controls['play_pause_btn']
                        if is_playing:
                            if HAS_QT_AWESOME:
                                icon = get_icon('pause', color='#e0e0e0')
                                if icon:
                                    play_pause_btn.setIcon(icon)
                                else:
                                    play_pause_btn.setText("")
                            else:
                                play_pause_btn.setText("")
                        else:
                            if HAS_QT_AWESOME:
                                icon = get_icon('play', color='#e0e0e0')
                                if icon:
                                    play_pause_btn.setIcon(icon)
                                else:
                                    play_pause_btn.setText("")
                            else:
                                play_pause_btn.setText("")
                    
                    # Update progress bar (only if not dragging or seeking)
                    if ('progress_bar' in controls and controls['progress_bar'] and
                        not controls.get('progress_dragging', False) and
                        not controls.get('progress_seeking', False)):
                        progress_bar = controls['progress_bar']
                        current_time = result.get('currentTime', 0)
                        duration = result.get('duration', 0)
                        if duration > 0:
                            progress = int((current_time / duration) * 1000)
                            progress_bar.setValue(progress)
                    
                    # Update time labels (elapsed and remaining/total)
                    current_time = result.get('currentTime', 0)
                    duration = result.get('duration', 0)
                    
                    def format_time(seconds):
                        if not seconds or seconds < 0:
                            return "00:00"
                        mins = int(seconds // 60)
                        secs = int(seconds % 60)
                        return f"{mins:02d}:{secs:02d}"
                    
                    # Update elapsed time label (left)
                    if 'time_elapsed_label' in controls and controls['time_elapsed_label']:
                        try:
                            current_str = format_time(current_time)
                            controls['time_elapsed_label'].setText(current_str)
                        except RuntimeError:
                            # Widget has been deleted
                            pass
                    
                    # Update remaining/total time label (right)
                    if 'time_remaining_label' in controls and controls['time_remaining_label']:
                        try:
                            time_display_mode = self.parent_window.settings.get('time_display_mode', 0) if self.parent_window else 0
                            if time_display_mode == 1 and duration > 0:
                                remaining = duration - current_time
                                remaining_str = format_time(remaining)
                                controls['time_remaining_label'].setText(f"-{remaining_str}")
                            else:
                                duration_str = format_time(duration)
                                controls['time_remaining_label'].setText(duration_str)
                        except RuntimeError:
                            # Widget has been deleted
                            pass
                    
                    # Update track menu button text with track number format (e.g., "01. trackname")
                    if 'tracklist_btn' in controls and controls['tracklist_btn']:
                        tracklist_btn = controls['tracklist_btn']
                        track = result.get('track', '')
                        track_number = result.get('trackNumber', '')
                        
                        # Format: 01. Track Name (zero-padded track number with period)
                        if track_number and track:
                            try:
                                track_num = int(track_number)
                                formatted_number = f"{track_num:02d}"
                                display_text = f"{formatted_number}. {track}"
                            except (ValueError, TypeError):
                                display_text = f"{track_number}. {track}"
                        elif track:
                            display_text = track
                        else:
                            display_text = "Tracks"
                        
                        tracklist_btn.setText(display_text)
                        # Update tooltip if text is truncated
                        self._update_button_tooltip(tracklist_btn, display_text)
                        # Image viewer buttons maintain full width (no width update needed)
                    
                    # Update album menu button text with "Album Name by Artist" format
                    if 'albumlist_btn' in controls and controls['albumlist_btn']:
                        albumlist_btn = controls['albumlist_btn']
                        album = result.get('album', '')
                        artist = result.get('artist', '')
                        if album and artist:
                            display_text = f"{album} by {artist}"
                        elif album:
                            display_text = album
                        else:
                            display_text = "Albums"
                        
                        albumlist_btn.setText(display_text)
                        # Update tooltip if text is truncated
                        self._update_button_tooltip(albumlist_btn, display_text)
                        # Image viewer buttons maintain full width (no width update needed)
                except RuntimeError:
                    # Widgets have been deleted
                    pass
            
            # Update time labels (elapsed and remaining/total)
            current_time = result.get('currentTime', 0)
            duration = result.get('duration', 0)
            
            # Update image viewer visualization if active
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                controls = self.parent_window._image_viewer_controls
                if 'update_viz' in controls and controls['update_viz']:
                    try:
                        controls['update_viz'](current_time, duration)
                    except RuntimeError:
                        pass
            
            def format_time(seconds):
                if not seconds or seconds < 0:
                    return "00:00"
                mins = int(seconds // 60)
                secs = int(seconds % 60)
                return f"{mins:02d}:{secs:02d}"
            
            # Update elapsed time label (left)
            if hasattr(self, 'time_elapsed_label') and self.time_elapsed_label:
                try:
                    current_str = format_time(current_time)
                    self.time_elapsed_label.setText(current_str)
                except RuntimeError:
                    # Widget has been deleted (e.g., during app shutdown)
                    pass
            
            # Update remaining/total time label (right)
            if hasattr(self, 'time_remaining_label') and self.time_remaining_label:
                try:
                    if self.time_display_mode == 1 and duration > 0:
                        remaining = duration - current_time
                        remaining_str = format_time(remaining)
                        self.time_remaining_label.setText(f"-{remaining_str}")
                    else:
                        duration_str = format_time(duration)
                        self.time_remaining_label.setText(duration_str)
                except RuntimeError:
                    # Widget has been deleted (e.g., during app shutdown)
                    pass
            
            # Update buffering state for play button animation
            is_buffering = result.get('isBuffering', False)
            try:
                self._update_buffering_state(is_buffering)
            except RuntimeError:
                # Widget has been deleted (e.g., during app shutdown)
                pass
            
            # Keep old time_label for backward compatibility (but don't show "/" format)
            if hasattr(self, 'time_label') and self.time_label:
                try:
                    # Just show total time or remaining time (no "/" format)
                    if self.time_display_mode == 1 and duration > 0:
                        remaining = duration - current_time
                        remaining_str = format_time(remaining)
                        self.time_label.setText(f"-{remaining_str}")
                    else:
                        duration_str = format_time(duration)
                        self.time_label.setText(duration_str)
                except RuntimeError:
                    # Widget has been deleted (e.g., during app shutdown)
                    pass
            
            # Update track menu button text with track number format (e.g., "01. trackname")
            if hasattr(self, 'track_menu_btn') and self.track_menu_btn:
                try:
                    track = result.get('track', '')  # Use track from JavaScript extraction (same as nano mode)
                    artist = result.get('artist', '')
                    track_number = result.get('trackNumber', '')
                    
                    # Format: 01. Track Name (zero-padded track number with period) - no artist in button text
                    if track_number and track:
                        try:
                            # Convert to int and format with zero-padding (01, 02, etc.)
                            track_num = int(track_number)
                            formatted_number = f"{track_num:02d}"
                            display_text = f"{formatted_number}. {track}"
                        except (ValueError, TypeError):
                            # If conversion fails, use track_number as-is with period
                            display_text = f"{track_number}. {track}"
                    elif track:
                        display_text = track
                    else:
                        display_text = "Tracklist"
                    
                    self.track_menu_btn.setText(display_text)
                    # Update tooltip if text is truncated
                    self._update_button_tooltip(self.track_menu_btn, display_text)
                    # Update button width to fit new text
                    self._update_track_button_width()
                except RuntimeError:
                    # Widget has been deleted (e.g., during app shutdown)
                    pass
            
            # Update album menu button text with "Album Name by Artist" format
            if hasattr(self, 'album_menu_btn') and self.album_menu_btn:
                try:
                    album = result.get('album', '')
                    artist = result.get('artist', '')
                    if album and artist:
                        display_text = f"{album} by {artist}"
                        self.album_menu_btn.setText(display_text)
                        # Update tooltip if text is truncated
                        self._update_button_tooltip(self.album_menu_btn, display_text)
                        # Save this metadata to the playlist for the current URL
                        if self.parent_window and self.parent_window.web_view:
                            current_url = self.parent_window.web_view.url().toString()
                            if current_url and current_url != 'about:blank':
                                # Ensure playlist manager is initialized
                                self.parent_window._ensure_playlist_manager()
                                # Save metadata - update_url_metadata will normalize URLs for matching
                                if hasattr(self.parent_window, 'playlist_manager') and self.parent_window.playlist_manager:
                                    # Save for current URL (normalization will match it to playlist item)
                                    self.parent_window.playlist_manager.update_url_metadata(current_url, display_text)
                                    # Also try to save for all URLs in playlist that might resolve to current_url
                                    playlist_urls = self.parent_window.playlist_manager.get_playlist()
                                    for playlist_url in playlist_urls:
                                        # Check if this playlist URL resolves to current URL
                                        if hasattr(self.parent_window, 'resolve_url_redirects'):
                                            try:
                                                resolved = self.parent_window.resolve_url_redirects(playlist_url)
                                                if resolved == current_url:
                                                    # Also save for the playlist URL
                                                    self.parent_window.playlist_manager.update_url_metadata(playlist_url, display_text)
                                            except:
                                                pass
                    elif album:
                        self.album_menu_btn.setText(album)
                        # Update tooltip if text is truncated
                        self._update_button_tooltip(self.album_menu_btn, album)
                        # Save album-only metadata if we have a URL
                        if self.parent_window and self.parent_window.web_view:
                            current_url = self.parent_window.web_view.url().toString()
                            if current_url and current_url != 'about:blank':
                                self.parent_window._ensure_playlist_manager()
                                if hasattr(self.parent_window, 'playlist_manager') and self.parent_window.playlist_manager:
                                    self.parent_window.playlist_manager.update_url_metadata(current_url, album)
                                    # Also try to save for all URLs in playlist that might resolve to current_url
                                    playlist_urls = self.parent_window.playlist_manager.get_playlist()
                                    for playlist_url in playlist_urls:
                                        if hasattr(self.parent_window, 'resolve_url_redirects'):
                                            try:
                                                resolved = self.parent_window.resolve_url_redirects(playlist_url)
                                                if resolved == current_url:
                                                    self.parent_window.playlist_manager.update_url_metadata(playlist_url, album)
                                            except:
                                                pass
                    else:
                        self.album_menu_btn.setText("Albumlist")
                        # Update tooltip if text is truncated
                        self._update_button_tooltip(self.album_menu_btn, "Albumlist")
                    # Update button width to fit new text
                    self._update_album_button_width()
                except RuntimeError:
                    # Widget has been deleted (e.g., during app shutdown)
                    pass
            
            # Store current track number (as int for arithmetic operations)
            track_number = result.get('trackNumber')
            if track_number:
                try:
                    self._current_track_number = int(track_number)
                except (ValueError, TypeError):
                    # If conversion fails, try to extract number from string
                    if isinstance(track_number, str):
                        track_number_clean = ''.join(filter(str.isdigit, track_number))
                        if track_number_clean:
                            try:
                                self._current_track_number = int(track_number_clean)
                            except (ValueError, TypeError):
                                self._current_track_number = None
                        else:
                            self._current_track_number = None
                    else:
                        self._current_track_number = None
            else:
                self._current_track_number = None
        
        self.parent_window.web_view.page().runJavaScript(js_code, on_state_received)
    
    # Playback control methods (reuse nano patterns)
    def _on_play_pause(self):
        """Handle play/pause button click."""
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        js_code = """
        (function() {
            var audio = document.querySelector('audio');
            if (audio && audio.readyState >= 2) {
                if (audio.paused) {
                    var playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(function(error) {
                            var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                            if (playBtn) {
                                playBtn.click();
                            }
                        });
                    }
                } else {
                    audio.pause();
                }
            } else {
                var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                if (playBtn) {
                    playBtn.click();
                }
            }
        })();
        """
        self.parent_window.web_view.page().runJavaScript(js_code)
    
    def _on_prev_track(self):
        """Handle previous track button click."""
        if self.parent_window:
            self.parent_window._trigger_previous_track()
    
    def _on_next_track(self):
        """Handle next track button click."""
        if self.parent_window:
            self.parent_window._trigger_next_track()
    
    def _on_prev_album(self):
        """Handle previous album button click."""
        if self.parent_window:
            # Ensure playlist sidebar exists (lazy-loaded)
            # The playlist sidebar is created in toggle_playlist(), so we need to ensure it exists
            if not hasattr(self.parent_window, 'playlist_sidebar') or self.parent_window.playlist_sidebar is None:
                # Create playlist sidebar if it doesn't exist (same logic as toggle_playlist)
                if hasattr(self.parent_window, 'toggle_playlist'):
                    # Temporarily store visibility state
                    was_visible = False
                    if hasattr(self.parent_window, 'settings'):
                        was_visible = self.parent_window.settings.get('playlist_visible', False)
                    # Create the sidebar (this will create it if None)
                    self.parent_window.toggle_playlist()
                    # Restore visibility state
                    if not was_visible and hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                        self.parent_window.playlist_sidebar.hide()
            if hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                self.parent_window.playlist_sidebar.load_previous_album()
    
    def _on_next_album(self):
        """Handle next album button click."""
        if self.parent_window:
            # Ensure playlist sidebar exists (lazy-loaded)
            # The playlist sidebar is created in toggle_playlist(), so we need to ensure it exists
            if not hasattr(self.parent_window, 'playlist_sidebar') or self.parent_window.playlist_sidebar is None:
                # Create playlist sidebar if it doesn't exist (same logic as toggle_playlist)
                if hasattr(self.parent_window, 'toggle_playlist'):
                    # Temporarily store visibility state
                    was_visible = False
                    if hasattr(self.parent_window, 'settings'):
                        was_visible = self.parent_window.settings.get('playlist_visible', False)
                    # Create the sidebar (this will create it if None)
                    self.parent_window.toggle_playlist()
                    # Restore visibility state
                    if not was_visible and hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                        self.parent_window.playlist_sidebar.hide()
            if hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                self.parent_window.playlist_sidebar.load_next_album()
    
    def _on_shuffle(self):
        """Handle shuffle button toggle - uses centralized PlayerWindow method."""
        if self.parent_window and hasattr(self.parent_window, 'toggle_shuffle'):
            self.parent_window.toggle_shuffle()
    
    def _on_repeat(self):
        """Handle repeat button toggle - uses centralized PlayerWindow method."""
        if self.parent_window and hasattr(self.parent_window, 'toggle_repeat'):
            self.parent_window.toggle_repeat()
    
    def _update_repeat_overlay(self, repeat_mode):
        """Update overlay on repeat button based on mode:
        - Mode 3 (Track): "1" overlay (white)
        - Other modes: no overlay
        """
        if not hasattr(self, 'repeat_btn') or not self.repeat_btn:
            return
        
        # Remove existing overlay if it exists
        if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label is not None:
            try:
                self._repeat_overlay_label.deleteLater()
            except (AttributeError, RuntimeError):
                pass  # Label might already be deleted
            self._repeat_overlay_label = None
        
        # Show overlay only for mode 3 ("1")
        if repeat_mode == 3:
            # Create overlay label
            from PyQt6.QtWidgets import QLabel
            from PyQt6.QtCore import Qt
            
            # Set overlay text to "1" for mode 3
            overlay_text = "1"
            
            # Set overlay color: white for mode 3 (track)
            overlay_color = 'white'
            
            # Create overlay as child of button's parent widget to ensure it's on top
            # Get the button's parent widget (the container)
            button_parent = self.repeat_btn.parent()
            if button_parent:
                self._repeat_overlay_label = QLabel(overlay_text, button_parent)
            else:
                # Fallback to button itself if no parent
                self._repeat_overlay_label = QLabel(overlay_text, self.repeat_btn)
            
            self._repeat_overlay_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            # Make overlay transparent to mouse events so clicks pass through to button
            self._repeat_overlay_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._repeat_overlay_label.setStyleSheet(f"""
                QLabel {{
                    background-color: transparent;
                    color: {overlay_color};
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                }}
            """)
            # Position will be updated when button is shown/resized
            # Use a method to update position
            def update_overlay_position():
                if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label and self.repeat_btn:
                    try:
                        # Get button position relative to its parent widget
                        btn_pos = self.repeat_btn.pos()
                        btn_size = self.repeat_btn.size()
                        overlay_size = 12  # Smaller overlay to ensure it stays within button bounds
                        # Calculate position relative to button's parent, centered on button
                        x = btn_pos.x() + (btn_size.width() - overlay_size) // 2
                        y = btn_pos.y() + (btn_size.height() - overlay_size) // 2
                        # Ensure overlay stays within button bounds
                        x = max(btn_pos.x(), min(x, btn_pos.x() + btn_size.width() - overlay_size))
                        y = max(btn_pos.y(), min(y, btn_pos.y() + btn_size.height() - overlay_size))
                        self._repeat_overlay_label.setGeometry(x, y, overlay_size, overlay_size)
                        self._repeat_overlay_label.show()
                        self._repeat_overlay_label.raise_()
                    except (RuntimeError, AttributeError):
                        pass  # Button or overlay might have been deleted
            
            # Update position immediately and on button resize
            QTimer.singleShot(0, update_overlay_position)
            # Also update when button is resized (if button has resizeEvent, we'd need to override it)
            # Use multiple delays to ensure button is fully rendered and positioned
            QTimer.singleShot(50, update_overlay_position)
            QTimer.singleShot(100, update_overlay_position)
            QTimer.singleShot(200, update_overlay_position)
        else:
            # Ensure overlay is removed for other modes
            if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label:
                self._repeat_overlay_label.hide()
    
    def _on_volume_click(self):
        """Handle volume button click."""
        if self.parent_window:
            # Pass the volume button so positioning can detect it's from a player widget
            self.parent_window.show_volume_control(auto_hide=True, delay_ms=1200, source_btn=self.volume_btn)
    
    def _on_progress_pressed(self):
        """Handle progress bar press."""
        self._progress_dragging = True
    
    def _on_progress_released(self):
        """Handle progress bar release - seek to position."""
        if self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            js_code = """
            (function() {
                var audio = document.querySelector('audio');
                if (audio && audio.duration) {
                    return audio.duration;
                }
                return 0;
            })();
            """
            def on_duration_received(duration):
                if duration and duration > 0:
                    slider_value = self.progress_bar.value()
                    seek_seconds = (slider_value / 1000.0) * duration
                    seek_js = f"""
                    (function() {{
                        var audio = document.querySelector('audio');
                        if (audio) {{
                            audio.currentTime = {seek_seconds};
                        }}
                    }})();
                    """
                    # Set seeking flag to prevent updates during seek
                    self._progress_seeking = True
                    self.parent_window.web_view.page().runJavaScript(seek_js)
                    # Keep dragging flag set briefly to prevent immediate updates
                    # Clear both flags after a short delay to allow seek to complete
                    QTimer.singleShot(300, lambda: setattr(self, '_progress_dragging', False))
                    QTimer.singleShot(300, lambda: setattr(self, '_progress_seeking', False))
            
            self.parent_window.web_view.page().runJavaScript(js_code, on_duration_received)
        else:
            self._progress_dragging = False
    
    def _on_progress_changed(self, value):
        """Handle progress bar value change (during drag)."""
        # Don't update webview during drag, only on release
        pass
    
    def _on_time_label_clicked(self, event):
        """Handle time label click - cycle display mode."""
        self.time_display_mode = (self.time_display_mode + 1) % 2
        if self.parent_window:
            self.parent_window.settings['time_display_mode'] = self.time_display_mode
            self.parent_window.save_settings()
        # Trigger update to refresh display
        self._update_playback_state()
    
    # Menu methods (reuse nano implementations)
    def _show_track_menu(self):
        """Show track menu with tracks from current album."""
        # Create dialog-based menu (reuse nano pattern)
        if not hasattr(self, '_track_menu_dialog') or not self._track_menu_dialog:
            self._track_menu_dialog = QDialog(self)
            self._track_menu_dialog.setWindowTitle("Tracks")
            self._track_menu_dialog.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Popup)
            self._track_menu_dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    border: 1px solid #4a90e2;
                    border-top: 1px solid #4a90e2;
                    border-right: 1px solid #4a90e2;
                    border-bottom: 1px solid #4a90e2;
                    border-left: 1px solid #4a90e2;
                }
            """)
            
            layout = QVBoxLayout(self._track_menu_dialog)
            layout.setContentsMargins(1, 1, 1, 1)  # 1px margin to account for border
            layout.setSpacing(0)
            
            self._track_list = QListWidget()
            self._track_list.setStyleSheet("""
                QListWidget {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: none;
                    font-size: 11px;
                }
                QListWidget::item {
                    padding: 2px 8px;
                    border: none;
                }
                QListWidget::item:selected {
                    background-color: #4a90e2;
                    color: #ffffff;
                }
                QListWidget::item:hover {
                    background-color: #3a3a3a;
                }
                QScrollBar:vertical {
                    background-color: #2b2b2b;
                    width: 10px;
                    margin: 0px;
                    border: none;
                }
                QScrollBar::handle:vertical {
                    background-color: #4a4a4a;
                    min-height: 20px;
                    border-radius: 5px;
                    margin: 2px;
                }
                QScrollBar::handle:vertical:hover {
                    background-color: #5a5a5a;
                }
                QScrollBar::handle:vertical:pressed {
                    background-color: #6a6a6a;
                }
                QScrollBar::add-line:vertical {
                    height: 0px;
                    subcontrol-position: bottom;
                    subcontrol-origin: margin;
                }
                QScrollBar::sub-line:vertical {
                    height: 0px;
                    subcontrol-position: top;
                    subcontrol-origin: margin;
                }
                QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                    background: none;
                }
            """)
            self._track_list.setSelectionMode(QListWidget.SelectionMode.NoSelection)
            self._track_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            # Enable mouse tracking for hover state detection
            self._track_list.setMouseTracking(True)
            # Enable tooltips
            self._track_list.setToolTipDuration(3000)  # Show tooltips for 3 seconds
            self._track_list.itemClicked.connect(self._on_track_menu_item_clicked)
            
            # Use TracklistDelegate for two-column layout (title on left, duration on right)
            track_delegate = TracklistDelegate()
            self._track_list.setItemDelegate(track_delegate)
            
            self._track_list.setMinimumHeight(100)
            self._track_list.setMaximumHeight(600)
            
            self._track_menu_dialog.setMinimumSize(200, 100)
            self._track_menu_dialog.setMaximumSize(400, 600)
            
            layout.addWidget(self._track_list)
            
            def on_track_menu_resize(event):
                if self._track_menu_dialog and self._track_list:
                    new_height = self._track_menu_dialog.height()
                    new_width = self._track_menu_dialog.width()
                    # Account for layout margins (1px on each side: 2px width, 2px height)
                    self._track_list.resize(new_width - 2, new_height - 2)
                    if self.parent_window:
                        self.parent_window.settings['track_menu_height'] = new_height
                        self.parent_window.save_settings()
                super(QDialog, self._track_menu_dialog).resizeEvent(event)
            
            self._track_menu_dialog.resizeEvent = on_track_menu_resize
        
        # Populate tracks
        self._track_list.clear()
        
        # Calculate button position BEFORE async call (like album menu does)
        # Check if this is being called from image viewer
        is_image_viewer = (hasattr(self, '_image_viewer_track_btn') and 
                          self.track_menu_btn == self._image_viewer_track_btn)
        
        if is_image_viewer:
            # Image viewer: always open upward from top of button
            btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().topLeft())
        else:
            # Regular player: use bottom of button (match album menu)
            btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
        
        # Get screen containing the button/widget (match album menu logic exactly)
        screen = None
        if self.track_menu_btn:
            # Try to get screen from the button's widget first
            screen = self.track_menu_btn.screen()
        if not screen and self.parent_window:
            # Fall back to parent window's screen
            screen = self.parent_window.screen()
        if not screen:
            # Final fallback to primary screen
            screen = QApplication.primaryScreen()
        
        # Store screen geometry for use in callback
        screen_geometry = None
        if screen:
            screen_geometry = screen.availableGeometry()
        
        if self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            js_code = """
            (function() {
                function cleanTrackTitle(text) {
                    if (!text) return '';
                    // Remove all time patterns (not just at end) - matches patterns like "00:00", "03:33", "00:00 03:33"
                    // Pattern: optional whitespace, digits, colon, digits, optional colon and digits, optional whitespace
                    text = text.replace(/\\s*\\d{1,2}:\\d{2}(?::\\d{2})?\\s*/g, ' ');
                    // Remove "lyrics" text (case-insensitive) - can appear anywhere
                    text = text.replace(/\\s*lyrics\\s*/gi, ' ');
                    // Remove any leading/trailing numbers with periods (like "01. " or "1. ")
                    text = text.replace(/^\\d+\\.\\s*/, '');
                    // Clean up multiple spaces and trim
                    text = text.replace(/\\s+/g, ' ').trim();
                    
                    // Remove duplicate title patterns - check if title has the same text before and after a dash
                    // This handles cases like "Swinging Home - Swinging Home" -> "Swinging Home"
                    // Try multiple dash types and spacing variations
                    var dashPatterns = [
                        /^(.+?)\\s*-\\s*\\1\\s*$/i,      // " - " (space dash space)
                        /^(.+?)\\s*\\s*\\1\\s*$/i,      // "  " (space en-dash space)
                        /^(.+?)\\s*\\s*\\1\\s*$/i,      // "  " (space em-dash space)
                        /^(.+?)-\\s*\\1\\s*$/i,          // "- " (dash space)
                        /^(.+?)\\s*-\\1\\s*$/i,          // " -" (space dash)
                        /^(.+?)\\s{2,}\\1\\s*$/i         // "  " (double space)
                    ];
                    for (var i = 0; i < dashPatterns.length; i++) {
                        var match = text.match(dashPatterns[i]);
                        if (match && match[1] && match[1].trim().length > 0) {
                            var cleaned = match[1].trim();
                            // Only use if it's shorter (meaning we removed a duplicate)
                            if (cleaned.length < text.length) {
                                text = cleaned;
                                break;
                            }
                        }
                    }
                    
                    return text;
                }
                
                var tracks = [];
                var tracklist = document.querySelector('#tracklist');
                if (tracklist) {
                    var trackElements = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                    
                    trackElements.forEach(function(trackEl, index) {
                        var trackNum = trackEl.getAttribute('data-num');
                        var trackIndex = trackNum ? parseInt(trackNum) - 1 : index;
                        
                        var infoDiv = trackEl.querySelector('.info');
                        var title = null;
                        
                        if (infoDiv) {
                            var titleSpan = infoDiv.querySelector('.title, span.title, a.title');
                            if (titleSpan) {
                                title = titleSpan.textContent.trim();
                                title = cleanTrackTitle(title);
                            } else {
                                var infoText = infoDiv.textContent.trim();
                                title = cleanTrackTitle(infoText);
                            }
                        }
                        
                        if (!title || title.length === 0) {
                            var titleEl = trackEl.querySelector('.track-title, .track_title, .title');
                            if (titleEl) {
                                title = titleEl.textContent.trim();
                                title = cleanTrackTitle(title);
                            }
                        }
                        
                        if (!title || title.length === 0) {
                            title = 'Track ' + (trackIndex + 1);
                        }
                        
                        // Check if track is playable
                        var isPlayable = false;
                        var playStatus = trackEl.querySelector('.play_status');
                        if (!playStatus) {
                            var playCol = trackEl.querySelector('td.play-col, .play-col');
                            if (playCol) {
                                playStatus = playCol.querySelector('.play_status');
                            }
                        }
                        if (playStatus) {
                            isPlayable = !playStatus.classList.contains('disabled');
                        } else {
                            isPlayable = trackEl.classList.contains('playable') || trackEl.classList.contains('has-audio');
                        }
                        
                        // Get duration if available - specifically look for .duration class element
                        var duration = null;
                        // First try to find the .duration element specifically (as user mentioned)
                        var durationEl = trackEl.querySelector('time.duration, .duration');
                        if (durationEl) {
                            var timeText = durationEl.textContent.trim();
                            // Only use if it looks like a time (contains colon or is a short number)
                            if (timeText.indexOf(':') !== -1 || (timeText.length <= 10 && /^[\d:\.]+$/.test(timeText))) {
                                duration = timeText;
                            }
                        }
                        // Fallback: look for other time elements if .duration not found
                        if (!duration) {
                            var timeEl = trackEl.querySelector('.time:not(.duration), .track-length, [class*="time"]:not([class*="title"]):not(.duration)');
                            if (timeEl) {
                                var timeText = timeEl.textContent.trim();
                                // Only use if it looks like a time (contains colon or is a short number)
                                if (timeText.indexOf(':') !== -1 || (timeText.length <= 10 && /^[\d:\.]+$/.test(timeText))) {
                                    duration = timeText;
                                }
                            }
                        }
                        
                        tracks.push({
                            index: trackIndex,
                            title: title,
                            dataNum: trackNum,
                            isPlayable: isPlayable,
                            duration: duration
                        });
                    });
                }
                return tracks;
            })();
            """
            def on_tracks_received(result):
                if result and isinstance(result, list):
                    self._track_data = {}
                    for track_info in result:
                        track_index = track_info.get('index', 0)
                        track_title = track_info.get('title', 'Track')
                        data_num = track_info.get('dataNum')
                        is_playable = track_info.get('isPlayable', True)
                        duration = track_info.get('duration', '')
                        
                        track_data = {'index': track_index, 'dataNum': data_num, 'isPlayable': is_playable}
                        
                        if data_num:
                            track_num = int(data_num)
                        else:
                            track_num = track_index + 1
                        
                        # Validate duration - only use if it looks like a time
                        validated_duration = None
                        if duration:
                            # Check if duration looks like a time (e.g., "3:45" or "12:34:56") or is a short number
                            is_valid_duration = (':' in duration) or (len(duration) <= 10 and duration.replace('.', '').replace(':', '').isdigit())
                            if is_valid_duration and track_title.lower() not in duration.lower():
                                validated_duration = duration
                        
                        # Display text is just the track number and title (duration will be shown in right column by delegate)
                        display_text = f"{track_num:02d}. {track_title}"
                        
                        item = QListWidgetItem(display_text)
                        # Store duration and full title in track_data so delegate can access it
                        track_data = {'index': track_index, 'dataNum': data_num, 'isPlayable': is_playable, 'duration': validated_duration, 'fullTitle': track_title}
                        item.setData(Qt.ItemDataRole.UserRole, track_data)
                        item.setData(Qt.ItemDataRole.UserRole + 1, False)
                        
                        # Grey out unplayable tracks
                        if not is_playable:
                            item.setForeground(QColor("#888888"))
                            item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEnabled)
                        
                        self._track_list.addItem(item)
                        self._track_data[track_index] = track_title
                    
                    self._track_list.clearSelection()
                    self._track_list.setCurrentItem(None)
                    
                    if self._current_track_number is not None:
                        self._highlight_current_track_menu()
                    
                    # Position and show dialog (using button position calculated before async call)
                    item_count = len(result)
                    if item_count > 0 and screen_geometry:
                        space_above = btn_pos.y() - screen_geometry.top()
                        space_below = screen_geometry.bottom() - btn_pos.y()
                        
                        # Use saved height if available, otherwise calculate based on available space (match album menu)
                        saved_height = self.parent_window.settings.get('track_menu_height', None) if self.parent_window else None
                        if saved_height and saved_height >= 100:
                            dialog_height = max(100, min(saved_height, 600))
                        else:
                            # Default to 300px or available space, whichever is smaller
                            dialog_height = min(300, max(space_above, space_below) - 5)
                            dialog_height = max(100, min(dialog_height, 600))
                        
                        self._track_menu_dialog.resize(250, dialog_height)
                        # Account for layout margins (1px left + 1px right = 2px) when resizing list
                        self._track_list.resize(250 - 2, dialog_height - 2)
                        
                        # Position dialog (open upward for regular/mini/micro mode, like album menu)
                        if is_image_viewer:
                            # Always open upward for image viewer
                            dialog_y = btn_pos.y() - dialog_height - 2
                        elif space_above >= dialog_height + 5:
                            # Open upward if there's enough space above (preferred for regular/mini/micro mode)
                            dialog_y = btn_pos.y() - dialog_height - 2
                        else:
                            # Not enough space above, open downward as fallback
                            dialog_y = btn_pos.y() + 2
                        
                        # Always align with button's left edge (like album menu)
                        dialog_x = btn_pos.x()
                        # Only adjust if it would go off the right edge of screen
                        if dialog_x + 250 > screen_geometry.right():
                            dialog_x = screen_geometry.right() - 250
                        # Only adjust if it would go off the left edge of screen
                        if dialog_x < screen_geometry.left():
                            dialog_x = screen_geometry.left()
                        
                        self._track_menu_dialog.move(dialog_x, dialog_y)
                        
                        # Prevent autohide while menu is open
                        self._menu_open = True
                        self._cancel_autohide_timer()
                        self._show_player_section()  # Ensure player is visible
                        
                        # Store reference for image viewer menu tracking
                        if hasattr(self, '_image_viewer_controls') and self._image_viewer_controls:
                            self._image_viewer_controls['menu_open'] = True
                        
                        # Show dialog and reposition to ensure it's at the correct location
                        self._track_menu_dialog.show()
                        # Reposition after showing to ensure correct placement
                        self._track_menu_dialog.move(dialog_x, dialog_y)
                        self._track_menu_dialog.exec()  # Blocking call
                        
                        # Allow autohide to resume after menu closes
                        self._menu_open = False
                        if hasattr(self, '_image_viewer_controls') and self._image_viewer_controls:
                            self._image_viewer_controls['menu_open'] = False
            
            self.parent_window.web_view.page().runJavaScript(js_code, on_tracks_received)
    
    def _highlight_current_track_menu(self):
        """Highlight current track in menu."""
        if not hasattr(self, '_track_list') or not self._track_list:
            return
        
        for i in range(self._track_list.count()):
            item = self._track_list.item(i)
            if item:
                track_data = item.data(Qt.ItemDataRole.UserRole)
                if track_data:
                    track_index = track_data.get('index')
                    data_num = track_data.get('dataNum')
                    if self._current_track_number is not None:
                        # Ensure _current_track_number is int for arithmetic
                        try:
                            current_track_num = int(self._current_track_number)
                            if data_num and int(data_num) == current_track_num:
                                item.setData(Qt.ItemDataRole.UserRole + 1, True)
                            elif track_index == current_track_num - 1:
                                item.setData(Qt.ItemDataRole.UserRole + 1, True)
                            else:
                                item.setData(Qt.ItemDataRole.UserRole + 1, False)
                        except (ValueError, TypeError):
                            item.setData(Qt.ItemDataRole.UserRole + 1, False)
                    else:
                        item.setData(Qt.ItemDataRole.UserRole + 1, False)
        self._track_list.viewport().update()
    
    def _on_track_menu_item_clicked(self, item):
        """Handle track menu item click - play track."""
        if not item or not self.parent_window:
            return
        
        track_data = item.data(Qt.ItemDataRole.UserRole)
        if not track_data:
            return
        
        is_playable = track_data.get('isPlayable', True)
        if not is_playable:
            return
        
        track_index = track_data.get('index', 0)
        data_num = track_data.get('dataNum')
        
        # Play track via JavaScript (same as nano)
        js_code = f"""
        (function() {{
            var tracklist = document.querySelector('#tracklist');
            if (!tracklist) {{
                return;
            }}
            
            var targetTrack = null;
            var dataNum = {repr(data_num) if data_num else 'null'};
            
            if (dataNum !== null) {{
                targetTrack = tracklist.querySelector('li.track[data-num="' + dataNum + '"]');
            }}
            
            if (!targetTrack) {{
                var tracks = tracklist.querySelectorAll('li.track');
                if (tracks.length > {track_index}) {{
                    targetTrack = tracks[{track_index}];
                }}
            }}
            
            if (targetTrack) {{
                var infoDiv = targetTrack.querySelector('.info');
                if (infoDiv) {{
                    infoDiv.click();
                }} else {{
                    targetTrack.click();
                }}
            }}
        }})();
        """
        self.parent_window.web_view.page().runJavaScript(js_code)
        self._track_menu_dialog.close()
    
    def _show_album_menu(self):
        """Show album menu with playlist contents."""
        # Create dialog-based menu (reuse nano pattern)
        if not hasattr(self, '_album_menu_dialog') or not self._album_menu_dialog:
            self._album_menu_dialog = QDialog(self)
            self._album_menu_dialog.setWindowTitle("Playlist")
            self._album_menu_dialog.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Popup)
            self._album_menu_dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    border: 1px solid #4a90e2;
                    border-top: 1px solid #4a90e2;
                    border-right: 1px solid #4a90e2;
                    border-bottom: 1px solid #4a90e2;
                    border-left: 1px solid #4a90e2;
                }
            """)
            
            layout = QVBoxLayout(self._album_menu_dialog)
            layout.setContentsMargins(1, 1, 1, 1)  # 1px margin to account for border
            layout.setSpacing(0)
            
            self._album_list = QListWidget()
            
            # Apply Windows 11 detection for consistent spacing
            is_windows_11 = self._detect_windows_11()
            if is_windows_11:
                item_padding = "0px 8px"
                item_min_height = "min-height: 18px;"
            else:
                item_padding = "2px 8px"
                item_min_height = ""
            
            album_stylesheet = """
                QListWidget {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: none;
                    font-size: 11px;
                }
                QListWidget::item {
                    padding: """ + item_padding + """;
                    border: none;
                    """ + item_min_height + """
                }
                QListWidget::item:selected {
                    background-color: #4a90e2;
                    color: #ffffff;
                }
                QListWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """
            self._album_list.setStyleSheet(album_stylesheet)
            self._album_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
            # Disable drag and drop in albumlist menu to allow tooltips to work properly
            # (Drag and drop is still available in the playlist sidebar)
            self._album_list.setDragDropMode(QListWidget.DragDropMode.NoDragDrop)
            self._album_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            # Enable mouse tracking for hover state detection and tooltips
            self._album_list.setMouseTracking(True)
            # Enable tooltips
            self._album_list.setToolTipDuration(3000)  # Show tooltips for 3 seconds
            # Ensure tooltips are always shown when needed (even if widget has focus)
            self._album_list.setAttribute(Qt.WidgetAttribute.WA_AlwaysShowToolTips, True)
            self._album_list.itemClicked.connect(self._on_album_menu_item_clicked)
            
            album_delegate = NanoMenuDelegate()
            self._album_list.setItemDelegate(album_delegate)
            
            # Add scrollbar styling to match playlist
            current_style = self._album_list.styleSheet()
            scrollbar_style = """
                QScrollBar:vertical {
                    background-color: #2b2b2b;
                    width: 10px;
                    margin: 0px;
                    border: none;
                }
                QScrollBar::handle:vertical {
                    background-color: #4a4a4a;
                    min-height: 20px;
                    border-radius: 5px;
                    margin: 2px;
                }
                QScrollBar::handle:vertical:hover {
                    background-color: #5a5a5a;
                }
                QScrollBar::handle:vertical:pressed {
                    background-color: #6a6a6a;
                }
                QScrollBar::add-line:vertical {
                    height: 0px;
                    subcontrol-position: bottom;
                    subcontrol-origin: margin;
                }
                QScrollBar::sub-line:vertical {
                    height: 0px;
                    subcontrol-position: top;
                    subcontrol-origin: margin;
                }
                QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                    background: none;
                }
            """
            self._album_list.setStyleSheet(current_style + scrollbar_style)
            
            # Drag and drop disabled in albumlist menu to allow tooltips to work properly
            # (Drag and drop is still available in the playlist sidebar)
            self._album_list.setAcceptDrops(False)
            
            layout.addWidget(self._album_list)
        
        # Populate from playlist manager
        self._album_list.clear()
        if self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
            playlist = self.parent_window.playlist_manager.get_playlist()
            current_url = self.parent_window.web_view.url().toString() if self.parent_window.web_view else None
            
            # Normalize URL for comparison (same logic as nano mode and playlist sidebar)
            def normalize_url(u):
                if not u:
                    return ""
                u = u.strip().rstrip('/')
                # Remove query parameters and fragments for comparison
                if '?' in u:
                    u = u.split('?')[0]
                if '#' in u:
                    u = u.split('#')[0]
                if u.startswith('http://'):
                    u = 'https://' + u[7:]
                return u.lower()
            
            normalized_current_url = normalize_url(current_url) if current_url else None
            
            for url in playlist:
                # Use get_url_display_text which checks saved metadata first (preferred - has correct formatting from page)
                display_text = None
                if hasattr(self.parent_window.playlist_manager, 'get_url_display_text'):
                    display_text = self.parent_window.playlist_manager.get_url_display_text(url)
                
                # Fall back to URL extraction only if no saved metadata
                if not display_text:
                    # Try to extract "album by artist" format from URL
                    if self.parent_window and hasattr(self.parent_window, 'extract_artist_album_from_url'):
                        extracted = self.parent_window.extract_artist_album_from_url(url)
                        if extracted:
                            # extract_artist_album_from_url now returns "Album by Artist" format
                            display_text = extracted
                        else:
                            # Fallback: just use URL filename
                            display_text = url.split('/')[-1] if '/' in url else url
                            # Remove query parameters for cleaner display
                            if '?' in display_text:
                                display_text = display_text.split('?')[0]
                    else:
                        # Fallback: just use URL filename
                        display_text = url.split('/')[-1] if '/' in url else url
                        # Remove query parameters for cleaner display
                        if '?' in display_text:
                            display_text = display_text.split('?')[0]
                
                item_widget = QListWidgetItem(display_text)
                item_widget.setData(Qt.ItemDataRole.UserRole, url)
                # Store full display text separately for tooltip (similar to tracklist menu)
                # Ensure we store a string (not None) for the tooltip
                if display_text:
                    item_widget.setData(Qt.ItemDataRole.UserRole + 2, str(display_text))
                # Don't set tooltip directly on item - let delegate handle it
                item_widget.setToolTip("")
                
                # Mark current album with blue text (same as playlist tracklist)
                # Use normalized URL comparison for reliable matching
                normalized_item_url = normalize_url(url)
                if normalized_current_url and normalized_item_url == normalized_current_url:
                    item_widget.setData(Qt.ItemDataRole.UserRole + 1, True)
                else:
                    item_widget.setData(Qt.ItemDataRole.UserRole + 1, False)  # Not current
                
                self._album_list.addItem(item_widget)
            
            # Position and show dialog
            # Check if this is being called from image viewer (button has specific tooltip or is in image viewer)
            is_image_viewer = (hasattr(self, '_image_viewer_album_btn') and 
                              self.album_menu_btn == self._image_viewer_album_btn)
            
            if is_image_viewer:
                # Image viewer: always open upward from top of button
                btn_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().topLeft())
            else:
                # Regular player: use bottom of button
                btn_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().bottomLeft())
            
            # Get screen containing the main window (not just primary screen)
            screen = None
            if self.parent_window:
                screen = self.parent_window.screen()
            if not screen:
                screen = QApplication.primaryScreen()
            if screen:
                screen_geometry = screen.availableGeometry()
                space_above = btn_pos.y() - screen_geometry.top()
                space_below = screen_geometry.bottom() - btn_pos.y()
                
                # Use saved height if available, otherwise calculate based on available space
                saved_height = self.parent_window.settings.get('album_menu_height', None) if self.parent_window else None
                if saved_height and saved_height >= 100:
                    dialog_height = max(100, min(saved_height, 600))
                else:
                    # Default to 300px or available space, whichever is smaller
                    dialog_height = min(300, max(space_above, space_below) - 5)
                    dialog_height = max(100, min(dialog_height, 600))
                
                self._album_menu_dialog.resize(250, dialog_height)
                
                if is_image_viewer:
                    # Always open upward for image viewer
                    dialog_y = btn_pos.y() - dialog_height - 2
                elif space_above >= space_below:
                    dialog_y = btn_pos.y() - dialog_height - 2
                else:
                    dialog_y = btn_pos.y() + 2
                
                dialog_x = btn_pos.x()
                if dialog_x + 250 > screen_geometry.right():
                    dialog_x = screen_geometry.right() - 250
                if dialog_x < screen_geometry.left():
                    dialog_x = screen_geometry.left()
                
                self._album_menu_dialog.move(dialog_x, dialog_y)
                
                # Prevent autohide while menu is open
                self._menu_open = True
                self._cancel_autohide_timer()
                self._show_player_section()  # Ensure player is visible
                
                self._album_menu_dialog.show()
                # Update list widget after showing to ensure highlighting is visible
                # Defer update to next event loop cycle
                if self._album_list:
                    QTimer.singleShot(0, lambda: self._album_list.update() if self._album_list else None)
                    self._album_list.viewport().update()
                self._album_menu_dialog.exec()  # Blocking call
                
                # Allow autohide to resume after menu closes
                self._menu_open = False
    
    def _on_album_menu_item_clicked(self, item):
        """Handle album menu item click - load album."""
        if not item or not self.parent_window:
            return
        
        url = item.data(Qt.ItemDataRole.UserRole)
        if url and hasattr(self.parent_window, 'load_url'):
            self.parent_window.load_url(url)
        self._album_menu_dialog.close()
    
    def _show_album_context_menu(self, pos):
        """Show album context menu."""
        # Placeholder - can be implemented later if needed
        pass
    
    def _on_cover_art_clicked(self):
        """Handle cover art click - open Qt-based image viewer."""
        print("[COVER ART CLICK] Signal received!")
        logger.debug("Cover art clicked!")
        if not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            logger.debug("Cover art click: No cover_art_label")
            return
        
        # Get the current pixmap from the cover art label
        pixmap = self.cover_art_label.pixmap()
        print(f"[COVER ART CLICK] Pixmap check: pixmap={pixmap}, isNull={pixmap.isNull() if pixmap else 'N/A'}")
        if not pixmap or pixmap.isNull():
            print("[COVER ART CLICK] No pixmap available in label")
            logger.debug("Cover art click: No pixmap available in label")
            return
        
        print(f"[COVER ART CLICK] Opening dialog with pixmap {pixmap.width()}x{pixmap.height()}")
        logger.debug(f"Cover art click: Opening dialog with pixmap {pixmap.width()}x{pixmap.height()}")
        
        # Create a Qt dialog to show the image
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton
        # Qt is already imported at the top of the file
        
        dialog = QDialog(self.parent_window if self.parent_window else None)
        dialog.setWindowTitle("Cover Art")
        # Set window flags to make it frameless, stay on top, and be a tool window
        dialog.setWindowFlags(
            Qt.WindowType.FramelessWindowHint | 
            Qt.WindowType.WindowStaysOnTopHint |
            Qt.WindowType.Tool
        )
        # Ensure dialog captures all mouse events (prevents right-click from passing through)
        dialog.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        
        # Install event filter to block right-click events from passing through
        # We'll accept press events but close on release, so the click "lands" on the dialog
        class RightClickEventFilter(QObject):
            def __init__(self, dialog_ref):
                super().__init__()
                self.dialog_ref = dialog_ref
                self.right_click_pressed = False
            
            def eventFilter(self, obj, event):
                if event.type() == QEvent.Type.MouseButtonPress:
                    if event.button() == Qt.MouseButton.RightButton:
                        event.accept()
                        self.right_click_pressed = True
                        return True  # Event handled, don't propagate
                    # Middle-click is handled by image label, not here
                elif event.type() == QEvent.Type.MouseButtonRelease:
                    if event.button() == Qt.MouseButton.RightButton:
                        event.accept()
                        if self.right_click_pressed:
                            # Close on release, so the click "lands" first
                            QTimer.singleShot(0, self.dialog_ref.close)
                            self.right_click_pressed = False
                        return True  # Event handled, don't propagate
                    # Middle-click is handled by image label, not here
                return False  # Let other events through
        
        right_click_filter = RightClickEventFilter(dialog)
        dialog.installEventFilter(right_click_filter)
        
        layout = QVBoxLayout(dialog)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Get screen from parent window (same monitor as main window)
        screen = None
        if self.parent_window:
            screen = self.parent_window.screen()
        if not screen:
            # Fallback to screen at parent window position
            if self.parent_window:
                screen = QApplication.screenAt(self.parent_window.pos())
        if not screen:
            # Final fallback to primary screen
            screen = QApplication.primaryScreen()
        
        # Calculate initial dialog size (max 90% of screen size)
        if screen:
            screen_size = screen.availableGeometry().size()
            max_width = int(screen_size.width() * 0.9)
            max_height = int(screen_size.height() * 0.9)
            
            # Scale pixmap maintaining aspect ratio for initial dialog size
            scaled_pixmap = pixmap.scaled(
                max_width, max_height,
                Qt.AspectRatioMode.KeepAspectRatio,
                Qt.TransformationMode.SmoothTransformation
            )
            dialog.resize(scaled_pixmap.size())
        else:
            dialog.resize(pixmap.size())
        
        # Zoomable image viewer (replaces simple QLabel)
        image_label = ZoomableImageViewer()
        # Store screen reference for fullscreen detection
        image_label._screen_ref = screen
        layout.addWidget(image_label)
        
        # Store reference to dialog and image_label in parent window for updates
        if self.parent_window:
            if not hasattr(self.parent_window, '_image_viewer_dialog'):
                self.parent_window._image_viewer_dialog = None
                self.parent_window._image_viewer_image_label = None
            self.parent_window._image_viewer_dialog = dialog
            self.parent_window._image_viewer_image_label = image_label
        
        # Set pixmap after adding to layout so label knows its size for fill zoom calculation
        # Use a timer to ensure the label is properly sized before calculating fill zoom
        def setup_image():
            image_label.setPixmap(pixmap)  # Set original pixmap (will calculate fill zoom)
        QTimer.singleShot(0, setup_image)
        
        # Create floating player controls bar
        controls_widget = QWidget(dialog)
        controls_widget.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        controls_widget.setAutoFillBackground(False)
        
        # Override paintEvent to draw semi-transparent background
        original_controls_paint = controls_widget.paintEvent
        def controls_paint_event(event):
            painter = QPainter(controls_widget)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            rect = controls_widget.rect()
            painter.setBrush(QBrush(QColor(0, 0, 0, 180)))  # Semi-transparent black background
            painter.setPen(QPen(QColor(255, 255, 255, 30), 1))  # Subtle border
            painter.drawRoundedRect(rect.adjusted(0, 0, -1, -1), 8, 8)
            painter.end()
            if original_controls_paint:
                original_controls_paint(event)
        
        controls_widget.paintEvent = controls_paint_event
        
        controls_layout = QVBoxLayout(controls_widget)
        controls_layout.setContentsMargins(15, 10, 15, 10)
        controls_layout.setSpacing(8)
        
        # Button style matching existing buttons (larger for image viewer)
        button_style = """
            QPushButton {
                background-color: rgba(21, 21, 21, 0.85);
                color: #e0e0e0;
                border: 1px solid rgba(176, 176, 176, 0.3);
                border-radius: 14px;
                font-size: 12px;
                padding: 0px;
                min-width: 28px;
                min-height: 28px;
            }
            QPushButton:hover {
                background-color: rgba(43, 43, 43, 0.9);
                border-color: rgba(176, 176, 176, 0.5);
                color: #ffffff;
            }
            QPushButton:checked {
                background-color: rgba(74, 144, 226, 0.3);
                border-color: rgba(74, 144, 226, 0.6);
                color: #4a90e2;
            }
        """
        
        # Controls row
        controls_row = QHBoxLayout()
        controls_row.setSpacing(2)  # Reduced spacing for tighter button layout
        controls_row.setContentsMargins(0, 0, 0, 0)
        
        # Previous album button
        prev_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-backward', color='#e0e0e0')
            if icon:
                prev_album_btn.setIcon(icon)
            else:
                prev_album_btn.setText("")
        else:
            prev_album_btn.setText("")
        prev_album_btn.setToolTip("Previous album")
        prev_album_btn.setFixedSize(28, 28)  # Larger buttons for image viewer
        prev_album_btn.setStyleSheet(button_style)
        if self.parent_window and hasattr(self.parent_window, 'playlist_sidebar'):
            def on_prev_album():
                if not hasattr(self.parent_window, 'playlist_sidebar') or self.parent_window.playlist_sidebar is None:
                    if hasattr(self.parent_window, 'toggle_playlist'):
                        was_visible = False
                        if hasattr(self.parent_window, 'settings'):
                            was_visible = self.parent_window.settings.get('playlist_visible', False)
                        self.parent_window.toggle_playlist()
                        if not was_visible and hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                            self.parent_window.playlist_sidebar.hide()
                if hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                    self.parent_window.playlist_sidebar.load_previous_album()
            prev_album_btn.clicked.connect(on_prev_album)
        controls_row.addWidget(prev_album_btn)
        
        # Previous track button
        prev_track_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('backward', color='#e0e0e0')
            if icon:
                prev_track_btn.setIcon(icon)
            else:
                prev_track_btn.setText("")
        else:
            prev_track_btn.setText("")
        prev_track_btn.setToolTip("Previous Track")
        prev_track_btn.setFixedSize(28, 28)  # Larger buttons for image viewer
        prev_track_btn.setStyleSheet(button_style)
        if self.parent_window and hasattr(self.parent_window, '_trigger_previous_track'):
            prev_track_btn.clicked.connect(self.parent_window._trigger_previous_track)
        controls_row.addWidget(prev_track_btn)
        
        # Play/Pause button (with animated border for buffering)
        play_pause_btn = AnimatedPlayButton()
        if HAS_QT_AWESOME:
            icon = get_icon('play', color='#e0e0e0')
            if icon:
                play_pause_btn.setIcon(icon)
            else:
                play_pause_btn.setText("")
        else:
            play_pause_btn.setText("")
        play_pause_btn.setToolTip("Play/Pause")
        play_pause_btn.setFixedSize(28, 28)  # Larger buttons for image viewer
        play_pause_btn.setStyleSheet(button_style)
        if self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            def on_play_pause():
                js_code = """
                (function() {
                    var audio = document.querySelector('audio');
                    if (audio && audio.readyState >= 2) {
                        if (audio.paused) {
                            var playPromise = audio.play();
                            if (playPromise !== undefined) {
                                playPromise.catch(function(error) {
                                    var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                                    if (playBtn) {
                                        playBtn.click();
                                    }
                                });
                            }
                        } else {
                            audio.pause();
                        }
                    } else {
                        var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                        if (playBtn) {
                            playBtn.click();
                        }
                    }
                })();
                """
                self.parent_window.web_view.page().runJavaScript(js_code)
            play_pause_btn.clicked.connect(on_play_pause)
        controls_row.addWidget(play_pause_btn)
        
        # Next track button
        next_track_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('forward', color='#e0e0e0')
            if icon:
                next_track_btn.setIcon(icon)
            else:
                next_track_btn.setText("")
        else:
            next_track_btn.setText("")
        next_track_btn.setToolTip("Next Track")
        next_track_btn.setFixedSize(28, 28)  # Larger buttons for image viewer
        next_track_btn.setStyleSheet(button_style)
        if self.parent_window and hasattr(self.parent_window, '_trigger_next_track'):
            next_track_btn.clicked.connect(self.parent_window._trigger_next_track)
        controls_row.addWidget(next_track_btn)
        
        # Next album button
        next_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-forward', color='#e0e0e0')
            if icon:
                next_album_btn.setIcon(icon)
            else:
                next_album_btn.setText("")
        else:
            next_album_btn.setText("")
        next_album_btn.setToolTip("Next album")
        next_album_btn.setFixedSize(28, 28)  # Larger buttons for image viewer
        next_album_btn.setStyleSheet(button_style)
        if self.parent_window and hasattr(self.parent_window, 'playlist_sidebar'):
            def on_next_album():
                if not hasattr(self.parent_window, 'playlist_sidebar') or self.parent_window.playlist_sidebar is None:
                    if hasattr(self.parent_window, 'toggle_playlist'):
                        was_visible = False
                        if hasattr(self.parent_window, 'settings'):
                            was_visible = self.parent_window.settings.get('playlist_visible', False)
                        self.parent_window.toggle_playlist()
                        if not was_visible and hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                            self.parent_window.playlist_sidebar.hide()
                if hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                    self.parent_window.playlist_sidebar.load_next_album()
            next_album_btn.clicked.connect(on_next_album)
        controls_row.addWidget(next_album_btn)
        
        controls_row.addSpacing(2)  # Reduced spacing between navigation and utility buttons
        
        # Shuffle button
        shuffle_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('random', color='#a0a0a0')
            if icon:
                shuffle_btn.setIcon(icon)
            else:
                shuffle_btn.setText("")
        else:
            shuffle_btn.setText("")
        shuffle_btn.setToolTip("Shuffle: Off")
        shuffle_btn.setFixedSize(28, 28)  # Larger buttons for image viewer
        shuffle_btn.setCheckable(True)
        shuffle_btn.setStyleSheet(button_style)
        if self.parent_window and hasattr(self.parent_window, 'toggle_shuffle'):
            shuffle_btn.clicked.connect(self.parent_window.toggle_shuffle)
        controls_row.addWidget(shuffle_btn)
        
        # Repeat button
        repeat_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.repeat', color='#a0a0a0')
            if icon:
                repeat_btn.setIcon(icon)
            else:
                repeat_btn.setText("")
        else:
            repeat_btn.setText("")
        repeat_btn.setToolTip("Repeat: Off")
        repeat_btn.setFixedSize(28, 28)  # Larger buttons for image viewer
        repeat_btn.setCheckable(True)
        repeat_btn.setStyleSheet(button_style)
        if self.parent_window and hasattr(self.parent_window, 'toggle_repeat'):
            repeat_btn.clicked.connect(self.parent_window.toggle_repeat)
        controls_row.addWidget(repeat_btn)
        
        # Volume button
        volume_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('volume-up', color='#e0e0e0')
            if icon:
                volume_btn.setIcon(icon)
            else:
                volume_btn.setText("")
        else:
            volume_btn.setText("")
        volume_btn.setToolTip("Volume")
        volume_btn.setFixedSize(28, 28)  # Larger buttons for image viewer
        volume_btn.setStyleSheet(button_style)
        if self.parent_window and hasattr(self.parent_window, 'show_volume_control'):
            volume_btn.clicked.connect(lambda: self.parent_window.show_volume_control(auto_hide=True, delay_ms=1200, source_btn=volume_btn))
        controls_row.addWidget(volume_btn)
        
        controls_layout.addLayout(controls_row)
        
        # Album button row (above controls)
        album_row = QHBoxLayout()
        album_row.setSpacing(8)
        album_row.setContentsMargins(0, 0, 0, 0)
        
        # Albumlist button (will show current album)
        albumlist_btn = QPushButton("Albums")
        albumlist_btn.setToolTip("Album List")
        albumlist_btn.setMinimumHeight(22)
        albumlist_btn.setMaximumHeight(22)
        # Use Expanding size policy to maintain full width (image viewer buttons should not resize)
        albumlist_btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        albumlist_btn.setStyleSheet(button_style)
        
        # Create a custom paint event that clips text cleanly - centered, but overflows to right only
        def paint_album_with_clipping(event):
            painter = QPainter(albumlist_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            option = QStyleOptionButton()
            albumlist_btn.initStyleOption(option)
            # Draw button background and bevel
            albumlist_btn.style().drawControl(QStyle.ControlElement.CE_PushButtonBevel, option, painter, albumlist_btn)
            # Clip to button rectangle to hide overflow cleanly
            painter.setClipRect(albumlist_btn.rect())
            # Draw text - centered if it fits, otherwise left-aligned with elision on right
            text_rect = albumlist_btn.rect().adjusted(15, 2, -15, -2)  # Left 10px padding, right 15px margin for elision
            text = albumlist_btn.text()
            font = albumlist_btn.font()
            font.setPixelSize(12)  # Match button style font size
            painter.setFont(font)
            painter.setPen(QColor("#e0e0e0"))
            font_metrics = QFontMetrics(font)
            text_width = font_metrics.horizontalAdvance(text)
            # If text fits, center it; otherwise left-align with elision on right
            if text_width <= text_rect.width():
                # Text fits - center it
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter, text)
            else:
                # Text too long - left-align with elision on right (start always visible)
                elided_text = font_metrics.elidedText(text, Qt.TextElideMode.ElideRight, text_rect.width())
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)
        albumlist_btn.paintEvent = paint_album_with_clipping
        
        # Store reference to image viewer button for width update checks
        self._image_viewer_album_btn = albumlist_btn
        
        # Custom handler to show album menu opening upward
        def show_album_menu_upward():
            nonlocal menu_open
            if hasattr(self, '_show_album_menu'):
                # Temporarily replace album_menu_btn with image viewer button
                # The _show_album_menu method will detect this and open upward
                original_btn = getattr(self, 'album_menu_btn', None)
                self.album_menu_btn = albumlist_btn
                
                # Set menu open flag and show controls
                menu_open = True
                if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                    self.parent_window._image_viewer_controls['menu_open'] = True
                show_controls()
                
                self._show_album_menu()
                
                # Menu closed, reset flag
                menu_open = False
                if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                    self.parent_window._image_viewer_controls['menu_open'] = False
                
                # Restore original button
                if original_btn:
                    self.album_menu_btn = original_btn
        
        albumlist_btn.clicked.connect(show_album_menu_upward)
        album_row.addWidget(albumlist_btn)
        
        controls_layout.insertLayout(0, album_row)  # Insert at the beginning
        
        # Track button row (above controls, below album)
        track_row = QHBoxLayout()
        track_row.setSpacing(8)
        track_row.setContentsMargins(0, 0, 0, 0)
        
        # Tracklist button (will show current track)
        tracklist_btn = QPushButton("Tracks")
        tracklist_btn.setToolTip("Track List")
        tracklist_btn.setMinimumHeight(22)
        tracklist_btn.setMaximumHeight(22)
        # Use Expanding size policy to maintain full width (image viewer buttons should not resize)
        tracklist_btn.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        tracklist_btn.setStyleSheet(button_style)
        
        # Create a custom paint event that clips text cleanly - centered, but overflows to right only
        def paint_track_with_clipping(event):
            painter = QPainter(tracklist_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            option = QStyleOptionButton()
            tracklist_btn.initStyleOption(option)
            # Draw button background and bevel
            tracklist_btn.style().drawControl(QStyle.ControlElement.CE_PushButtonBevel, option, painter, tracklist_btn)
            # Clip to button rectangle to hide overflow cleanly
            painter.setClipRect(tracklist_btn.rect())
            # Draw text - centered if it fits, otherwise left-aligned with elision on right
            text_rect = tracklist_btn.rect().adjusted(15, 2, -15, -2)  # Left 10px padding, right 15px margin for elision
            text = tracklist_btn.text()
            font = tracklist_btn.font()
            font.setPixelSize(12)  # Match button style font size
            painter.setFont(font)
            painter.setPen(QColor("#e0e0e0"))
            font_metrics = QFontMetrics(font)
            text_width = font_metrics.horizontalAdvance(text)
            # If text fits, center it; otherwise left-align with elision on right
            if text_width <= text_rect.width():
                # Text fits - center it
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter, text)
            else:
                # Text too long - left-align with elision on right (start always visible)
                elided_text = font_metrics.elidedText(text, Qt.TextElideMode.ElideRight, text_rect.width())
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)
        tracklist_btn.paintEvent = paint_track_with_clipping
        
        # Store reference to image viewer button for width update checks
        self._image_viewer_track_btn = tracklist_btn
        
        # Custom handler to show track menu opening upward
        def show_track_menu_upward():
            nonlocal menu_open
            if hasattr(self, '_show_track_menu'):
                # Temporarily replace track_menu_btn with image viewer button
                # The _show_track_menu method will detect this and open upward
                original_btn = getattr(self, 'track_menu_btn', None)
                self.track_menu_btn = tracklist_btn
                
                # Set menu open flag and show controls
                menu_open = True
                if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                    self.parent_window._image_viewer_controls['menu_open'] = True
                show_controls()
                
                self._show_track_menu()
                
                # Menu closed, reset flag
                menu_open = False
                if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                    self.parent_window._image_viewer_controls['menu_open'] = False
                
                # Restore original button
                if original_btn:
                    self.track_menu_btn = original_btn
        
        tracklist_btn.clicked.connect(show_track_menu_upward)
        track_row.addWidget(tracklist_btn)
        
        controls_layout.insertLayout(1, track_row)  # Insert after album row
        
        # Progress bar row with time labels (like regular mode)
        progress_row = QHBoxLayout()
        progress_row.setSpacing(4)
        progress_row.setContentsMargins(0, 0, 0, 0)
        
        # Elapsed time label (left)
        time_elapsed_label = QLabel("00:00")
        time_elapsed_label.setStyleSheet("""
            QLabel {
                color: #e0e0e0;
                font-size: 11px;
                padding: 2px 4px;
                background-color: transparent;
                border: none;
            }
            QLabel:hover {
                background-color: transparent;
                border: 1px solid rgba(74, 144, 226, 0.4);
                border-radius: 3px;
            }
        """)
        font_metrics = QFontMetrics(time_elapsed_label.font())
        # Account for longer times like "99:59" to prevent cutoff
        text_width = max(font_metrics.horizontalAdvance("00:00"), font_metrics.horizontalAdvance("99:59"))
        time_elapsed_label.setMinimumWidth(text_width + 12)  # Extra padding to prevent cutoff
        time_elapsed_label.setMaximumWidth(text_width + 12)
        time_elapsed_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        time_elapsed_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)
        progress_row.addWidget(time_elapsed_label, 0)
        
        # Progress bar (center, stretches to fill available space)
        progress_bar = QSlider(Qt.Orientation.Horizontal)
        progress_bar.setMinimum(0)
        progress_bar.setMaximum(1000)
        progress_bar.setValue(0)
        progress_bar.setFixedHeight(5)
        progress_bar.setStyleSheet("""
            QSlider {
                background: transparent;
                border: none;
            }
            QSlider::groove:horizontal {
                background: rgba(150, 150, 150, 0.3);
                height: 5px;
                border-radius: 2px;
                border: none;
            }
            QSlider::handle:horizontal {
                background: rgba(224, 224, 224, 0.9);
                width: 12px;
                height: 12px;
                margin: -3px 0;
                border-radius: 6px;
                border: 1px solid rgba(176, 176, 176, 0.5);
            }
            QSlider::handle:horizontal:hover {
                background: rgba(255, 255, 255, 1.0);
                border: 1px solid rgba(224, 224, 224, 0.8);
            }
            QSlider::sub-page:horizontal {
                background: rgba(74, 144, 226, 0.7);
                border-radius: 2px;
            }
        """)
        progress_row.addWidget(progress_bar, 1)  # Stretch to fill space
        
        # Total/remaining time label (right)
        time_remaining_label = QLabel("00:00")
        time_remaining_label.setStyleSheet("""
            QLabel {
                color: #e0e0e0;
                font-size: 11px;
                padding: 2px 4px;
                background-color: transparent;
                border: none;
            }
            QLabel:hover {
                background-color: transparent;
                border: 1px solid rgba(74, 144, 226, 0.4);
                border-radius: 3px;
            }
        """)
        text_width = max(font_metrics.horizontalAdvance("00:00"), font_metrics.horizontalAdvance("-00:00"))
        time_remaining_label.setMinimumWidth(text_width + 8)
        time_remaining_label.setMaximumWidth(text_width + 8)
        time_remaining_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        time_remaining_label.setAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
        time_remaining_label.setCursor(Qt.CursorShape.PointingHandCursor)
        # Click handler to toggle time display mode (same as regular mode)
        def on_time_label_clicked(event):
            if self.parent_window:
                # Get current time display mode from settings
                current_mode = self.parent_window.settings.get('time_display_mode', 0)
                # Toggle between 0 (total) and 1 (remaining)
                new_mode = 1 - current_mode
                self.parent_window.settings['time_display_mode'] = new_mode
                self.parent_window.save_settings()
                # Update label immediately
                if hasattr(self.parent_window, '_image_viewer_controls') and self.parent_window._image_viewer_controls:
                    controls = self.parent_window._image_viewer_controls
                    if 'time_remaining_label' in controls and controls['time_remaining_label']:
                        # Get current time and duration to update label
                        if self.parent_window.web_view and self.parent_window.web_view.page():
                            js_code = """
                            (function() {
                                var audio = document.querySelector('audio');
                                if (audio) {
                                    return {
                                        currentTime: audio.currentTime || 0,
                                        duration: audio.duration || 0
                                    };
                                }
                                return {currentTime: 0, duration: 0};
                            })();
                            """
                            def on_time_received(result):
                                if result and isinstance(result, dict):
                                    current_time = result.get('currentTime', 0)
                                    duration = result.get('duration', 0)
                                    def format_time(seconds):
                                        if not seconds or seconds < 0:
                                            return "00:00"
                                        mins = int(seconds // 60)
                                        secs = int(seconds % 60)
                                        return f"{mins:02d}:{secs:02d}"
                                    if controls['time_remaining_label']:
                                        if new_mode == 1 and duration > 0:
                                            remaining = duration - current_time
                                            remaining_str = format_time(remaining)
                                            controls['time_remaining_label'].setText(f"-{remaining_str}")
                                        else:
                                            duration_str = format_time(duration)
                                            controls['time_remaining_label'].setText(duration_str)
                            self.parent_window.web_view.page().runJavaScript(js_code, on_time_received)
        time_remaining_label.mousePressEvent = on_time_label_clicked
        progress_row.addWidget(time_remaining_label, 0)
        
        # Progress bar seek functionality
        if self.parent_window:
            if not hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls = {}
            self.parent_window._image_viewer_controls['progress_dragging'] = False
            self.parent_window._image_viewer_controls['progress_seeking'] = False
        
        def on_progress_pressed():
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls['progress_dragging'] = True
        
        def on_progress_released():
            if self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
                js_code = """
                (function() {
                    var audio = document.querySelector('audio');
                    if (audio && audio.duration) {
                        return audio.duration;
                    }
                    return 0;
                })();
                """
                def on_duration_received(duration):
                    if duration and duration > 0:
                        slider_value = progress_bar.value()
                        seek_seconds = (slider_value / 1000.0) * duration
                        seek_js = f"""
                        (function() {{
                            var audio = document.querySelector('audio');
                            if (audio) {{
                                audio.currentTime = {seek_seconds};
                            }}
                        }})();
                        """
                        if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                            self.parent_window._image_viewer_controls['progress_seeking'] = True
                        self.parent_window.web_view.page().runJavaScript(seek_js)
                        def clear_dragging():
                            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                                self.parent_window._image_viewer_controls['progress_dragging'] = False
                        def clear_seeking():
                            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                                self.parent_window._image_viewer_controls['progress_seeking'] = False
                        QTimer.singleShot(300, clear_dragging)
                        QTimer.singleShot(300, clear_seeking)
                
                self.parent_window.web_view.page().runJavaScript(js_code, on_duration_received)
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls['progress_dragging'] = False
        
        progress_bar.sliderPressed.connect(on_progress_pressed)
        progress_bar.sliderReleased.connect(on_progress_released)
        
        controls_layout.addLayout(progress_row)
        
        # Position controls widget center-center
        controls_widget.setParent(dialog)
        controls_widget.raise_()
        
        # Create loading overlay for image viewer player (without black background)
        image_viewer_loading_overlay = QWidget(dialog)
        image_viewer_loading_overlay.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        image_viewer_loading_overlay.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)  # Don't block mouse events
        image_viewer_loading_overlay.setAutoFillBackground(False)
        image_viewer_loading_overlay.hide()
        
        # Load Bandcamp logo for loading animation
        logo_path = Path(__file__).parent / "Logo" / "bandcamp-button-circle-line-aqua-128.png"
        logo_pixmap = None
        if logo_path.exists():
            logo_pixmap = QPixmap(str(logo_path))
            logo_pixmap = logo_pixmap.scaled(50, 50, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
        
        # Setup rotation animation
        loading_rotation_animation = QPropertyAnimation()
        loading_rotation_animation.setTargetObject(image_viewer_loading_overlay)
        loading_rotation_animation.setPropertyName(b"rotation_angle")
        loading_rotation_animation.setDuration(1500)
        loading_rotation_animation.setStartValue(0)
        loading_rotation_animation.setEndValue(360)
        loading_rotation_animation.setLoopCount(-1)
        loading_rotation_animation.setEasingCurve(QEasingCurve.Type.Linear)
        
        # Setup pulse animation
        loading_pulse_animation = QPropertyAnimation()
        loading_pulse_animation.setTargetObject(image_viewer_loading_overlay)
        loading_pulse_animation.setPropertyName(b"pulse_opacity")
        loading_pulse_animation.setDuration(1500)
        loading_pulse_animation.setStartValue(0.4)
        loading_pulse_animation.setEndValue(1.0)
        loading_pulse_animation.setLoopCount(1)
        loading_pulse_animation.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        loading_pulse_animation_reverse = QPropertyAnimation()
        loading_pulse_animation_reverse.setTargetObject(image_viewer_loading_overlay)
        loading_pulse_animation_reverse.setPropertyName(b"pulse_opacity")
        loading_pulse_animation_reverse.setDuration(1500)
        loading_pulse_animation_reverse.setStartValue(1.0)
        loading_pulse_animation_reverse.setEndValue(0.4)
        loading_pulse_animation_reverse.setLoopCount(1)
        loading_pulse_animation_reverse.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        loading_pulse_animation.finished.connect(loading_pulse_animation_reverse.start)
        loading_pulse_animation_reverse.finished.connect(loading_pulse_animation.start)
        
        # Create a simple object to hold animation properties for pyqtProperty
        class LoadingAnimationProps(QObject):
            rotation_angle_changed = pyqtSignal(float)
            pulse_opacity_changed = pyqtSignal(float)
            
            def __init__(self):
                super().__init__()
                self._rotation_angle = 0
                self._pulse_opacity = 1.0
            
            def get_rotation_angle(self):
                return self._rotation_angle
            
            def set_rotation_angle(self, value):
                self._rotation_angle = value
                self.rotation_angle_changed.emit(value)
            
            def get_pulse_opacity(self):
                return self._pulse_opacity
            
            def set_pulse_opacity(self, value):
                self._pulse_opacity = value
                self.pulse_opacity_changed.emit(value)
            
            rotation_angle = pyqtProperty(float, get_rotation_angle, set_rotation_angle)
            pulse_opacity = pyqtProperty(float, get_pulse_opacity, set_pulse_opacity)
        
        loading_props = LoadingAnimationProps()
        
        # Connect signals to update the overlay
        loading_props.rotation_angle_changed.connect(image_viewer_loading_overlay.update)
        loading_props.pulse_opacity_changed.connect(image_viewer_loading_overlay.update)
        
        # Set animations to target the properties object
        loading_rotation_animation.setTargetObject(loading_props)
        loading_pulse_animation.setTargetObject(loading_props)
        loading_pulse_animation_reverse.setTargetObject(loading_props)
        
        # Custom paint event for loading animation (with background matching tooltip style)
        def loading_paint_event(event):
            painter = QPainter(image_viewer_loading_overlay)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
            
            # Draw semi-transparent background matching tooltip style
            rect = image_viewer_loading_overlay.rect()
            painter.setBrush(QBrush(QColor(0, 0, 0, 180)))  # Semi-transparent black background (same as tooltip)
            painter.setPen(QPen(QColor(255, 255, 255, 30), 1))  # Subtle border matching tooltip (no visible outline)
            painter.drawRoundedRect(rect.adjusted(0, 0, -1, -1), 8, 8)
            
            # Get center of widget
            center_x = image_viewer_loading_overlay.width() / 2
            center_y = image_viewer_loading_overlay.height() / 2
            
            # Draw spinning circle loader (positioned in upper portion)
            loader_radius = 30
            loader_width = 4
            loader_center_y = center_y - 15  # Offset loader upward to make room for text and dots
            
            # Draw spinning arc
            pen = QPen()
            pen.setWidth(loader_width)
            pen.setCapStyle(Qt.PenCapStyle.RoundCap)
            
            # Create colorful gradient for the spinner using shades of #1da0c3
            conical_gradient = QConicalGradient(center_x, loader_center_y, loading_props._rotation_angle)
            conical_gradient.setColorAt(0.0, QColor(29, 160, 195))
            conical_gradient.setColorAt(0.25, QColor(20, 140, 175))
            conical_gradient.setColorAt(0.5, QColor(15, 120, 155))
            conical_gradient.setColorAt(0.75, QColor(20, 140, 175))
            conical_gradient.setColorAt(1.0, QColor(29, 160, 195))
            
            pen.setBrush(conical_gradient)
            painter.setPen(pen)
            
            # Draw arc (270 degrees)
            loader_rect = QRect(
                int(center_x - loader_radius),
                int(loader_center_y - loader_radius),
                int(loader_radius * 2),
                int(loader_radius * 2)
            )
            
            start_angle = int(loading_props._rotation_angle * 16)
            span_angle = int(270 * 16)
            
            painter.drawArc(loader_rect, start_angle, span_angle)
            
            # Draw Bandcamp logo in center of spinner
            if logo_pixmap and not logo_pixmap.isNull():
                logo_size = logo_pixmap.size()
                logo_x = int(center_x - logo_size.width() / 2)
                logo_y = int(loader_center_y - logo_size.height() / 2)
                painter.drawPixmap(logo_x, logo_y, logo_pixmap)
            
            # Draw pulsing "Loading..." text (positioned below spinner)
            text_color = QColor(220, 220, 220)
            text_color.setAlphaF(loading_props._pulse_opacity)
            painter.setPen(text_color)
            font = painter.font()
            font.setPointSize(14)
            font.setBold(True)
            painter.setFont(font)
            
            text = "Loading..."
            font_metrics = painter.fontMetrics()
            text_rect = font_metrics.boundingRect(text)
            text_x = int(center_x - text_rect.width() / 2)
            # Position text below spinner with proper spacing, accounting for text height
            text_y = int(loader_center_y + loader_radius + 20 + font_metrics.ascent())
            
            painter.drawText(text_x, text_y, text)
            
            # Draw three pulsing dots (positioned below text)
            dot_radius = 4
            dot_spacing = 12
            dots_start_x = center_x - (dot_spacing * 1.5)
            # Position dots below text with spacing
            dots_y = text_y + font_metrics.descent() + 8
            
            for i in range(3):
                dot_x = dots_start_x + (i * dot_spacing)
                dot_opacity = max(0.3, loading_props._pulse_opacity - (i * 0.2))
                base_color = QColor(29, 160, 195)
                dot_brightness = 1.0 + (i * 0.15)
                dot_color = QColor(
                    min(255, int(base_color.red() * dot_brightness)),
                    min(255, int(base_color.green() * dot_brightness)),
                    min(255, int(base_color.blue() * dot_brightness))
                )
                dot_color.setAlphaF(dot_opacity)
                painter.setBrush(QBrush(dot_color))
                painter.setPen(Qt.PenStyle.NoPen)
                painter.drawEllipse(int(dot_x - dot_radius), int(dots_y - dot_radius), dot_radius * 2, dot_radius * 2)
            
            painter.end()
        
        image_viewer_loading_overlay.paintEvent = loading_paint_event
        
        # Connect animations to update
        loading_rotation_animation.valueChanged.connect(image_viewer_loading_overlay.update)
        loading_pulse_animation.valueChanged.connect(image_viewer_loading_overlay.update)
        loading_pulse_animation_reverse.valueChanged.connect(image_viewer_loading_overlay.update)
        
        def show_loading_overlay():
            if image_viewer_loading_overlay.isVisible():
                return
            image_viewer_loading_overlay.show()
            image_viewer_loading_overlay.raise_()
            loading_rotation_animation.start()
            loading_pulse_animation.start()
        
        def hide_loading_overlay():
            if not image_viewer_loading_overlay.isVisible():
                return
            loading_rotation_animation.stop()
            loading_pulse_animation.stop()
            loading_pulse_animation_reverse.stop()
            image_viewer_loading_overlay.hide()
        
        def update_loading_overlay_position():
            if controls_widget.parent():
                # Position above controls widget, centered horizontally
                controls_pos = controls_widget.pos()
                controls_size = controls_widget.size()
                overlay_width = 180  # Width for the loading animation
                overlay_height = 200  # Height to accommodate spinner, text, and dots
                overlay_x = controls_pos.x() + (controls_size.width() - overlay_width) // 2
                overlay_y = controls_pos.y() - overlay_height - 20  # 20px gap above controls
                image_viewer_loading_overlay.setGeometry(overlay_x, overlay_y, overlay_width, overlay_height)
        
        # Function to check and sync loading state with main window
        def check_loading_state():
            if self.parent_window and hasattr(self.parent_window, 'is_loading'):
                if self.parent_window.is_loading:
                    update_loading_overlay_position()
                    show_loading_overlay()
                else:
                    hide_loading_overlay()
        
        # Check loading state periodically and on controls position update
        loading_check_timer = QTimer(dialog)
        loading_check_timer.timeout.connect(check_loading_state)
        loading_check_timer.start(100)  # Check every 100ms
        
        # Define update_controls_position function (will be called from resize handler)
        def update_controls_position():
            if controls_widget.parent():
                dialog_size = dialog.size()
                controls_size = controls_widget.sizeHint()
                x = (dialog_size.width() - controls_size.width()) // 2
                y = (dialog_size.height() - controls_size.height()) // 2
                controls_widget.setGeometry(x, y, controls_size.width(), controls_size.height())
                # Also update loading overlay position
                update_loading_overlay_position()
                check_loading_state()
        
        # Auto-hide functionality - show on enter, hide on leave
        # Load autohide state from settings (default: fully visible/autohide off)
        if self.parent_window and hasattr(self.parent_window, 'settings'):
            controls_autohide_enabled = self.parent_window.settings.get('image_viewer_player_autohide', False)
        else:
            controls_autohide_enabled = False  # Default: fully visible (autohide off)
        
        opacity_effect = QGraphicsOpacityEffect(controls_widget)
        controls_widget.setGraphicsEffect(opacity_effect)
        # Initial opacity will be set in initial_setup based on loaded setting
        opacity_effect.setOpacity(0.0)  # Temporary - will be set correctly in initial_setup
        
        fade_animation = QPropertyAnimation(opacity_effect, b"opacity")
        fade_animation.setDuration(300)
        
        # Track menu open state
        menu_open = False
        
        # Store menu_open in controls dict for access from menu handlers
        if self.parent_window:
            if not hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls = {}
            self.parent_window._image_viewer_controls['menu_open'] = False
        
        def show_controls():
            if not controls_autohide_enabled:
                return  # Don't show if autohide is disabled
            controls_widget.show()
            controls_widget.raise_()
            fade_animation.setStartValue(opacity_effect.opacity())
            fade_animation.setEndValue(1.0)
            fade_animation.start()
        
        def hide_controls():
            if not controls_autohide_enabled:
                return  # Don't hide if autohide is disabled
            
            # Check if menus are actually open
            menus_open = False
            if hasattr(self, '_album_menu_dialog') and self._album_menu_dialog and self._album_menu_dialog.isVisible():
                menus_open = True
            if hasattr(self, '_track_menu_dialog') and self._track_menu_dialog and self._track_menu_dialog.isVisible():
                menus_open = True
            # Also check menu_open flag from controls dict (for visualization menu)
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                if self.parent_window._image_viewer_controls.get('menu_open', False):
                    menus_open = True
            
            if menus_open:
                return  # Don't hide if menu is open
            fade_animation.setStartValue(opacity_effect.opacity())
            fade_animation.setEndValue(0.0)
            fade_animation.start()
            def check_and_hide():
                # Re-check menu state at hide time
                menus_still_open = False
                if hasattr(self, '_album_menu_dialog') and self._album_menu_dialog and self._album_menu_dialog.isVisible():
                    menus_still_open = True
                if hasattr(self, '_track_menu_dialog') and self._track_menu_dialog and self._track_menu_dialog.isVisible():
                    menus_still_open = True
                # Also check menu_open flag from controls dict (for visualization menu)
                if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                    if self.parent_window._image_viewer_controls.get('menu_open', False):
                        menus_still_open = True
                if fade_animation.endValue() == 0.0 and controls_autohide_enabled and not menus_still_open:
                    controls_widget.hide()
            QTimer.singleShot(300, check_and_hide)
        
        # Store toggle function to be connected later
        def create_toggle_autohide(btn_ref):
            def toggle_autohide():
                nonlocal controls_autohide_enabled
                controls_autohide_enabled = not controls_autohide_enabled
                # Save autohide state to settings
                if self.parent_window and hasattr(self.parent_window, 'settings'):
                    self.parent_window.settings['image_viewer_player_autohide'] = controls_autohide_enabled
                    # Save settings to file
                    if hasattr(self.parent_window, 'save_settings'):
                        self.parent_window.save_settings()
                # Update button state: checked = autohide on, unchecked = fully visible (autohide off)
                btn_ref.setChecked(controls_autohide_enabled)
                btn_ref.setToolTip("Autohide On" if controls_autohide_enabled else "Autohide Off (Always Visible)")
                btn_ref.repaint()
                if controls_autohide_enabled:
                    # Autohide enabled - make hotspot interactive and hide controls if mouse not over
                    hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
                    if not controls_widget.underMouse() and not hotspot_widget.underMouse():
                        hide_controls()
                else:
                    # Autohide disabled - always show controls and make hotspot transparent so controls are interactive
                    hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
                    controls_widget.show()
                    controls_widget.raise_()
                    fade_animation.setStartValue(opacity_effect.opacity())
                    fade_animation.setEndValue(1.0)
                    fade_animation.start()
            return toggle_autohide
        
        # Create hotspot area (invisible widget) in center to show controls on hover
        hotspot_widget = QWidget(dialog)
        hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        hotspot_widget.setStyleSheet("background-color: transparent;")
        
        def update_hotspot_position():
            if hotspot_widget.parent():
                dialog_size = dialog.size()
                # Make hotspot larger than controls for easier access
                hotspot_size = 200  # 200x200 hotspot area
                x = (dialog_size.width() - hotspot_size) // 2
                y = (dialog_size.height() - hotspot_size) // 2
                hotspot_widget.setGeometry(x, y, hotspot_size, hotspot_size)
        
        hotspot_widget.setParent(dialog)
        hotspot_widget.raise_()
        
        # Show controls when mouse enters hotspot
        def hotspot_enter_event(event):
            if controls_autohide_enabled:
                show_controls()
        
        hotspot_widget.enterEvent = hotspot_enter_event
        
        # Show controls when mouse enters the controls widget
        original_controls_enter = controls_widget.enterEvent
        def controls_enter_event(event):
            if controls_autohide_enabled:
                show_controls()
            if original_controls_enter:
                original_controls_enter(event)
        
        controls_widget.enterEvent = controls_enter_event
        
        # Hide controls when mouse leaves the controls widget
        original_controls_leave = controls_widget.leaveEvent
        def controls_leave_event(event):
            if controls_autohide_enabled:
                hide_controls()
            if original_controls_leave:
                original_controls_leave(event)
        
        controls_widget.leaveEvent = controls_leave_event
        
        # Hide controls when mouse leaves hotspot (if not entering controls)
        def hotspot_leave_event(event):
            if controls_autohide_enabled:
                # Check if mouse is moving to controls widget
                mouse_pos = dialog.mapFromGlobal(QCursor.pos())
                if not controls_widget.geometry().contains(mouse_pos):
                    hide_controls()
        
        hotspot_widget.leaveEvent = hotspot_leave_event
        
        # Update controls and hotspot position on resize
        existing_resize_handler = dialog.resizeEvent
        def combined_dialog_resize_event(event):
            update_controls_position()
            update_hotspot_position()
            if existing_resize_handler:
                existing_resize_handler(event)
        
        dialog.resizeEvent = combined_dialog_resize_event
        
        # Initial hotspot setup
        QTimer.singleShot(100, update_hotspot_position)
        
        # Initial setup - respect loaded autohide setting
        def initial_setup():
            update_controls_position()
            controls_widget.show()
            # Raise controls above hotspot so they can receive mouse events
            controls_widget.raise_()
            # Set initial opacity based on autohide state
            if controls_autohide_enabled:
                # Autohide enabled - start hidden (will show on hover)
                opacity_effect.setOpacity(0.0)
                hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
            else:
                # Autohide disabled - start visible
                opacity_effect.setOpacity(1.0)
                hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            # Ensure controls are enabled and can receive mouse events
            controls_widget.setEnabled(True)
        QTimer.singleShot(100, initial_setup)
        
        # Store references for updates
        if self.parent_window:
            if not hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls = {}
            self.parent_window._image_viewer_controls['widget'] = controls_widget
            self.parent_window._image_viewer_controls['controls_widget'] = controls_widget
            self.parent_window._image_viewer_controls['play_pause_btn'] = play_pause_btn
            self.parent_window._image_viewer_controls['shuffle_btn'] = shuffle_btn
            self.parent_window._image_viewer_controls['repeat_btn'] = repeat_btn
            self.parent_window._image_viewer_controls['volume_btn'] = volume_btn
            self.parent_window._image_viewer_controls['progress_bar'] = progress_bar
            self.parent_window._image_viewer_controls['time_elapsed_label'] = time_elapsed_label
            self.parent_window._image_viewer_controls['time_remaining_label'] = time_remaining_label
            self.parent_window._image_viewer_controls['albumlist_btn'] = albumlist_btn
            self.parent_window._image_viewer_controls['tracklist_btn'] = tracklist_btn
            
            # Initialize button states from main window (sync immediately)
            # This will also set up the repeat overlay if mode is 3
            if hasattr(self.parent_window, '_sync_shuffle_repeat_buttons'):
                self.parent_window._sync_shuffle_repeat_buttons()
        
        # Store references to utility buttons for player controls to access
        # (These will be created later, so we'll store them when created)
        self._image_viewer_info_btn = None
        self._image_viewer_fullscreen_btn = None
        self._image_viewer_autohide_toggle_func = None  # Store toggle function
        self._image_viewer_show_tooltip = None  # Store show_tooltip function
        
        # Top row: Bandcamp icon (left) and utility buttons (autohide toggle, info, fullscreen, close) - aligned to right
        # This will be added to controls_layout after buttons are created
        top_row = QHBoxLayout()
        top_row.setSpacing(2)  # Tight spacing for utility buttons
        top_row.setContentsMargins(0, 0, 0, 0)
        
        # Bandcamp icon on the left (use QLabel to preserve icon colors)
        bandcamp_icon_label = QLabel()
        bandcamp_icon_label.setFixedSize(28, 28)  # Match playback button size
        bandcamp_icon_label.setToolTip("Bandcamp")
        bandcamp_icon_label.setStyleSheet("background-color: transparent; border: none; padding: 0px;")
        bandcamp_icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        # Make it non-interactive (decorative only)
        bandcamp_icon_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        # Try to use app icon if available, otherwise use text
        if self.parent_window and hasattr(self.parent_window, 'app_icon') and self.parent_window.app_icon:
            bandcamp_icon_label.setPixmap(self.parent_window.app_icon.pixmap(20, 20))
        else:
            # Fallback to text/emoji
            bandcamp_icon_label.setText("")
            bandcamp_icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        top_row.addWidget(bandcamp_icon_label)
        
        # Add stretch to push utility buttons to the right
        top_row.addStretch(1)
        
        # Close button with custom styling for proper centering
        close_btn = QPushButton("")
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                border: 3px solid white;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                width: 30px;
                height: 30px;
                padding: 0px;
                text-align: center;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.3);
                border: 3px solid white;
            }
        """)
        close_btn.setFixedSize(30, 30)
        
        # Override paintEvent to ensure perfect vertical centering
        def centered_paint_event(event):
            painter = QPainter(close_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw background (check hover state)
            rect = close_btn.rect()
            if close_btn.underMouse():
                # Hover state
                painter.setBrush(QBrush(QColor(255, 255, 255, 77)))  # rgba(255, 255, 255, 0.3)
            else:
                # Normal state
                painter.setBrush(QBrush(QColor(0, 0, 0, 178)))  # rgba(0, 0, 0, 0.7)
            
            painter.setPen(QPen(QColor(255, 255, 255), 3))  # White border, 3px
            painter.drawEllipse(rect.adjusted(1, 1, -1, -1))  # Adjust for border
            
            # Draw X centered
            painter.setPen(QPen(QColor(255, 255, 255)))  # White X
            font = close_btn.font()
            font.setPointSize(18)
            font.setBold(True)
            painter.setFont(font)
            
            # Calculate text position for perfect centering
            # Use drawText with QRect for automatic centering
            metrics = QFontMetrics(font)
            text_rect = metrics.boundingRect("")
            
            # Create a centered rectangle for the text
            # Account for the border (3px on each side) and adjust for fine-tuning
            # Move right by 1px and up by 1px for perfect centering
            text_area = rect.adjusted(3, 3, -3, -3)  # Account for 3px border
            text_area = text_area.adjusted(1, -1, 1, -1)  # Shift right 1px, up 1px
            
            # Use QRect with alignment flags for perfect centering
            painter.drawText(text_area, Qt.AlignmentFlag.AlignCenter, "")
            painter.end()
        
        close_btn.paintEvent = centered_paint_event
        close_btn.clicked.connect(dialog.close)
        
        # Info button with same styling as close button
        info_btn = QPushButton("i")
        info_btn.setFixedSize(30, 30)
        
        # Override paintEvent for info button (same style as close button)
        def info_paint_event(event):
            painter = QPainter(info_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw background (check hover state)
            rect = info_btn.rect()
            if info_btn.underMouse():
                # Hover state
                painter.setBrush(QBrush(QColor(255, 255, 255, 77)))  # rgba(255, 255, 255, 0.3)
            else:
                # Normal state
                painter.setBrush(QBrush(QColor(0, 0, 0, 178)))  # rgba(0, 0, 0, 0.7)
            
            painter.setPen(QPen(QColor(255, 255, 255), 3))  # White border, 3px
            painter.drawEllipse(rect.adjusted(1, 1, -1, -1))  # Adjust for border
            
            # Draw "i" centered
            painter.setPen(QPen(QColor(255, 255, 255)))  # White text
            font = info_btn.font()
            font.setPointSize(16)
            font.setBold(True)
            painter.setFont(font)
            
            # Create a centered rectangle for the text
            text_area = rect.adjusted(3, 3, -3, -3)
            painter.drawText(text_area, Qt.AlignmentFlag.AlignCenter, "i")
            painter.end()
        
        info_btn.paintEvent = info_paint_event
        
        # Store reference to info button for player controls
        self._image_viewer_info_btn = info_btn
        
        # Fullscreen button with same styling as close/info buttons
        fullscreen_btn = QPushButton("")  # Fullscreen icon
        fullscreen_btn.setFixedSize(30, 30)
        
        # Track fullscreen state
        is_fullscreen = False
        
        # Override paintEvent for fullscreen button (same style as close/info buttons)
        def fullscreen_paint_event(event):
            painter = QPainter(fullscreen_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw background (check hover state)
            rect = fullscreen_btn.rect()
            if fullscreen_btn.underMouse():
                # Hover state
                painter.setBrush(QBrush(QColor(255, 255, 255, 77)))  # rgba(255, 255, 255, 0.3)
            else:
                # Normal state
                painter.setBrush(QBrush(QColor(0, 0, 0, 178)))  # rgba(0, 0, 0, 0.7)
            
            painter.setPen(QPen(QColor(255, 255, 255), 3))  # White border, 3px
            painter.drawEllipse(rect.adjusted(1, 1, -1, -1))  # Adjust for border
            
            # Draw fullscreen icon centered (use "" for fullscreen, "" for exit - same icon)
            painter.setPen(QPen(QColor(255, 255, 255)))  # White text
            font = fullscreen_btn.font()
            font.setPointSize(14)
            font.setBold(True)
            painter.setFont(font)
            
            # Create a centered rectangle for the text (move up by 1px for better centering)
            text_area = rect.adjusted(3, 2, -3, -4)  # Move up by 1px (2 instead of 3, -4 instead of -3)
            # Use "" (fullscreen) or "" (exit fullscreen) - using same icon for simplicity
            icon_text = ""  # Fullscreen icon
            painter.drawText(text_area, Qt.AlignmentFlag.AlignCenter, icon_text)
            painter.end()
        
        fullscreen_btn.paintEvent = fullscreen_paint_event
        
        # Fullscreen toggle function
        def toggle_fullscreen():
            nonlocal is_fullscreen
            is_fullscreen = not is_fullscreen
            if is_fullscreen:
                # Enter fullscreen - Qt will automatically resize to screen size
                dialog.setWindowState(dialog.windowState() | Qt.WindowState.WindowFullScreen)
                # The resizeEvent of image_label will be triggered automatically,
                # which will recalculate fill zoom for best fit
            else:
                # Exit fullscreen - restore original size
                dialog.setWindowState(dialog.windowState() & ~Qt.WindowState.WindowFullScreen)
                # Restore original dialog size
                if screen:
                    screen_size = screen.availableGeometry().size()
                    max_width = int(screen_size.width() * 0.9)
                    max_height = int(screen_size.height() * 0.9)
                    scaled_pixmap = pixmap.scaled(
                        max_width, max_height,
                        Qt.AspectRatioMode.KeepAspectRatio,
                        Qt.TransformationMode.SmoothTransformation
                    )
                    QTimer.singleShot(100, lambda: dialog.resize(scaled_pixmap.size()))
            fullscreen_btn.repaint()
            # Update button positions after fullscreen toggle (with delay to ensure resize completes)
            QTimer.singleShot(150, update_button_positions)
        
        fullscreen_btn.clicked.connect(toggle_fullscreen)
        
        # Store reference to fullscreen button for player controls
        self._image_viewer_fullscreen_btn = fullscreen_btn
        
        # Autohide toggle button for modal top-right controls (eye icon)
        # Load autohide state from settings (default: fully visible/autohide off)
        if self.parent_window and hasattr(self.parent_window, 'settings'):
            modal_controls_autohide_enabled = self.parent_window.settings.get('image_viewer_modal_autohide', False)
        else:
            modal_controls_autohide_enabled = False  # Default: fully visible (autohide off)
        
        modal_autohide_btn = QPushButton()
        modal_autohide_btn.setFixedSize(30, 30)  # Match other modal buttons
        
        # Override paintEvent for autohide button (same style as close/info/fullscreen buttons)
        def modal_autohide_paint_event(event):
            painter = QPainter(modal_autohide_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            
            # Draw background (check hover state and checked state)
            rect = modal_autohide_btn.rect()
            if modal_autohide_btn.underMouse():
                # Hover state
                painter.setBrush(QBrush(QColor(255, 255, 255, 77)))  # rgba(255, 255, 255, 0.3)
            elif modal_autohide_btn.isChecked():
                # Checked state (autohide on)
                painter.setBrush(QBrush(QColor(74, 144, 226, 178)))  # Blue when autohide on
            else:
                # Normal state (autohide off = always visible)
                painter.setBrush(QBrush(QColor(0, 0, 0, 178)))  # rgba(0, 0, 0, 0.7)
            
            painter.setPen(QPen(QColor(255, 255, 255), 3))  # White border, 3px
            painter.drawEllipse(rect.adjusted(1, 1, -1, -1))  # Adjust for border
            
            # Draw eye icon centered
            if HAS_QT_AWESOME:
                icon = get_icon('eye', color='#e0e0e0')
                if icon:
                    icon_rect = rect.adjusted(6, 6, -6, -6)
                    painter.drawPixmap(icon_rect, icon.pixmap(icon_rect.size()))
                else:
                    painter.setPen(QPen(QColor(255, 255, 255)))
                    font = modal_autohide_btn.font()
                    font.setPointSize(14)
                    font.setBold(True)
                    painter.setFont(font)
                    text_area = rect.adjusted(3, 3, -3, -3)
                    painter.drawText(text_area, Qt.AlignmentFlag.AlignCenter, "")
            else:
                painter.setPen(QPen(QColor(255, 255, 255)))
                font = modal_autohide_btn.font()
                font.setPointSize(14)
                font.setBold(True)
                painter.setFont(font)
                text_area = rect.adjusted(3, 3, -3, -3)
                painter.drawText(text_area, Qt.AlignmentFlag.AlignCenter, "")
            painter.end()
        
        modal_autohide_btn.paintEvent = modal_autohide_paint_event
        modal_autohide_btn.setCheckable(True)
        # Set initial state from loaded setting (checked = autohide on, unchecked = autohide off)
        modal_autohide_btn.setChecked(modal_controls_autohide_enabled)
        modal_autohide_btn.setToolTip("Autohide On" if modal_controls_autohide_enabled else "Autohide Off (Always Visible)")
        
        # Create container widget for all modal controls (for opacity effect)
        modal_controls_container = QWidget(image_label)
        modal_controls_container.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        modal_controls_container.setAutoFillBackground(False)
        
        # Override paintEvent to draw background matching tooltip style
        original_modal_container_paint = modal_controls_container.paintEvent
        def modal_container_paint_event(event):
            painter = QPainter(modal_controls_container)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
            
            # Draw semi-transparent background matching tooltip style
            rect = modal_controls_container.rect()
            painter.setBrush(QBrush(QColor(0, 0, 0, 180)))  # Semi-transparent black background (same as tooltip)
            painter.setPen(QPen(QColor(255, 255, 255, 30), 1))  # Subtle border matching tooltip
            painter.drawRoundedRect(rect.adjusted(0, 0, -1, -1), 8, 8)
            
            painter.end()
            # Call original paintEvent to draw child widgets (buttons)
            if original_modal_container_paint:
                original_modal_container_paint(event)
        
        modal_controls_container.paintEvent = modal_container_paint_event
        
        # Add opacity effect to container
        modal_opacity_effect = QGraphicsOpacityEffect(modal_controls_container)
        modal_controls_container.setGraphicsEffect(modal_opacity_effect)
        modal_fade_animation = QPropertyAnimation(modal_opacity_effect, b"opacity")
        modal_fade_animation.setDuration(300)
        
        # Function to show modal controls
        def show_modal_controls():
            if not modal_controls_autohide_enabled:
                return  # Don't show if autohide is disabled
            modal_controls_container.show()
            modal_controls_container.raise_()
            modal_fade_animation.setStartValue(modal_opacity_effect.opacity())
            modal_fade_animation.setEndValue(1.0)
            modal_fade_animation.start()
        
        # Function to hide modal controls
        def hide_modal_controls():
            if not modal_controls_autohide_enabled:
                return  # Don't hide if autohide is disabled
            modal_fade_animation.setStartValue(modal_opacity_effect.opacity())
            modal_fade_animation.setEndValue(0.0)
            modal_fade_animation.start()
            def check_and_hide():
                if modal_fade_animation.endValue() == 0.0 and modal_controls_autohide_enabled:
                    modal_controls_container.hide()
            QTimer.singleShot(300, check_and_hide)
        
        # Toggle function will be defined after hotspot is created
        
        # Show controls when mouse enters the container
        original_modal_controls_enter = modal_controls_container.enterEvent
        def modal_controls_enter_event(event):
            if modal_controls_autohide_enabled:
                show_modal_controls()
            if original_modal_controls_enter:
                original_modal_controls_enter(event)
        modal_controls_container.enterEvent = modal_controls_enter_event
        
        # Hide controls when mouse leaves the container
        original_modal_controls_leave = modal_controls_container.leaveEvent
        def modal_controls_leave_event(event):
            if modal_controls_autohide_enabled:
                hide_modal_controls()
            if original_modal_controls_leave:
                original_modal_controls_leave(event)
        modal_controls_container.leaveEvent = modal_controls_leave_event
        
        # Create hotspot area near top-right corner to show modal controls on hover
        modal_hotspot_widget = QWidget(image_label)
        modal_hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        modal_hotspot_widget.setStyleSheet("background-color: transparent;")
        
        def update_modal_hotspot_position():
            if modal_hotspot_widget.parent():
                # Position hotspot in top-right corner, larger than controls for easier access
                hotspot_size = 150  # 150x150 hotspot area
                hotspot_x = image_label.width() - hotspot_size
                hotspot_y = 0
                modal_hotspot_widget.setGeometry(hotspot_x, hotspot_y, hotspot_size, hotspot_size)
        
        modal_hotspot_widget.setParent(image_label)
        modal_hotspot_widget.raise_()
        
        # Show modal controls when mouse enters hotspot
        def modal_hotspot_enter_event(event):
            if modal_controls_autohide_enabled:
                show_modal_controls()
        
        modal_hotspot_widget.enterEvent = modal_hotspot_enter_event
        
        # Hide modal controls when mouse leaves hotspot (if not entering controls)
        def modal_hotspot_leave_event(event):
            if modal_controls_autohide_enabled:
                # Check if mouse is moving to controls container
                mouse_pos = image_label.mapFromGlobal(QCursor.pos())
                if not modal_controls_container.geometry().contains(mouse_pos):
                    hide_modal_controls()
        
        modal_hotspot_widget.leaveEvent = modal_hotspot_leave_event
        
        # Note: Resize handler will be set up later to include both button positions and hotspot
        
        # Initial hotspot setup
        QTimer.singleShot(100, update_modal_hotspot_position)
        
        # Update toggle function to handle hotspot transparency
        def toggle_modal_controls():
            nonlocal modal_controls_autohide_enabled
            modal_controls_autohide_enabled = not modal_controls_autohide_enabled
            # Save autohide state to settings
            if self.parent_window and hasattr(self.parent_window, 'settings'):
                self.parent_window.settings['image_viewer_modal_autohide'] = modal_controls_autohide_enabled
                # Save settings to file
                if hasattr(self.parent_window, 'save_settings'):
                    self.parent_window.save_settings()
            # Update button state: checked = autohide on, unchecked = autohide off
            modal_autohide_btn.setChecked(modal_controls_autohide_enabled)
            modal_autohide_btn.setToolTip("Autohide On" if modal_controls_autohide_enabled else "Autohide Off (Always Visible)")
            modal_autohide_btn.repaint()
            if modal_controls_autohide_enabled:
                # Autohide enabled - make hotspot interactive and hide controls if mouse not over
                modal_hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
                if not modal_controls_container.underMouse() and not modal_hotspot_widget.underMouse():
                    hide_modal_controls()
            else:
                # Autohide disabled - always show controls and make hotspot transparent
                modal_hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
                modal_controls_container.show()
                modal_controls_container.raise_()
                modal_fade_animation.setStartValue(modal_opacity_effect.opacity())
                modal_fade_animation.setEndValue(1.0)
                modal_fade_animation.start()
        
        # Connect the toggle function
        modal_autohide_btn.clicked.connect(toggle_modal_controls)
        
        # Create tooltip overlay widget (must be a top-level window, not a child)
        tooltip_widget = QLabel(None)  # No parent - makes it a top-level window
        tooltip_widget.setWindowFlags(
            Qt.WindowType.FramelessWindowHint |
            Qt.WindowType.WindowStaysOnTopHint |
            Qt.WindowType.Tool |
            Qt.WindowType.BypassWindowManagerHint  # Helps ensure it shows on top
        )
        # Enable transparency - this allows the image to show through
        tooltip_widget.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        tooltip_widget.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating)  # Don't steal focus
        
        tooltip_widget.setStyleSheet("""
            QLabel {
                background-color: transparent;
                color: white;
                padding: 12px 16px;
                font-size: 14px;
            }
        """)
        
        # Tooltip content - more compact formatting
        tooltip_text = """
          <b>Zoom In / Out</b>  Mouse Wheel<br>
          <b>Cycle Zoom</b>  Left Click<br>
          <b>Pan</b>  Left Click + Drag<br>
          <b>Reset Zoom</b>  Middle Click<br>
          <b>Close</b>  Right Click"""
        
        tooltip_widget.setText(tooltip_text)
        tooltip_widget.setWordWrap(False)
        
        # Override paintEvent to manually draw the semi-transparent background
        # Store the original paintEvent method from QLabel class
        original_paint = QLabel.paintEvent
        def tooltip_paint_event(event):
            painter = QPainter(tooltip_widget)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
            
            # Draw semi-transparent background matching player controls style
            rect = tooltip_widget.rect()
            painter.setBrush(QBrush(QColor(0, 0, 0, 180)))  # Semi-transparent black background (same as player controls)
            painter.setPen(QPen(QColor(255, 255, 255, 30), 1))  # Subtle border matching player controls (no visible outline)
            painter.drawRoundedRect(rect.adjusted(0, 0, -1, -1), 8, 8)
            
            painter.end()
            # Call the original QLabel.paintEvent to draw the text
            original_paint(tooltip_widget, event)
        
        tooltip_widget.paintEvent = tooltip_paint_event
        
        tooltip_widget.adjustSize()
        tooltip_widget.hide()
        
        # Show/hide tooltip on hover
        def show_tooltip():
            if info_btn.parent() and dialog.isVisible():
                # Ensure tooltip is sized correctly
                tooltip_widget.adjustSize()
                # Position tooltip above the player controls (centered horizontally, above controls_widget)
                dialog_pos = dialog.mapToGlobal(dialog.rect().topLeft())
                controls_pos = controls_widget.mapToGlobal(controls_widget.rect().topLeft())
                # Center horizontally on dialog, position above controls
                tooltip_x = dialog_pos.x() + dialog.width() // 2 - tooltip_widget.width() // 2
                tooltip_y = controls_pos.y() - tooltip_widget.height() - 20  # 20px gap above controls
                tooltip_widget.move(tooltip_x, tooltip_y)
                tooltip_widget.show()
                tooltip_widget.raise_()
                # Force it to be visible and on top
                tooltip_widget.setWindowState(tooltip_widget.windowState() & ~Qt.WindowState.WindowMinimized)
                tooltip_widget.repaint()
        
        def hide_tooltip():
            tooltip_widget.hide()
        
        # Add click-to-close functionality (defined after hide_tooltip)
        def tooltip_mouse_press_event(event):
            if event.button() == Qt.MouseButton.LeftButton:
                hide_tooltip()
            event.accept()
        
        tooltip_widget.mousePressEvent = tooltip_mouse_press_event
        
        # Toggle tooltip function for button clicks
        def toggle_tooltip():
            if tooltip_widget.isVisible():
                hide_tooltip()
            else:
                show_tooltip()
        
        # Store references for player controls button
        self._image_viewer_show_tooltip = show_tooltip
        self._image_viewer_hide_tooltip = hide_tooltip
        self._image_viewer_toggle_tooltip = toggle_tooltip
        
        # Override enterEvent and leaveEvent for hover tooltip
        original_info_enter = info_btn.enterEvent
        original_info_leave = info_btn.leaveEvent
        
        def info_enter_event(event):
            if original_info_enter:
                original_info_enter(event)
            # Use QTimer to ensure tooltip shows after event processing
            QTimer.singleShot(50, show_tooltip)
        
        def info_leave_event(event):
            if original_info_leave:
                original_info_leave(event)
            hide_tooltip()
        
        info_btn.enterEvent = info_enter_event
        info_btn.leaveEvent = info_leave_event
        
        # Create player controls version of utility buttons (top row in player controls)
        # Autohide toggle button for player controls (eye icon) - controls the player controls autohide
        player_autohide_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('eye', color='#e0e0e0')
            if icon:
                player_autohide_btn.setIcon(icon)
                player_autohide_btn.setIconSize(QSize(18, 18))  # Match icon size with other buttons
            else:
                player_autohide_btn.setText("")
        else:
            player_autohide_btn.setText("")
        player_autohide_btn.setFixedSize(28, 28)  # Match playback button size
        player_autohide_btn.setCheckable(True)
        # Set initial state from loaded setting (checked = autohide on, unchecked = autohide off)
        player_autohide_btn.setChecked(controls_autohide_enabled)
        player_autohide_btn.setToolTip("Autohide On" if controls_autohide_enabled else "Autohide Off (Always Visible)")
        player_autohide_btn.setStyleSheet(button_style)
        # Connect to player controls autohide toggle function
        toggle_player_autohide_func = create_toggle_autohide(player_autohide_btn)
        player_autohide_btn.clicked.connect(toggle_player_autohide_func)
        top_row.addWidget(player_autohide_btn)
        
        # Visualization button (opens menu to choose visualization type)
        player_viz_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('chart-line', color='#e0e0e0')
            if icon:
                player_viz_btn.setIcon(icon)
                player_viz_btn.setIconSize(QSize(18, 18))
            else:
                player_viz_btn.setText("")
        else:
            player_viz_btn.setText("")
        player_viz_btn.setFixedSize(28, 28)
        player_viz_btn.setToolTip("Visualization Options")
        player_viz_btn.setStyleSheet(button_style)
        
        # Load visualization setting (default: 'none')
        if self.parent_window and hasattr(self.parent_window, 'settings'):
            current_viz_mode = self.parent_window.settings.get('image_viewer_visualization', 'none')
        else:
            current_viz_mode = 'none'
        
        # Create visualization overlay widget (will be shown/hidden based on mode)
        viz_overlay = QWidget(image_label)
        viz_overlay.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        viz_overlay.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        viz_overlay.setAutoFillBackground(False)
        viz_overlay.hide()
        
        # Visualization state
        viz_mode = current_viz_mode
        viz_current_time = 0.0
        viz_duration = 0.0
        viz_glow_phase = 0.0  # For pulsing glow effect
        viz_spectrum_data = [0.0] * 64  # Spectrum analyzer data (64 bars)
        viz_spectrum_phase = 0.0  # For spectrum animation
        viz_is_playing = False
        viz_ring_energy = 0.0  # Overall energy for ring pulsing
        viz_ring_segments = [0.0] * 32  # Frequency segments for ring visualization
        
        # New visualization state variables
        viz_radial_spectrum_data = [0.0] * 48  # Radial spectrum bars (48 bars around circle)
        viz_radial_phase = 0.0  # For radial spectrum rotation
        viz_waveform_data = [0.0] * 128  # Waveform data points
        viz_waveform_phase = 0.0  # For waveform animation
        
        # Separate particle system state (can run alongside base visualizations)
        if self.parent_window and hasattr(self.parent_window, 'settings'):
            current_particle_mode = self.parent_window.settings.get('image_viewer_particles', 'none')
        else:
            current_particle_mode = 'none'
        particle_mode = current_particle_mode
        viz_particles = []  # Particle system: list of dicts with x, y, vx, vy, life, size, color
        viz_particle_timer = 0.0  # Timer for particle generation
        
        # Function to update visualization
        def update_visualization():
            # Declare nonlocal variables first
            nonlocal viz_glow_phase, viz_spectrum_phase, viz_spectrum_data, viz_radial_spectrum_data, viz_radial_phase
            nonlocal viz_waveform_data, viz_waveform_phase, viz_particles, viz_particle_timer, particle_mode
            
            # Update if overlay is visible and either base viz or particles are active
            if not viz_overlay.isVisible() or (viz_mode == 'none' and particle_mode == 'none'):
                return
            
            if viz_mode == 'progress_ring':
                # Update glow phase for pulsing effect
                nonlocal viz_glow_phase, viz_ring_energy, viz_ring_segments
                viz_glow_phase = (viz_glow_phase + 0.05) % (2 * 3.14159)  # Smooth rotation
                
                # Generate spectrum-like data for ring visualization
                num_segments = len(viz_ring_segments)
                if viz_is_playing:
                    # Generate frequency-like data for ring segments
                    for i in range(num_segments):
                        # Different frequencies for different segments
                        freq1 = (i / num_segments) * 3.0
                        freq2 = (i / num_segments) * 6.0
                        
                        # Combine multiple frequencies
                        phase1 = (viz_glow_phase * freq1) % (2 * 3.14159)
                        phase2 = (viz_glow_phase * freq2 + 1.5) % (2 * 3.14159)
                        
                        # Simple sine approximation
                        phase1_norm = phase1 / (2 * 3.14159)
                        phase2_norm = phase2 / (2 * 3.14159)
                        
                        if phase1_norm < 0.5:
                            val1 = phase1_norm * 2
                        else:
                            val1 = 2 - (phase1_norm * 2)
                        
                        if phase2_norm < 0.5:
                            val2 = phase2_norm * 2
                        else:
                            val2 = 2 - (phase2_norm * 2)
                        
                        combined = (val1 * 0.7 + val2 * 0.3)
                        energy = 0.3 + combined * 0.7
                        
                        # Apply decay
                        current = viz_ring_segments[i]
                        if energy > current:
                            viz_ring_segments[i] = energy
                        else:
                            viz_ring_segments[i] = max(0.1, current - 0.03)
                    
                    # Calculate overall energy for ring pulsing
                    avg_energy = sum(viz_ring_segments) / num_segments
                    if avg_energy > viz_ring_energy:
                        viz_ring_energy = avg_energy
                    else:
                        viz_ring_energy = max(0.2, viz_ring_energy - 0.02)
                else:
                    # Decay when paused
                    for i in range(num_segments):
                        viz_ring_segments[i] = max(0.0, viz_ring_segments[i] - 0.05)
                    viz_ring_energy = max(0.1, viz_ring_energy - 0.05)
                
                # Update progress ring based on current time and duration
                viz_overlay.update()
            elif viz_mode == 'spectrum':
                # Update spectrum analyzer animation
                viz_spectrum_phase = (viz_spectrum_phase + 0.1) % (2 * 3.14159)
                
                # Generate spectrum data (simulated - reacts to playback and time)
                num_bars = len(viz_spectrum_data)
                base_energy = 0.1 if viz_is_playing else 0.05
                
                for i in range(num_bars):
                    # Create frequency-like pattern with multiple sine waves
                    # Different frequencies for different bars
                    freq1 = (i / num_bars) * 4.0  # Low to high frequency
                    freq2 = (i / num_bars) * 8.0  # Higher harmonics
                    
                    # Combine multiple frequencies for realistic spectrum
                    value1 = 0.5 + 0.5 * ((viz_spectrum_phase * freq1) % (2 * 3.14159)) / (2 * 3.14159)
                    value2 = 0.5 + 0.5 * ((viz_spectrum_phase * freq2 + 1.5) % (2 * 3.14159)) / (2 * 3.14159)
                    
                    # Mix frequencies (weighted average)
                    combined = (value1 * 0.7 + value2 * 0.3)
                    
                    # Add some randomness and decay
                    if viz_is_playing:
                        # More energy when playing
                        energy = base_energy + combined * 0.9
                        # Add beat-like pulses
                        beat = 0.3 * (0.5 + 0.5 * ((viz_spectrum_phase * 2) % (2 * 3.14159)) / (2 * 3.14159))
                        energy = min(1.0, energy + beat)
                    else:
                        # Less energy when paused
                        energy = base_energy + combined * 0.3
                    
                    # Apply decay (bars fall down over time)
                    current_value = viz_spectrum_data[i]
                    if energy > current_value:
                        # Rise quickly
                        viz_spectrum_data[i] = energy
                    else:
                        # Fall slowly (decay)
                        viz_spectrum_data[i] = max(0.0, current_value - 0.05)
                
                viz_overlay.update()
            elif viz_mode == 'radial_spectrum':
                # Update radial spectrum animation
                viz_radial_phase = (viz_radial_phase + 0.08) % (2 * 3.14159)
                
                # Generate radial spectrum data (bars radiating from center)
                num_bars = len(viz_radial_spectrum_data)
                base_energy = 0.15 if viz_is_playing else 0.05
                
                for i in range(num_bars):
                    # Create frequency-like pattern
                    angle = (i / num_bars) * 2 * 3.14159
                    freq1 = (i / num_bars) * 3.5
                    freq2 = (i / num_bars) * 7.0
                    
                    # Combine multiple frequencies
                    value1 = 0.5 + 0.5 * ((viz_radial_phase * freq1 + angle) % (2 * 3.14159)) / (2 * 3.14159)
                    value2 = 0.5 + 0.5 * ((viz_radial_phase * freq2 + angle + 1.5) % (2 * 3.14159)) / (2 * 3.14159)
                    
                    combined = (value1 * 0.7 + value2 * 0.3)
                    
                    if viz_is_playing:
                        energy = base_energy + combined * 0.85
                        # Add beat pulses
                        beat = 0.25 * (0.5 + 0.5 * ((viz_radial_phase * 2.5) % (2 * 3.14159)) / (2 * 3.14159))
                        energy = min(1.0, energy + beat)
                    else:
                        energy = base_energy + combined * 0.3
                    
                    # Apply decay
                    current_value = viz_radial_spectrum_data[i]
                    if energy > current_value:
                        viz_radial_spectrum_data[i] = energy
                    else:
                        viz_radial_spectrum_data[i] = max(0.0, current_value - 0.04)
                
                viz_overlay.update()
            elif viz_mode == 'waveform':
                # Update waveform animation
                viz_waveform_phase = (viz_waveform_phase + 0.12) % (2 * 3.14159)
                
                # Generate waveform data (smooth flowing wave)
                num_points = len(viz_waveform_data)
                base_amplitude = 0.2 if viz_is_playing else 0.1
                
                for i in range(num_points):
                    # Create smooth wave pattern
                    position = i / num_points
                    freq1 = position * 4.0
                    freq2 = position * 8.0
                    freq3 = position * 12.0
                    
                    # Combine multiple frequencies for complex wave
                    wave1 = ((viz_waveform_phase * freq1 + position * 2) % (2 * 3.14159)) / (2 * 3.14159)
                    wave2 = ((viz_waveform_phase * freq2 + position * 3 + 1.0) % (2 * 3.14159)) / (2 * 3.14159)
                    wave3 = ((viz_waveform_phase * freq3 + position * 4 + 2.0) % (2 * 3.14159)) / (2 * 3.14159)
                    
                    # Convert to triangle wave approximation
                    def triangle_wave(phase):
                        phase_norm = phase % 1.0
                        if phase_norm < 0.5:
                            return phase_norm * 2
                        else:
                            return 2 - (phase_norm * 2)
                    
                    val1 = triangle_wave(wave1)
                    val2 = triangle_wave(wave2)
                    val3 = triangle_wave(wave3)
                    
                    combined = (val1 * 0.5 + val2 * 0.3 + val3 * 0.2)
                    
                    if viz_is_playing:
                        amplitude = base_amplitude + combined * 0.8
                        # Add beat modulation
                        beat = 0.2 * triangle_wave((viz_waveform_phase * 2) % 1.0)
                        amplitude = min(1.0, amplitude + beat)
                    else:
                        amplitude = base_amplitude + combined * 0.4
                    
                    # Apply decay
                    current_value = viz_waveform_data[i]
                    if amplitude > current_value:
                        viz_waveform_data[i] = amplitude
                    else:
                        viz_waveform_data[i] = max(0.0, current_value - 0.03)
                
                viz_overlay.update()
            
            # Update particles separately (can run alongside base visualizations)
            if particle_mode == 'particles':
                # Update particle system (original - attraction to center)
                viz_particle_timer += 0.1
                
                # Generate new particles when playing
                if viz_is_playing and viz_particle_timer >= 0.3:
                    viz_particle_timer = 0.0
                    rect = viz_overlay.rect()
                    center_x = rect.width() / 2
                    center_y = rect.height() / 2
                    
                    # Generate 1-3 particles per frame
                    num_new = random.randint(1, 3)
                    for _ in range(num_new):
                        # Spawn from edges or center
                        spawn_type = random.choice(['edge', 'center'])
                        if spawn_type == 'edge':
                            side = random.choice(['top', 'bottom', 'left', 'right'])
                            if side == 'top':
                                x = random.uniform(0, rect.width())
                                y = 0
                            elif side == 'bottom':
                                x = random.uniform(0, rect.width())
                                y = rect.height()
                            elif side == 'left':
                                x = 0
                                y = random.uniform(0, rect.height())
                            else:  # right
                                x = rect.width()
                                y = random.uniform(0, rect.height())
                        else:  # center
                            x = center_x + random.uniform(-20, 20)
                            y = center_y + random.uniform(-20, 20)
                        
                        # Velocity towards or away from center
                        dx = x - center_x
                        dy = y - center_y
                        dist = (dx*dx + dy*dy) ** 0.5
                        if dist > 0:
                            # Normalize and set speed
                            speed = random.uniform(0.5, 2.0)
                            vx = (dx / dist) * speed
                            vy = (dy / dist) * speed
                        else:
                            angle = random.uniform(0, 2 * math.pi)
                            speed = random.uniform(0.5, 2.0)
                            vx = speed * math.cos(angle)
                            vy = speed * math.sin(angle)
                        
                        # Particle properties
                        life = random.uniform(1.0, 2.5)
                        size = random.uniform(4.0, 8.0)
                        
                        # Color based on position (gradient)
                        color_ratio = random.uniform(0, 1)
                        if color_ratio < 0.33:
                            r, g, b = 255, int(100 + color_ratio * 3 * 155), 0
                        elif color_ratio < 0.66:
                            t = (color_ratio - 0.33) / 0.33
                            r, g, b = int(255 * (1 - t)), 255, int(255 * t)
                        else:
                            t = (color_ratio - 0.66) / 0.34
                            r, g, b = 0, int(255 * (1 - t)), 255
                        
                        viz_particles.append({
                            'x': x, 'y': y, 'vx': vx, 'vy': vy,
                            'life': life, 'max_life': life,
                            'size': size, 'color': (r, g, b)
                        })
                
                # Update existing particles
                rect = viz_overlay.rect()
                center_x = rect.width() / 2
                center_y = rect.height() / 2
                
                particles_to_remove = []
                for i, particle in enumerate(viz_particles):
                    # Update position
                    particle['x'] = particle.get('x', 0) + particle.get('vx', 0)
                    particle['y'] = particle.get('y', 0) + particle.get('vy', 0)
                    
                    # Apply gravity/attraction towards center
                    dx = center_x - particle.get('x', center_x)
                    dy = center_y - particle.get('y', center_y)
                    dist = (dx*dx + dy*dy) ** 0.5
                    if dist > 0:
                        attraction = 0.02
                        particle['vx'] = particle.get('vx', 0) + (dx / dist) * attraction
                        particle['vy'] = particle.get('vy', 0) + (dy / dist) * attraction
                    
                    # Decay velocity (friction)
                    particle['vx'] = particle.get('vx', 0) * 0.98
                    particle['vy'] = particle.get('vy', 0) * 0.98
                    
                    # Update life
                    particle['life'] = particle.get('life', 1.0) - 0.05
                    
                    # Remove if dead or out of bounds
                    if particle.get('life', 0) <= 0:
                        particles_to_remove.append(i)
                    elif (particle.get('x', 0) < -50 or particle.get('x', 0) > rect.width() + 50 or
                          particle.get('y', 0) < -50 or particle.get('y', 0) > rect.height() + 50):
                        particles_to_remove.append(i)
                
                # Remove dead particles (reverse order to maintain indices)
                for i in reversed(particles_to_remove):
                    viz_particles.pop(i)
                
                # Limit particle count
                if len(viz_particles) > 150:
                    viz_particles = viz_particles[-150:]
                
                viz_overlay.update()
            elif particle_mode == 'snow':
                # Snow effect - falling flakes with slight drift
                viz_particle_timer += 0.1
                rect = viz_overlay.rect()
                
                # Generate new snowflakes
                spawn_rate = 0.15 if viz_is_playing else 0.08
                if viz_particle_timer >= spawn_rate:
                    viz_particle_timer = 0.0
                    num_new = random.randint(1, 2) if viz_is_playing else random.randint(0, 1)
                    for _ in range(num_new):
                        x = random.uniform(-20, rect.width() + 20)
                        y = -10  # Start above screen
                        # Horizontal drift (wind effect)
                        vx = random.uniform(-0.3, 0.3)
                        # Falling speed varies by size (size between original and current)
                        size = random.uniform(3.0, 7.0)
                        vy = random.uniform(0.8, 1.5) * (size / 5.0)  # Larger flakes fall faster
                        # Rotation for tumbling effect
                        rotation = random.uniform(0, 2 * math.pi)
                        rotation_speed = random.uniform(-0.05, 0.05)
                        
                        viz_particles.append({
                            'x': x, 'y': y, 'vx': vx, 'vy': vy,
                            'life': 1.0, 'max_life': 1.0,
                            'size': size, 'color': (255, 255, 255),
                            'rotation': rotation, 'rotation_speed': rotation_speed
                        })
                
                # Update snowflakes
                particles_to_remove = []
                for i, particle in enumerate(viz_particles):
                    particle['x'] += particle.get('vx', 0)
                    particle['y'] += particle.get('vy', 0)
                    particle['rotation'] = particle.get('rotation', 0) + particle.get('rotation_speed', 0)
                    
                    # Slight horizontal drift variation (wind gusts)
                    particle['vx'] += random.uniform(-0.01, 0.01)
                    particle['vx'] = max(-0.5, min(0.5, particle['vx']))  # Limit drift
                    
                    # Remove if below screen
                    if particle['y'] > rect.height() + 20:
                        particles_to_remove.append(i)
                
                for i in reversed(particles_to_remove):
                    viz_particles.pop(i)
                
                # Limit particle count
                if len(viz_particles) > 200:
                    viz_particles = viz_particles[-200:]
                
                viz_overlay.update()
            elif particle_mode == 'rain':
                # Rain effect - falling streaks
                viz_particle_timer += 0.1
                rect = viz_overlay.rect()
                
                # Rain falls at a more pronounced angle (wind effect)
                base_angle = -0.4  # Base angle (negative = falling right)
                
                # Calculate spawn area to ensure full screen coverage
                # With diagonal rain, we need to spawn from much further left to cover bottom-right
                # Rain travels horizontally: distance = height * tan(angle)
                max_horizontal_travel = rect.height() * abs(math.tan(base_angle))
                # Spawn from much wider area - need extra margin to reach bottom-right corner
                # Bottom-right needs rain from far left that travels the full diagonal
                spawn_left = -max_horizontal_travel - rect.width() - 150  # Much wider to cover bottom-right
                spawn_right = rect.width() + 100
                
                # Generate new raindrops
                spawn_rate = 0.02 if viz_is_playing else 0.06  # Even faster spawn for better coverage
                if viz_particle_timer >= spawn_rate:
                    viz_particle_timer = 0.0
                    num_new = random.randint(4, 8) if viz_is_playing else random.randint(3, 5)  # More raindrops
                    for _ in range(num_new):
                        # Spawn from multiple edges for complete coverage
                        spawn_edge = random.choice(['top', 'top_right', 'left'])
                        
                        if spawn_edge == 'top':
                            # Spawn from top edge (full width, heavily weighted to left for bottom-right coverage)
                            # Weight spawns more to the left side to ensure bottom-right gets rain
                            if random.random() < 0.7:  # 70% chance to spawn from left half
                                x = random.uniform(spawn_left, rect.width() * 0.5)
                            else:  # 30% from right half
                                x = random.uniform(rect.width() * 0.5, spawn_right)
                            y = -30  # Start above screen
                        elif spawn_edge == 'top_right':
                            # Also spawn from top-right area to directly cover bottom-right
                            x = random.uniform(rect.width() * 0.6, spawn_right)
                            y = random.uniform(-50, rect.height() * 0.3)  # Upper portion
                        else:  # left
                            # Spawn from left edge to fill gaps
                            x = -30  # Start left of screen
                            y = random.uniform(-50, rect.height() + 50)  # Full height range
                        
                        # Consistent angle with small variation
                        angle_variation = random.uniform(-0.08, 0.08)  # Small variation
                        angle = base_angle + angle_variation
                        speed = random.uniform(3.0, 6.0)
                        vx = speed * math.sin(angle)
                        vy = speed * math.cos(angle)
                        # Length of streak (longer for better visibility)
                        length = random.uniform(15.0, 25.0)
                        
                        viz_particles.append({
                            'x': x, 'y': y, 'vx': vx, 'vy': vy,
                            'life': 1.0, 'max_life': 1.0,
                            'size': 1.0, 'length': length,
                            'color': (200, 220, 255)  # Light blue-gray
                        })
                
                # Update raindrops
                particles_to_remove = []
                for i, particle in enumerate(viz_particles):
                    particle['x'] += particle.get('vx', 0)
                    particle['y'] += particle.get('vy', 0)
                    
                    # Remove if below screen or too far off sides (due to diagonal angle)
                    if (particle.get('y', 0) > rect.height() + 50 or
                        particle.get('x', 0) < -100 or particle.get('x', 0) > rect.width() + 100):
                        particles_to_remove.append(i)
                
                for i in reversed(particles_to_remove):
                    viz_particles.pop(i)
                
                # Limit particle count (increased for better coverage)
                if len(viz_particles) > 400:
                    viz_particles = viz_particles[-400:]
                
                viz_overlay.update()
            elif particle_mode == 'stars':
                # Stars effect - twinkling points
                viz_particle_timer += 0.1
                rect = viz_overlay.rect()
                
                # Generate stars (only once, or occasionally add new ones)
                if len(viz_particles) < 100:
                    if viz_particle_timer >= 0.5:
                        viz_particle_timer = 0.0
                        num_new = random.randint(1, 3)
                        for _ in range(num_new):
                            x = random.uniform(0, rect.width())
                            y = random.uniform(0, rect.height())
                            # Twinkle phase (0-1 cycle)
                            twinkle_phase = random.uniform(0, 2 * math.pi)
                            twinkle_speed = random.uniform(0.02, 0.08)
                            size = random.uniform(2.0, 6.0)
                            
                            viz_particles.append({
                                'x': x, 'y': y, 'vx': 0, 'vy': 0,
                                'life': 1.0, 'max_life': 1.0,
                                'size': size, 'color': (255, 255, 255),
                                'twinkle_phase': twinkle_phase, 'twinkle_speed': twinkle_speed
                            })
                
                # Update stars (twinkling)
                for particle in viz_particles:
                    particle['twinkle_phase'] = (particle.get('twinkle_phase', 0) + 
                                                particle.get('twinkle_speed', 0.05)) % (2 * math.pi)
                
                viz_overlay.update()
            elif particle_mode == 'fireflies':
                # Fireflies effect - floating, glowing particles
                viz_particle_timer += 0.1
                rect = viz_overlay.rect()
                
                # Generate new fireflies
                spawn_rate = 0.2 if viz_is_playing else 0.4
                if viz_particle_timer >= spawn_rate:
                    viz_particle_timer = 0.0
                    if len(viz_particles) < 30:
                        num_new = random.randint(0, 1)
                        for _ in range(num_new):
                            # Spawn from edges but further in (more visible in center)
                            side = random.choice(['top', 'bottom', 'left', 'right'])
                            edge_offset = 80  # Spawn 80px from edges instead of exactly on edge
                            if side == 'top':
                                x = random.uniform(edge_offset, rect.width() - edge_offset)
                                y = edge_offset
                            elif side == 'bottom':
                                x = random.uniform(edge_offset, rect.width() - edge_offset)
                                y = rect.height() - edge_offset
                            elif side == 'left':
                                x = edge_offset
                                y = random.uniform(edge_offset, rect.height() - edge_offset)
                            else:  # right
                                x = rect.width() - edge_offset
                                y = random.uniform(edge_offset, rect.height() - edge_offset)
                            
                            # Random velocity (slow, floating)
                            angle = random.uniform(0, 2 * math.pi)
                            speed = random.uniform(0.2, 0.6)
                            vx = speed * math.cos(angle)
                            vy = speed * math.sin(angle)
                            
                            # Glow phase
                            glow_phase = random.uniform(0, 2 * math.pi)
                            glow_speed = random.uniform(0.05, 0.15)
                            size = random.uniform(4.0, 8.0)
                            
                            # Warm yellow-green color
                            color_variation = random.uniform(0, 1)
                            if color_variation < 0.5:
                                r, g, b = 255, 255, int(150 + color_variation * 2 * 105)
                            else:
                                r, g, b = int(200 + (color_variation - 0.5) * 2 * 55), 255, 100
                            
                            viz_particles.append({
                                'x': x, 'y': y, 'vx': vx, 'vy': vy,
                                'life': random.uniform(3.0, 6.0), 'max_life': 5.0,
                                'size': size, 'color': (r, g, b),
                                'glow_phase': glow_phase, 'glow_speed': glow_speed
                            })
                
                # Update fireflies
                particles_to_remove = []
                for i, particle in enumerate(viz_particles):
                    particle['x'] += particle['vx']
                    particle['y'] += particle['vy']
                    particle['glow_phase'] = (particle.get('glow_phase', 0) + 
                                             particle.get('glow_speed', 0.1)) % (2 * math.pi)
                    
                    # Gentle random movement
                    particle['vx'] += random.uniform(-0.02, 0.02)
                    particle['vy'] += random.uniform(-0.02, 0.02)
                    particle['vx'] = max(-0.8, min(0.8, particle['vx']))
                    particle['vy'] = max(-0.8, min(0.8, particle['vy']))
                    
                    # Update life
                    particle['life'] = particle.get('life', 5.0) - 0.01
                    
                    # Remove if dead or out of bounds
                    if particle.get('life', 0) <= 0:
                        particles_to_remove.append(i)
                    elif (particle['x'] < -50 or particle['x'] > rect.width() + 50 or
                          particle['y'] < -50 or particle['y'] > rect.height() + 50):
                        particles_to_remove.append(i)
                
                for i in reversed(particles_to_remove):
                    viz_particles.pop(i)
                
                viz_overlay.update()
            elif particle_mode == 'bubbles':
                # Bubbles effect - rising, floating bubbles
                viz_particle_timer += 0.1
                rect = viz_overlay.rect()
                
                # Generate new bubbles
                spawn_rate = 0.15 if viz_is_playing else 0.3
                if viz_particle_timer >= spawn_rate:
                    viz_particle_timer = 0.0
                    num_new = random.randint(1, 2) if viz_is_playing else random.randint(0, 1)
                    for _ in range(num_new):
                        x = random.uniform(0, rect.width())
                        y = rect.height() + 10  # Start below screen
                        # Rising speed (slower for larger bubbles)
                        size = random.uniform(6.0, 14.0)
                        vy = -random.uniform(0.5, 1.2) * (10.0 / size)  # Larger = slower
                        # Horizontal drift
                        vx = random.uniform(-0.2, 0.2)
                        # Wobble phase for floating effect
                        wobble_phase = random.uniform(0, 2 * math.pi)
                        wobble_speed = random.uniform(0.05, 0.15)
                        
                        # Light blue/cyan color with transparency
                        alpha_variation = random.uniform(0.3, 0.7)
                        r, g, b = int(150 * alpha_variation), int(200 * alpha_variation), int(255 * alpha_variation)
                        
                        viz_particles.append({
                            'x': x, 'y': y, 'vx': vx, 'vy': vy,
                            'life': 1.0, 'max_life': 1.0,
                            'size': size, 'color': (r, g, b),
                            'wobble_phase': wobble_phase, 'wobble_speed': wobble_speed,
                            'wobble_amplitude': random.uniform(0.3, 0.8)
                        })
                
                # Update bubbles
                particles_to_remove = []
                for i, particle in enumerate(viz_particles):
                    # Wobble (horizontal oscillation)
                    particle['wobble_phase'] = (particle.get('wobble_phase', 0) + 
                                              particle.get('wobble_speed', 0.1)) % (2 * math.pi)
                    wobble_offset = math.sin(particle['wobble_phase']) * particle.get('wobble_amplitude', 0.5)
                    
                    particle['x'] += particle['vx'] + wobble_offset
                    particle['y'] += particle['vy']
                    
                    # Remove if above screen
                    if particle['y'] < -30:
                        particles_to_remove.append(i)
                
                for i in reversed(particles_to_remove):
                    viz_particles.pop(i)
                
                # Limit particle count
                if len(viz_particles) > 80:
                    viz_particles = viz_particles[-80:]
                
                viz_overlay.update()
            elif particle_mode == 'sparkles':
                # Sparkles effect - shimmering, twinkling particles
                viz_particle_timer += 0.1
                rect = viz_overlay.rect()
                
                # Generate new sparkles
                spawn_rate = 0.1 if viz_is_playing else 0.2
                if viz_particle_timer >= spawn_rate:
                    viz_particle_timer = 0.0
                    num_new = random.randint(1, 3) if viz_is_playing else random.randint(0, 2)
                    for _ in range(num_new):
                        x = random.uniform(0, rect.width())
                        y = random.uniform(0, rect.height())
                        # Sparkles appear and fade quickly
                        life = random.uniform(0.5, 1.5)
                        size = random.uniform(4.0, 10.0)
                        # Random sparkle color (gold, silver, rainbow)
                        color_type = random.choice(['gold', 'silver', 'rainbow'])
                        if color_type == 'gold':
                            r, g, b = 255, 215, 0
                        elif color_type == 'silver':
                            r, g, b = 200, 200, 255
                        else:  # rainbow
                            hue = random.uniform(0, 1)
                            if hue < 0.17:
                                r, g, b = 255, int(255 * hue * 6), 0
                            elif hue < 0.33:
                                r, g, b = int(255 * (2 - hue * 6)), 255, 0
                            elif hue < 0.5:
                                r, g, b = 0, 255, int(255 * (hue * 6 - 2))
                            elif hue < 0.67:
                                r, g, b = 0, int(255 * (4 - hue * 6)), 255
                            elif hue < 0.83:
                                r, g, b = int(255 * (hue * 6 - 4)), 0, 255
                            else:
                                r, g, b = 255, 0, int(255 * (6 - hue * 6))
                        
                        # Twinkle phase
                        twinkle_phase = random.uniform(0, 2 * math.pi)
                        twinkle_speed = random.uniform(0.1, 0.3)
                        
                        viz_particles.append({
                            'x': x, 'y': y, 'vx': 0, 'vy': 0,
                            'life': life, 'max_life': life,
                            'size': size, 'color': (r, g, b),
                            'twinkle_phase': twinkle_phase, 'twinkle_speed': twinkle_speed
                        })
                
                # Update sparkles
                particles_to_remove = []
                for i, particle in enumerate(viz_particles):
                    particle['twinkle_phase'] = (particle.get('twinkle_phase', 0) + 
                                                particle.get('twinkle_speed', 0.2)) % (2 * math.pi)
                    particle['life'] -= 0.05
                    
                    if particle['life'] <= 0:
                        particles_to_remove.append(i)
                
                for i in reversed(particles_to_remove):
                    viz_particles.pop(i)
                
                # Limit particle count
                if len(viz_particles) > 100:
                    viz_particles = viz_particles[-100:]
                
                viz_overlay.update()
        
        # Paint event for visualization overlay
        def viz_paint_event(event):
            # Render if either base visualization or particles are active
            if viz_mode == 'none' and particle_mode == 'none':
                return
            
            painter = QPainter(viz_overlay)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing, True)
            
            if viz_mode == 'progress_ring':
                # Draw circular progress ring around the edges
                rect = viz_overlay.rect()
                center_x = rect.width() / 2
                center_y = rect.height() / 2
                
                # Calculate progress (0.0 to 1.0)
                progress = 0.0
                if viz_duration > 0:
                    progress = min(1.0, max(0.0, viz_current_time / viz_duration))
                
                # Ring parameters - fixed position, variable thickness
                base_ring_width = 12  # Nice thick base (even when energy is low)
                max_thickness = 35  # Maximum thickness when energy is high
                energy_ring_width = base_ring_width + int(viz_ring_energy * (max_thickness - base_ring_width))  # Thickness grows with energy
                
                # Fixed radius - ring stays in place
                ring_margin = 20  # Distance from edges (fixed)
                ring_radius = min(rect.width(), rect.height()) / 2 - ring_margin
                
                # No background ring - only show progress arc
                
                # Draw progress arc (if there's progress)
                if progress > 0:
                    # Calculate pulsing glow intensity (subtle pulse)
                    # Simple sine approximation: sin(x)  x - x/6 for small x, but we'll use a simpler approach
                    phase_normalized = (viz_glow_phase % (2 * 3.14159)) / (2 * 3.14159)
                    # Create smooth pulse using a triangle wave approximation
                    if phase_normalized < 0.5:
                        pulse = phase_normalized * 2  # 0 to 1
                    else:
                        pulse = 2 - (phase_normalized * 2)  # 1 to 0
                    # Convert to sine-like wave (smooth curve)
                    glow_intensity = 0.7 + 0.3 * (0.5 + 0.5 * (pulse * 2 - 1))
                    
                    # Color gradient based on progress (blue -> cyan -> green -> yellow)
                    # Interpolate between colors as progress increases
                    if progress < 0.33:
                        # Blue to Cyan
                        t = progress / 0.33
                        r = int(74 + (0 - 74) * t)
                        g = int(144 + (255 - 144) * t)
                        b = int(226 + (255 - 226) * t)
                    elif progress < 0.66:
                        # Cyan to Green
                        t = (progress - 0.33) / 0.33
                        r = int(0 + (0 - 0) * t)
                        g = int(255 + (200 - 255) * t)
                        b = int(255 + (0 - 255) * t)
                    else:
                        # Green to Yellow
                        t = (progress - 0.66) / 0.34
                        r = int(0 + (255 - 0) * t)
                        g = int(200 + (255 - 200) * t)
                        b = int(0 + (0 - 0) * t)
                    
                    # Base progress color with gradient - enhance with energy
                    energy_multiplier = 0.7 + (viz_ring_energy * 0.3)  # Boost brightness with energy
                    base_alpha = int(220 * glow_intensity * energy_multiplier)
                    progress_color = QColor(r, g, b, min(255, base_alpha))
                    
                    # Draw glow effect (larger, more transparent ring behind) - thickness varies with energy
                    glow_width = energy_ring_width + 4
                    glow_alpha = int(80 * glow_intensity * (0.8 + viz_ring_energy * 0.2))
                    glow_color = QColor(r, g, b, min(255, glow_alpha))
                    glow_pen = QPen(glow_color, glow_width)
                    glow_pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                    painter.setPen(glow_pen)
                    
                    # Draw glow arc - fixed radius, variable thickness
                    start_angle = 90 * 16  # Start at top (12 o'clock)
                    span_angle = int(-progress * 360 * 16)  # Negative for clockwise
                    arc_rect = QRect(
                        int(center_x - ring_radius),
                        int(center_y - ring_radius),
                        int(ring_radius * 2),
                        int(ring_radius * 2)
                    )
                    painter.drawArc(arc_rect, start_angle, span_angle)
                    
                    # Draw main progress arc - fixed radius, variable thickness (grows inward)
                    pen = QPen(progress_color, energy_ring_width)
                    pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                    painter.setPen(pen)
                    painter.drawArc(arc_rect, start_angle, span_angle)
                    
                    # Draw bright highlight at the end of the progress arc (leading edge)
                    if progress < 1.0:
                        highlight_alpha = int(255 * glow_intensity)
                        highlight_color = QColor(255, 255, 255, highlight_alpha)
                        highlight_pen = QPen(highlight_color, energy_ring_width + 2)
                        highlight_pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                        painter.setPen(highlight_pen)
                        
                        # Draw small arc at the end position (use expanded radius)
                        end_angle = start_angle + span_angle
                        highlight_span = 3 * 16  # Small arc (3 degrees)
                        painter.drawArc(arc_rect, end_angle, highlight_span)
            
            elif viz_mode == 'spectrum':
                # Draw spectrum analyzer bars around the edges
                rect = viz_overlay.rect()
                width = rect.width()
                height = rect.height()
                
                # Bar parameters
                bar_width = 3
                bar_spacing = 2
                margin = 15  # Distance from edges
                max_bar_height = 80  # Maximum height for bars
                
                num_bars = len(viz_spectrum_data)
                bars_per_side = num_bars // 4  # Distribute bars evenly around 4 sides
                
                # Top edge bars
                top_x_start = margin
                top_available_width = width - (margin * 2)
                top_bar_spacing = (top_available_width - (bars_per_side * bar_width)) / (bars_per_side - 1) if bars_per_side > 1 else 0
                
                for i in range(bars_per_side):
                    bar_index = i
                    bar_value = viz_spectrum_data[bar_index]
                    bar_height = int(bar_value * max_bar_height)
                    
                    if bar_height > 0:
                        x = int(top_x_start + i * (bar_width + top_bar_spacing))
                        y = margin
                        
                        # Color gradient: low freq (red) to high freq (blue/cyan)
                        color_ratio = i / bars_per_side
                        if color_ratio < 0.33:
                            # Red to Yellow
                            r = 255
                            g = int(100 + color_ratio * 3 * 155)
                            b = 0
                        elif color_ratio < 0.66:
                            # Yellow to Cyan
                            t = (color_ratio - 0.33) / 0.33
                            r = int(255 * (1 - t))
                            g = 255
                            b = int(255 * t)
                        else:
                            # Cyan to Blue
                            t = (color_ratio - 0.66) / 0.34
                            r = 0
                            g = int(255 * (1 - t))
                            b = 255
                        
                        # Alpha based on bar value (brighter when higher)
                        alpha = int(180 + bar_value * 75)
                        bar_color = QColor(r, g, b, alpha)
                        
                        # Draw bar (grows downward from top)
                        painter.fillRect(x, y, bar_width, bar_height, bar_color)
                        
                        # Add glow effect for brighter bars
                        if bar_value > 0.7:
                            glow_alpha = int(100 * bar_value)
                            glow_color = QColor(r, g, b, glow_alpha)
                            painter.fillRect(x - 1, y, bar_width + 2, bar_height + 2, glow_color)
                
                # Bottom edge bars
                for i in range(bars_per_side):
                    bar_index = bars_per_side + i
                    bar_value = viz_spectrum_data[bar_index]
                    bar_height = int(bar_value * max_bar_height)
                    
                    if bar_height > 0:
                        x = int(top_x_start + i * (bar_width + top_bar_spacing))
                        y = height - margin - bar_height
                        
                        # Same color calculation
                        color_ratio = i / bars_per_side
                        if color_ratio < 0.33:
                            r = 255
                            g = int(100 + color_ratio * 3 * 155)
                            b = 0
                        elif color_ratio < 0.66:
                            t = (color_ratio - 0.33) / 0.33
                            r = int(255 * (1 - t))
                            g = 255
                            b = int(255 * t)
                        else:
                            t = (color_ratio - 0.66) / 0.34
                            r = 0
                            g = int(255 * (1 - t))
                            b = 255
                        
                        alpha = int(180 + bar_value * 75)
                        bar_color = QColor(r, g, b, alpha)
                        
                        # Draw bar (grows upward from bottom)
                        painter.fillRect(x, y, bar_width, bar_height, bar_color)
                        
                        if bar_value > 0.7:
                            glow_alpha = int(100 * bar_value)
                            glow_color = QColor(r, g, b, glow_alpha)
                            painter.fillRect(x - 1, y - 1, bar_width + 2, bar_height + 2, glow_color)
                
                # Left edge bars
                left_y_start = margin
                left_available_height = height - (margin * 2)
                left_bar_spacing = (left_available_height - (bars_per_side * bar_width)) / (bars_per_side - 1) if bars_per_side > 1 else 0
                
                for i in range(bars_per_side):
                    bar_index = (bars_per_side * 2) + i
                    bar_value = viz_spectrum_data[bar_index]
                    bar_height = int(bar_value * max_bar_height)
                    
                    if bar_height > 0:
                        x = margin
                        y = int(left_y_start + i * (bar_width + left_bar_spacing))
                        
                        # Color calculation
                        color_ratio = i / bars_per_side
                        if color_ratio < 0.33:
                            r = 255
                            g = int(100 + color_ratio * 3 * 155)
                            b = 0
                        elif color_ratio < 0.66:
                            t = (color_ratio - 0.33) / 0.33
                            r = int(255 * (1 - t))
                            g = 255
                            b = int(255 * t)
                        else:
                            t = (color_ratio - 0.66) / 0.34
                            r = 0
                            g = int(255 * (1 - t))
                            b = 255
                        
                        alpha = int(180 + bar_value * 75)
                        bar_color = QColor(r, g, b, alpha)
                        
                        # Draw bar (grows rightward from left)
                        painter.fillRect(x, y, bar_height, bar_width, bar_color)
                        
                        if bar_value > 0.7:
                            glow_alpha = int(100 * bar_value)
                            glow_color = QColor(r, g, b, glow_alpha)
                            painter.fillRect(x - 1, y - 1, bar_height + 2, bar_width + 2, glow_color)
                
                # Right edge bars
                for i in range(bars_per_side):
                    bar_index = (bars_per_side * 3) + i
                    bar_value = viz_spectrum_data[bar_index]
                    bar_height = int(bar_value * max_bar_height)
                    
                    if bar_height > 0:
                        x = width - margin - bar_height
                        y = int(left_y_start + i * (bar_width + left_bar_spacing))
                        
                        # Color calculation
                        color_ratio = i / bars_per_side
                        if color_ratio < 0.33:
                            r = 255
                            g = int(100 + color_ratio * 3 * 155)
                            b = 0
                        elif color_ratio < 0.66:
                            t = (color_ratio - 0.33) / 0.33
                            r = int(255 * (1 - t))
                            g = 255
                            b = int(255 * t)
                        else:
                            t = (color_ratio - 0.66) / 0.34
                            r = 0
                            g = int(255 * (1 - t))
                            b = 255
                        
                        alpha = int(180 + bar_value * 75)
                        bar_color = QColor(r, g, b, alpha)
                        
                        # Draw bar (grows leftward from right)
                        painter.fillRect(x, y, bar_height, bar_width, bar_color)
                        
                        if bar_value > 0.7:
                            glow_alpha = int(100 * bar_value)
                            glow_color = QColor(r, g, b, glow_alpha)
                            painter.fillRect(x - 1, y - 1, bar_height + 2, bar_width + 2, glow_color)
            
            elif viz_mode == 'radial_spectrum':
                # Draw radial spectrum bars radiating from center
                rect = viz_overlay.rect()
                center_x = rect.width() / 2
                center_y = rect.height() / 2
                
                # Calculate base radius (distance from center to start of bars)
                base_radius = min(rect.width(), rect.height()) * 0.15
                max_bar_length = min(rect.width(), rect.height()) * 0.35
                
                num_bars = len(viz_radial_spectrum_data)
                
                for i in range(num_bars):
                    bar_value = viz_radial_spectrum_data[i]
                    if bar_value <= 0:
                        continue
                    
                    # Calculate angle for this bar (start at top, go clockwise)
                    angle = (i / num_bars) * 2 * math.pi - math.pi / 2  # Start at top (-90 degrees)
                    
                    # Calculate bar length
                    bar_length = base_radius + (bar_value * max_bar_length)
                    
                    # Start and end points using trigonometry
                    start_x = center_x + base_radius * math.cos(angle)
                    start_y = center_y + base_radius * math.sin(angle)
                    end_x = center_x + bar_length * math.cos(angle)
                    end_y = center_y + bar_length * math.sin(angle)
                    
                    # Color gradient: low freq (red) to high freq (blue/cyan)
                    color_ratio = i / num_bars
                    if color_ratio < 0.33:
                        r = 255
                        g = int(100 + color_ratio * 3 * 155)
                        b = 0
                    elif color_ratio < 0.66:
                        t = (color_ratio - 0.33) / 0.33
                        r = int(255 * (1 - t))
                        g = 255
                        b = int(255 * t)
                    else:
                        t = (color_ratio - 0.66) / 0.34
                        r = 0
                        g = int(255 * (1 - t))
                        b = 255
                    
                    # Alpha based on bar value
                    alpha = int(180 + bar_value * 75)
                    bar_color = QColor(r, g, b, alpha)
                    
                    # Draw bar (line with thickness)
                    bar_width = 3
                    pen = QPen(bar_color, bar_width)
                    pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                    painter.setPen(pen)
                    painter.drawLine(int(start_x), int(start_y), int(end_x), int(end_y))
                    
                    # Add glow for brighter bars
                    if bar_value > 0.7:
                        glow_alpha = int(100 * bar_value)
                        glow_color = QColor(r, g, b, glow_alpha)
                        glow_pen = QPen(glow_color, bar_width + 2)
                        glow_pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                        painter.setPen(glow_pen)
                        painter.drawLine(int(start_x), int(start_y), int(end_x), int(end_y))
            
            elif viz_mode == 'waveform':
                # Draw waveform around the edges
                rect = viz_overlay.rect()
                width = rect.width()
                height = rect.height()
                
                num_points = len(viz_waveform_data)
                margin = 20
                
                # Create path for waveform
                path = QPainterPath()
                points_per_side = num_points // 4
                
                # Top edge
                top_available = width - (margin * 2)
                for i in range(points_per_side):
                    x = margin + (i / (points_per_side - 1)) * top_available if points_per_side > 1 else margin
                    amplitude = viz_waveform_data[i] * 40  # Max amplitude 40px
                    y = margin + amplitude
                    if i == 0:
                        path.moveTo(x, y)
                    else:
                        path.lineTo(x, y)
                
                # Right edge
                right_available = height - (margin * 2)
                for i in range(points_per_side):
                    y = margin + (i / (points_per_side - 1)) * right_available if points_per_side > 1 else margin
                    amplitude = viz_waveform_data[points_per_side + i] * 40
                    x = width - margin - amplitude
                    path.lineTo(x, y)
                
                # Bottom edge
                for i in range(points_per_side):
                    x = width - margin - (i / (points_per_side - 1)) * top_available if points_per_side > 1 else width - margin
                    amplitude = viz_waveform_data[points_per_side * 2 + i] * 40
                    y = height - margin - amplitude
                    path.lineTo(x, y)
                
                # Left edge
                for i in range(points_per_side):
                    y = height - margin - (i / (points_per_side - 1)) * right_available if points_per_side > 1 else height - margin
                    amplitude = viz_waveform_data[points_per_side * 3 + i] * 40
                    x = margin + amplitude
                    path.lineTo(x, y)
                
                # Close path
                path.closeSubpath()
                
                # Color gradient based on progress
                progress = 0.0
                if viz_duration > 0:
                    progress = min(1.0, max(0.0, viz_current_time / viz_duration))
                
                if progress < 0.33:
                    t = progress / 0.33
                    r = int(74 + (0 - 74) * t)
                    g = int(144 + (255 - 144) * t)
                    b = int(226 + (255 - 226) * t)
                elif progress < 0.66:
                    t = (progress - 0.33) / 0.33
                    r = int(0 + (0 - 0) * t)
                    g = int(255 + (200 - 255) * t)
                    b = int(255 + (0 - 255) * t)
                else:
                    t = (progress - 0.66) / 0.34
                    r = int(0 + (255 - 0) * t)
                    g = int(200 + (255 - 200) * t)
                    b = int(0 + (0 - 0) * t)
                
                # Draw waveform
                wave_color = QColor(r, g, b, 200)
                pen = QPen(wave_color, 2)
                pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                pen.setJoinStyle(Qt.PenJoinStyle.RoundJoin)
                painter.setPen(pen)
                painter.setBrush(Qt.BrushStyle.NoBrush)
                painter.drawPath(path)
                
                # Add glow effect
                glow_color = QColor(r, g, b, 80)
                glow_pen = QPen(glow_color, 4)
                glow_pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                glow_pen.setJoinStyle(Qt.PenJoinStyle.RoundJoin)
                painter.setPen(glow_pen)
                painter.drawPath(path)
            
            # Draw particles separately (can render alongside base visualizations)
            if particle_mode == 'particles':
                # Draw particle system (original - attraction to center)
                rect = viz_overlay.rect()
                
                for particle in viz_particles:
                    # Calculate alpha based on life
                    life_ratio = particle.get('life', 1.0) / particle.get('max_life', 1.0)
                    alpha = int(255 * life_ratio)
                    
                    # Get color
                    r, g, b = particle.get('color', (255, 100, 0))
                    particle_color = QColor(r, g, b, alpha)
                    
                    # Draw particle
                    size = int(particle.get('size', 3.0) * life_ratio)  # Shrink as it dies
                    if size > 0:
                        x = int(particle.get('x', 0))
                        y = int(particle.get('y', 0))
                        painter.setBrush(QBrush(particle_color))
                        painter.setPen(Qt.PenStyle.NoPen)
                        painter.drawEllipse(x - size//2, y - size//2, size, size)
                        
                        # Add glow for larger particles
                        if size > 3:
                            glow_alpha = int(alpha * 0.5)
                            glow_color = QColor(r, g, b, glow_alpha)
                            painter.setBrush(QBrush(glow_color))
                            painter.drawEllipse(x - size, y - size, size * 2, size * 2)
            elif particle_mode == 'snow':
                # Draw snowflakes
                rect = viz_overlay.rect()
                
                for particle in viz_particles:
                    r, g, b = particle.get('color', (255, 255, 255))
                    # Snowflakes are white with slight transparency variation
                    alpha = int(200 + 55 * (0.5 + 0.5 * math.sin(particle.get('rotation', 0))))
                    snow_color = QColor(r, g, b, alpha)
                    
                    size = int(particle.get('size', 3.0))
                    x = int(particle.get('x', 0))
                    y = int(particle.get('y', 0))
                    rotation = particle.get('rotation', 0)
                    
                    # Draw snowflake as small circle with cross pattern
                    painter.save()
                    painter.translate(x, y)
                    painter.rotate(math.degrees(rotation))
                    
                    # Main circle
                    painter.setBrush(QBrush(snow_color))
                    painter.setPen(Qt.PenStyle.NoPen)
                    painter.drawEllipse(-size//2, -size//2, size, size)
                    
                    # Cross pattern for snowflake look
                    if size > 2:
                        pen = QPen(snow_color, max(1, size // 3))
                        pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                        painter.setPen(pen)
                        # Horizontal line
                        painter.drawLine(-size, 0, size, 0)
                        # Vertical line
                        painter.drawLine(0, -size, 0, size)
                        # Diagonal lines for larger flakes
                        if size > 3:
                            diag_len = int(size * 0.7)
                            painter.drawLine(-diag_len, -diag_len, diag_len, diag_len)
                            painter.drawLine(-diag_len, diag_len, diag_len, -diag_len)
                    
                    painter.restore()
            elif particle_mode == 'rain':
                # Draw rain streaks
                rect = viz_overlay.rect()
                
                for particle in viz_particles:
                    r, g, b = particle.get('color', (200, 220, 255))
                    # Rain is semi-transparent
                    alpha = int(180)
                    rain_color = QColor(r, g, b, alpha)
                    
                    length = particle.get('length', 20.0)
                    x = int(particle.get('x', 0))
                    y = int(particle.get('y', 0))
                    
                    # Draw streak (line) - thicker for better visibility
                    pen = QPen(rain_color, 3)
                    pen.setCapStyle(Qt.PenCapStyle.RoundCap)
                    painter.setPen(pen)
                    
                    # Calculate end point based on velocity direction
                    vx = particle.get('vx', 0)
                    vy = particle.get('vy', 3.0)
                    angle = math.atan2(vy, vx)
                    end_x = x + int(length * math.cos(angle))
                    end_y = y + int(length * math.sin(angle))
                    
                    painter.drawLine(x, y, end_x, end_y)
            elif particle_mode == 'stars':
                # Draw twinkling stars
                rect = viz_overlay.rect()
                
                for particle in viz_particles:
                    r, g, b = particle.get('color', (255, 255, 255))
                    # Twinkle effect using sine wave
                    twinkle_phase = particle.get('twinkle_phase', 0)
                    twinkle_intensity = 0.3 + 0.7 * (0.5 + 0.5 * math.sin(twinkle_phase))
                    alpha = int(255 * twinkle_intensity)
                    star_color = QColor(r, g, b, alpha)
                    
                    size = int(particle.get('size', 2.0) * twinkle_intensity)
                    x = int(particle.get('x', 0))
                    y = int(particle.get('y', 0))
                    
                    if size > 0:
                        # Draw star as small cross
                        pen_width = max(1, size // 4)  # Scale pen width with star size
                        painter.setPen(QPen(star_color, pen_width))
                        painter.setBrush(QBrush(star_color))
                        
                        # Main point
                        painter.drawEllipse(x - size//2, y - size//2, size, size)
                        
                        # Cross pattern for star look
                        if size > 1:
                            cross_size = size + 2
                            painter.drawLine(x - cross_size, y, x + cross_size, y)
                            painter.drawLine(x, y - cross_size, x, y + cross_size)
            elif viz_mode == 'fireflies':
                # Draw glowing fireflies
                rect = viz_overlay.rect()
                
                for particle in viz_particles:
                    r, g, b = particle.get('color', (255, 255, 150))
                    # Pulsing glow effect
                    glow_phase = particle.get('glow_phase', 0)
                    glow_intensity = 0.4 + 0.6 * (0.5 + 0.5 * math.sin(glow_phase))
                    life_ratio = particle.get('life', 5.0) / particle.get('max_life', 5.0)
                    alpha = int(255 * glow_intensity * life_ratio)
                    firefly_color = QColor(r, g, b, alpha)
                    
                    size = int(particle.get('size', 3.0) * glow_intensity)
                    x = int(particle.get('x', 0))
                    y = int(particle.get('y', 0))
                    
                    if size > 0:
                        # Draw firefly with glow
                        painter.setBrush(QBrush(firefly_color))
                        painter.setPen(Qt.PenStyle.NoPen)
                        painter.drawEllipse(x - size//2, y - size//2, size, size)
                        
                        # Outer glow
                        if size > 2:
                            glow_size = size * 2
                            glow_alpha = int(alpha * 0.3)
                            glow_color = QColor(r, g, b, glow_alpha)
                            painter.setBrush(QBrush(glow_color))
                            painter.drawEllipse(x - glow_size//2, y - glow_size//2, glow_size, glow_size)
            elif particle_mode == 'bubbles':
                # Draw floating bubbles
                rect = viz_overlay.rect()
                
                for particle in viz_particles:
                    r, g, b = particle.get('color', (150, 200, 255))
                    # Bubbles are semi-transparent
                    alpha = int(120)
                    bubble_color = QColor(r, g, b, alpha)
                    
                    size = int(particle.get('size', 5.0))
                    x = int(particle.get('x', 0))
                    y = int(particle.get('y', 0))
                    
                    if size > 0:
                        # Draw bubble (circle with highlight)
                        painter.setBrush(QBrush(bubble_color))
                        pen = QPen(QColor(r, g, b, 180), 1)
                        painter.setPen(pen)
                        painter.drawEllipse(x - size//2, y - size//2, size, size)
                        
                        # Highlight (reflection) on bubble
                        if size > 4:
                            highlight_size = size // 3
                            highlight_x = x - size//3
                            highlight_y = y - size//3
                            highlight_color = QColor(255, 255, 255, 100)
                            painter.setBrush(QBrush(highlight_color))
                            painter.setPen(Qt.PenStyle.NoPen)
                            painter.drawEllipse(highlight_x - highlight_size//2, 
                                              highlight_y - highlight_size//2, 
                                              highlight_size, highlight_size)
            elif particle_mode == 'sparkles':
                # Draw shimmering sparkles
                rect = viz_overlay.rect()
                
                for particle in viz_particles:
                    r, g, b = particle.get('color', (255, 215, 0))
                    # Twinkle effect
                    twinkle_phase = particle.get('twinkle_phase', 0)
                    twinkle_intensity = 0.2 + 0.8 * (0.5 + 0.5 * math.sin(twinkle_phase))
                    life_ratio = particle.get('life', 1.0) / particle.get('max_life', 1.0)
                    alpha = int(255 * twinkle_intensity * life_ratio)
                    sparkle_color = QColor(r, g, b, alpha)
                    
                    size = int(particle.get('size', 3.0) * twinkle_intensity)
                    x = int(particle.get('x', 0))
                    y = int(particle.get('y', 0))
                    
                    if size > 0:
                        # Draw sparkle as star shape
                        pen_width = max(1, size // 5)  # Scale pen width with sparkle size
                        painter.setPen(QPen(sparkle_color, pen_width))
                        painter.setBrush(QBrush(sparkle_color))
                        
                        # Center point
                        painter.drawEllipse(x - size//4, y - size//4, size//2, size//2)
                        
                        # Star rays (longer for larger sparkles)
                        ray_length = int(size * 1.2)
                        # 8-pointed star
                        for angle in range(0, 360, 45):
                            rad = math.radians(angle)
                            end_x = x + int(ray_length * math.cos(rad))
                            end_y = y + int(ray_length * math.sin(rad))
                            painter.drawLine(x, y, end_x, end_y)
            
            painter.end()
        
        viz_overlay.paintEvent = viz_paint_event
        
        # Timer to update visualization smoothly (30 FPS)
        viz_update_timer = QTimer(dialog)
        viz_update_timer.timeout.connect(update_visualization)
        
        # Function to set visualization mode (base visualizations only)
        def set_visualization_mode(mode):
            nonlocal viz_mode
            viz_mode = mode
            
            # Save to settings
            if self.parent_window and hasattr(self.parent_window, 'settings'):
                self.parent_window.settings['image_viewer_visualization'] = mode
                if hasattr(self.parent_window, 'save_settings'):
                    self.parent_window.save_settings()
            
            # Show/hide overlay and start/stop timer
            if mode == 'none' and particle_mode == 'none':
                viz_overlay.hide()
                viz_update_timer.stop()
            else:
                viz_overlay.show()
                viz_overlay.raise_()
                if not viz_update_timer.isActive():
                    viz_update_timer.start(33)  # ~30 FPS
                update_visualization()
        
        # Function to set particle mode (can run alongside base visualizations)
        def set_particle_mode(mode):
            nonlocal particle_mode, viz_particles
            particle_mode = mode
            
            # Clear particles when switching modes to avoid conflicts
            viz_particles = []
            
            # Save to settings
            if self.parent_window and hasattr(self.parent_window, 'settings'):
                self.parent_window.settings['image_viewer_particles'] = mode
                if hasattr(self.parent_window, 'save_settings'):
                    self.parent_window.save_settings()
            
            # Show/hide overlay and start/stop timer
            if viz_mode == 'none' and mode == 'none':
                viz_overlay.hide()
                viz_update_timer.stop()
            else:
                viz_overlay.show()
                viz_overlay.raise_()
                if not viz_update_timer.isActive():
                    viz_update_timer.start(33)  # ~30 FPS
                update_visualization()
        
        # Create visualization menu
        def show_viz_menu():
            # Set menu open flag to prevent autohide
            nonlocal menu_open
            menu_open = True
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls['menu_open'] = True
            show_controls()  # Ensure controls are visible
            
            # Get button position
            btn_pos = player_viz_btn.mapToGlobal(player_viz_btn.rect().bottomLeft())
            
            # Create menu dialog
            menu_dialog = QDialog(dialog)
            # Store menu dialog reference for zoom prevention
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls['viz_menu_dialog'] = menu_dialog
            menu_dialog.setWindowFlags(
                Qt.WindowType.FramelessWindowHint |
                Qt.WindowType.Popup
            )
            menu_dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    border: 1px solid #4a90e2;
                    border-top: 1px solid #4a90e2;
                    border-right: 1px solid #4a90e2;
                    border-bottom: 1px solid #4a90e2;
                    border-left: 1px solid #4a90e2;
                }
            """)
            
            menu_layout = QVBoxLayout(menu_dialog)
            menu_layout.setContentsMargins(1, 1, 1, 1)  # 1px margin to account for border
            menu_layout.setSpacing(0)
            
            # Use QListWidget to match album menu style
            menu_list = QListWidget()
            
            # Apply Windows 11 detection for consistent spacing
            is_windows_11 = False
            if hasattr(self, '_detect_windows_11'):
                is_windows_11 = self._detect_windows_11()
            elif self.parent_window and hasattr(self.parent_window, '_detect_windows_11'):
                is_windows_11 = self.parent_window._detect_windows_11()
            
            if is_windows_11:
                item_padding = "0px 8px"
                item_min_height = "min-height: 18px;"
            else:
                item_padding = "2px 8px"
                item_min_height = ""
            
            menu_stylesheet = """
                QListWidget {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: none;
                    font-size: 11px;
                }
                QListWidget::item {
                    padding: """ + item_padding + """;
                    border: none;
                    """ + item_min_height + """
                }
                QListWidget::item:selected {
                    background-color: transparent;
                    color: #4a90e2;
                }
                QListWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """
            menu_list.setStyleSheet(menu_stylesheet)
            menu_list.setSelectionMode(QListWidget.SelectionMode.SingleSelection)
            menu_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            
            # Menu items (base visualizations only - particles have separate menu)
            menu_items = [
                ('none', 'None (Disabled)'),
                ('progress_ring', ' Progress Ring'),
                ('spectrum', ' Spectrum (Edge Bars)'),
                ('radial_spectrum', ' Radial Spectrum'),
                ('waveform', ' Waveform')
            ]
            
            for mode, label in menu_items:
                item = QListWidgetItem(label)
                item.setData(Qt.ItemDataRole.UserRole, mode)
                menu_list.addItem(item)
                # Select current mode
                if mode == viz_mode:
                    menu_list.setCurrentItem(item)
            
            def on_item_clicked(item):
                mode = item.data(Qt.ItemDataRole.UserRole)
                if mode:
                    set_visualization_mode(mode)
                    menu_dialog.close()
                    # Reset menu open flag
                    nonlocal menu_open
                    menu_open = False
                    if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                        self.parent_window._image_viewer_controls['menu_open'] = False
                        # Clear menu dialog reference
                        if 'viz_menu_dialog' in self.parent_window._image_viewer_controls:
                            del self.parent_window._image_viewer_controls['viz_menu_dialog']
            
            menu_list.itemClicked.connect(on_item_clicked)
            menu_layout.addWidget(menu_list)
            
            # Handle menu close to reset menu_open flag
            def on_menu_finished():
                nonlocal menu_open
                menu_open = False
                if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                    self.parent_window._image_viewer_controls['menu_open'] = False
                    # Clear menu dialog reference
                    if 'viz_menu_dialog' in self.parent_window._image_viewer_controls:
                        del self.parent_window._image_viewer_controls['viz_menu_dialog']
            
            menu_dialog.finished.connect(on_menu_finished)
            
            # Set minimum size for menu
            menu_list.setMinimumHeight(50)
            menu_list.setMaximumHeight(200)
            menu_dialog.setMinimumSize(150, 50)
            menu_dialog.setMaximumSize(300, 200)
            
            # Calculate menu size and position
            menu_dialog.adjustSize()
            menu_width = menu_dialog.width()
            menu_height = menu_dialog.height()
            
            # Position menu below button
            menu_x = btn_pos.x()
            menu_y = btn_pos.y() + 2
            
            # Check if menu goes off screen
            screen = QApplication.screenAt(btn_pos)
            if screen:
                screen_geometry = screen.availableGeometry()
                if menu_x + menu_width > screen_geometry.right():
                    menu_x = screen_geometry.right() - menu_width
                if menu_y + menu_height > screen_geometry.bottom():
                    menu_y = btn_pos.y() - menu_height - 2
            
            menu_dialog.move(menu_x, menu_y)
            menu_dialog.exec()
            
            # Reset menu open flag after menu closes
            menu_open = False
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls['menu_open'] = False
        
        player_viz_btn.clicked.connect(show_viz_menu)
        top_row.addWidget(player_viz_btn)
        
        # Particle effects button (separate from base visualizations)
        player_particle_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('snowflake', color='#e0e0e0')
            if not icon:
                icon = get_icon('star', color='#e0e0e0')
            if icon:
                player_particle_btn.setIcon(icon)
                player_particle_btn.setIconSize(QSize(18, 18))
            else:
                player_particle_btn.setText("")
        else:
            player_particle_btn.setText("")
        player_particle_btn.setFixedSize(28, 28)
        player_particle_btn.setToolTip("Particle Effects")
        player_particle_btn.setStyleSheet(button_style)
        
        # Create particle effects menu
        def show_particle_menu():
            # Set menu open flag to prevent autohide
            nonlocal menu_open
            menu_open = True
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls['menu_open'] = True
            show_controls()  # Ensure controls are visible
            
            # Get button position
            btn_pos = player_particle_btn.mapToGlobal(player_particle_btn.rect().bottomLeft())
            
            # Create menu dialog
            menu_dialog = QDialog(dialog)
            # Store menu dialog reference for zoom prevention
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls['particle_menu_dialog'] = menu_dialog
            menu_dialog.setWindowFlags(
                Qt.WindowType.FramelessWindowHint |
                Qt.WindowType.Popup
            )
            menu_dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    border: 1px solid #4a90e2;
                    border-top: 1px solid #4a90e2;
                    border-right: 1px solid #4a90e2;
                    border-bottom: 1px solid #4a90e2;
                    border-left: 1px solid #4a90e2;
                }
            """)
            
            menu_layout = QVBoxLayout(menu_dialog)
            menu_layout.setContentsMargins(1, 1, 1, 1)  # 1px margin to account for border
            menu_layout.setSpacing(0)
            
            # Use QListWidget to match album menu style
            menu_list = QListWidget()
            
            # Apply Windows 11 detection for consistent spacing
            is_windows_11 = False
            if hasattr(self, '_detect_windows_11'):
                is_windows_11 = self._detect_windows_11()
            elif self.parent_window and hasattr(self.parent_window, '_detect_windows_11'):
                is_windows_11 = self.parent_window._detect_windows_11()
            
            if is_windows_11:
                item_padding = "0px 8px"
                item_min_height = "min-height: 18px;"
            else:
                item_padding = "2px 8px"
                item_min_height = ""
            
            menu_stylesheet = """
                QListWidget {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: none;
                    font-size: 11px;
                }
                QListWidget::item {
                    padding: """ + item_padding + """;
                    border: none;
                    """ + item_min_height + """
                }
                QListWidget::item:selected {
                    background-color: transparent;
                    color: #4a90e2;
                }
                QListWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """
            menu_list.setStyleSheet(menu_stylesheet)
            menu_list.setSelectionMode(QListWidget.SelectionMode.SingleSelection)
            menu_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            
            # Particle menu items
            particle_menu_items = [
                ('none', 'None (Disabled)'),
                ('snow', ' Snow'),
                ('rain', ' Rain'),
                ('stars', ' Stars'),
                ('fireflies', ' Fireflies'),
                ('bubbles', ' Bubbles'),
                ('sparkles', ' Sparkles')
            ]
            
            for mode, label in particle_menu_items:
                item = QListWidgetItem(label)
                item.setData(Qt.ItemDataRole.UserRole, mode)
                menu_list.addItem(item)
                # Select current mode
                if mode == particle_mode:
                    menu_list.setCurrentItem(item)
            
            def on_item_clicked(item):
                mode = item.data(Qt.ItemDataRole.UserRole)
                if mode:
                    set_particle_mode(mode)
                    menu_dialog.close()
                    # Reset menu open flag
                    nonlocal menu_open
                    menu_open = False
                    if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                        self.parent_window._image_viewer_controls['menu_open'] = False
                        # Clear menu dialog reference
                        if 'particle_menu_dialog' in self.parent_window._image_viewer_controls:
                            del self.parent_window._image_viewer_controls['particle_menu_dialog']
            
            menu_list.itemClicked.connect(on_item_clicked)
            menu_layout.addWidget(menu_list)
            
            # Handle menu close to reset menu_open flag
            def on_menu_finished():
                nonlocal menu_open
                menu_open = False
                if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                    self.parent_window._image_viewer_controls['menu_open'] = False
                    # Clear menu dialog reference
                    if 'particle_menu_dialog' in self.parent_window._image_viewer_controls:
                        del self.parent_window._image_viewer_controls['particle_menu_dialog']
            
            menu_dialog.finished.connect(on_menu_finished)
            
            # Set minimum size for menu
            menu_list.setMinimumHeight(50)
            menu_list.setMaximumHeight(200)
            menu_dialog.setMinimumSize(150, 50)
            menu_dialog.setMaximumSize(300, 200)
            
            # Calculate menu size and position
            menu_dialog.adjustSize()
            menu_width = menu_dialog.width()
            menu_height = menu_dialog.height()
            
            # Position menu below button
            menu_x = btn_pos.x()
            menu_y = btn_pos.y() + 2
            
            # Check if menu goes off screen
            screen = QApplication.screenAt(btn_pos)
            if screen:
                screen_geometry = screen.availableGeometry()
                if menu_x + menu_width > screen_geometry.right():
                    menu_x = screen_geometry.right() - menu_width
                if menu_y + menu_height > screen_geometry.bottom():
                    menu_y = btn_pos.y() - menu_height - 2
            
            menu_dialog.move(menu_x, menu_y)
            menu_dialog.exec()
            
            # Reset menu open flag after menu closes
            menu_open = False
            if self.parent_window and hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls['menu_open'] = False
        
        player_particle_btn.clicked.connect(show_particle_menu)
        top_row.addWidget(player_particle_btn)
        
        # Function to update visualization with playback state
        def update_viz_from_playback(current_time, duration, is_playing=False):
            nonlocal viz_current_time, viz_duration, viz_is_playing
            viz_current_time = current_time
            viz_duration = duration
            viz_is_playing = is_playing
            update_visualization()
        
        # Store reference for external updates
        if self.parent_window:
            if not hasattr(self.parent_window, '_image_viewer_controls'):
                self.parent_window._image_viewer_controls = {}
            self.parent_window._image_viewer_controls['viz_overlay'] = viz_overlay
            self.parent_window._image_viewer_controls['update_viz'] = update_viz_from_playback
        
        # Initialize visualization mode and particle mode
        set_visualization_mode(current_viz_mode)
        set_particle_mode(current_particle_mode)
        
        # Update visualization overlay position on resize
        def update_viz_position():
            if viz_overlay.parent():
                viz_overlay.setGeometry(image_label.rect())
        
        # Connect to image_label resize
        original_image_resize = image_label.resizeEvent
        def image_resize_with_viz(event):
            if original_image_resize:
                original_image_resize(event)
            update_viz_position()
        
        image_label.resizeEvent = image_resize_with_viz
        QTimer.singleShot(100, update_viz_position)
        
        # Info button (always visible, not controlled by autohide)
        player_info_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('fa5s.info', color='#e0e0e0')
            if icon:
                player_info_btn.setIcon(icon)
                player_info_btn.setIconSize(QSize(18, 18))  # Match icon size with other buttons
            else:
                player_info_btn.setText("i")
        else:
            player_info_btn.setText("i")
        player_info_btn.setFixedSize(28, 28)  # Match playback button size
        player_info_btn.setToolTip("View Controls Help")
        player_info_btn.setStyleSheet(button_style)
        # Connect to toggle_tooltip function (show if hidden, hide if shown)
        def on_player_info_click():
            if self._image_viewer_toggle_tooltip:
                self._image_viewer_toggle_tooltip()
        player_info_btn.clicked.connect(on_player_info_click)
        top_row.addWidget(player_info_btn)
        
        # Fullscreen button (always visible, not controlled by autohide)
        player_fullscreen_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('expand', color='#e0e0e0')
            if icon:
                player_fullscreen_btn.setIcon(icon)
                player_fullscreen_btn.setIconSize(QSize(18, 18))  # Match icon size with other buttons
            else:
                # Try alternative fullscreen icons
                icon = get_icon('expand-arrows-alt', color='#e0e0e0')
                if icon:
                    player_fullscreen_btn.setIcon(icon)
                    player_fullscreen_btn.setIconSize(QSize(18, 18))
                else:
                    player_fullscreen_btn.setText("")
        else:
            player_fullscreen_btn.setText("")
        player_fullscreen_btn.setFixedSize(28, 28)  # Match playback button size
        player_fullscreen_btn.setToolTip("Toggle Fullscreen")
        player_fullscreen_btn.setStyleSheet(button_style)
        # Connect to same fullscreen functionality
        def on_player_fullscreen_click():
            if self._image_viewer_fullscreen_btn:
                self._image_viewer_fullscreen_btn.click()
        player_fullscreen_btn.clicked.connect(on_player_fullscreen_click)
        top_row.addWidget(player_fullscreen_btn)
        
        # Close button (always visible, not controlled by autohide)
        player_close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('mdi.close-thick', color='#e0e0e0')
            if icon:
                player_close_btn.setIcon(icon)
                player_close_btn.setIconSize(QSize(18, 18))  # Match icon size with other buttons
            else:
                player_close_btn.setText("")
        else:
            player_close_btn.setText("")
        player_close_btn.setFixedSize(28, 28)  # Match playback button size
        player_close_btn.setToolTip("Close Image Viewer")
        player_close_btn.setStyleSheet(button_style)
        # Connect to close dialog
        player_close_btn.clicked.connect(dialog.close)
        top_row.addWidget(player_close_btn)
        
        # Insert top row at the beginning of controls_layout (before album and track rows)
        controls_layout.insertLayout(0, top_row)
        
        # Position buttons in top-right corner - all buttons are children of the container
        close_btn.setParent(modal_controls_container)
        info_btn.setParent(modal_controls_container)
        fullscreen_btn.setParent(modal_controls_container)
        modal_autohide_btn.setParent(modal_controls_container)
        close_btn.raise_()
        info_btn.raise_()
        fullscreen_btn.raise_()
        modal_autohide_btn.raise_()
        
        def update_button_positions():
            if modal_controls_container.parent():
                button_spacing = 10  # Even spacing between buttons
                button_width = close_btn.width()  # All buttons are same size (30px)
                button_height = close_btn.height()
                right_margin = 10  # Match top margin for even spacing
                top_margin = 10
                # Padding around buttons for background (matches top/bottom spacing)
                container_padding = 10  # Padding matches top_margin for consistent spacing
                
                # Calculate container size (4 buttons with spacing + padding)
                # Container width includes buttons, spacing, and padding
                container_width = (button_width * 4) + (button_spacing * 3) + (container_padding * 2)
                container_height = button_height + (container_padding * 2)
                
                # Position container in top-right corner with right_margin spacing from right edge
                container_x = image_label.width() - container_width - right_margin
                container_y = top_margin
                modal_controls_container.setGeometry(container_x, container_y, container_width, container_height)
                
                # Calculate positions relative to container (with padding)
                # Close button on the right
                close_x = container_width - button_width - container_padding
                close_btn.move(close_x, container_padding)
                
                # Fullscreen button to the left of close button
                fullscreen_x = close_x - button_width - button_spacing
                fullscreen_btn.move(fullscreen_x, container_padding)
                
                # Info button to the left of fullscreen button
                info_x = fullscreen_x - button_width - button_spacing
                info_btn.move(info_x, container_padding)
                
                # Autohide button to the left of info button
                autohide_x = info_x - button_width - button_spacing
                modal_autohide_btn.move(autohide_x, container_padding)
        
        # Store original resizeEvent and call both
        original_resize_event = image_label.resizeEvent
        def combined_resize_event(event):
            original_resize_event(event)
            update_button_positions()
            update_modal_hotspot_position()
        image_label.resizeEvent = combined_resize_event
        update_button_positions()
        
        # Initial setup for modal controls container
        def initial_modal_setup():
            update_button_positions()
            update_modal_hotspot_position()
            modal_controls_container.show()
            modal_controls_container.raise_()
            # Set initial opacity based on autohide state
            if modal_controls_autohide_enabled:
                # Autohide enabled - start hidden (will show on hover), make hotspot interactive
                modal_opacity_effect.setOpacity(0.0)
                modal_hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
            else:
                # Autohide disabled - start visible, make hotspot transparent
                modal_opacity_effect.setOpacity(1.0)
                modal_hotspot_widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            modal_controls_container.setEnabled(True)
        QTimer.singleShot(100, initial_modal_setup)
        
        # Don't set tooltip as child - it needs to be a top-level window for the window flags to work
        # Instead, we'll hide it when the dialog closes
        def on_dialog_finished():
            tooltip_widget.hide()
            # Clear image viewer references when dialog closes
            if self.parent_window:
                if hasattr(self.parent_window, '_image_viewer_dialog'):
                    self.parent_window._image_viewer_dialog = None
                if hasattr(self.parent_window, '_image_viewer_image_label'):
                    self.parent_window._image_viewer_image_label = None
        dialog.finished.connect(on_dialog_finished)
        
        # Center dialog on screen
        if screen:
            screen_geometry = screen.availableGeometry()
            dialog_x = screen_geometry.x() + (screen_geometry.width() - dialog.width()) // 2
            dialog_y = screen_geometry.y() + (screen_geometry.height() - dialog.height()) // 2
            dialog.move(dialog_x, dialog_y)
        
        # Close on Escape key, toggle fullscreen on Enter key
        def handle_key_press(event):
            if event.key() == Qt.Key.Key_Escape:
                dialog.close()
            elif event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
                toggle_fullscreen()
        dialog.keyPressEvent = handle_key_press
        
        # Note: Right-click handling is done by the event filter above,
        # so we don't need separate dialog-level handlers
        
        # Handle mouse events for pan/zoom and closing
        # Store original mouse handlers
        original_mouse_press = image_label.mousePressEvent
        original_mouse_move = image_label.mouseMoveEvent
        original_mouse_release = image_label.mouseReleaseEvent
        original_wheel = image_label.wheelEvent
        
        def mouse_press_event(event):
            # Check if click is on modal controls container first - if so, don't handle panning
            if modal_controls_container.geometry().contains(event.pos()):
                # Let the buttons handle the click
                return
            
            # Get parent window reference (try multiple ways to be robust)
            parent_win = None
            if self.parent_window:
                parent_win = self.parent_window
            elif hasattr(dialog, 'parent') and dialog.parent():
                # Try to get parent window from dialog
                parent_win = dialog.parent()
            
            # Check if menus are open - if so, close them and prevent zoom
            menus_open = False
            if parent_win:
                if hasattr(parent_win, '_album_menu_dialog') and parent_win._album_menu_dialog and parent_win._album_menu_dialog.isVisible():
                    menus_open = True
                if hasattr(parent_win, '_track_menu_dialog') and parent_win._track_menu_dialog and parent_win._track_menu_dialog.isVisible():
                    menus_open = True
                # Check for visualizer menu using menu_open flag (more reliable than isVisible for popup dialogs)
                if hasattr(parent_win, '_image_viewer_controls'):
                    if parent_win._image_viewer_controls.get('menu_open', False):
                        menus_open = True
            
            if menus_open:
                if event.button() == Qt.MouseButton.LeftButton:
                    # Close menus on image click and prevent zoom
                    if parent_win:
                        if hasattr(parent_win, '_album_menu_dialog') and parent_win._album_menu_dialog and parent_win._album_menu_dialog.isVisible():
                            parent_win._album_menu_dialog.close()
                        if hasattr(parent_win, '_track_menu_dialog') and parent_win._track_menu_dialog and parent_win._track_menu_dialog.isVisible():
                            parent_win._track_menu_dialog.close()
                        # Close visualizer menu
                        if hasattr(parent_win, '_image_viewer_controls'):
                            if parent_win._image_viewer_controls.get('menu_open', False):
                                # Close the visualizer menu dialog if it exists
                                if parent_win._image_viewer_controls.get('viz_menu_dialog'):
                                    viz_menu = parent_win._image_viewer_controls.get('viz_menu_dialog')
                                    if viz_menu:
                                        viz_menu.close()
                                    # Clear the reference
                                    del parent_win._image_viewer_controls['viz_menu_dialog']
                                # Clear the menu_open flag
                                parent_win._image_viewer_controls['menu_open'] = False
                    event.accept()
                    return  # Don't process zoom/pan
            
            # Let zoomable viewer handle left-click for panning
            if event.button() == Qt.MouseButton.LeftButton:
                original_mouse_press(event)
            # Right-click - accept but don't close yet (let it "land")
            elif event.button() == Qt.MouseButton.RightButton:
                event.accept()  # Accept the event to prevent it from propagating
                # Don't close on press - let the click "land" first
            # Middle-click - reset zoom
            elif event.button() == Qt.MouseButton.MiddleButton:
                event.accept()  # Accept the event to prevent it from propagating
                image_label.reset_view()
            else:
                original_mouse_press(event)
        
        def mouse_release_event(event):
            # Get parent window reference (try multiple ways to be robust)
            parent_win = None
            if self.parent_window:
                parent_win = self.parent_window
            elif hasattr(dialog, 'parent') and dialog.parent():
                # Try to get parent window from dialog
                parent_win = dialog.parent()
            
            # Check if menus are open - if so, don't process zoom
            menus_open = False
            if parent_win:
                if hasattr(parent_win, '_album_menu_dialog') and parent_win._album_menu_dialog and parent_win._album_menu_dialog.isVisible():
                    menus_open = True
                if hasattr(parent_win, '_track_menu_dialog') and parent_win._track_menu_dialog and parent_win._track_menu_dialog.isVisible():
                    menus_open = True
                # Check for visualizer menu using menu_open flag (more reliable than isVisible for popup dialogs)
                if hasattr(parent_win, '_image_viewer_controls'):
                    if parent_win._image_viewer_controls.get('menu_open', False):
                        menus_open = True
            
            if menus_open:
                if event.button() == Qt.MouseButton.LeftButton:
                    event.accept()
                    return  # Don't process zoom
            
            # Right-click - close on release
            if event.button() == Qt.MouseButton.RightButton:
                event.accept()  # Accept the event to prevent it from propagating
                # Close on release, so the click "lands" first
                QTimer.singleShot(0, dialog.close)
            # Middle-click - already handled in press event (reset zoom)
            elif event.button() == Qt.MouseButton.MiddleButton:
                event.accept()  # Accept the event to prevent it from propagating
            else:
                original_mouse_release(event)
        
        image_label.mousePressEvent = mouse_press_event
        image_label.mouseReleaseEvent = mouse_release_event
        # Removed double-click handler - not needed
        
        # Ensure dialog is on top but doesn't interfere with autohide button
        # Set z-order to be below the autohide trigger button
        try:
            print(f"[COVER ART CLICK] About to show dialog, parent_window={self.parent_window}")
            dialog.show()
            print(f"[COVER ART CLICK] Dialog shown, size={dialog.size()}, pos={dialog.pos()}, visible={dialog.isVisible()}")
            dialog.raise_()
            dialog.activateWindow()
            
            # After showing, ensure autohide button is still on top
            if self.parent_window and hasattr(self.parent_window, 'autohide_trigger_btn') and self.parent_window.autohide_trigger_btn:
                QTimer.singleShot(50, lambda: self.parent_window.autohide_trigger_btn.raise_() if self.parent_window.autohide_trigger_btn.isVisible() else None)
            
            print("[COVER ART CLICK] Dialog shown, executing...")
            logger.debug("Cover art click: Dialog shown, executing...")
            dialog.exec()
            print("[COVER ART CLICK] Dialog closed")
            logger.debug("Cover art click: Dialog closed")
        except Exception as e:
            print(f"[COVER ART CLICK] ERROR: {e}")
            import traceback
            traceback.print_exc()
            logger.error(f"Cover art click: Error showing dialog: {e}", exc_info=True)


class RegularPlayerWidget(BasePlayerWidget):
    """Regular mode widget: cover art + player + tracklist."""
    
    @staticmethod
    def _detect_windows_11():
        """Detect if running on Windows 11 (build 22000 or higher)."""
        is_windows_11 = False
        if sys.platform == 'win32':
            try:
                import platform
                # Windows 11 is build 22000 or higher
                version_info = platform.version()
                # Extract build number from version string (e.g., "10.0.22000")
                try:
                    build_num = int(version_info.split('.')[-1])
                    is_windows_11 = build_num >= 22000
                except (ValueError, IndexError):
                    # Fallback: check via sys.getwindowsversion() if available
                    if hasattr(sys, 'getwindowsversion'):
                        win_ver = sys.getwindowsversion()
                        is_windows_11 = win_ver.build >= 22000
            except Exception:
                pass
        return is_windows_11
    
    def setup_ui(self):
        """Setup regular mode UI."""
        # Set size policy to allow widget to expand vertically
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Cover art (top)
        self.cover_art_label = ClickableCoverArtLabel()
        self.cover_art_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.cover_art_label.setStyleSheet("""
            QLabel {
                background-color: #1a1a1a;
                border: none;
            }
        """)
        self.cover_art_label.setScaledContents(True)
        # Fixed height for cover art (maintain aspect ratio)
        self.cover_art_label.setFixedHeight(260)  # Square for 260px width
        # Set size policy to Fixed so it doesn't expand
        self.cover_art_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        # Cover art is no longer clickable - use image viewer button in top nav instead
        # Enable context menu on cover art
        self.cover_art_label.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.cover_art_label.customContextMenuRequested.connect(self._show_player_context_menu)
        main_layout.addWidget(self.cover_art_label, 0)  # No stretch - fixed size
        
        # Store original pixmap for mini mode blur extraction
        self._original_cover_art_pixmap = None
        
        # Blurred cover art region (only the area covered by player section in mini mode)
        # This is a second cover art label that shows only the blurred region behind the player
        self.blurred_cover_art_label = QLabel(self)
        self.blurred_cover_art_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.blurred_cover_art_label.setScaledContents(False)  # We'll manually scale the pixmap
        self.blurred_cover_art_label.setStyleSheet("""
            QLabel {
                background-color: transparent;
                border: none;
            }
        """)
        # Apply blur effect to the entire label
        blur_effect = QGraphicsBlurEffect()
        blur_effect.setBlurRadius(5)  # Same blur as micro mode
        self.blurred_cover_art_label.setGraphicsEffect(blur_effect)
        self.blurred_cover_art_label.lower()  # Behind player section, above main cover art
        self.blurred_cover_art_label.hide()  # Hide until cover art loads
        
        # Player controls section - stays in layout, but can be raised above playlist
        self.player_section = QWidget(self)
        self.player_section.setStyleSheet("background-color: #2b2b2b;")
        # Enable context menu on player section
        self.player_section.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.player_section.customContextMenuRequested.connect(self._show_player_context_menu)
        # Set size policy to Fixed so it doesn't expand and push tracklist out
        self.player_section.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        # Set fixed height: original 105px + extra padding (15px top + 15px bottom - original 2px top - 4px bottom = 24px extra)
        # Total: 105 + 24 = 129px to maintain same content space with new padding
        self.player_section.setFixedHeight(129)
        player_layout = QVBoxLayout(self.player_section)
        player_layout.setContentsMargins(15, 15, 15, 15)  # Same padding as micro mode
        player_layout.setSpacing(0)
        
        self.setup_player_controls(player_layout)
        
        # Create invisible hotzone overlay for autohide (covers player area, always receives mouse events)
        # This allows showing the player when hovering over the area even when it's hidden
        self.autohide_hotzone = QWidget(self)
        self.autohide_hotzone.setStyleSheet("background-color: transparent;")
        self.autohide_hotzone.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)  # Ensure it receives mouse events
        self.autohide_hotzone.hide()  # Hidden by default, shown when autohide is enabled
        self.autohide_hotzone.raise_()  # Ensure it's on top to receive mouse events
        
        # Autohide toggle button (only visible in mini mode, positioned at top right)
        self.autohide_toggle_btn = QPushButton(self.player_section)
        self.autohide_toggle_btn.setCheckable(True)
        self.autohide_toggle_btn.setFixedSize(22, 22)
        self.autohide_toggle_btn.setToolTip("Autohide Player")
        # Use eye icon (same as removed top nav button)
        # Initial state: autohide is disabled, so use gray color
        icon_color = '#a0a0a0'
        if HAS_QT_AWESOME:
            icon = get_icon('fa6s.eye', color=icon_color)
            if icon:
                self.autohide_toggle_btn.setIcon(icon)
            else:
                self.autohide_toggle_btn.setText("")
        else:
            self.autohide_toggle_btn.setText("")
        self.autohide_toggle_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #a0a0a0;
                border: none;
                font-size: 14px;
                padding: 2px;
                outline: none;
            }
            QPushButton:hover {
                background-color: transparent;
                border: 1px solid rgba(74, 144, 226, 0.4);
                border-radius: 3px;
            }
            QPushButton:focus {
                outline: none;
            }
            QPushButton:focus:hover {
                background-color: transparent;
                border: 1px solid rgba(74, 144, 226, 0.4);
                border-radius: 3px;
            }
            QPushButton:pressed {
                outline: none;
                border: 1px solid rgba(74, 144, 226, 0.6);
                border-radius: 3px;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: transparent;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
            QPushButton:checked:hover {
                color: #4a90e2;
                background-color: transparent;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """)
        self.autohide_toggle_btn.clicked.connect(self._on_autohide_toggle)
        self.autohide_toggle_btn.hide()  # Hide by default, only show in mini mode
        
        # Autohide state
        self._autohide_enabled = False
        self._autohide_timer = None
        self._player_section_visible = True
        self._menu_open = False  # Track if album/track menu is open
        
        # Add player section to layout (no spacer needed - it's in the layout)
        main_layout.addWidget(self.player_section, 0)  # No stretch - fixed size
        
        # Tracklist widget (always visible, scrollable)
        self.tracklist_widget = QListWidget()
        
        # Detect Windows 11 for tighter spacing (Windows 11 has different default spacing)
        is_windows_11 = self._detect_windows_11()
        
        # Apply tighter spacing for Windows 11, original spacing for Windows 10
        if is_windows_11:
            item_padding = "0px 8px"
            item_min_height = "min-height: 18px;"
        else:
            item_padding = "4px 8px"
            item_min_height = ""
        
        tracklist_stylesheet = """
            QListWidget {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                font-size: 11px;
            }
            QListWidget::item {
                padding: """ + item_padding + """;
                border: none;
                """ + item_min_height + """
            }
            QListWidget::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QListWidget::item:hover {
                background-color: #3a3a3a;
            }
            QListWidget::item:disabled {
                color: #888888;
            }
            QScrollBar:vertical {
                background-color: #2b2b2b;
                width: 10px;
                margin: 0px;
                border: none;
            }
            QScrollBar::handle:vertical {
                background-color: #4a4a4a;
                min-height: 20px;
                border-radius: 5px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #5a5a5a;
            }
            QScrollBar::handle:vertical:pressed {
                background-color: #6a6a6a;
            }
            QScrollBar::add-line:vertical {
                height: 0px;
                subcontrol-position: bottom;
                subcontrol-origin: margin;
            }
            QScrollBar::sub-line:vertical {
                height: 0px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                background: none;
            }
        """
        self.tracklist_widget.setStyleSheet(tracklist_stylesheet)
        self.tracklist_widget.setSelectionMode(QListWidget.SelectionMode.NoSelection)
        self.tracklist_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        # Make items more compact (reduce spacing between items) - match playlist styling
        self.tracklist_widget.setSpacing(0)
        self.tracklist_widget.setUniformItemSizes(True)  # Optimize rendering for uniform item sizes
        # Enable mouse tracking for hover state detection
        self.tracklist_widget.setMouseTracking(True)
        # Enable tooltips
        self.tracklist_widget.setToolTipDuration(3000)  # Show tooltips for 3 seconds
        self.tracklist_widget.itemClicked.connect(self._on_tracklist_item_clicked)
        
        # Use TracklistDelegate for two-column layout (title on left, duration on right)
        tracklist_delegate = TracklistDelegate()
        self.tracklist_widget.setItemDelegate(tracklist_delegate)
        
        # Set size policy to allow tracklist to expand and fill remaining space
        self.tracklist_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        # Set minimum height to ensure tracklist is visible
        self.tracklist_widget.setMinimumHeight(150)
        # Make sure tracklist is visible even when empty (show background)
        self.tracklist_widget.setVisible(True)
        
        # Add placeholder text to test visibility
        placeholder_item = QListWidgetItem("Loading tracklist...")
        placeholder_item.setForeground(QColor("#888888"))
        placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)  # Make it non-interactive
        self.tracklist_widget.addItem(placeholder_item)
        
        main_layout.addWidget(self.tracklist_widget, 1)  # Stretch to fill remaining space
        
        # Tracklist will be updated when page loads (via on_page_loaded callback)
        # Also try to update after a short delay in case page is already loaded
        QTimer.singleShot(500, self._update_tracklist)
    
    def _on_autohide_toggle(self):
        """Handle autohide toggle button click."""
        if not self.parent_window:
            return
        
        # Toggle autohide state
        self._autohide_enabled = self.autohide_toggle_btn.isChecked()
        self.parent_window.mini_mode_player_autohide = self._autohide_enabled
        self.parent_window.settings['mini_mode_player_autohide'] = self._autohide_enabled
        self.parent_window.save_settings()
        
        # Update icon based on state
        self._update_autohide_icon()
        
        # Setup mouse events if enabling
        if self._autohide_enabled:
            self._setup_autohide_mouse_events()
            # Start autohide timer after initial delay
            QTimer.singleShot(600, self._start_autohide_timer)
        else:
            # If disabling autohide, ensure player section is visible
            self._show_player_section()
            # Remove event filter from player section only (cover art no longer has event filter)
            if hasattr(self, 'player_section') and self.player_section:
                self.player_section.removeEventFilter(self)
    
    def _update_autohide_icon(self):
        """Update autohide toggle button icon based on state."""
        if not hasattr(self, 'autohide_toggle_btn') or not self.autohide_toggle_btn:
            return
        
        is_checked = self._autohide_enabled
        icon_color = '#4a90e2' if is_checked else '#a0a0a0'
        
        if HAS_QT_AWESOME:
            # Use eye icon (same as removed top nav button)
            icon = get_icon('fa6s.eye', color=icon_color)
            if icon:
                self.autohide_toggle_btn.setIcon(icon)
            else:
                self.autohide_toggle_btn.setText("")
        else:
            self.autohide_toggle_btn.setText("")
    
    def _show_player_section(self):
        """Show player section (for autohide)."""
        if not hasattr(self, 'player_section') or not self.player_section:
            return
        
        self.player_section.show()
        self._player_section_visible = True
        
        # Hide hotzone when player is visible (player section will receive mouse events)
        if hasattr(self, 'autohide_hotzone') and self.autohide_hotzone:
            self.autohide_hotzone.hide()
        
        # Also show blurred cover art if in mini mode
        if (hasattr(self, 'blurred_cover_art_label') and self.blurred_cover_art_label and
            self.parent_window and hasattr(self.parent_window, 'mini_mode_state') and
            self.parent_window.mini_mode_state == 1):
            self.blurred_cover_art_label.show()
    
    def _hide_player_section(self):
        """Hide player section (for autohide)."""
        if not hasattr(self, 'player_section') or not self.player_section:
            return
        if not self._autohide_enabled:
            return
        
        self.player_section.hide()
        self._player_section_visible = False
        
        # Show hotzone when player is hidden (so hovering over the area will show it)
        if hasattr(self, 'autohide_hotzone') and self.autohide_hotzone:
            self._update_autohide_hotzone_position()
            self.autohide_hotzone.show()
            self.autohide_hotzone.raise_()
        
        # Also hide blurred cover art
        if hasattr(self, 'blurred_cover_art_label') and self.blurred_cover_art_label:
            self.blurred_cover_art_label.hide()
    
    def _start_autohide_timer(self):
        """Start autohide timer to hide player section after delay."""
        if not self._autohide_enabled:
            return
        
        # Don't start autohide timer if a menu is open
        if self._menu_open:
            return
        
        if self._autohide_timer:
            self._autohide_timer.stop()
        
        # Hide after 150ms delay (matching webview version)
        self._autohide_timer = QTimer(self)
        self._autohide_timer.setSingleShot(True)
        self._autohide_timer.timeout.connect(self._hide_player_section)
        self._autohide_timer.start(150)
    
    def _cancel_autohide_timer(self):
        """Cancel autohide timer and show player section."""
        if self._autohide_timer:
            self._autohide_timer.stop()
            self._autohide_timer = None
        
        if self._autohide_enabled:
            self._show_player_section()
    
    def _setup_autohide_mouse_events(self):
        """Setup mouse enter/leave events on player section for autohide."""
        # Install event filter on player section
        if hasattr(self, 'player_section') and self.player_section:
            self.player_section.installEventFilter(self)
        
        # Also install event filter on hotzone overlay (invisible area that covers player)
        # This allows showing the player when hovering over the area even when it's hidden
        if hasattr(self, 'autohide_hotzone') and self.autohide_hotzone:
            self.autohide_hotzone.installEventFilter(self)
            self._update_autohide_hotzone_position()
            self.autohide_hotzone.show()
    
    def eventFilter(self, obj, event):
        """Event filter for autohide mouse events."""
        if not self._autohide_enabled:
            return super().eventFilter(obj, event)
        
        # Handle mouse enter on player section or hotzone (not cover art)
        if event.type() == QEvent.Type.Enter:
            if obj == self.player_section or obj == self.autohide_hotzone:
                self._cancel_autohide_timer()
                self._show_player_section()
                return True
        
        # Handle mouse leave on player section or hotzone (not cover art)
        elif event.type() == QEvent.Type.Leave:
            if obj == self.player_section or obj == self.autohide_hotzone:
                self._start_autohide_timer()
                return True
        
        return super().eventFilter(obj, event)
    
    def _update_autohide_for_mini_mode(self):
        """Update autohide button visibility and state for mini mode."""
        if not hasattr(self, 'autohide_toggle_btn') or not self.autohide_toggle_btn:
            return
        
        # Only show in mini mode
        if (self.parent_window and hasattr(self.parent_window, 'mini_mode_state') and
            self.parent_window.mini_mode_state == 1):
            self.autohide_toggle_btn.show()
            # Update state from settings
            if hasattr(self.parent_window, 'mini_mode_player_autohide'):
                self._autohide_enabled = self.parent_window.mini_mode_player_autohide
                self.autohide_toggle_btn.setChecked(self._autohide_enabled)
                self._update_autohide_icon()
                # Position at top right
                QTimer.singleShot(50, lambda: self._position_autohide_button())
                
                # Setup mouse events if autohide is enabled
                if self._autohide_enabled:
                    self._setup_autohide_mouse_events()
                    QTimer.singleShot(600, self._start_autohide_timer)  # Initial delay like webview
                    # Update hotzone position after setup
                    QTimer.singleShot(100, self._update_autohide_hotzone_position)
                else:
                    self._show_player_section()
                    # Hide hotzone when autohide is disabled
                    if hasattr(self, 'autohide_hotzone') and self.autohide_hotzone:
                        self.autohide_hotzone.hide()
        else:
            self.autohide_toggle_btn.hide()
            # Disable autohide when not in mini mode
            self._autohide_enabled = False
            self._cancel_autohide_timer()
            self._show_player_section()
            # Remove event filter from player section only (cover art no longer has event filter)
            if hasattr(self, 'player_section') and self.player_section:
                self.player_section.removeEventFilter(self)
    
    def _position_autohide_button(self):
        """Position autohide button at top right of player section."""
        if not hasattr(self, 'autohide_toggle_btn') or not self.autohide_toggle_btn:
            return
        if not hasattr(self, 'player_section') or not self.player_section:
            return
        
        btn_size = self.autohide_toggle_btn.size()
        section_rect = self.player_section.rect()
        self.autohide_toggle_btn.move(section_rect.width() - btn_size.width() - 5, 5)
        self.autohide_toggle_btn.raise_()
    
    def _update_autohide_hotzone_position(self):
        """Update hotzone overlay position to match player section."""
        if not hasattr(self, 'autohide_hotzone') or not self.autohide_hotzone:
            return
        if not hasattr(self, 'player_section') or not self.player_section:
            return
        
        # Get player section geometry relative to parent widget
        player_geometry = self.player_section.geometry()
        if player_geometry.width() > 0 and player_geometry.height() > 0:
            # Position hotzone to exactly match player section
            self.autohide_hotzone.setGeometry(player_geometry)
            self.autohide_hotzone.raise_()  # Ensure it's on top to receive mouse events
    
    def _update_blurred_cover_art_position(self):
        """Update blurred cover art region position to match player section (for mini mode)."""
        # Only show blur in mini mode (state 1)
        if not self.parent_window or not hasattr(self.parent_window, 'mini_mode_state') or self.parent_window.mini_mode_state != 1:
            if hasattr(self, 'blurred_cover_art_label') and self.blurred_cover_art_label:
                self.blurred_cover_art_label.hide()
            return
        
        if not hasattr(self, 'blurred_cover_art_label') or not self.blurred_cover_art_label:
            return
        if not hasattr(self, 'player_section') or not self.player_section:
            return
        
        # Position blurred region exactly where player section is
        player_geometry = self.player_section.geometry()
        if player_geometry.width() > 0 and player_geometry.height() > 0:
            self.blurred_cover_art_label.setGeometry(player_geometry)
            # Ensure z-order: main cover art (bottom) < blurred region (middle) < player section (top)
            if hasattr(self, 'cover_art_label') and self.cover_art_label:
                self.cover_art_label.lower()
            # Z-order will be set when pixmap is updated
    
    def _update_blurred_cover_art_pixmap(self):
        """Update blurred cover art pixmap from main cover art (for mini mode)."""
        logger.debug("[MINI BLUR DEBUG] RegularPlayerWidget._update_blurred_cover_art_pixmap called")
        
        # Only show blur in mini mode (state 1)
        if not self.parent_window or not hasattr(self.parent_window, 'mini_mode_state') or self.parent_window.mini_mode_state != 1:
            if hasattr(self, 'blurred_cover_art_label') and self.blurred_cover_art_label:
                self.blurred_cover_art_label.hide()
            logger.debug("[MINI BLUR DEBUG] Not in mini mode, hiding blurred label")
            return
        
        if not hasattr(self, 'blurred_cover_art_label') or not self.blurred_cover_art_label:
            logger.debug("[MINI BLUR DEBUG] No blurred_cover_art_label")
            return
        if not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            logger.debug("[MINI BLUR DEBUG] No cover_art_label")
            return
        if not hasattr(self, 'player_section') or not self.player_section:
            logger.debug("[MINI BLUR DEBUG] No player_section")
            return
        
        # Use original pixmap if available (before scaling), otherwise use current pixmap
        main_pixmap = None
        if hasattr(self, '_original_cover_art_pixmap') and self._original_cover_art_pixmap:
            main_pixmap = self._original_cover_art_pixmap
            logger.debug(f"[MINI BLUR DEBUG] Using original pixmap, size: {main_pixmap.size()}")
        else:
            main_pixmap = self.cover_art_label.pixmap()
            logger.debug(f"[MINI BLUR DEBUG] Using current pixmap, size: {main_pixmap.size() if main_pixmap else 'None'}")
        
        if not main_pixmap or main_pixmap.isNull():
            logger.debug("[MINI BLUR DEBUG] Main pixmap is null, hiding blurred label")
            self.blurred_cover_art_label.hide()
            return
        
        # Get player section geometry
        player_geometry = self.player_section.geometry()
        logger.debug(f"[MINI BLUR DEBUG] Player section geometry: {player_geometry}")
        if player_geometry.width() <= 0 or player_geometry.height() <= 0:
            logger.debug("[MINI BLUR DEBUG] Player section geometry invalid, hiding blurred label")
            self.blurred_cover_art_label.hide()
            return
        
        # Get main label geometry
        main_label_geometry = self.cover_art_label.geometry()
        logger.debug(f"[MINI BLUR DEBUG] Main label geometry: {main_label_geometry}")
        if main_label_geometry.width() <= 0 or main_label_geometry.height() <= 0:
            logger.debug("[MINI BLUR DEBUG] Main label geometry invalid, hiding blurred label")
            self.blurred_cover_art_label.hide()
            return
        
        # Calculate player position relative to main label
        player_x = player_geometry.x() - main_label_geometry.x()
        player_y = player_geometry.y() - main_label_geometry.y()
        player_w = player_geometry.width()
        player_h = player_geometry.height()
        
        # Get pixmap and label sizes
        pixmap_size = main_pixmap.size()
        label_size = main_label_geometry.size()
        
        # Calculate scale factors (how the pixmap is scaled to fit the label)
        pixmap_aspect = pixmap_size.width() / pixmap_size.height() if pixmap_size.height() > 0 else 1.0
        label_aspect = label_size.width() / label_size.height() if label_size.height() > 0 else 1.0
        
        # Determine how the pixmap is scaled within the label
        if pixmap_aspect > label_aspect:
            # Pixmap is wider - scaled to fit width, height is letterboxed
            scale = label_size.width() / pixmap_size.width() if pixmap_size.width() > 0 else 1.0
            scaled_pixmap_height = pixmap_size.height() * scale
            offset_y = (label_size.height() - scaled_pixmap_height) / 2
            offset_x = 0
        else:
            # Pixmap is taller - scaled to fit height, width is pillarboxed
            scale = label_size.height() / pixmap_size.height() if pixmap_size.height() > 0 else 1.0
            scaled_pixmap_width = pixmap_size.width() * scale
            offset_x = (label_size.width() - scaled_pixmap_width) / 2
            offset_y = 0
        
        # Calculate source region in original pixmap coordinates
        scaled_player_x = player_x - offset_x
        scaled_player_y = player_y - offset_y
        scaled_player_w = player_w
        scaled_player_h = player_h
        
        # Map to original pixmap coordinates
        src_x = int(scaled_player_x / scale) if scale > 0 else 0
        src_y = int(scaled_player_y / scale) if scale > 0 else 0
        src_w = int(scaled_player_w / scale) if scale > 0 else player_w
        src_h = int(scaled_player_h / scale) if scale > 0 else player_h
        
        # Ensure we don't go out of bounds
        src_x = max(0, min(src_x, pixmap_size.width() - 1))
        src_y = max(0, min(src_y, pixmap_size.height() - 1))
        src_w = max(1, min(src_w, pixmap_size.width() - src_x))
        src_h = max(1, min(src_h, pixmap_size.height() - src_y))
        
        # Extract the region from the original pixmap
        logger.debug(f"[MINI BLUR DEBUG] Extracting region: src_x={src_x}, src_y={src_y}, src_w={src_w}, src_h={src_h}")
        cropped_pixmap = main_pixmap.copy(src_x, src_y, src_w, src_h)
        logger.debug(f"[MINI BLUR DEBUG] Cropped pixmap size: {cropped_pixmap.size()}")
        
        # Scale to match player section size exactly
        scaled_pixmap = cropped_pixmap.scaled(
            player_w, player_h,
            Qt.AspectRatioMode.KeepAspectRatioByExpanding,
            Qt.TransformationMode.SmoothTransformation
        )
        logger.debug(f"[MINI BLUR DEBUG] Scaled pixmap size: {scaled_pixmap.size()}, target: {player_w}x{player_h}")
        
        # If the scaled pixmap is larger than player section, crop to center
        if scaled_pixmap.width() > player_w or scaled_pixmap.height() > player_h:
            crop_x = (scaled_pixmap.width() - player_w) // 2 if scaled_pixmap.width() > player_w else 0
            crop_y = (scaled_pixmap.height() - player_h) // 2 if scaled_pixmap.height() > player_h else 0
            final_pixmap = scaled_pixmap.copy(crop_x, crop_y, player_w, player_h)
            logger.debug(f"[MINI BLUR DEBUG] Cropped scaled pixmap to: {final_pixmap.size()}")
        else:
            final_pixmap = scaled_pixmap
        
        # Set the blurred pixmap
        self.blurred_cover_art_label.setPixmap(final_pixmap)
        logger.debug(f"[MINI BLUR DEBUG] Set pixmap on blurred label, size: {final_pixmap.size()}")
        
        # Position and show the blurred label
        self._update_blurred_cover_art_position()
        self.blurred_cover_art_label.show()
        logger.debug(f"[MINI BLUR DEBUG] Blurred label visible: {self.blurred_cover_art_label.isVisible()}, geometry: {self.blurred_cover_art_label.geometry()}")
        self.blurred_cover_art_label.raise_()  # Ensure it's above main cover art
        self.player_section.raise_()  # Ensure player section is on top
    
    def _update_tracklist(self):
        """Update tracklist widget with tracks from current album."""
        if not hasattr(self, 'tracklist_widget') or not self.tracklist_widget:
            logger.debug("_update_tracklist: tracklist_widget not found")
            return
        
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            logger.debug("_update_tracklist: webview or page not available")
            return
        
        # Check if we're on a valid Bandcamp page (not about:blank or empty)
        current_url = self.parent_window.web_view.url().toString()
        if not current_url or current_url == "about:blank" or "bandcamp.com" not in current_url:
            logger.debug(f"_update_tracklist: invalid URL: {current_url}")
            # Update placeholder to show status
            self.tracklist_widget.clear()
            placeholder_item = QListWidgetItem("No Bandcamp page loaded")
            placeholder_item.setForeground(QColor("#888888"))
            placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
            self.tracklist_widget.addItem(placeholder_item)
            return
        
        # Check if webview is hidden - JavaScript might still work but log for debugging
        if self.parent_window.web_view and not self.parent_window.web_view.isVisible():
            logger.debug("_update_tracklist: webview is hidden, but attempting to get tracks")
        
        # Check if page is still loading - wait if it is
        page = self.parent_window.web_view.page()
        if page and hasattr(page, 'isLoading') and page.isLoading():
            logger.debug("_update_tracklist: page is still loading, will retry")
            self.tracklist_widget.clear()
            placeholder_item = QListWidgetItem("Page loading...")
            placeholder_item.setForeground(QColor("#888888"))
            placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
            self.tracklist_widget.addItem(placeholder_item)
            QTimer.singleShot(500, self._update_tracklist)
            return
        
        self.tracklist_widget.clear()
        
        js_code = """
        (function() {
            // Helper function to clean track title - removes time patterns, lyrics text, and extra whitespace
            function cleanTrackTitle(text) {
                if (!text) return '';
                // Remove all time patterns (not just at end) - matches patterns like "00:00", "03:33", "00:00 03:33"
                // Pattern: optional whitespace, digits, colon, digits, optional colon and digits, optional whitespace
                text = text.replace(/\\s*\\d{1,2}:\\d{2}(?::\\d{2})?\\s*/g, ' ');
                // Remove "lyrics" text (case-insensitive) - can appear anywhere
                text = text.replace(/\\s*lyrics\\s*/gi, ' ');
                // Remove any leading/trailing numbers with periods (like "01. " or "1. ")
                text = text.replace(/^\\d+\\.\\s*/, '');
                // Clean up multiple spaces and trim
                text = text.replace(/\\s+/g, ' ').trim();
                
                // Remove duplicate title patterns - split by dash and check if parts are identical
                // This handles cases like "Swinging Home - Swinging Home" -> "Swinging Home"
                var originalText = text;
                var parts = text.split(/\\s*[-]\\s*/);
                if (parts.length === 2) {
                    var part1 = parts[0].trim();
                    var part2 = parts[1].trim();
                    // DEBUG: Log duplicate detection attempt
                    console.log('cleanTrackTitle: Input="' + originalText + '", Part1="' + part1 + '", Part2="' + part2 + '", Match=' + (part1.toLowerCase() === part2.toLowerCase()));
                    // If both parts are the same (case-insensitive), keep only the first
                    if (part1.toLowerCase() === part2.toLowerCase() && part1.length > 0) {
                        text = part1;
                        console.log('cleanTrackTitle: Duplicate removed! "' + originalText + '" -> "' + text + '"');
                    }
                }
                
                return text;
            }
            
            var tracks = [];
            // Use the same method as nano mode - find tracks via #tracklist
            var tracklist = document.querySelector('#tracklist');
            if (tracklist) {
                // Get all tracks - same selectors as nano mode uses
                var trackElements = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                
                trackElements.forEach(function(trackEl, index) {
                    // Get track number from data-num attribute if available
                    var trackNum = trackEl.getAttribute('data-num');
                    var trackIndex = trackNum ? parseInt(trackNum) - 1 : index; // data-num is 1-based
                    
                    // Get track title - look for .info div first (same as nano mode)
                    var infoDiv = trackEl.querySelector('.info');
                    var title = null;
                    
                    if (infoDiv) {
                        // Get title from .info div - look for title span or text (same as nano mode)
                        var titleSpan = infoDiv.querySelector('.title, span.title, a.title');
                        if (titleSpan) {
                            title = titleSpan.textContent.trim();
                            title = cleanTrackTitle(title);
                        } else {
                            // Get text from info div, but exclude time/duration (same as nano mode)
                            var infoText = infoDiv.textContent.trim();
                            title = cleanTrackTitle(infoText);
                        }
                    }
                    
                    // Fallback: look for .track-title or similar (same as nano mode)
                    if (!title || title.length === 0) {
                        var titleEl = trackEl.querySelector('.track-title, .track_title, .title');
                        if (titleEl) {
                            title = titleEl.textContent.trim();
                            title = cleanTrackTitle(title);
                        }
                    }
                    
                    // Fallback: get text from track element, clean it up (same as nano mode)
                    if (!title || title.length === 0) {
                        var clone = trackEl.cloneNode(true);
                        var playBtn = clone.querySelector('.playbutton, button');
                        if (playBtn) playBtn.remove();
                        // Remove time elements if they exist
                        var timeEls = clone.querySelectorAll('.time, .duration, [class*="time"], [class*="duration"]');
                        timeEls.forEach(function(el) { el.remove(); });
                        title = clone.textContent.trim();
                        title = cleanTrackTitle(title);
                    }
                    
                    // Final fallback
                    if (!title || title.length === 0) {
                        title = 'Track ' + (trackIndex + 1);
                    }
                    
                    // DEBUG: Log title extraction for debugging
                    console.log('Tracklist Widget - Track ' + trackIndex + ': Extracted title = "' + title + '"');
                    
                    // Check if track is playable
                    var isPlayable = false;
                    var playStatus = trackEl.querySelector('.play_status');
                    if (!playStatus) {
                        var playCol = trackEl.querySelector('td.play-col, .play-col');
                        if (playCol) {
                            playStatus = playCol.querySelector('.play_status');
                        }
                    }
                    if (playStatus) {
                        isPlayable = !playStatus.classList.contains('disabled');
                    } else {
                        isPlayable = trackEl.classList.contains('playable') || trackEl.classList.contains('has-audio');
                    }
                    
                    // Get duration if available - specifically look for .duration class element
                    var duration = null;
                    // First try to find the .duration element specifically (as user mentioned)
                    var durationEl = trackEl.querySelector('time.duration, .duration');
                    if (durationEl) {
                        var timeText = durationEl.textContent.trim();
                        // Only use if it looks like a time (contains colon or is a short number)
                        if (timeText.indexOf(':') !== -1 || (timeText.length <= 10 && /^[\d:\.]+$/.test(timeText))) {
                            duration = timeText;
                        }
                    }
                    // Fallback: look for other time elements if .duration not found
                    if (!duration) {
                        var timeEl = trackEl.querySelector('.time:not(.duration), .track-length, [class*="time"]:not([class*="title"]):not(.duration)');
                        if (timeEl) {
                            var timeText = timeEl.textContent.trim();
                            // Only use if it looks like a time (contains colon or is a short number)
                            if (timeText.indexOf(':') !== -1 || (timeText.length <= 10 && /^[\d:\.]+$/.test(timeText))) {
                                duration = timeText;
                            }
                        }
                    }
                    
                    tracks.push({
                        index: trackIndex,
                        title: title,
                        dataNum: trackNum,
                        isPlayable: isPlayable,
                        duration: duration
                    });
                });
            }
            return tracks;
        })();
        """
        
        def on_tracks_received(result):
            # Handle None or invalid results
            if result is None:
                logger.debug("_update_tracklist: JavaScript returned None")
                # Show placeholder and retry
                self.tracklist_widget.clear()
                placeholder_item = QListWidgetItem("Loading tracks... (retrying)")
                placeholder_item.setForeground(QColor("#888888"))
                placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
                self.tracklist_widget.addItem(placeholder_item)
                if hasattr(self, 'parent_window') and self.parent_window:
                    QTimer.singleShot(1000, self._update_tracklist)
                return
            
            if not isinstance(result, list):
                logger.debug(f"_update_tracklist: Unexpected result type: {type(result)}")
                # Show placeholder and retry
                self.tracklist_widget.clear()
                placeholder_item = QListWidgetItem("Loading tracks... (retrying)")
                placeholder_item.setForeground(QColor("#888888"))
                placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
                self.tracklist_widget.addItem(placeholder_item)
                if hasattr(self, 'parent_window') and self.parent_window:
                    QTimer.singleShot(1000, self._update_tracklist)
                return
            
            logger.debug(f"_update_tracklist: Received {len(result)} tracks")
            
            if len(result) > 0:
                for track_info in result:
                    track_index = track_info.get('index', 0)
                    track_title = track_info.get('title', 'Track')
                    data_num = track_info.get('dataNum')
                    is_playable = track_info.get('isPlayable', True)
                    duration = track_info.get('duration', '')
                    
                    # DEBUG: Print to console for visibility (will show in terminal/console)
                    print(f"[DEBUG] Tracklist Widget - Track {track_index}: Received title from JS: '{track_title}'")
                    
                    # Remove duplicate title patterns as a backup (in case JavaScript didn't catch it)
                    # Check if title has pattern like "Title - Title" and remove duplicate
                    original_title = track_title
                    duplicate_found = False
                    for separator in [' - ', '  ', '  ', ' -', '- ', ' ', ' ', ' ', ' ']:
                        if separator in track_title:
                            parts = track_title.split(separator, 1)
                            if len(parts) == 2:
                                part1 = parts[0].strip()
                                part2 = parts[1].strip()
                                print(f"[DEBUG] Tracklist Widget - Track {track_index}: Checking separator '{separator}': Part1='{part1}', Part2='{part2}'")
                                # If both parts are the same (case-insensitive), keep only the first
                                if part1.lower() == part2.lower() and part1:
                                    track_title = part1
                                    duplicate_found = True
                                    print(f"[DEBUG] Tracklist Widget - Track {track_index}: DUPLICATE DETECTED! '{original_title}' -> '{track_title}'")
                                    break
                    
                    if not duplicate_found:
                        print(f"[DEBUG] Tracklist Widget - Track {track_index}: No duplicate found, keeping: '{track_title}'")
                    
                    if data_num:
                        track_num = int(data_num)
                    else:
                        track_num = track_index + 1
                    
                    # DEBUG: Check what duration contains
                    print(f"[DEBUG] Tracklist Widget - Track {track_index}: Duration value: '{duration}'")
                    
                    # Validate duration - only use if it looks like a time
                    validated_duration = None
                    if duration:
                        # Check if duration looks like a time (e.g., "3:45" or "12:34:56") or is a short number
                        # If it's longer than 10 chars or contains the track title, it's probably not a duration
                        is_valid_duration = (':' in duration) or (len(duration) <= 10 and duration.replace('.', '').replace(':', '').isdigit())
                        if is_valid_duration and track_title.lower() not in duration.lower():
                            validated_duration = duration
                        else:
                            print(f"[DEBUG] Tracklist Widget - Track {track_index}: Skipping invalid duration: '{duration}'")
                    
                    # Display text is just the track number and title (duration will be shown in right column by delegate)
                    display_text = f"{track_num:02d}. {track_title}"
                    
                    # DEBUG: Print final display text
                    print(f"[DEBUG] Tracklist Widget - Track {track_index}: Final display_text: '{display_text}', Duration: '{validated_duration}'")
                    
                    item = QListWidgetItem(display_text)
                    # Store duration and full title in track_data so delegate can access it
                    track_data = {'index': track_index, 'dataNum': data_num, 'isPlayable': is_playable, 'duration': validated_duration, 'fullTitle': track_title}
                    item.setData(Qt.ItemDataRole.UserRole, track_data)
                    # Don't set tooltip here - let the delegate determine if text is truncated
                    # The delegate will check during paint/helpEvent if the text was actually elided
                    item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Current track marker
                    
                    # Grey out unplayable tracks
                    if not is_playable:
                        item.setForeground(QColor("#888888"))
                        item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEnabled)
                    
                    self.tracklist_widget.addItem(item)
                
                # Add 2 empty placeholder items at the end to allow scrolling past the last track
                # This ensures the last track is visible even when the playlist is minimized
                for i in range(2):
                    empty_item = QListWidgetItem("")
                    empty_item.setFlags(Qt.ItemFlag.NoItemFlags)  # Make it non-interactive
                    empty_item.setForeground(QColor("#2b2b2b"))  # Match background color (invisible)
                    self.tracklist_widget.addItem(empty_item)
                
                # Highlight current track
                self._highlight_current_tracklist()
            else:
                # No tracks found, show placeholder and retry
                logger.debug("_update_tracklist: No tracks found in result")
                self.tracklist_widget.clear()
                placeholder_item = QListWidgetItem("No tracks found (retrying...)")
                placeholder_item.setForeground(QColor("#888888"))
                placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
                self.tracklist_widget.addItem(placeholder_item)
                if hasattr(self, 'parent_window') and self.parent_window:
                    QTimer.singleShot(1000, self._update_tracklist)
        
        # Execute JavaScript - even if webview is hidden, JavaScript should still work
        # But we need to ensure the page is ready
        try:
            self.parent_window.web_view.page().runJavaScript(js_code, on_tracks_received)
        except Exception as e:
            logger.error(f"_update_tracklist: Error executing JavaScript: {e}")
            # Show error placeholder
            self.tracklist_widget.clear()
            placeholder_item = QListWidgetItem("Error loading tracks")
            placeholder_item.setForeground(QColor("#ff6666"))
            placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
            self.tracklist_widget.addItem(placeholder_item)
    
    def _highlight_current_tracklist(self):
        """Highlight current track in tracklist."""
        if not hasattr(self, 'tracklist_widget') or not self.tracklist_widget:
            return
        
        for i in range(self.tracklist_widget.count()):
            item = self.tracklist_widget.item(i)
            if item:
                track_data = item.data(Qt.ItemDataRole.UserRole)
                if track_data:
                    track_index = track_data.get('index')
                    data_num = track_data.get('dataNum')
                    if self._current_track_number:
                        if data_num and int(data_num) == self._current_track_number:
                            item.setData(Qt.ItemDataRole.UserRole + 1, True)
                        elif track_index == self._current_track_number - 1:
                            item.setData(Qt.ItemDataRole.UserRole + 1, True)
                        else:
                            item.setData(Qt.ItemDataRole.UserRole + 1, False)
                    else:
                        item.setData(Qt.ItemDataRole.UserRole + 1, False)
                self.tracklist_widget.viewport().update()
    
    def _on_tracklist_item_clicked(self, item):
        """Handle tracklist item click - play track."""
        if not item or not self.parent_window:
            return
        
        track_data = item.data(Qt.ItemDataRole.UserRole)
        if not track_data:
            return
        
        is_playable = track_data.get('isPlayable', True)
        if not is_playable:
            return
        
        track_index = track_data.get('index', 0)
        data_num = track_data.get('dataNum')
        
        # Play track via JavaScript
        js_code = f"""
        (function() {{
            var tracklist = document.querySelector('#tracklist');
            if (!tracklist) {{
                return;
            }}
            
            var targetTrack = null;
            var dataNum = {repr(data_num) if data_num else 'null'};
            
            if (dataNum !== null) {{
                targetTrack = tracklist.querySelector('li.track[data-num="' + dataNum + '"]');
            }}
            
            if (!targetTrack) {{
                var tracks = tracklist.querySelectorAll('li.track');
                if (tracks.length > {track_index}) {{
                    targetTrack = tracks[{track_index}];
                }}
            }}
            
            if (targetTrack) {{
                var infoDiv = targetTrack.querySelector('.info');
                if (infoDiv) {{
                    infoDiv.click();
                }} else {{
                    targetTrack.click();
                }}
            }}
        }})();
        """
        self.parent_window.web_view.page().runJavaScript(js_code)
    
    def _update_playback_state(self):
        """Update playback state and highlight current track."""
        super()._update_playback_state()
        # Also update tracklist highlighting
        if hasattr(self, 'tracklist_widget'):
            self._highlight_current_tracklist()
        
        # Also update playlist sidebar tracklist highlighting if tracks tab is active
        if hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
            if hasattr(self.parent_window.playlist_sidebar, 'active_tab'):
                if self.parent_window.playlist_sidebar.active_tab == 'tracks':
                    if hasattr(self.parent_window.playlist_sidebar, '_highlight_playlist_tracklist'):
                        self.parent_window.playlist_sidebar._highlight_playlist_tracklist()
    
class MiniPlayerWidget(BasePlayerWidget):
    """Mini mode widget: cover art background + player overlay."""
    
    def setup_ui(self):
        """Setup mini mode UI with overlay layout."""
        # Main widget with cover art as background
        self.cover_art_label = ClickableCoverArtLabel(self)
        self.cover_art_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.cover_art_label.setStyleSheet("""
            QLabel {
                background-color: #1a1a1a;
                border: none;
            }
        """)
        self.cover_art_label.setScaledContents(True)
        # Cover art will fill the widget
        self.cover_art_label.lower()  # Put behind player
        # Store reference to ensure cover art stays behind playlist
        self._cover_art_z_order_locked = False
        # Store original pixmap for blur extraction (needed because setScaledContents changes the pixmap)
        self._original_cover_art_pixmap = None
        # Cover art is no longer clickable - use image viewer button in top nav instead
        
        # Create loading animation widget
        self.cover_art_loading_widget = CoverArtLoadingWidget(self.cover_art_label)
        self.cover_art_loading_widget.hide()
        
        # Blurred cover art region (only the area covered by player overlay)
        # This is a second cover art label that shows only the blurred region behind the player
        self.blurred_cover_art_label = QLabel(self)
        self.blurred_cover_art_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.blurred_cover_art_label.setScaledContents(False)  # We'll manually scale the pixmap
        self.blurred_cover_art_label.setStyleSheet("""
            QLabel {
                background-color: transparent;
                border: none;
            }
        """)
        # Apply blur effect to the entire label
        blur_effect = QGraphicsBlurEffect()
        blur_effect.setBlurRadius(5)  # Same blur as micro mode
        self.blurred_cover_art_label.setGraphicsEffect(blur_effect)
        self.blurred_cover_art_label.lower()  # Behind player overlay, above main cover art
        self.blurred_cover_art_label.hide()  # Hide until cover art loads
        
        # Player controls overlay (positioned at bottom)
        self.player_overlay = QWidget(self)
        self.player_overlay.setStyleSheet("""
            QWidget {
                background-color: rgba(20, 20, 20, 0.75);
                border-radius: 8px 8px 0 0;
            }
        """)
        
        player_layout = QVBoxLayout(self.player_overlay)
        player_layout.setContentsMargins(15, 15, 15, 15)  # Same padding as micro mode
        player_layout.setSpacing(0)
        
        self.setup_player_controls(player_layout)
        
        # Position player overlay at bottom (will be updated on resize)
        # Delay initial positioning until widget is shown and sized
        QTimer.singleShot(0, self._update_player_overlay_position)
    
    def resizeEvent(self, event):
        """Handle resize - update cover art and player overlay positions."""
        super().resizeEvent(event)
        if hasattr(self, 'cover_art_label') and self.cover_art_label:
            self.cover_art_label.setGeometry(0, 0, self.width(), self.height())
        self._update_player_overlay_position()
    
    def _update_player_overlay_position(self):
        """Update player overlay position at bottom of widget."""
        if not hasattr(self, 'player_overlay') or not self.player_overlay:
            return
        
        # Get widget dimensions (use size hint if widget not yet sized)
        widget_width = self.width() if self.width() > 0 else self.sizeHint().width()
        widget_height = self.height() if self.height() > 0 else self.sizeHint().height()
        
        if widget_width <= 0:
            widget_width = 260  # Default width
        if widget_height <= 0:
            widget_height = 200  # Default height
        
        # Calculate player height
        player_height = 80  # Approximate height of player controls
        if self.player_overlay:
            hint_height = self.player_overlay.sizeHint().height()
            if hint_height > 0:
                player_height = hint_height
        
        # Ensure player height doesn't exceed widget height
        if player_height > widget_height:
            player_height = widget_height
        
        # Position at bottom
        y_pos = max(0, widget_height - player_height)
        self.player_overlay.setGeometry(0, y_pos, widget_width, player_height)
        self.player_overlay.raise_()  # Bring to front
        
        # Update blurred cover art region position to match player overlay
        self._update_blurred_cover_art_position()
    
    def _update_blurred_cover_art_position(self):
        """Update blurred cover art region position to match player overlay."""
        if not hasattr(self, 'blurred_cover_art_label') or not self.blurred_cover_art_label:
            return
        if not hasattr(self, 'player_overlay') or not self.player_overlay:
            return
        
        # Position blurred region exactly where player overlay is
        overlay_geometry = self.player_overlay.geometry()
        if overlay_geometry.width() > 0 and overlay_geometry.height() > 0:
            self.blurred_cover_art_label.setGeometry(overlay_geometry)
            # Ensure z-order: main cover art (bottom) < blurred region (middle) < player overlay (top)
            if hasattr(self, 'cover_art_label') and self.cover_art_label:
                self.cover_art_label.lower()
            # Z-order will be set when pixmap is updated
    
    def _update_blurred_cover_art_pixmap(self):
        """Update blurred cover art pixmap from main cover art."""
        logger.debug("[MINI BLUR DEBUG] _update_blurred_cover_art_pixmap called")
        
        if not hasattr(self, 'blurred_cover_art_label') or not self.blurred_cover_art_label:
            logger.debug("[MINI BLUR DEBUG] No blurred_cover_art_label")
            return
        if not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            logger.debug("[MINI BLUR DEBUG] No cover_art_label")
            return
        if not hasattr(self, 'player_overlay') or not self.player_overlay:
            logger.debug("[MINI BLUR DEBUG] No player_overlay")
            return
        
        # Use original pixmap if available (before scaling), otherwise use current pixmap
        # The original pixmap is the full-size image before setScaledContents scales it
        main_pixmap = None
        if hasattr(self, '_original_cover_art_pixmap') and self._original_cover_art_pixmap:
            main_pixmap = self._original_cover_art_pixmap
            logger.debug(f"[MINI BLUR DEBUG] Using original pixmap, size: {main_pixmap.size()}")
        else:
            # Fallback to current pixmap (might be scaled)
            main_pixmap = self.cover_art_label.pixmap()
            logger.debug(f"[MINI BLUR DEBUG] Using current pixmap, size: {main_pixmap.size() if main_pixmap else 'None'}")
        
        if not main_pixmap or main_pixmap.isNull():
            logger.debug("[MINI BLUR DEBUG] Main pixmap is null, hiding blurred label")
            self.blurred_cover_art_label.hide()
            return
        
        # Get player overlay geometry
        overlay_geometry = self.player_overlay.geometry()
        logger.debug(f"[MINI BLUR DEBUG] Overlay geometry: {overlay_geometry}")
        if overlay_geometry.width() <= 0 or overlay_geometry.height() <= 0:
            logger.debug("[MINI BLUR DEBUG] Overlay geometry invalid, hiding blurred label")
            self.blurred_cover_art_label.hide()
            return
        
        # Get main label geometry
        main_label_geometry = self.cover_art_label.geometry()
        logger.debug(f"[MINI BLUR DEBUG] Main label geometry: {main_label_geometry}")
        if main_label_geometry.width() <= 0 or main_label_geometry.height() <= 0:
            logger.debug("[MINI BLUR DEBUG] Main label geometry invalid, hiding blurred label")
            self.blurred_cover_art_label.hide()
            return
        
        # Calculate overlay position relative to main label
        overlay_x = overlay_geometry.x() - main_label_geometry.x()
        overlay_y = overlay_geometry.y() - main_label_geometry.y()
        overlay_w = overlay_geometry.width()
        overlay_h = overlay_geometry.height()
        
        # Get pixmap and label sizes
        pixmap_size = main_pixmap.size()
        label_size = main_label_geometry.size()
        
        # Calculate scale factors (how the pixmap is scaled to fit the label)
        # Since setScaledContents(True) maintains aspect ratio, we need to account for that
        pixmap_aspect = pixmap_size.width() / pixmap_size.height() if pixmap_size.height() > 0 else 1.0
        label_aspect = label_size.width() / label_size.height() if label_size.height() > 0 else 1.0
        
        # Determine how the pixmap is scaled within the label
        if pixmap_aspect > label_aspect:
            # Pixmap is wider - scaled to fit width, height is letterboxed
            scale = label_size.width() / pixmap_size.width() if pixmap_size.width() > 0 else 1.0
            scaled_pixmap_height = pixmap_size.height() * scale
            offset_y = (label_size.height() - scaled_pixmap_height) / 2
            offset_x = 0
        else:
            # Pixmap is taller - scaled to fit height, width is pillarboxed
            scale = label_size.height() / pixmap_size.height() if pixmap_size.height() > 0 else 1.0
            scaled_pixmap_width = pixmap_size.width() * scale
            offset_x = (label_size.width() - scaled_pixmap_width) / 2
            offset_y = 0
        
        # Calculate source region in original pixmap coordinates
        # First, map overlay position to scaled pixmap coordinates (accounting for letterboxing/pillarboxing)
        scaled_overlay_x = overlay_x - offset_x
        scaled_overlay_y = overlay_y - offset_y
        scaled_overlay_w = overlay_w
        scaled_overlay_h = overlay_h
        
        # Then map to original pixmap coordinates
        src_x = int(scaled_overlay_x / scale) if scale > 0 else 0
        src_y = int(scaled_overlay_y / scale) if scale > 0 else 0
        src_w = int(scaled_overlay_w / scale) if scale > 0 else overlay_w
        src_h = int(scaled_overlay_h / scale) if scale > 0 else overlay_h
        
        # Ensure we don't go out of bounds
        src_x = max(0, min(src_x, pixmap_size.width() - 1))
        src_y = max(0, min(src_y, pixmap_size.height() - 1))
        src_w = max(1, min(src_w, pixmap_size.width() - src_x))
        src_h = max(1, min(src_h, pixmap_size.height() - src_y))
        
        # Extract the region from the original pixmap
        logger.debug(f"[MINI BLUR DEBUG] Extracting region: src_x={src_x}, src_y={src_y}, src_w={src_w}, src_h={src_h}")
        cropped_pixmap = main_pixmap.copy(src_x, src_y, src_w, src_h)
        logger.debug(f"[MINI BLUR DEBUG] Cropped pixmap size: {cropped_pixmap.size()}")
        
        # Scale to match overlay size exactly (fill the overlay area)
        scaled_pixmap = cropped_pixmap.scaled(
            overlay_w, overlay_h,
            Qt.AspectRatioMode.KeepAspectRatioByExpanding,
            Qt.TransformationMode.SmoothTransformation
        )
        logger.debug(f"[MINI BLUR DEBUG] Scaled pixmap size: {scaled_pixmap.size()}, target: {overlay_w}x{overlay_h}")
        
        # If the scaled pixmap is larger than overlay, crop to center
        if scaled_pixmap.width() > overlay_w or scaled_pixmap.height() > overlay_h:
            crop_x = (scaled_pixmap.width() - overlay_w) // 2 if scaled_pixmap.width() > overlay_w else 0
            crop_y = (scaled_pixmap.height() - overlay_h) // 2 if scaled_pixmap.height() > overlay_h else 0
            final_pixmap = scaled_pixmap.copy(crop_x, crop_y, overlay_w, overlay_h)
            logger.debug(f"[MINI BLUR DEBUG] Cropped scaled pixmap to: {final_pixmap.size()}")
        else:
            final_pixmap = scaled_pixmap
        
        # Set the blurred pixmap - this will be blurred by the QGraphicsBlurEffect
        self.blurred_cover_art_label.setPixmap(final_pixmap)
        logger.debug(f"[MINI BLUR DEBUG] Set pixmap on blurred label, size: {final_pixmap.size()}")
        
        # Position and show the blurred label
        self._update_blurred_cover_art_position()
        self.blurred_cover_art_label.show()
        logger.debug(f"[MINI BLUR DEBUG] Blurred label visible: {self.blurred_cover_art_label.isVisible()}, geometry: {self.blurred_cover_art_label.geometry()}")
        self.blurred_cover_art_label.raise_()  # Ensure it's above main cover art
        self.player_overlay.raise_()  # Ensure player overlay is on top
    
    def _update_cover_art(self):
        """Update cover art and resize window to match."""
        super()._update_cover_art()
        # After cover art loads, update blurred region
        QTimer.singleShot(100, self._update_blurred_cover_art_pixmap)
        # After cover art loads, resize window to match image height
        # This will be handled by the parent window


class MicroPlayerWidget(BasePlayerWidget):
    """Micro mode widget: transparent player over cover art - Qt-only implementation."""
    
    def setup_ui(self):
        """Setup micro mode UI with transparent overlay."""
        # Set size policy - fixed height based on player controls, expanding width
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        
        # Set widget background to transparent so cover art shows through
        self.setStyleSheet("""
            QWidget {
                background-color: transparent;
            }
        """)
        
        # Cover art as background layer - fills entire widget
        self.cover_art_label = ClickableCoverArtLabel(self)
        # Align to top so top of image is visible (bottom will be cut off if image is taller than widget)
        self.cover_art_label.setAlignment(Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignHCenter)
        # Use dark background as fallback until cover art loads, then transparent
        self.cover_art_label.setStyleSheet("""
            QLabel {
                background-color: #1a1a1a;
                border: none;
            }
        """)
        # Don't use setScaledContents(True) as it distorts aspect ratio
        # Instead, we'll scale the pixmap manually in _on_cover_art_loaded to maintain aspect ratio
        self.cover_art_label.setScaledContents(False)
        # Ensure label doesn't expand beyond widget width
        self.cover_art_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.cover_art_label.setVisible(True)  # Ensure it's visible
        self.cover_art_label.lower()  # Put behind player
        # Store original pixmap for quality-preserving rescaling on resize
        self._original_cover_art_pixmap = None
        # Cover art is no longer clickable - use image viewer button in top nav instead
        # Enable context menu on cover art
        self.cover_art_label.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.cover_art_label.customContextMenuRequested.connect(self._show_player_context_menu)
        
        # Create loading animation widget
        self.cover_art_loading_widget = CoverArtLoadingWidget(self.cover_art_label)
        self.cover_art_loading_widget.hide()
        
        # Apply blur effect to cover art
        blur_effect = QGraphicsBlurEffect()
        blur_effect.setBlurRadius(5)  # Adjust blur intensity (higher = more blur)
        self.cover_art_label.setGraphicsEffect(blur_effect)
        
        # Player controls with transparent background overlay (70% opacity)
        self.player_overlay = QWidget(self)
        self.player_overlay.setStyleSheet("""
            QWidget {
                background-color: rgba(20, 20, 20, 0.75);
                border: none;
            }
        """)
        # Enable context menu on player overlay
        self.player_overlay.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.player_overlay.customContextMenuRequested.connect(self._show_player_context_menu)
        
        player_layout = QVBoxLayout(self.player_overlay)
        player_layout.setContentsMargins(15, 15, 15, 15)
        player_layout.setSpacing(0)
        
        self.setup_player_controls(player_layout)
        
        # Calculate player height based on content
        self._update_player_height()
    
    def _update_player_height(self):
        """Update widget height to match player controls height."""
        if not hasattr(self, 'player_overlay') or not self.player_overlay:
            return
        
        # Get the preferred height of the player overlay
        player_height = self.player_overlay.sizeHint().height()
        if player_height <= 0:
            # Fallback: estimate height based on typical player controls
            # 4 rows: album button (~30px) + track button (~30px) + controls (~40px) + progress (~30px) + padding
            player_height = 140
        
        # Set fixed height to match player
        self.setFixedHeight(player_height)
        
        # Update cover art and player overlay geometry
        self._update_geometry()
    
    def _update_geometry(self):
        """Update cover art and player overlay geometry."""
        if hasattr(self, 'cover_art_label') and self.cover_art_label:
            self.cover_art_label.setGeometry(0, 0, self.width(), self.height())
        if hasattr(self, 'player_overlay') and self.player_overlay:
            # Player overlay fills entire widget
            self.player_overlay.setGeometry(0, 0, self.width(), self.height())
            self.player_overlay.raise_()  # Bring to front
    
    def resizeEvent(self, event):
        """Handle resize - update cover art and player overlay."""
        super().resizeEvent(event)
        self._update_geometry()
        # Rescale cover art if pixmap exists to maintain aspect ratio on resize
        if hasattr(self, 'cover_art_label') and self.cover_art_label:
            pixmap = self.cover_art_label.pixmap()
            if pixmap and not pixmap.isNull():
                label_size = self.cover_art_label.size()
                if label_size.width() > 0 and label_size.height() > 0:
                    # Use original pixmap if available, otherwise use current pixmap
                    source_pixmap = getattr(self, '_original_cover_art_pixmap', None)
                    if source_pixmap is None or source_pixmap.isNull():
                        source_pixmap = pixmap
                    # Scale to fit width while maintaining aspect ratio (top-aligned, crop from bottom)
                    # Use scaledToWidth to ensure it fits exactly to the width
                    scaled_pixmap = source_pixmap.scaledToWidth(
                        label_size.width(),
                        Qt.TransformationMode.SmoothTransformation
                    )
                    # Crop to show top portion (top-aligned)
                    if label_size.height() > 0 and scaled_pixmap.height() > label_size.height():
                        cropped_pixmap = scaled_pixmap.copy(
                            0, 0,  # Start from top-left
                            label_size.width(),
                            label_size.height()  # Crop to label height
                        )
                        self.cover_art_label.setPixmap(cropped_pixmap)
                    else:
                        # Pixmap fits, use as-is
                        self.cover_art_label.setPixmap(scaled_pixmap)
    
    def showEvent(self, event):
        """Update height when widget is shown."""
        super().showEvent(event)  # This will call BasePlayerWidget.showEvent which updates button widths
        QTimer.singleShot(10, self._update_player_height)
        # Update cover art when widget is shown
        QTimer.singleShot(50, self._update_cover_art)
    
    def _update_cover_art(self):
        """Update cover art - override to ensure it's called."""
        super()._update_cover_art()
        # Ensure cover art label is visible and properly sized
        if hasattr(self, 'cover_art_label') and self.cover_art_label:
            # Ensure geometry is updated before checking size
            if hasattr(self, '_update_geometry'):
                self._update_geometry()
            self.cover_art_label.setVisible(True)
            self.cover_art_label.update()  # Force repaint
    
    def _rescale_cached_cover_art(self):
        """Rescale cached cover art after geometry is updated."""
        if (hasattr(self, 'cover_art_label') and self.cover_art_label and
            hasattr(self, '_original_cover_art_pixmap') and self._original_cover_art_pixmap):
            pixmap = self._original_cover_art_pixmap
            label_size = self.cover_art_label.size()
            if label_size.width() <= 0:
                label_size = self.size()
            if label_size.width() > 0:
                # Scale to fit the label width
                scaled_pixmap = pixmap.scaledToWidth(
                    label_size.width(),
                    Qt.TransformationMode.SmoothTransformation
                )
                # Crop if needed
                if label_size.height() > 0 and scaled_pixmap.height() > label_size.height():
                    cropped_pixmap = scaled_pixmap.copy(
                        0, 0,
                        label_size.width(),
                        label_size.height()
                    )
                    self.cover_art_label.setPixmap(cropped_pixmap)
                else:
                    self.cover_art_label.setPixmap(scaled_pixmap)
                self.cover_art_label.update()
    
    def _on_cover_art_loaded(self, reply):
        """Override to scale cover art maintaining aspect ratio (may crop to fit)."""
        try:
            if reply.error() == QNetworkReply.NetworkError.NoError:
                url = reply.property('url')
                if url and hasattr(self, '_current_cover_art_url') and url == self._current_cover_art_url:
                    data = reply.readAll()
                    pixmap = QPixmap()
                    if pixmap.loadFromData(data):
                        if hasattr(self, 'cover_art_label') and self.cover_art_label:
                            # Store original pixmap for quality-preserving rescaling
                            self._original_cover_art_pixmap = pixmap
                            
                            # Scale pixmap to fit width while maintaining aspect ratio
                            # Crop from bottom to show top portion (top-aligned)
                            label_size = self.cover_art_label.size()
                            if label_size.width() > 0:
                                # Scale to fit the label width while maintaining aspect ratio
                                # Use scaledToWidth to ensure it fits exactly to the width
                                scaled_pixmap = pixmap.scaledToWidth(
                                    label_size.width(),
                                    Qt.TransformationMode.SmoothTransformation
                                )
                                # If scaled pixmap is taller than label, crop from bottom to show top
                                if label_size.height() > 0 and scaled_pixmap.height() > label_size.height():
                                    cropped_pixmap = scaled_pixmap.copy(
                                        0, 0,  # Start from top-left
                                        label_size.width(),
                                        label_size.height()  # Crop to label height
                                    )
                                    self.cover_art_label.setPixmap(cropped_pixmap)
                                else:
                                    # Pixmap fits, use as-is
                                    self.cover_art_label.setPixmap(scaled_pixmap)
                            else:
                                # Fallback: use widget size if label size not available yet
                                widget_size = self.size()
                                if widget_size.width() > 0:
                                    # Scale to fit the widget width
                                    scaled_pixmap = pixmap.scaledToWidth(
                                        widget_size.width(),
                                        Qt.TransformationMode.SmoothTransformation
                                    )
                                    # Crop if needed
                                    if widget_size.height() > 0 and scaled_pixmap.height() > widget_size.height():
                                        cropped_pixmap = scaled_pixmap.copy(
                                            0, 0,
                                            widget_size.width(),
                                            widget_size.height()
                                        )
                                        self.cover_art_label.setPixmap(cropped_pixmap)
                                    else:
                                        self.cover_art_label.setPixmap(scaled_pixmap)
                                else:
                                    # Last resort: use original pixmap and retry after geometry update
                                    self.cover_art_label.setPixmap(pixmap)
                                    QTimer.singleShot(100, lambda: self._rescale_cached_cover_art())
                            
                            # Ensure label is visible and behind player overlay
                            self.cover_art_label.setVisible(True)
                            self.cover_art_label.lower()
                            
                            # Update geometry to ensure it fills the widget
                            if hasattr(self, 'width') and hasattr(self, 'height'):
                                self.cover_art_label.setGeometry(0, 0, self.width(), self.height())
                            
                            # Force update
                            self.cover_art_label.update()
                            self.cover_art_label.repaint()
                            self.update()
                            self.repaint()
        except Exception as e:
            logger.error(f"Error in MicroPlayerWidget._on_cover_art_loaded: {e}")
            # Fallback to parent implementation
            super()._on_cover_art_loaded(reply)
    
    def _cancel_autohide_timer(self):
        """Cancel autohide timer - stub method for micro mode (no autohide)."""
        # Micro mode doesn't have autohide functionality, so this is a no-op
        pass
    
    def _show_player_section(self):
        """Show player section - stub method for micro mode (no autohide)."""
        # Micro mode doesn't have autohide functionality, so this is a no-op
        pass

# ============================================================================
# PLAYER WINDOW CLASS
# ============================================================================

class PlayerWindow(QMainWindow):
    """Main player window with web view and playlist controls"""

    # Marshal arbitrary callables onto the UI thread (used by background workers like update checks)
    _ui_invoke = pyqtSignal(object)
    
    def __init__(self):
        super().__init__()
        
        # Minimize console window immediately (like downloader does)
        # This happens AFTER Qt is initialized, which is more reliable on Windows 10
        self._minimize_console_immediately()
        
        # Hide window initially to prevent flash before geometry is restored
        # Set opacity to 0 immediately to prevent any brief visibility
        self.setWindowOpacity(0.0)
        self.setVisible(False)
        edition = globals().get("__edition__")
        edition_suffix = f" ({edition})" if edition else ""
        QMainWindow.setWindowTitle(self, f"Empty - Bandcamp Player{edition_suffix}")
        self.window_title_label = None  # Will be set in create_custom_title_bar
        self.setMinimumSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT)
        self.setMaximumWidth(WINDOW_MAX_WIDTH)
        
        # Load and set icon
        icon_path = Path(__file__).parent / "icon.ico"
        if icon_path.exists():
            icon = QIcon(str(icon_path))
            self.setWindowIcon(icon)
            self.app_icon = icon
        else:
            self.app_icon = None
        
        # Settings
        self.settings_file = Path(__file__).parent / "settings.json"
        self.settings = self.load_settings()
        
        # WebEngine profile - will be initialized lazily on first URL load
        # This defers the overhead of setting up persistent storage until it's actually needed
        self.webengine_profile = None
        self._webengine_storage_setup = False
        
        # Setup IPC server for AutoHotkey communication (named pipe) - do this early
        # so it's always available, even when starting in nano mode or if deferred_init is delayed
        self.setup_ipc_server()

        # UI-thread invocation hook (allows worker threads to show dialogs safely)
        try:
            self._ui_invoke.connect(self._on_ui_invoke, type=Qt.ConnectionType.QueuedConnection)
        except Exception:
            # Fallback: default connection type (still queued across threads)
            self._ui_invoke.connect(self._on_ui_invoke)
        
        # State
        self.compact_mode = self.settings.get("compact_mode", True)  # Default to enabled
        self.bandcamp_mode = self.settings.get("bandcamp_mode", True)  # Default to enabled
        self.always_on_top = self.settings.get("always_on_top", True)
        self.frameless_mode = self.settings.get("frameless_mode", True)  # Default to enabled
        self.autoplay = self.settings.get("autoplay", True)  # Default to enabled
        self.autoplay_on_startup = self.settings.get("autoplay_on_startup", True)  # Default to enabled
        self.transparent_overlay = self.settings.get("transparent_overlay", False)  # Default to opaque
        self.autohide_address_bar = self.settings.get("autohide_address_bar", True)  # Default to enabled
        self.mini_mode_player_autohide = self.settings.get("mini_mode_player_autohide", False)  # Default to disabled
        self.webview_scrollbar_visible = self.settings.get("webview_scrollbar_visible", False)  # Default to hidden
        self.nano_mode_on_minimize = self.settings.get("nano_mode_on_minimize", True)  # Default to enabled
        # Remove "fully hidden" mode: migrate any old hidden state to autohide
        legacy_hidden = self.settings.get("mini_mode_player_hidden", False)
        if legacy_hidden and not self.mini_mode_player_autohide:
            self.mini_mode_player_autohide = True
        self.mini_mode_player_hidden = False
        self.volume_level = self.settings.get("volume_level", 100)  # Default to 100% (0-200 range)
        # Load mini_mode_state from settings (restore last used mode)
        # BUT: Always start in regular mode first to ensure proper initialization
        # Then switch to saved mode after page loads (similar to nano mode)
        saved_mini_mode_state = self.settings.get("mini_mode_state", 0)  # 0 = Regular, 1 = Mini, 2 = Micro
        
        # Start in regular mode (state 0) for proper initialization
        self.mini_mode_state = 0
        
        # Set flag to switch to saved mode after page loads (if not regular mode)
        if saved_mini_mode_state != 0:
            self._activate_mini_mode_after_page_load = saved_mini_mode_state
            print(f"[STARTUP DEBUG] Will switch to mode {saved_mini_mode_state} after page loads (starting in regular mode for initialization)")
        else:
            self._activate_mini_mode_after_page_load = None
        
        # Qt-based player widgets (new implementation)
        self.use_qt_widgets = self.settings.get("use_qt_widgets", True)  # Feature flag - default to enabled
        self.regular_player_widget = None
        self.mini_player_widget = None
        self.micro_player_widget = None
        # Track current track number for autoplay persistence
        # Initialize from settings if available (preserve last played track)
        self._current_track_number = self.settings.get("last_played_track_number")
        
        # Centralized shuffle/repeat state (shared across all player widgets)
        # Load from settings with migration from old boolean format
        old_repeat = self.settings.get('repeat_on', False)
        old_shuffle = self.settings.get('shuffle_on', False)
        self.shuffle_mode = self.settings.get('shuffle_mode', 1 if old_shuffle else 0)  # 0=off, 1=tracks, 2=albums, 3=super
        self.repeat_mode = self.settings.get('repeat_mode', 1 if old_repeat else 1)  # 0=off, 1=continuous, 2=album, 3=track (default to continuous)
        
        # Detachable playlist state
        self.playlist_detached = False
        self.detached_playlist_window = None
        self.playlist_detached_offset = self.settings.get("playlist_detached_offset", (20, 0))  # Default offset to right (for backward compatibility)
        self.playlist_detached_position = self.settings.get("playlist_detached_position", None)  # Absolute position (x, y)
        self.playlist_detached_size = self.settings.get("playlist_detached_size", "260x400")  # Default size
        # Link mode state (playlist window follows main window)
        self.playlist_window_linked = self.settings.get("playlist_window_linked", False)
        self._playlist_window_link_offset = None  # Relative offset when linked
        self._last_main_window_pos = None  # For detecting main window movement
        self._last_detached_playlist_pos = None  # For detecting detached window movement
        self._moving_detached_playlist_programmatically = False  # Flag to prevent recursive updates
        # Track if we minimized the detached playlist (so we can restore it when main window restores)
        self._detached_playlist_minimized_by_main = False
        # Nano mode state
        self.nano_player_window = None
        self._main_window_hidden_for_nano = False  # Track if main window was hidden for nano mode
        self._page_loaded_at_least_once = False  # Track if page has loaded at least once (for startup nano mode)
        self._first_restore_from_nano = False  # Track if this is first restore from nano after startup
        self._doing_quick_sync = False  # Flag to prevent nano mode from activating during quick sync
        self._minimize_button_clicked = False  # Flag to track when minimize button is clicked (to bypass nano mode)
        # Window snapping
        self._snap_threshold = 20  # Pixels - distance threshold for snapping
        # Debounced snapping (prevents jitter by snapping after dragging stops)
        self._snap_debounce_ms = 90
        self._moving_main_window_programmatically = False  # Prevent recursive snap scheduling
        self._detached_snap_timer = QTimer(self)
        self._detached_snap_timer.setSingleShot(True)
        self._detached_snap_timer.timeout.connect(self._handle_playlist_window_snapping)
        # Docking state for main window + playlist window combination
        self._windows_docked_edge = None  # 'top', 'bottom', 'left', 'right', or None
        self._windows_docked = False  # Whether windows are docked together at screen edge
        # Drag state tracking
        self._is_dragging_main_window = False  # Track if main window is being dragged
        self._is_dragging_playlist_window = False  # Track if playlist window is being dragged
        self._snapped_during_drag = False  # Track if windows snapped during drag (to link on release)
        self._playlist_drag_start_pos = None  # Track playlist position when drag started
        self._playlist_breakaway_activated = False  # Track if playlist has broken away (disable snapping for this drag)
        self._playlist_release_window_active = False  # Track if we're in the release window (brief period after unlinking where snapping is disabled)
        self._playlist_release_window_timer = QTimer(self)
        self._playlist_release_window_timer.setSingleShot(True)
        self._playlist_release_window_timer.timeout.connect(lambda: setattr(self, '_playlist_release_window_active', False))
        self._main_snap_timer = QTimer(self)
        self._main_snap_timer.setSingleShot(True)
        self._main_snap_timer.timeout.connect(self._handle_main_window_snapping)
        
        # Shuffle-related state
        self._shuffled_track_list = None  # List of track numbers in shuffled order
        self._shuffled_track_index = 0  # Current position in shuffled list
        self._shuffled_track_album_url = None  # URL of album for which we have shuffled list
        self._pending_super_shuffle_load = False  # Flag to load Super Shuffle track when current track finishes
        self._is_super_shuffle_load = False  # Flag to track if this is a Super Shuffle URL load
        self._super_shuffle_album_url = None  # Store album URL for Super Shuffle track selection

        # Link-mode smoothing (throttle moves to reduce jitter without "lagging behind")
        self._link_move_interval_ms = 8  # target ~120fps (best-effort; OS timer resolution may limit)
        self._pending_linked_detached_pos = None
        self._last_programmatic_detached_pos = None
        self._link_move_idle_ticks = 0
        self._linked_move_timer = QTimer(self)
        self._linked_move_timer.setSingleShot(False)
        self._linked_move_timer.setInterval(self._link_move_interval_ms)
        try:
            # Prefer higher resolution for smoother linking on Windows
            self._linked_move_timer.setTimerType(Qt.TimerType.PreciseTimer)
        except Exception:
            pass
        self._linked_move_timer.timeout.connect(self._apply_pending_linked_detached_move)
        
        # Restore window geometry from settings if available (must be after settings are loaded)
        # Handle geometry based on the mode we're starting in
        if self.mini_mode_state == 0:
            # Regular mode: restore geometry, but ensure default height
            geometry = self.settings.get("window_geometry")
            if geometry:
                try:
                    geometry_bytes = QByteArray.fromHex(geometry.encode())
                    self.restoreGeometry(geometry_bytes)
                    # Always use default height for regular mode
                    self.resize(self.width(), WINDOW_DEFAULT_HEIGHT)
                except Exception as e:
                    # If restore fails, use default size
                    logger.warning(f"Could not restore window geometry: {e}")
                    self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            else:
                self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
        else:
            # Mini/Micro mode: try to use saved height for immediate correct size
            if self.mini_mode_state == 1:
                # Mini mode: use saved cover art height
                saved_mini_height = self.settings.get("mini_mode_saved_height")
                if saved_mini_height and isinstance(saved_mini_height, (int, float)) and saved_mini_height > 0:
                    # Use saved height for immediate correct size (will be refined when page loads)
                    window_padding = 0
                    if hasattr(self, 'title_bar') and self.title_bar:
                        window_padding += 30  # Estimate title bar height
                    if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                        window_padding += 40  # Estimate controls bar height
                    estimated_height = int(saved_mini_height) + window_padding
                    self.resize(WINDOW_DEFAULT_WIDTH, estimated_height)
                    logger.debug(f"Using saved mini mode height: {estimated_height}")
                else:
                    # No saved height, start with default (will resize when page loads)
                    self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            elif self.mini_mode_state == 2:
                # Micro mode: use saved player height
                saved_micro_height = self.settings.get("micro_mode_saved_height")
                if saved_micro_height and isinstance(saved_micro_height, (int, float)) and saved_micro_height > 0:
                    # Use saved height for immediate correct size (will be refined when page loads)
                    window_padding = 0
                    if hasattr(self, 'title_bar') and self.title_bar:
                        window_padding += 30  # Estimate title bar height
                    if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                        window_padding += 40  # Estimate controls bar height
                    estimated_height = int(saved_micro_height) + window_padding
                    self.resize(WINDOW_DEFAULT_WIDTH, estimated_height)
                    logger.debug(f"Using saved micro mode height: {estimated_height}")
                else:
                    # No saved height, start with default (will resize when page loads)
                    self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
        
        # No longer storing/loading original size - each mode uses fixed defaults
        # Regular mode: always WINDOW_DEFAULT_WIDTH x WINDOW_DEFAULT_HEIGHT
        # Mini/Micro modes: always WINDOW_DEFAULT_WIDTH, height calculated dynamically
        
        # Load saved mini mode height from settings
        saved_mini_height = self.settings.get("mini_mode_saved_height")
        if saved_mini_height and isinstance(saved_mini_height, (int, float)):
            self.mini_mode_cover_art_height = int(saved_mini_height)
        else:
            self.mini_mode_cover_art_height = None
        self.dev_tools_window = None
        self.dev_tools_page = None  # Store dev tools page reference for element inspection
        self.inspect_position = None  # Store position for element inspection
        self.title_bar = None  # Custom title bar for frameless mode
        self.volume_popup = None  # Volume control popup widget
        self.volume_hide_timer = None  # Timer for auto-hiding volume popup
        self.volume_popup_fade_animation = None  # Animation for fade in/out
        
        # Shared cover art cache for all modes (URL -> QPixmap)
        self._cover_art_cache = {}  # Maps cover art URL to QPixmap
        self._current_cover_art_url = None  # Current cover art URL
        self._cover_art_network_manager = None  # Network manager for preloading cover art
        self._js_injected_on_current_page = False  # Track if JavaScript has been injected on current page
        self.is_loading = False  # Track loading state to prevent overlay flicker
        self._was_micro_mode = False  # Track if we were in micro mode (for proper restoration)
        self._original_context_menu_policy = None  # Store original context menu policy to restore after loading
        
        # Components - defer heavy initialization for faster startup
        # Store playlist file path but don't load yet (defer to deferred_init)
        self._current_playlist_file = self.settings.get("current_playlist_file")
        if self._current_playlist_file:
            # Verify the file exists, otherwise fallback to default
            playlist_path = Path(self._current_playlist_file)
            if not playlist_path.is_absolute():
                playlist_path = Path(__file__).parent / "Playlists" / playlist_path.name
            if not playlist_path.exists():
                logger.info(f"Saved playlist file {playlist_path} not found, using default")
                self._current_playlist_file = None
        
        # Create playlist manager immediately (lightweight - just file I/O)
        self.playlist_manager = PlaylistManager(playlist_file=self._current_playlist_file)
        self._playlist_manager_initialized = True
        self.css_injector = CSSInjector()
        
        # Setup UI (minimal - defer heavy components)
        self.setup_ui()
        self.setup_web_view()
        # Setup menu immediately (lightweight - just creates menu structure)
        self.setup_menu()
        # Defer system tray setup until after window shows (faster startup)
        self.tray_icon = None
        # Setup shortcuts immediately (very lightweight - just one shortcut)
        self.setup_shortcuts()
        # Apply settings immediately (lightweight - just applies window properties)
        self.apply_settings()
        self._settings_applied = True
        
        # Set global stylesheet to remove button focus outlines (Windows 10 issue)
        # This removes the white outline that appears when buttons are pressed on Windows 10
        self.setStyleSheet("""
            QPushButton:focus {
                outline: none;
                border: none;
            }
            QPushButton:pressed {
                outline: none;
                border: none;
            }
            QToolButton:focus {
                outline: none;
                border: none;
            }
            QToolButton:pressed {
                outline: none;
                border: none;
            }
        """)
        
        # Enable drag and drop on the entire window
        self.setAcceptDrops(True)
        
        # Install event filter on central widget to catch drag/drop events
        central_widget = self.centralWidget()
        if central_widget:
            central_widget.installEventFilter(self)
        
        # Determine initial URL now (playlist manager is available)
        # This allows URL loading to start as soon as possible
        self._last_played_url = self.settings.get("last_played_url")
        self._initial_url_pending = None
        playlist = self.playlist_manager.get_playlist()
        if self._last_played_url:
            # Extract URLs from playlist objects for comparison
            playlist_urls = [item.get("url") if isinstance(item, dict) else item for item in playlist]
            # Verify last played URL is still in playlist (or allow it anyway for flexibility)
            if self._last_played_url in playlist_urls or not playlist:
                self._initial_url_pending = self._last_played_url
            elif playlist:
                # Last played URL not in playlist, use first item instead
                first_item = playlist[0]
                self._initial_url_pending = first_item.get("url") if isinstance(first_item, dict) else first_item
        elif playlist:
            # No last played URL, use first in playlist
            first_item = playlist[0]
            self._initial_url_pending = first_item.get("url") if isinstance(first_item, dict) else first_item
        
        self._is_startup_load = False  # Flag to track if this is the initial startup URL load
        self._has_url_loaded = False  # Flag to track if any URL has been loaded
        self._update_check_done = False  # Flag to track if update check has been performed
    
    def _minimize_console_immediately(self):
        """Hide console window immediately at startup (like downloader does)."""
        try:
            if sys.platform == 'win32':
                import ctypes
                kernel32 = ctypes.windll.kernel32
                user32 = ctypes.windll.user32
                hwnd = kernel32.GetConsoleWindow()
                if hwnd:
                    launcher_mode = os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1'
                    if launcher_mode:
                        # In launcher mode, try to free console (may already be freed by launcher)
                        # If it fails, try minimizing as fallback
                        try:
                            kernel32.FreeConsole()
                        except Exception:
                            # If FreeConsole fails, minimize as fallback
                            user32.ShowWindow(hwnd, 6)  # SW_MINIMIZE = 6
                    else:
                        # Not in launcher mode, just minimize (safer for development)
                        # SW_MINIMIZE = 6 - minimizes to taskbar
                        user32.ShowWindow(hwnd, 6)
        except Exception:
            pass  # Silently fail if console hiding doesn't work
    
    def _ensure_playlist_manager(self):
        """Ensure playlist manager is initialized (lazy initialization)."""
        if not self._playlist_manager_initialized:
            if self.playlist_manager is None:
                self.playlist_manager = PlaylistManager(playlist_file=self._current_playlist_file)
            self._playlist_manager_initialized = True
    
    def deferred_init(self):
        """Deferred initialization - runs after window is shown for faster startup"""
        # Ensure playlist manager is initialized (should already be done in __init__)
        self._ensure_playlist_manager()
        
        # Setup menu if it wasn't done in __init__ (backward compatibility)
        if getattr(self, '_menu_setup_deferred', False):
            self.setup_menu()
            self._menu_setup_deferred = False
        
        # Setup shortcuts if it wasn't done in __init__ (backward compatibility)
        if getattr(self, '_shortcuts_setup_deferred', False):
            self.setup_shortcuts()
            self._shortcuts_setup_deferred = False
        
        # Apply settings if it wasn't done in __init__ (backward compatibility)
        if not getattr(self, '_settings_applied', False):
            self.apply_settings()
            self._settings_applied = True
        
        # Apply mode settings (CSS for legacy, Qt widgets for new implementation)
        use_qt = getattr(self, 'use_qt_widgets', True)  # Default to True if not set
        
        if use_qt:
            # Use Qt widgets - apply mode for all states (including regular mode)
            self.apply_mini_mode()
            # Update UI to reflect the mode
            self.update_mini_mode_button()
            self.update_mini_mode_menu_text()
        elif self.mini_mode_state != 0 and self.web_view:
            # Legacy CSS-based implementation - only for mini/micro modes
            # Check if a page is already loaded (has a URL)
            # On first launch, no page is loaded yet, so skip injection here
            page_has_url = False
            if self.web_view.page():
                url = self.web_view.url()
                if url and url.toString() and url.toString() != 'about:blank':
                    page_has_url = True
            
            # Only inject CSS if a page is already loaded
            # On first launch, the page will be loaded later, and CSS will be injected in on_page_loaded()
            if page_has_url:
                # Inject CSS immediately so styling is correct when window appears
                self.inject_css()
            # Apply mini/micro mode settings (this will set up min/max sizes correctly)
            # Note: This is safe to call even on startup - it will handle the mode correctly
            self.apply_mini_mode()
            # Update UI to reflect the mode
            self.update_mini_mode_button()
            self.update_mini_mode_menu_text()
            # Note: Mini mode resize will be applied in on_page_loaded when page is ready
            # This ensures dimensions are available for accurate resizing
        
        # Show window immediately for faster perceived startup
        # Window is already properly sized and positioned from __init__
        self.updateGeometry()
        
        # Show window immediately (opacity will be restored from 0.0 to 1.0)
        self.setVisible(True)
        self.show()
        self.raise_()
        
        # Start fade-in immediately after showing (much shorter delay for faster startup)
        # Reduced from 400ms + 100ms delay to just 50ms for near-instant appearance
        QTimer.singleShot(50, lambda: self._fade_in_window())
        
        # Setup media key listener after window is ready
        self.setup_media_key_listener()
    
    def _fade_in_window(self):
        """Start the fade-in animation (separated for better timing)"""
        # Create smooth fade-in animation (reuse if exists)
        if not hasattr(self, '_fade_in_animation'):
            self._fade_in_animation = QPropertyAnimation(self, b"windowOpacity")
            self._fade_in_animation.setDuration(300)  # Reduced from 600ms to 300ms for faster startup
            self._fade_in_animation.setEasingCurve(QEasingCurve.Type.OutCubic)  # Smooth easing
        else:
            self._fade_in_animation.stop()
        
        # Ensure we start from 0
        current_opacity = self.windowOpacity()
        if current_opacity > 0.01:
            self.setWindowOpacity(0.0)
        
        # Set animation values
        self._fade_in_animation.setStartValue(0.0)
        self._fade_in_animation.setEndValue(1.0)
        
        # Start fade-in
        self._fade_in_animation.start()
        
        # IPC server is already set up in __init__ to ensure it's always available
        # (even when starting in nano mode or if deferred_init is delayed)
        
        # Setup system tray (non-critical, can be deferred)
        if self.tray_icon is None:
            self.setup_tray()
        
        # Initial URL was already determined in __init__ (optimization for faster startup)
        # Restore playlist state from settings
        playlist_visible = self.settings.get("playlist_visible", True)  # Default to visible
        
        # Restore detached state if it was detached
        playlist_detached = self.settings.get("playlist_detached", False)
        if playlist_detached:
            # Set the detached flag immediately to prevent any reattachment
            self.playlist_detached = True
            self.playlist_detached_offset = self.settings.get("playlist_detached_offset", (20, 0))
            self.playlist_detached_position = self.settings.get("playlist_detached_position", None)
            self.playlist_detached_size = self.settings.get("playlist_detached_size", "260x400")
            # Restore link mode state
            self.playlist_window_linked = self.settings.get("playlist_window_linked", False)
            # If playlist was detached, we need to create it and detach it
            # Always restore detached state, regardless of visibility (detached window can be minimized)
            # Always set the restore flag so state is restored when playlist is first created
            self._restore_playlist_state_pending = True
            # Create playlist first, then detach it
            if self.playlist_sidebar is None:
                # Create playlist if it doesn't exist (will be created when toggled)
                if playlist_visible:
                    self.toggle_playlist()
                else:
                    # Even if not visible, we need to create it to detach it
                    # Create it hidden, then detach
                    self.toggle_playlist()
                    # Hide it after creation but before detaching
                    if self.playlist_sidebar:
                        self.playlist_sidebar.hide()
            else:
                self._restore_playlist_state()
            # Detach after a short delay to ensure playlist is fully created and initialized
            # Reduced delay for faster startup (was 300ms, now 100ms)
            def detach_on_startup():
                # Double-check that we should still be detached (in case something changed)
                if self.settings.get("playlist_detached", False):
                    self._detach_playlist()
                    # Ensure window is shown after detaching (with a small delay to allow window creation)
                    def ensure_window_shown():
                        if hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
                            self.detached_playlist_window.show()
                            self.detached_playlist_window.raise_()
                    QTimer.singleShot(50, ensure_window_shown)  # Reduced from 100ms
            QTimer.singleShot(100, detach_on_startup)  # Reduced from 300ms for faster startup
            # Don't return early - we still need to load the initial URL!
            # Just skip the normal playlist restoration
        else:
            # Normal playlist restoration (not detached)
            # Always set the restore flag so state is restored when playlist is first created
            # This ensures that even if playlist is hidden, its state (height, minimized) is restored
            self._restore_playlist_state_pending = True
            
            # If playlist should be visible, create it now (it's lazy-loaded)
            if playlist_visible:
                # This will create the playlist if it doesn't exist
                if self.playlist_sidebar is None:
                    # Force creation - the restore function will be called automatically
                    # when the playlist is created (see toggle_playlist)
                    self.toggle_playlist()  # This creates the playlist and restores state if flag is set
                else:
                    # Playlist already exists, restore state directly
                    self._restore_playlist_state()
        
        # Check if we should start in nano mode
        # We'll activate it after the page loads (see on_page_loaded)
        start_in_nano = self.settings.get('start_in_nano_mode', False)
        if start_in_nano and self.nano_mode_on_minimize:
            # Set flag to activate nano mode after first page load
            self._activate_nano_after_page_load = True
        else:
            self._activate_nano_after_page_load = False
        
        # Load initial URL if pending (start immediately - window is already shown)
        # This must run regardless of whether playlist is detached or attached
        # URL loading happens in parallel with playlist restoration for faster startup
        if self._initial_url_pending:
            url = self._initial_url_pending
            self._initial_url_pending = None
            # Start loading immediately (no delay needed - window is already visible)
            # Explicitly pass is_startup_load=True to preserve the flag
            self.load_url(url, is_startup_load=True)
        else:
            # No URL to load - show welcome message
            if self.welcome_widget:
                self.welcome_widget.show()
                # Update title to indicate empty state
                edition = globals().get("__edition__")
                edition_suffix = f" ({edition})" if edition else ""
                QMainWindow.setWindowTitle(self, f"Empty - Bandcamp Player{edition_suffix}")
                if self.window_title_label:
                    self.window_title_label.setText(self._truncate_title_text("Empty"))
            
            # Hide player widget and cover art on first startup if no URLs/playlist
            # This allows the welcome message to take up the whole viewport
            use_qt = getattr(self, 'use_qt_widgets', True)
            if use_qt and hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                self.regular_player_widget.hide()
            # Also hide webview if not using Qt widgets
            if not use_qt and self.web_view:
                self.web_view.hide()
                # Make webview transparent to mouse events so it doesn't block clicks on cover art
                self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)

        # Keep playlist quick button in sync after startup restoration
        try:
            QTimer.singleShot(0, self.update_playlist_quick_btn_visibility)
        except Exception:
            pass
        
        # Update check will be performed after first URL loads (in on_page_loaded)
    
    def _restore_playlist_state(self):
        """Restore playlist state from settings (called after playlist is created)"""
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # If playlist was detached, don't restore attached playlist state (it will be in detached window)
        playlist_detached = self.settings.get("playlist_detached", False)
        if playlist_detached:
            # Skip restoration - playlist will be moved to detached window
            return
        
        playlist_visible = self.settings.get("playlist_visible", True)  # Default to visible
        # Prefer attached-specific minimized state if present (so detaching/reattaching doesn't lose it)
        playlist_minimized = self.settings.get("playlist_attached_minimized", self.settings.get("playlist_minimized", True))  # Default to minimized
        # Use attached height if available, otherwise use regular playlist_height
        playlist_height = self.settings.get('playlist_attached_height')
        if not playlist_height:
            playlist_height = self.settings.get("playlist_height", 250)
        
        # If playlist_height is 115px (micro mode height), restore from playlist_height_regular instead
        # This handles the case where app was closed in micro mode
        if playlist_height == 135:
            playlist_height_regular = self.settings.get("playlist_height_regular")
            if playlist_height_regular and playlist_height_regular != 135:
                playlist_height = playlist_height_regular
                logger.debug(f"Restoring playlist height from playlist_height_regular (was 115px): {playlist_height}")
            else:
                # No regular height saved, use default
                playlist_height = 250
                logger.debug(f"No playlist_height_regular found, using default: {playlist_height}")
        
        # Restore height first (before visibility/minimized state)
        playlist_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, playlist_height)))
        self.playlist_sidebar.setFixedHeight(playlist_height)
        if hasattr(self.playlist_sidebar, '_restore_height'):
            self.playlist_sidebar._restore_height = playlist_height
        
        # Restore visibility
        self.playlist_sidebar.setVisible(playlist_visible)
        if hasattr(self, 'playlist_resize_handle'):
            handle = self.playlist_resize_handle
            handle.setVisible(playlist_visible)
            # Set height to 0 when hidden to prevent taking up space
            if playlist_visible:
                handle.setFixedHeight(4)
            else:
                handle.setFixedHeight(0)
        if hasattr(self, 'playlist_btn'):
            self.playlist_btn.setChecked(playlist_visible)
            self._update_playlist_button_icon(playlist_visible)
        if hasattr(self, 'show_playlist_action'):
            self.show_playlist_action.setChecked(playlist_visible)
        
        # Restore minimized state (must be done after visibility is set)
        # Only toggle if the current state doesn't match the saved state
        if playlist_minimized != self.playlist_sidebar.is_minimized:
            # Use the internal method that doesn't require an event parameter
            self.playlist_sidebar._toggle_minimize_state()
        else:
            # Even if state matches, update button icon to reflect current state
            if hasattr(self.playlist_sidebar, 'minimize_btn'):
                self.playlist_sidebar._update_minimize_button_icon()
        
        # If we're in micro mode and playlist was just restored, ensure it's minimized and trigger resize
        # This handles the first launch case where playlist is created after apply_mini_mode is called
        if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 2:
            if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                # Playlist is visible but not minimized - minimize it for micro mode
                self.playlist_sidebar._toggle_minimize_state()
            # Force geometry update and trigger resize to ensure window accommodates minimized playlist
            self.playlist_sidebar.updateGeometry()
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.updateGeometry()
            layout = self.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            # Defer UI update instead of forcing immediate processing
            QTimer.singleShot(0, lambda: layout.update() if layout else None)
            # Trigger resize after a short delay to ensure geometry is updated
            QTimer.singleShot(100, self.resize_to_micro_mode)
    
    def setup_ui(self):
        """Setup the main UI layout"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Enable drag and drop on central widget
        central_widget.setAcceptDrops(True)
        
        # Add drag/drop handlers to central widget to allow dropping URLs anywhere
        def central_drag_enter(event):
            """Handle drag enter on central widget"""
            if event.mimeData().hasUrls() or event.mimeData().hasText():
                event.acceptProposedAction()
            else:
                event.ignore()
        
        def central_drop(event):
            """Handle drop on central widget - check if over playlist, otherwise load URL"""
            url = None
            
            # Get first URL from drag event
            if event.mimeData().hasUrls():
                url_list = event.mimeData().urls()
                if url_list:
                    url = url_list[0].toString()
            
            # If no URL from list, try text
            if not url and event.mimeData().hasText():
                text = event.mimeData().text().strip()
                if text:
                    # Extract URLs from text (handles multiple URLs)
                    playlist_sidebar = safe_getattr(self, 'playlist_sidebar')
                    if playlist_sidebar:
                        urls = playlist_sidebar.extract_urls_from_text(text)
                        if urls:
                            url = urls[0]  # Take first URL
                    else:
                        # Fallback: take first line
                        lines = [line.strip() for line in text.split('\n') if line.strip()]
                        if lines:
                            url = lines[0]
            
            if not url:
                event.ignore()
                return
            
            # Check if drop is over playlist sidebar
            drop_pos = event.position().toPoint() if hasattr(event, 'position') else event.pos()
            global_pos = central_widget.mapToGlobal(drop_pos)
            
            # Check if drop is over playlist sidebar
            is_over_playlist = False
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible():
                playlist_rect = self.playlist_sidebar.geometry()
                playlist_global_rect = QRect(
                    self.playlist_sidebar.mapToGlobal(QPoint(0, 0)),
                    playlist_rect.size()
                )
                if playlist_global_rect.contains(global_pos):
                    is_over_playlist = True
            
            # Also check if drop is over playlist list widget
            if not is_over_playlist and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                if hasattr(self.playlist_sidebar, 'list_widget') and self.playlist_sidebar.list_widget:
                    list_rect = self.playlist_sidebar.list_widget.geometry()
                    list_global_rect = QRect(
                        self.playlist_sidebar.list_widget.mapToGlobal(QPoint(0, 0)),
                        list_rect.size()
                    )
                    if list_global_rect.contains(global_pos):
                        is_over_playlist = True
            
            if is_over_playlist:
                # Drop is over playlist - queue it (add to playlist)
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    added_count, skipped_count = self.playlist_sidebar.process_urls([url])
                    # Show feedback
                    if added_count > 0:
                        message = "URL added to playlist"
                    else:
                        message = "URL not added (duplicate or invalid)"
                    QToolTip.showText(global_pos, message, central_widget, QRect(), 2000)
            else:
                # Drop is anywhere else - load the URL
                self._handle_global_drop(url)
            
            event.acceptProposedAction()
        
        central_widget.dragEnterEvent = central_drag_enter
        central_widget.dropEvent = central_drop
        
        # Set background color for frameless mode (rounded corners handled by mask)
        if self.frameless_mode:
            central_widget.setStyleSheet("""
                QWidget {
                    background-color: rgb(21, 21, 21);
                }
            """)
        
        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        # Force alignment to top - prevent vertical centering
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        
        # Top controls bar - fixed at top (wrap in widget to prevent centering)
        self.controls_bar_widget = QWidget()
        self.controls_bar_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        # When autohide is enabled, make it overlay with semi-transparent background
        controls_bar_widget = self.controls_bar_widget  # Keep local reference for layout
        controls_bar = QHBoxLayout(controls_bar_widget)
        controls_bar.setContentsMargins(5, 5, 5, 5)
        controls_bar.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        
        # Store original style for controls bar (will be modified when autohide is enabled)
        self.controls_bar_original_style = None
        
        # Add stretch to push buttons to the right
        controls_bar.addStretch()
        
        # Autohide Top Nav button removed - functionality moved to mini player autohide toggle
        
        # Volume button - ORDER: 3
        self.volume_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('fa5s.volume-up', color='#e0e0e0')
            if icon:
                self.volume_btn.setIcon(icon)
            else:
                self.volume_btn.setText("")
        else:
            self.volume_btn.setText("")
        self.volume_btn.setMinimumWidth(30)
        self.volume_btn.setMaximumWidth(30)
        self.volume_btn.setToolTip("Volume")
        self.volume_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        self.volume_btn.clicked.connect(lambda: self.show_volume_control(auto_hide=True, delay_ms=1200))
        controls_bar.addWidget(self.volume_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Paste button - ORDER: 4
        paste_btn = QPushButton()
        set_icon_safe(paste_btn, 'paste', color='#e0e0e0', fallback_text="")
        paste_btn.setMinimumWidth(30)
        paste_btn.setMaximumWidth(30)
        paste_btn.setToolTip("Paste URL From Clipboard")
        paste_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 16px;
                font-weight: bold;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        paste_btn.clicked.connect(self.on_paste_url)
        controls_bar.addWidget(paste_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Playlist button - ORDER: 5
        self.playlist_btn = QPushButton()
        icon_color = '#a0a0a0'  # Default to light color (playlist hidden by default)
        if HAS_QT_AWESOME:
            # Use the original icon for the top nav (looks better at 30x30)
            icon = get_icon('mdi6.list-box', color=icon_color)
            if icon:
                self.playlist_btn.setIcon(icon)
            else:
                self.playlist_btn.setText("")        
        else:
            self.playlist_btn.setText("")
        self.playlist_btn.setFixedSize(30, 30)
        self.playlist_btn.setToolTip("Toggle Playlist")
        self.playlist_btn.setCheckable(True)
        self.playlist_btn.setChecked(False)  # Playlist is hidden by default
        self.playlist_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #a0a0a0;
                border: none;
                font-size: 14px;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """)
        self.playlist_btn.clicked.connect(self.toggle_playlist)
        controls_bar.addWidget(self.playlist_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Mini Mode button will be added to title bar instead
        # Create it here but don't add to controls bar
        # The button will be added to title bar in create_custom_title_bar
        if not hasattr(self, 'mini_mode_btn') or self.mini_mode_btn is None:
            self.mini_mode_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('square', color='#e0e0e0')
                if icon:
                    self.mini_mode_btn.setIcon(icon)
                else:
                    self.mini_mode_btn.setText("")  # Default icon (will be updated by update_mini_mode_button)
            else:
                self.mini_mode_btn.setText("")  # Default icon (will be updated by update_mini_mode_button)
            self.mini_mode_btn.setFixedSize(28, 30)
            self.mini_mode_btn.setToolTip("Mini Mode")
            self.mini_mode_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 0px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            self.mini_mode_btn.clicked.connect(self.toggle_mini_mode)
        # Update button visibility and state (will be added to title bar later)
        self.update_mini_mode_button()
        
        # Settings button
        menu_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('cog', color='#e0e0e0')
            if icon:
                menu_btn.setIcon(icon)
            else:
                menu_btn.setText("")
        else:
            menu_btn.setText("")
        menu_btn.setMinimumWidth(30)
        menu_btn.setMaximumWidth(30)
        menu_btn.setToolTip("Menu")
        menu_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        menu_btn.clicked.connect(self.show_menu)
        controls_bar.addWidget(menu_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Add controls bar widget at the top (fixed size, always at top)
        # When autohide is enabled, we'll make it overlay instead of being in layout
        self.controls_bar_in_layout = True
        layout.addWidget(controls_bar_widget, 0)  # Stretch factor 0 = no expansion
        
        # Create autohide trigger button (visible when address bar is hidden)
        self.autohide_trigger_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('mdi6.dots-horizontal', color='#b0b0b0')
            if icon:
                self.autohide_trigger_btn.setIcon(icon)
            else:
                self.autohide_trigger_btn.setText("")
        else:
            self.autohide_trigger_btn.setText("")
        self.autohide_trigger_btn.setFixedSize(24, 24)
        self.autohide_trigger_btn.setToolTip("Show Menu")
        self.autohide_trigger_btn.setParent(self)  # Parent to main window for absolute positioning
        self.autohide_trigger_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(21, 21, 21, 0.4);
                color: #b0b0b0;
                border: 1px solid rgba(176, 176, 176, 0.2);
                border-radius: 12px;
                font-size: 16px;
                padding: 0px;
            }
            QPushButton:hover {
                background-color: rgba(43, 43, 43, 0.7);
                border-color: rgba(176, 176, 176, 0.5);
                color: #e0e0e0;
            }
        """)
        self.autohide_trigger_btn.clicked.connect(self.show_address_bar_immediate)
        # Override enterEvent to show address bar on hover
        original_enter_event = self.autohide_trigger_btn.enterEvent
        def trigger_enter_event(event):
            if self.autohide_address_bar and not self.controls_bar_widget.isVisible():
                self.show_address_bar_immediate()
            if original_enter_event:
                original_enter_event(event)
        self.autohide_trigger_btn.enterEvent = trigger_enter_event
        self.autohide_trigger_btn.hide()  # Hidden by default, shown when address bar is hidden (will use fade when shown)
        self.autohide_trigger_btn.raise_()  # Ensure it's on top

        # Image viewer button (top-left, overlaying cover art)
        # Positioned similar to autohide trigger button but always visible
        self.image_viewer_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('fa5s.search', color='#b0b0b0')
            if icon:
                self.image_viewer_btn.setIcon(icon)
            else:
                self.image_viewer_btn.setText("")
        else:
            self.image_viewer_btn.setText("")
        self.image_viewer_btn.setFixedSize(24, 24)
        self.image_viewer_btn.setToolTip("View Cover Art")
        self.image_viewer_btn.setParent(self)  # Parent to main window for absolute positioning
        self.image_viewer_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(21, 21, 21, 0.4);
                color: #b0b0b0;
                border: 1px solid rgba(176, 176, 176, 0.2);
                border-radius: 12px;
                font-size: 14px;
                padding: 0px;
            }
            QPushButton:hover {
                background-color: rgba(43, 43, 43, 0.7);
                border-color: rgba(176, 176, 176, 0.5);
                color: #e0e0e0;
            }
        """)
        self.image_viewer_btn.clicked.connect(self.open_image_viewer)
        # Visibility will be controlled by update_image_viewer_btn_visibility()
        # Update visibility immediately, position with slight delay to avoid layout interference
        self.update_image_viewer_btn_visibility()
        QTimer.singleShot(100, self.update_image_viewer_btn_position)

        # Playlist quick button (bottom-right). Safe/isolated: no animations, no JS interaction.
        # Shows only when playlist is closed (and attached) in regular mode.
        self.playlist_quick_btn = QPushButton()
        if HAS_QT_AWESOME:
            # Match the top-nav playlist icon for consistency
            icon = get_icon('mdi6.list-box', color='#b0b0b0')
            if icon:
                self.playlist_quick_btn.setIcon(icon)
            else:
                self.playlist_quick_btn.setText("")
        else:
            self.playlist_quick_btn.setText("")
        self.playlist_quick_btn.setFixedSize(24, 24)
        self.playlist_quick_btn.setToolTip("Show Playlist")
        self.playlist_quick_btn.setParent(self)  # Absolute positioning
        self.playlist_quick_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(21, 21, 21, 0.4);
                color: #b0b0b0;
                border: 1px solid rgba(176, 176, 176, 0.2);
                border-radius: 12px;
                font-size: 14px;
                padding: 0px;
            }
            QPushButton:hover {
                background-color: rgba(43, 43, 43, 0.7);
                border-color: rgba(176, 176, 176, 0.5);
                color: #e0e0e0;
            }
        """)
        self.playlist_quick_btn.clicked.connect(self._on_playlist_quick_btn_clicked)
        self.playlist_quick_btn.hide()
        self.playlist_quick_btn.raise_()
        
        # Create welcome message widget (shown when no URL has been loaded)
        self.welcome_widget = QWidget()
        self.welcome_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.welcome_widget.setStyleSheet("""
            QWidget {
                background-color: #212121;
            }
        """)
        welcome_layout = QVBoxLayout(self.welcome_widget)
        welcome_layout.setContentsMargins(20, 40, 20, 40)  # Reduced horizontal margins to prevent cutoff
        welcome_layout.setSpacing(20)
        welcome_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Welcome message (instructions only)
        welcome_message = QLabel("Drop a Bandcamp URL anywhere in this window or use the paste url button in the top menu to get started.")
        welcome_message.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignTop)  # Justified text alignment
        welcome_message.setWordWrap(True)
        welcome_message.setMaximumWidth(220)  # Constrain width to prevent cutoff (260px window - 40px margins)
        welcome_message.setStyleSheet("""
            QLabel {
                color: #b0b0b0;
                font-size: 14px;
                background-color: transparent;
                border: none;
                padding: 10px 5px;
                line-height: 1.5;
            }
        """)
        welcome_layout.addWidget(welcome_message)
        
        # Add welcome widget to layout (will be hidden when URL loads)
        layout.addWidget(self.welcome_widget, 1)  # Stretch factor 1 = takes available space
        # Initially hide welcome widget - will be shown in deferred_init if no URL is pending
        self.welcome_widget.hide()
        
        # Web view (will be added in setup_web_view)
        self.web_view = None
        
        # Loading overlay (will be added after web view is created)
        self.loading_overlay = None
        
        # Playlist sidebar (lazy-loaded - only create when first shown)
        self.playlist_sidebar = None
        self._restore_playlist_state_pending = False  # Flag to restore state when playlist is created
        
        # Keep old playlist_widget reference for backward compatibility
        self.playlist_widget = None
        
        # Update playlist display
        self.update_playlist_display()
        
        # Create bottom resize handle for frameless mode (will be shown/hidden based on frameless mode)
        self.bottom_resize_handle = None
        self.resize_start_y = None
        self.resize_start_height = None
        
        # Autohide address bar state (initialize timers before setup_autohide_address_bar)
        self.address_bar_hide_timer = QTimer(self)
        self.address_bar_hide_timer.setSingleShot(True)
        self.address_bar_hide_timer.timeout.connect(self.hide_address_bar)
        self.address_bar_show_timer = QTimer(self)
        self.address_bar_show_timer.setSingleShot(True)
        self.address_bar_show_timer.timeout.connect(self.show_address_bar)
        self.address_bar_animation = None
        
        # Animation for trigger button fade in/out
        self.trigger_btn_animation = None
        
        # Failsafe timer to ensure address bar always hides after no interaction
        self.address_bar_failsafe_timer = QTimer(self)
        self.address_bar_failsafe_timer.setSingleShot(True)
        self.address_bar_failsafe_timer.timeout.connect(self._failsafe_hide_address_bar)
        self.address_bar_failsafe_delay = 5000  # 5 seconds of no interaction
        
        # Mouse tracking timer to check if mouse is within address bar
        self.address_bar_mouse_tracker = QTimer(self)
        self.address_bar_mouse_tracker.timeout.connect(self.check_address_bar_mouse_position)
        self.address_bar_mouse_tracker.setInterval(100)  # Check every 100ms
        
        # Setup autohide address bar if enabled (after timers are initialized)
        self.setup_autohide_address_bar()
    
    def setup_autohide_address_bar(self):
        """Setup autohide address bar functionality"""
        if not hasattr(self, 'controls_bar_widget'):
            return
        
        # Create a hover area widget for backward compatibility (but disabled)
        # The full-width hover area is now disabled - only the icon acts as hotspot
        self.address_bar_hover_area = QWidget(self)
        # Hover area is always 10px at the very top (consistent across all modes)
        hover_height = 10
        self.address_bar_hover_area.setFixedHeight(hover_height)
        self.address_bar_hover_area.setStyleSheet("background-color: transparent;")
        # Always make it transparent for mouse events - disabled functionality
        self.address_bar_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        self.address_bar_hover_area.hide()  # Always hidden - no longer used
        
        # Position hover area function (disabled - kept for backward compatibility)
        def update_hover_area_position():
            # Hover area is now disabled - always keep it hidden and transparent
            if hasattr(self, 'address_bar_hover_area') and self.address_bar_hover_area:
                self.address_bar_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
                self.address_bar_hover_area.hide()
        
        # No longer need to set up event handlers for hover area - it's disabled
        # The icon (autohide_trigger_btn) handles all hover/click interactions now
        
        # Mouse enter/leave events for controls bar
        # When mouse enters the controls bar itself, show it (if autohide is enabled)
        # BUT in all modes, only show when hovering over the trigger button
        def controls_bar_enter(event):
            if self.autohide_address_bar:
                # In all modes (including regular), don't show on enter - only show on trigger button hover
                # The address bar should only show when hovering over the trigger button
                return
        
        def controls_bar_leave(event):
            """Only hide if mouse is truly outside the address bar bounds and trigger icon"""
            if not self.autohide_address_bar:
                return
            
            # Use a small delay to check if mouse moved to a child widget
            # This prevents hiding when moving between buttons/input field
            def check_and_hide():
                if not self.autohide_address_bar:
                    return
                # Get current global mouse position
                global_pos = QCursor.pos()
                # Convert to window coordinates
                window_pos = self.mapFromGlobal(global_pos)
                
                # Check if mouse is over the trigger icon
                if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
                    if self.autohide_trigger_btn.geometry().contains(window_pos):
                        # Mouse is over trigger icon, don't hide
                        return
                
                # Check if mouse is within address bar geometry
                if self.controls_bar_widget.geometry().contains(window_pos):
                    # Mouse is still within address bar, don't hide
                    return
                # Mouse has truly left both the address bar and trigger icon area
                self.schedule_address_bar_hide()
            
            # Small delay to allow mouse to move to child widgets
            QTimer.singleShot(100, check_and_hide)
        
        self.controls_bar_widget.enterEvent = controls_bar_enter
        self.controls_bar_widget.leaveEvent = controls_bar_leave
        
        # Install event filter on controls bar to catch mouse movements within it
        self.controls_bar_widget.installEventFilter(self)
        
        # Show address bar when URL input gets focus (via event filter)
        # This is handled in the existing eventFilter method
        
        # Apply initial state
        if self.autohide_address_bar:
            # Make address bar overlay
            QTimer.singleShot(100, self.make_address_bar_overlay)
            # Start mouse tracking
            self.address_bar_mouse_tracker.start()
            # Hide initially after a short delay
            QTimer.singleShot(600, self.schedule_address_bar_hide)
            # Start failsafe timer after initial delay
            QTimer.singleShot(600 + self.address_bar_failsafe_delay, self._reset_address_bar_failsafe_timer)
        else:
            # Always show if autohide is disabled
            self.show_address_bar_immediate()
            # Stop failsafe timer if autohide is disabled
            self.address_bar_failsafe_timer.stop()
        
        # Store update function for later use (now a no-op, kept for compatibility)
        self.update_hover_area_position = update_hover_area_position
    
    def schedule_address_bar_hide(self, delay=150):
        """Schedule address bar to hide after delay (default 150ms)"""
        if not self.autohide_address_bar:
            return
        self.address_bar_hide_timer.stop()
        self.address_bar_hide_timer.start(delay)
        # Also start failsafe timer as backup
        self._reset_address_bar_failsafe_timer()
    
    def cancel_address_bar_hide(self):
        """Cancel scheduled address bar hide"""
        self.address_bar_hide_timer.stop()
        # Reset failsafe timer on any interaction
        self._reset_address_bar_failsafe_timer()
    
    def hide_address_bar(self):
        """Hide the address bar with smooth fade animation"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Stop failsafe timer since we're hiding normally
        self.address_bar_failsafe_timer.stop()
        
        # Stop any existing animation
        if self.address_bar_animation:
            self.address_bar_animation.stop()
        
        # Create smooth fade out animation
        effect = QGraphicsOpacityEffect(self.controls_bar_widget)
        self.controls_bar_widget.setGraphicsEffect(effect)
        
        self.address_bar_animation = QPropertyAnimation(effect, b"opacity")
        self.address_bar_animation.setDuration(250)  # Smooth fade - 250ms
        self.address_bar_animation.setStartValue(1.0)
        self.address_bar_animation.setEndValue(0.0)
        self.address_bar_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)  # Very smooth easing curve
        
        # Start trigger button fade-in immediately (at the same time as address bar fade-out)
        # This prevents the "pop in" effect by making it appear smoothly as the nav bar fades
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
            self.show_trigger_button(animated=True)
        
        def on_animation_finished():
            self.controls_bar_widget.hide()
            self.controls_bar_widget.setGraphicsEffect(None)
            self.address_bar_animation = None
            # Show hover area when address bar is hidden
            if hasattr(self, 'update_hover_area_position'):
                self.update_hover_area_position()
            # Update overlay position in case window was resized
            if hasattr(self, 'update_address_bar_overlay_position'):
                self.update_address_bar_overlay_position()
        
        self.address_bar_animation.finished.connect(on_animation_finished)
        self.address_bar_animation.start()
    
    def _reset_address_bar_failsafe_timer(self):
        """Reset the failsafe timer that ensures address bar hides after no interaction"""
        if not self.autohide_address_bar:
            self.address_bar_failsafe_timer.stop()
            return
        
        # Only start failsafe timer if address bar is visible
        if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget.isVisible():
            self.address_bar_failsafe_timer.stop()
            self.address_bar_failsafe_timer.start(self.address_bar_failsafe_delay)
        else:
            self.address_bar_failsafe_timer.stop()
    
    def _failsafe_hide_address_bar(self):
        """Failsafe function to force hide address bar if it's stuck visible"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Only force hide if address bar is actually visible
        if self.controls_bar_widget.isVisible():
            logger.debug("Failsafe: Force hiding stuck address bar")
            self.hide_address_bar()
    
    def show_address_bar_immediate(self):
        """Show the address bar immediately (no animation)"""
        if not hasattr(self, 'controls_bar_widget'):
            return
        
        self.cancel_address_bar_hide()
        
        # Stop any existing animation
        if self.address_bar_animation:
            self.address_bar_animation.stop()
            self.address_bar_animation = None
        
        # Hide hover area when showing address bar (always hidden now, but keep for compatibility)
        if hasattr(self, 'address_bar_hover_area') and self.address_bar_hover_area:
            self.address_bar_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self.address_bar_hover_area.hide()
        
        # Reset failsafe timer when showing address bar
        self._reset_address_bar_failsafe_timer()
        
        # Update overlay position if in overlay mode
        if self.autohide_address_bar and hasattr(self, 'update_address_bar_overlay_position'):
            self.update_address_bar_overlay_position()
        
        # Show and make fully opaque
        self.controls_bar_widget.show()
        self.controls_bar_widget.setGraphicsEffect(None)
        self.controls_bar_widget.setWindowOpacity(1.0)
        self.controls_bar_widget.raise_()  # Ensure it's on top
        
        # Hide trigger button when address bar is shown (with fade out)
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
            self.hide_trigger_button(animated=True)
    
    def show_address_bar(self):
        """Show the address bar with smooth fade animation"""
        if not hasattr(self, 'controls_bar_widget'):
            return
        
        self.cancel_address_bar_hide()
        
        # Stop any existing animation
        if self.address_bar_animation:
            self.address_bar_animation.stop()
        
        # Hide hover area when showing address bar (always hidden now, but keep for compatibility)
        if hasattr(self, 'address_bar_hover_area') and self.address_bar_hover_area:
            self.address_bar_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self.address_bar_hover_area.hide()
        
        # Update overlay position if in overlay mode
        if self.autohide_address_bar and hasattr(self, 'update_address_bar_overlay_position'):
            self.update_address_bar_overlay_position()
        
        # Show widget first
        self.controls_bar_widget.show()
        self.controls_bar_widget.raise_()  # Ensure it's on top
        
        # Create smooth fade in animation
        effect = QGraphicsOpacityEffect(self.controls_bar_widget)
        self.controls_bar_widget.setGraphicsEffect(effect)
        effect.setOpacity(0.0)
        
        self.address_bar_animation = QPropertyAnimation(effect, b"opacity")
        self.address_bar_animation.setDuration(250)  # Smooth fade - 250ms
        self.address_bar_animation.setStartValue(0.0)
        self.address_bar_animation.setEndValue(1.0)
        self.address_bar_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)  # Very smooth easing curve
        
        def on_animation_finished():
            self.controls_bar_widget.setGraphicsEffect(None)
            self.address_bar_animation = None
        
        self.address_bar_animation.finished.connect(on_animation_finished)
        self.address_bar_animation.start()
    
    def toggle_autoplay(self):
        """Toggle autoplay setting"""
        self.autoplay = not self.autoplay
        self.autoplay_action.setChecked(self.autoplay)
        self.save_settings()
    
    def toggle_shuffle(self):
        """Centralized shuffle toggle - cycles through modes and syncs all widgets."""
        # Cycle through modes: 0  1  2  3  0
        self.shuffle_mode = (self.shuffle_mode + 1) % 4
        
        # Save to settings
        self.settings['shuffle_mode'] = self.shuffle_mode
        self.settings['shuffle_on'] = self.shuffle_mode > 0  # Backward compatibility
        self.save_settings()
        
        # Update playlist sidebar if it exists
        playlist_sidebar = safe_getattr(self, 'playlist_sidebar')
        if playlist_sidebar:
            playlist_sidebar.shuffle_mode = self.shuffle_mode
            playlist_sidebar._update_shuffle_button_ui()
            # Don't call _update_javascript_shuffle_mode here - we'll do it directly from main window
            # to avoid duplicate shuffled list creation
        
        # Always update JavaScript directly as well to ensure it happens immediately
        self._update_javascript_shuffle_mode_direct()
        
        # If shuffle mode 1 (tracks) is enabled, create shuffled track list
        # This must happen after JavaScript mode is updated
        if self.shuffle_mode == 1:
            # Get current URL and create shuffled track list
            if hasattr(self, 'web_view') and self.web_view and self.web_view.url():
                current_url = self.web_view.url().toString()
                if current_url and 'bandcamp.com' in current_url.lower():
                    # Clear any existing shuffled list first
                    self._shuffled_track_list = None
                    self._shuffled_track_index = 0
                    # Delay to ensure tracklist DOM is ready and JavaScript mode is set
                    # Use multiple delays with retry to ensure tracklist is loaded
                    def create_list_with_retry():
                        if not self._shuffled_track_list:  # Only create if not already created
                            self._create_shuffled_track_list(current_url)
                    QTimer.singleShot(300, create_list_with_retry)  # First attempt
                    QTimer.singleShot(800, create_list_with_retry)  # Retry if first fails
                    QTimer.singleShot(1500, create_list_with_retry)  # Final retry
        
        # Sync all player widgets
        self._sync_shuffle_repeat_buttons()
    
    def _update_javascript_shuffle_mode_direct(self):
        """Update JavaScript shuffle mode directly from main window (fallback if playlist sidebar doesn't exist)"""
        if not hasattr(self, 'web_view') or not self.web_view or not self.web_view.page():
            return
        
        shuffle_mode = self.shuffle_mode
        js_code = f"""
        (function() {{
            window.bandcampShuffleMode = {shuffle_mode};
            console.log('Bandcamp Player: Shuffle mode updated to {shuffle_mode}');
            
            // Remove interception attributes so buttons can be re-setup with new mode
            var nextBtn = document.querySelector('button[aria-label="Skip to next song"], .next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
            if (nextBtn) {{
                nextBtn.removeAttribute('data-bandcamp-player-intercepted');
            }}
            
            var prevBtn = document.querySelector('button[aria-label="Skip to previous song"], .next-prev-controls button[aria-label*="previous"], .next-prev-controls button[aria-label*="Previous"], button[aria-label*="Skip to previous"]');
            if (prevBtn) {{
                prevBtn.removeAttribute('data-bandcamp-player-intercepted');
            }}
        }})();
        """
        self.run_javascript_safe(js_code)
        
        # If shuffle is disabled, also clear the shuffled track list variables
        if shuffle_mode == 0:
            # Clear Python-side shuffled track list
            self._shuffled_track_list = None
            self._shuffled_track_index = 0
            self._shuffled_track_album_url = None
            
            # Clear JavaScript-side shuffled track list
            clear_js = """
            (function() {
                window.bandcampShuffledTrackList = null;
                window.bandcampShuffledTrackIndex = 0;
                console.log('Bandcamp Player: Cleared shuffled track list (shuffle disabled)');
            })();
            """
            self.run_javascript_safe(clear_js)
        
        # Re-setup button interception when shuffle mode changes (debounced to avoid multiple calls)
        if hasattr(self, '_setup_next_prev_button_interception'):
            self._debounced_setup_button_interception()
    
    def _update_javascript_repeat_mode_direct(self):
        """Update JavaScript repeat mode directly from main window (fallback if playlist sidebar doesn't exist)"""
        if not hasattr(self, 'web_view') or not self.web_view or not self.web_view.page():
            return
        
        repeat_mode = self.repeat_mode
        js_code = f"""
        (function() {{
            window.bandcampRepeatMode = {repeat_mode};
            console.log('Bandcamp Player: Repeat mode updated to {repeat_mode}');
        }})();
        """
        self.run_javascript_safe(js_code)
    
    def toggle_repeat(self):
        """Centralized repeat toggle - cycles through modes and syncs all widgets."""
        # Cycle through modes: 0  1  2  3  0
        self.repeat_mode = (self.repeat_mode + 1) % 4
        
        # Save to settings
        self.settings['repeat_mode'] = self.repeat_mode
        self.settings['repeat_on'] = self.repeat_mode > 0  # Backward compatibility
        self.save_settings()
        
        # Update playlist sidebar if it exists
        playlist_sidebar = safe_getattr(self, 'playlist_sidebar')
        if playlist_sidebar:
            playlist_sidebar.repeat_mode = self.repeat_mode
            playlist_sidebar._update_repeat_button_ui()
        
        # Always update JavaScript directly as well to ensure it happens immediately
        self._update_javascript_repeat_mode_direct()
        
        # Sync all player widgets
        self._sync_shuffle_repeat_buttons()
    
    def _sync_shuffle_repeat_buttons(self):
        """Sync shuffle/repeat button states across all player widgets."""
        # Sync nano player
        nano_player = safe_getattr(self, 'nano_player_window')
        if nano_player and hasattr(nano_player, '_sync_shuffle_repeat_buttons'):
            nano_player._sync_shuffle_repeat_buttons()
        
        # Sync Qt-based player widgets
        widgets_to_sync = []
        regular_widget = safe_getattr(self, 'regular_player_widget')
        if regular_widget:
            widgets_to_sync.append(regular_widget)
        mini_widget = safe_getattr(self, 'mini_player_widget')
        if mini_widget:
            widgets_to_sync.append(mini_widget)
        micro_widget = safe_getattr(self, 'micro_player_widget')
        if micro_widget:
            widgets_to_sync.append(self.micro_player_widget)
        
        for widget in widgets_to_sync:
            try:
                if hasattr(widget, 'shuffle_btn') and widget.shuffle_btn:
                    widget.shuffle_btn.blockSignals(True)
                    is_active = self.shuffle_mode > 0
                    widget.shuffle_btn.setChecked(is_active)
                    
                    # Generate tooltip based on mode (same as playlist sidebar)
                    if self.shuffle_mode == 0:
                        tooltip = "Shuffle: Off"
                    elif self.shuffle_mode == 1:
                        tooltip = "Shuffle: Tracks (shuffle tracks in album)"
                    elif self.shuffle_mode == 2:
                        tooltip = "Shuffle: Albums (randomize album order)"
                    else:  # mode 3
                        tooltip = "Super Shuffle (random album & track)"
                    widget.shuffle_btn.setToolTip(tooltip)
                    
                    # Update icon
                    if HAS_QT_AWESOME:
                        if self.shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            widget.shuffle_btn.setIcon(icon)
                    widget.shuffle_btn.blockSignals(False)
                
                if hasattr(widget, 'repeat_btn') and widget.repeat_btn:
                    widget.repeat_btn.blockSignals(True)
                    is_active = self.repeat_mode > 0
                    widget.repeat_btn.setChecked(is_active)
                    
                    # Generate tooltip based on mode (same as playlist sidebar)
                    if self.repeat_mode == 0:
                        tooltip = "Repeat: Off"
                    elif self.repeat_mode == 1:
                        tooltip = "Repeat: Continuous (play next album)"
                    elif self.repeat_mode == 2:
                        tooltip = "Repeat: Album (loop current album)"
                    else:  # mode 3
                        tooltip = "Repeat: Track (loop current track)"
                    widget.repeat_btn.setToolTip(tooltip)
                    
                    # Update icon
                    if HAS_QT_AWESOME:
                        if self.repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            widget.repeat_btn.setIcon(icon)
                    widget.repeat_btn.blockSignals(False)
                    
                    # Update repeat overlay for mode 3 ("1" overlay)
                    if hasattr(widget, '_update_repeat_overlay'):
                        widget._update_repeat_overlay(self.repeat_mode)
            except (AttributeError, RuntimeError) as e:
                logger.debug(f"Error syncing buttons for widget: {e}")
        
        # Sync image viewer controls if they exist
        if hasattr(self, '_image_viewer_controls') and self._image_viewer_controls:
            try:
                controls = self._image_viewer_controls
                
                # Update shuffle button
                if 'shuffle_btn' in controls and controls['shuffle_btn']:
                    shuffle_btn = controls['shuffle_btn']
                    shuffle_btn.blockSignals(True)
                    is_active = self.shuffle_mode > 0
                    shuffle_btn.setChecked(is_active)
                    
                    # Generate tooltip based on mode (same as playlist sidebar)
                    if self.shuffle_mode == 0:
                        tooltip = "Shuffle: Off"
                    elif self.shuffle_mode == 1:
                        tooltip = "Shuffle: Tracks (shuffle tracks in album)"
                    elif self.shuffle_mode == 2:
                        tooltip = "Shuffle: Albums (randomize album order)"
                    else:  # mode 3
                        tooltip = "Super Shuffle (random album & track)"
                    shuffle_btn.setToolTip(tooltip)
                    
                    # Update icon
                    if HAS_QT_AWESOME:
                        if self.shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            shuffle_btn.setIcon(icon)
                    shuffle_btn.blockSignals(False)
                
                # Update repeat button
                if 'repeat_btn' in controls and controls['repeat_btn']:
                    repeat_btn = controls['repeat_btn']
                    repeat_btn.blockSignals(True)
                    is_active = self.repeat_mode > 0
                    repeat_btn.setChecked(is_active)
                    
                    # Generate tooltip based on mode (same as playlist sidebar)
                    if self.repeat_mode == 0:
                        tooltip = "Repeat: Off"
                    elif self.repeat_mode == 1:
                        tooltip = "Repeat: Continuous (play next album)"
                    elif self.repeat_mode == 2:
                        tooltip = "Repeat: Album (loop current album)"
                    else:  # mode 3
                        tooltip = "Repeat: Track (loop current track)"
                    repeat_btn.setToolTip(tooltip)
                    
                    # Update icon (match main window player icons)
                    if HAS_QT_AWESOME:
                        if self.repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)  # Continuous
                        elif self.repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)  # Album loop
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)  # Track loop
                        if icon:
                            repeat_btn.setIcon(icon)
                    repeat_btn.blockSignals(False)
                    
                    # Update "1" overlay for repeat mode 3 (track loop)
                    self._update_image_viewer_repeat_overlay(self.repeat_mode, repeat_btn)
            except (AttributeError, RuntimeError) as e:
                logger.debug(f"Error syncing image viewer controls: {e}")
    
    def _update_image_viewer_repeat_overlay(self, repeat_mode, repeat_btn):
        """Update overlay on image viewer repeat button based on mode:
        - Mode 3 (Track): "1" overlay (white)
        - Other modes: no overlay
        """
        if not repeat_btn:
            return
        
        # Remove existing overlay if it exists
        overlay_key = '_image_viewer_repeat_overlay_label'
        if hasattr(self, overlay_key) and getattr(self, overlay_key) is not None:
            try:
                getattr(self, overlay_key).deleteLater()
            except (AttributeError, RuntimeError):
                pass  # Label might already be deleted
            setattr(self, overlay_key, None)
        
        # Show overlay only for mode 3 ("1")
        if repeat_mode == 3:
            # Create overlay label
            from PyQt6.QtWidgets import QLabel
            from PyQt6.QtCore import Qt
            
            # Set overlay text to "1" for mode 3
            overlay_text = "1"
            
            # Set overlay color: white for mode 3 (track)
            overlay_color = 'white'
            
            # Create overlay as child of button's parent widget to ensure it's on top
            # Get the button's parent widget (the container)
            button_parent = repeat_btn.parent()
            if button_parent:
                overlay_label = QLabel(overlay_text, button_parent)
            else:
                # Fallback to button itself if no parent
                overlay_label = QLabel(overlay_text, repeat_btn)
            
            overlay_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            # Make overlay transparent to mouse events so clicks pass through to button
            overlay_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            overlay_label.setStyleSheet(f"""
                QLabel {{
                    background-color: transparent;
                    color: {overlay_color};
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                }}
            """)
            
            # Store reference
            setattr(self, overlay_key, overlay_label)
            
            # Position will be updated when button is shown/resized
            # Use a method to update position
            def update_overlay_position():
                overlay = getattr(self, overlay_key, None)
                if overlay and repeat_btn:
                    try:
                        # Get button position relative to its parent widget
                        btn_pos = repeat_btn.pos()
                        btn_size = repeat_btn.size()
                        overlay_size = 12  # Smaller overlay to ensure it stays within button bounds
                        # Calculate position relative to button's parent, centered on button
                        x = btn_pos.x() + (btn_size.width() - overlay_size) // 2
                        y = btn_pos.y() + (btn_size.height() - overlay_size) // 2
                        # Ensure overlay stays within button bounds
                        x = max(btn_pos.x(), min(x, btn_pos.x() + btn_size.width() - overlay_size))
                        y = max(btn_pos.y(), min(y, btn_pos.y() + btn_size.height() - overlay_size))
                        overlay.setGeometry(x, y, overlay_size, overlay_size)
                        overlay.show()
                        overlay.raise_()
                    except (RuntimeError, AttributeError):
                        pass  # Button or overlay might have been deleted
            
            # Update position immediately and on button resize
            QTimer.singleShot(0, update_overlay_position)
            # Also update when button is resized (if button has resizeEvent, we'd need to override it)
            # For now, update on a short delay to ensure button is sized
            QTimer.singleShot(100, update_overlay_position)
        else:
            # Ensure overlay is removed for mode 0, mode 1, and mode 2
            overlay = getattr(self, overlay_key, None)
            if overlay:
                overlay.hide()
    
    def toggle_autoplay_on_startup(self):
        """Toggle autoplay on startup setting"""
        self.autoplay_on_startup = not self.autoplay_on_startup
        self.autoplay_on_startup_action.setChecked(self.autoplay_on_startup)
        self.save_settings()
    
    def toggle_autohide_address_bar(self):
        """Toggle autohide address bar"""
        self.autohide_address_bar = not self.autohide_address_bar
        # Update top nav button state and icon color
        # Top nav autohide button removed - functionality moved to mini player autohide toggle
        
        if self.autohide_address_bar:
            # Enable autohide - make address bar overlay
            self.make_address_bar_overlay()
            # Start mouse tracking
            self.address_bar_mouse_tracker.start()
            # Schedule hide after delay
            QTimer.singleShot(600, self.schedule_address_bar_hide)
            # Start failsafe timer
            QTimer.singleShot(600 + self.address_bar_failsafe_delay, self._reset_address_bar_failsafe_timer)
        else:
            # Disable autohide - stop mouse tracking
            self.address_bar_mouse_tracker.stop()
            # Stop failsafe timer
            self.address_bar_failsafe_timer.stop()
            # Hide trigger button
            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
                self.hide_trigger_button(animated=False)
            # Restore to normal layout
            self.restore_address_bar_to_layout()
            # Show immediately and cancel any hide timers
            self.cancel_address_bar_hide()
            self.show_address_bar_immediate()
        
        self.save_settings()
        
        # If in mini or micro mode, resize to account for address bar autohide change
        if self.mini_mode_state == 1:
            QTimer.singleShot(100, self.resize_to_mini_mode)
        elif self.mini_mode_state == 2:
            QTimer.singleShot(100, self.resize_to_micro_mode)
    
    def toggle_nano_mode_on_minimize(self):
        """Toggle nano mode on minimize setting"""
        self.nano_mode_on_minimize = not self.nano_mode_on_minimize
        self.save_settings()
    
    def toggle_mini_mode_player_autohide(self):
        """Toggle mini mode player autohide - toggles between Visible and Autohide only"""
        # Fully hidden mode removed
        self.mini_mode_player_hidden = False
        
        # Toggle autohide
        self.mini_mode_player_autohide = not self.mini_mode_player_autohide
        self.mini_mode_player_autohide_action.setChecked(self.mini_mode_player_autohide)
        
        # Update the CSS class on the body element via JavaScript
        if self.web_view and self.web_view.page():
            js_code = f"""
            (function() {{
                if (document.body) {{
                    var isAutohide = {'true' if self.mini_mode_player_autohide else 'false'};
                    if (isAutohide) {{
                        document.body.classList.add('mini-mode-autohide');
                        // Set player to visible when autohide is enabled
                        document.body.classList.remove('mini-mode-player-hidden');
                        
                        // Setup autohide on-demand (user just toggled, DOM should be ready)
                        function setupAutohideOnDemand() {{
                            if (!document.body.classList.contains('mini-mode-autohide')) {{
                                return;
                            }}
                            
                            var player = document.querySelector('#player');
                            if (!player || player.hasAttribute('data-autohide-setup')) {{
                                return;
                            }}
                            
                            // Remove old listeners if they exist
                            var oldEnterHandler = player._bandcampAutohideEnterHandler;
                            var oldLeaveHandler = player._bandcampAutohideLeaveHandler;
                            if (oldEnterHandler) {{
                                player.removeEventListener('mouseenter', oldEnterHandler);
                            }}
                            if (oldLeaveHandler) {{
                                player.removeEventListener('mouseleave', oldLeaveHandler);
                            }}
                            
                            // Create new handlers
                            var enterHandler = function() {{
                                player.classList.add('player-hovered');
                            }};
                            var leaveHandler = function() {{
                                player.classList.remove('player-hovered');
                            }};
                            
                            // Store handlers
                            player._bandcampAutohideEnterHandler = enterHandler;
                            player._bandcampAutohideLeaveHandler = leaveHandler;
                            
                            // Add listeners
                            player.addEventListener('mouseenter', enterHandler);
                            player.addEventListener('mouseleave', leaveHandler);
                            
                            // Mark as set up
                            player.setAttribute('data-autohide-setup', 'true');
                        }}
                        
                        // Set up immediately (user action, DOM should be ready)
                        setupAutohideOnDemand();
                        
                        // Retry if player doesn't exist yet (short retry since user just toggled)
                        var retryCount = 0;
                        var maxRetries = 5;
                        var checkPlayer = function() {{
                            var player = document.querySelector('#player');
                            if (player && !player.hasAttribute('data-autohide-setup')) {{
                                setupAutohideOnDemand();
                            }} else if (!player && retryCount < maxRetries) {{
                                retryCount++;
                                setTimeout(checkPlayer, 100);
                            }}
                        }};
                        setTimeout(checkPlayer, 50);
                        
                        // Watch for player being added dynamically
                        if (typeof MutationObserver !== 'undefined') {{
                            var observer = new MutationObserver(function(mutations) {{
                                var player = document.querySelector('#player');
                                if (player && !player.hasAttribute('data-autohide-setup')) {{
                                    setupAutohideOnDemand();
                                }}
                            }});
                            observer.observe(document.body, {{
                                childList: true,
                                subtree: true
                            }});
                        }}
                    }} else {{
                        document.body.classList.remove('mini-mode-autohide');
                        
                        // Clean up autohide when disabled
                        var player = document.querySelector('#player');
                        if (player) {{
                            player.classList.remove('player-hovered');
                            
                            // Remove event listeners
                            var oldEnterHandler = player._bandcampAutohideEnterHandler;
                            var oldLeaveHandler = player._bandcampAutohideLeaveHandler;
                            if (oldEnterHandler) {{
                                player.removeEventListener('mouseenter', oldEnterHandler);
                                delete player._bandcampAutohideEnterHandler;
                            }}
                            if (oldLeaveHandler) {{
                                player.removeEventListener('mouseleave', oldLeaveHandler);
                                delete player._bandcampAutohideLeaveHandler;
                            }}
                            
                            player.removeAttribute('data-autohide-setup');
                        }}
                    }}
                    
                    // Update button icon to reflect current state
                    var toggleBtn = document.getElementById('bandcamp-player-visibility-toggle');
                    if (toggleBtn) {{
                        var isAutohideState = document.body.classList.contains('mini-mode-autohide');
                        if (isAutohideState) {{
                            toggleBtn.textContent = '';
                        }} else {{
                            toggleBtn.textContent = '';
                        }}
                    }}
                }}
            }})();
            """
            self.run_javascript_safe(js_code)
        
        self.save_settings()
    
    def toggle_mini_mode_player_visibility(self):
        """Deprecated: previously cycled 3 states; now toggles Visible  Autohide."""
        self.toggle_mini_mode_player_autohide()
        
        # Update menu action state
        self.mini_mode_player_autohide_action.setChecked(self.mini_mode_player_autohide)
        
        # Update the CSS class on the body element via JavaScript
        if self.web_view and self.web_view.page():
            js_code = f"""
            (function() {{
                if (document.body) {{
                    // Update autohide class
                    var isAutohide = {'true' if self.mini_mode_player_autohide else 'false'};
                    if (isAutohide) {{
                        document.body.classList.add('mini-mode-autohide');
                        
                        // Setup autohide on-demand (user just toggled, DOM should be ready)
                        function setupAutohideOnDemand() {{
                            if (!document.body.classList.contains('mini-mode-autohide')) {{
                                return;
                            }}
                            
                            var player = document.querySelector('#player');
                            if (!player || player.hasAttribute('data-autohide-setup')) {{
                                return;
                            }}
                            
                            // Remove old listeners if they exist
                            var oldEnterHandler = player._bandcampAutohideEnterHandler;
                            var oldLeaveHandler = player._bandcampAutohideLeaveHandler;
                            if (oldEnterHandler) {{
                                player.removeEventListener('mouseenter', oldEnterHandler);
                            }}
                            if (oldLeaveHandler) {{
                                player.removeEventListener('mouseleave', oldLeaveHandler);
                            }}
                            
                            // Create new handlers
                            var enterHandler = function() {{
                                player.classList.add('player-hovered');
                            }};
                            var leaveHandler = function() {{
                                player.classList.remove('player-hovered');
                            }};
                            
                            // Store handlers
                            player._bandcampAutohideEnterHandler = enterHandler;
                            player._bandcampAutohideLeaveHandler = leaveHandler;
                            
                            // Add listeners
                            player.addEventListener('mouseenter', enterHandler);
                            player.addEventListener('mouseleave', leaveHandler);
                            
                            // Mark as set up
                            player.setAttribute('data-autohide-setup', 'true');
                        }}
                        
                        // Set up immediately (user action, DOM should be ready)
                        setupAutohideOnDemand();
                        
                        // Retry if player doesn't exist yet (short retry since user just toggled)
                        var retryCount = 0;
                        var maxRetries = 5;
                        var checkPlayer = function() {{
                            var player = document.querySelector('#player');
                            if (player && !player.hasAttribute('data-autohide-setup')) {{
                                setupAutohideOnDemand();
                            }} else if (!player && retryCount < maxRetries) {{
                                retryCount++;
                                setTimeout(checkPlayer, 100);
                            }}
                        }};
                        setTimeout(checkPlayer, 50);
                        
                        // Watch for player being added dynamically
                        if (typeof MutationObserver !== 'undefined') {{
                            var observer = new MutationObserver(function(mutations) {{
                                var player = document.querySelector('#player');
                                if (player && !player.hasAttribute('data-autohide-setup')) {{
                                    setupAutohideOnDemand();
                                }}
                            }});
                            observer.observe(document.body, {{
                                childList: true,
                                subtree: true
                            }});
                        }}
                    }} else {{
                        document.body.classList.remove('mini-mode-autohide');
                        
                        // Clean up autohide when disabled
                        var player = document.querySelector('#player');
                        if (player) {{
                            player.classList.remove('player-hovered');
                            
                            // Remove event listeners
                            var oldEnterHandler = player._bandcampAutohideEnterHandler;
                            var oldLeaveHandler = player._bandcampAutohideLeaveHandler;
                            if (oldEnterHandler) {{
                                player.removeEventListener('mouseenter', oldEnterHandler);
                                delete player._bandcampAutohideEnterHandler;
                            }}
                            if (oldLeaveHandler) {{
                                player.removeEventListener('mouseleave', oldLeaveHandler);
                                delete player._bandcampAutohideLeaveHandler;
                            }}
                            
                            player.removeAttribute('data-autohide-setup');
                        }}
                    }}
                    
                    // Hidden mode removed
                    document.body.classList.remove('mini-mode-player-hidden');
                    
                    // Update toggle button icon to reflect current state
                    // Ensure button is visible in mini mode
                    var toggleBtn = document.getElementById('bandcamp-player-visibility-toggle');
                    if (toggleBtn) {{
                        var isAutohideState = document.body.classList.contains('mini-mode-autohide');
                        if (isAutohideState) {{
                            toggleBtn.textContent = '';
                        }} else {{
                            toggleBtn.textContent = '';
                        }}
                        // Ensure button is visible in mini mode (not micro mode)
                        if (document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {{
                            toggleBtn.style.display = 'flex';
                            toggleBtn.style.visibility = 'visible';
                            toggleBtn.style.opacity = '1';
                            toggleBtn.style.pointerEvents = 'auto';
                        }}
                    }}
                }}
            }})();
            """
            self.run_javascript_safe(js_code)
        
        self.save_settings()
    
    def check_address_bar_mouse_position(self):
        """Check if mouse is over trigger button or address bar and keep it visible if so"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Get current global mouse position
        global_pos = QCursor.pos()
        # Convert to window coordinates
        window_pos = self.mapFromGlobal(global_pos)
        
        # Check if mouse is over the trigger button (only way to show hidden address bar)
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
            if self.autohide_trigger_btn.geometry().contains(window_pos):
                # Mouse is over trigger button, show address bar
                self.cancel_address_bar_hide()
                if not self.controls_bar_widget.isVisible():
                    self.show_address_bar_immediate()
                return
        
        # Only check address bar geometry if it's already visible (to keep it visible)
        # Don't show it just because mouse is in that area - only the icon can trigger showing
        if self.controls_bar_widget.isVisible() and self.controls_bar_widget.geometry().contains(window_pos):
            # Mouse is within visible address bar, cancel any hide timer and keep it visible
            self.cancel_address_bar_hide()
    
    def check_and_hide_address_bar_after_menu(self):
        """Check if mouse is outside address bar after menu closes and hide if so"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Get current global mouse position
        global_pos = QCursor.pos()
        # Convert to window coordinates
        window_pos = self.mapFromGlobal(global_pos)
        # Check if mouse is within address bar geometry
        if not self.controls_bar_widget.geometry().contains(window_pos):
            # Mouse is outside address bar, schedule hide
            self.schedule_address_bar_hide()
    
    def check_and_hide_address_bar_after_drag(self):
        """Check if mouse is outside address bar after drag ends and hide if so"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Don't hide if we're still dragging
        if hasattr(self, 'playlist_start_resize_y') and self.playlist_start_resize_y is not None:
            return
        
        # Get current global mouse position
        global_pos = QCursor.pos()
        # Convert to window coordinates
        window_pos = self.mapFromGlobal(global_pos)
        # Check if mouse is within address bar geometry
        if not self.controls_bar_widget.geometry().contains(window_pos):
            # Also check if mouse is over the trigger icon
            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
                if not self.autohide_trigger_btn.geometry().contains(window_pos):
                    # Mouse is outside both address bar and trigger icon, schedule hide
                    self.schedule_address_bar_hide()
            else:
                # Mouse is outside address bar and no trigger icon visible, schedule hide
                self.schedule_address_bar_hide()
    
    def make_address_bar_overlay(self):
        """Make address bar overlay the content (semi-transparent, absolute positioning)"""
        if not hasattr(self, 'controls_bar_widget') or not self.controls_bar_widget:
            return
        
        # Store original style if not already stored
        if self.controls_bar_original_style is None:
            self.controls_bar_original_style = self.controls_bar_widget.styleSheet()
        
        # Remove from layout if it's in layout
        if self.controls_bar_in_layout:
            layout = self.centralWidget().layout()
            if layout:
                layout.removeWidget(self.controls_bar_widget)
            self.controls_bar_in_layout = False
        
        # Make it overlay with semi-transparent background
        self.controls_bar_widget.setParent(self)
        self.controls_bar_widget.setStyleSheet("""
            QWidget {
                background-color: rgba(21, 21, 21, 0.85);
                border: none;
            }
            QLineEdit {
                background-color: rgba(43, 43, 43, 0.9);
            }
            QPushButton {
                background-color: transparent;
            }
            QPushButton:hover {
                background-color: rgba(58, 58, 58, 0.8);
            }
        """)
        
        # Position absolutely at top
        self.update_address_bar_overlay_position()
        
        # Raise above web view
        self.controls_bar_widget.raise_()
        self.controls_bar_widget.show()
    
    def restore_address_bar_to_layout(self):
        """Restore address bar to normal layout (not overlay)"""
        if not hasattr(self, 'controls_bar_widget') or not self.controls_bar_widget:
            return
        
        # Add back to layout if not already there
        if not self.controls_bar_in_layout:
            # Get the central widget layout
            layout = self.centralWidget().layout()
            if layout:
                # Remove from window parent first (if it's a child of the window)
                if self.controls_bar_widget.parent() == self:
                    self.controls_bar_widget.setParent(None)
                
                # Find the correct position (after title bar if it exists, otherwise at position 0)
                insert_position = 0
                if self.title_bar and self.title_bar.isVisible():
                    # Find title bar index
                    for i in range(layout.count()):
                        item = layout.itemAt(i)
                        if item and item.widget() == self.title_bar:
                            insert_position = i + 1
                            break
                
                # Insert at correct position
                layout.insertWidget(insert_position, self.controls_bar_widget, 0)
            else:
                # If no layout, set parent to central widget
                self.controls_bar_widget.setParent(self.centralWidget())
            
            self.controls_bar_in_layout = True
        
        # Restore original style
        if self.controls_bar_original_style:
            self.controls_bar_widget.setStyleSheet(self.controls_bar_original_style)
        else:
            self.controls_bar_widget.setStyleSheet("")
        
        # Ensure it's visible and properly positioned (not absolutely positioned)
        self.controls_bar_widget.show()
        # Don't call raise_() here as it's in the layout now, not an overlay
    
    def update_address_bar_overlay_position(self):
        """Update address bar overlay position"""
        if not hasattr(self, 'controls_bar_widget') or not self.controls_bar_widget:
            return
        
        if not self.autohide_address_bar or self.controls_bar_in_layout:
            return
        
        # Calculate top offset (title bar if visible)
        top_offset = 0
        if self.title_bar and self.title_bar.isVisible():
            top_offset = self.title_bar.height()
        
        # Get controls bar height
        controls_bar_height = self.controls_bar_widget.sizeHint().height()
        if controls_bar_height <= 0:
            controls_bar_height = 40  # Default height
        
        # Position absolutely at top
        self.controls_bar_widget.setGeometry(0, top_offset, self.width(), controls_bar_height)
        self.controls_bar_widget.raise_()
    
    def update_image_viewer_btn_visibility(self):
        """Update image viewer button visibility - hide in micro mode, show in regular and mini modes.
        Hides immediately for quick response, shows with slight delay to avoid layout interference."""
        if not hasattr(self, 'image_viewer_btn') or not self.image_viewer_btn:
            return
        
        try:
            # Hide in micro mode (mini_mode_state == 2), show in regular (0) and mini (1) modes
            if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 2:
                # Hide immediately for quick response
                self.image_viewer_btn.hide()
            else:
                # Show with slight delay to avoid layout interference
                QTimer.singleShot(10, lambda: self.image_viewer_btn.show() if hasattr(self, 'image_viewer_btn') and self.image_viewer_btn else None)
        except RuntimeError:
            # Widget has been deleted, ignore
            pass
    
    def update_image_viewer_btn_position(self):
        """Update image viewer button position (top left, below titlebar and controls bar if visible).
        Uses minimal layout interference - only updates geometry, no raise() calls that might affect mini mode."""
        if not hasattr(self, 'image_viewer_btn') or not self.image_viewer_btn:
            return
        
        try:
            # Calculate top offset (title bar if visible)
            top_offset = 0
            if self.title_bar and self.title_bar.isVisible():
                top_offset = self.title_bar.height()
            
            # If controls bar is visible and in layout (not overlay mode), add its height
            # In mini/micro mode with autohide, controls bar is hidden so we don't account for it
            if (hasattr(self, 'controls_bar_widget') and self.controls_bar_widget and 
                self.controls_bar_widget.isVisible() and
                hasattr(self, 'controls_bar_in_layout') and self.controls_bar_in_layout):
                # Only add height if controls bar is actually in the layout (not overlay)
                controls_bar_height = self.controls_bar_widget.height()
                if controls_bar_height > 0:
                    top_offset += controls_bar_height
            
            button_size = 24
            y_pos = top_offset + 3  # Small offset from top
            x_pos = 5  # Small margin from left edge
            
            # Use setGeometry directly - this is safe and doesn't trigger layout recalculations
            self.image_viewer_btn.setGeometry(x_pos, y_pos, button_size, button_size)
        except RuntimeError:
            # Widget has been deleted, ignore
            pass
    
    def update_autohide_trigger_position(self):
        """Update autohide trigger button position (always top right in all modes)"""
        if not hasattr(self, 'autohide_trigger_btn') or not self.autohide_trigger_btn:
            return
        
        if not self.autohide_address_bar:
            return
        
        # Calculate top offset (title bar if visible)
        top_offset = 0
        if self.title_bar and self.title_bar.isVisible():
            top_offset = self.title_bar.height()
        
        button_size = 24
        y_pos = top_offset + 3  # Small offset from top
        
        # Always position at top right in all modes
        x_pos = self.width() - button_size - 5  # Small margin from right edge
        
        self.autohide_trigger_btn.setGeometry(x_pos, y_pos, button_size, button_size)
        self.autohide_trigger_btn.raise_()

    def update_playlist_quick_btn_position(self):
        """Update playlist quick button position (bottom right)."""
        if not hasattr(self, 'playlist_quick_btn') or not self.playlist_quick_btn:
            return

        button_size = 24
        x_pos = self.width() - button_size - 5

        # Avoid overlapping the bottom resize handle if present/visible
        bottom_offset = 0
        try:
            if self.frameless_mode and hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle and self.bottom_resize_handle.isVisible():
                bottom_offset = self.bottom_resize_handle.height()
        except Exception:
            bottom_offset = 0

        y_pos = self.height() - button_size - 5 - bottom_offset
        if y_pos < 0:
            y_pos = 0

        self.playlist_quick_btn.setGeometry(x_pos, y_pos, button_size, button_size)
        self.playlist_quick_btn.raise_()

    def update_playlist_quick_btn_visibility(self):
        """Show/hide the bottom-right playlist quick button based on current app state (safe)."""
        if not hasattr(self, 'playlist_quick_btn') or not self.playlist_quick_btn:
            return

        try:
            # Only in regular mode
            if getattr(self, 'mini_mode_state', 0) != 0:
                self.playlist_quick_btn.hide()
                return

            # Only when playlist is attached (not detached)
            if getattr(self, 'playlist_detached', False):
                self.playlist_quick_btn.hide()
                return

            # Show only when playlist is closed/hidden
            playlist_closed = True
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                playlist_closed = not self.playlist_sidebar.isVisible()

            if playlist_closed:
                self.update_playlist_quick_btn_position()
                self.playlist_quick_btn.show()
                self.playlist_quick_btn.raise_()
            else:
                self.playlist_quick_btn.hide()
        except Exception:
            # Never crash the app due to a helper UI button
            try:
                self.playlist_quick_btn.hide()
            except Exception:
                pass

    def _on_playlist_quick_btn_clicked(self):
        """Open the attached playlist from the bottom-right quick button (safe)."""
        try:
            # Hide immediately to avoid flashing above the opening playlist
            if hasattr(self, 'playlist_quick_btn') and self.playlist_quick_btn:
                self.playlist_quick_btn.hide()

            if getattr(self, 'mini_mode_state', 0) != 0:
                return
            if getattr(self, 'playlist_detached', False):
                return

            # Ensure first click works even when playlist is lazy-created and restore is pending.
            if hasattr(self, 'playlist_btn') and self.playlist_btn:
                self.playlist_btn.setChecked(True)
                self._update_playlist_button_icon(True)
            if hasattr(self, 'show_playlist_action') and self.show_playlist_action:
                self.show_playlist_action.setChecked(True)

            # Only open if currently closed
            if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar or (not self.playlist_sidebar.isVisible()):
                self.toggle_playlist()

            # Recompute visibility after state changes
            self.update_playlist_quick_btn_visibility()
        except Exception:
            pass
    
    def show_trigger_button(self, animated=True):
        """Show trigger button with fade in animation"""
        if not hasattr(self, 'autohide_trigger_btn') or not self.autohide_trigger_btn:
            return
        
        # Check if widget is still valid (not deleted)
        try:
            # Try to access widget properties to verify it's still valid
            _ = self.autohide_trigger_btn.isVisible()
        except RuntimeError:
            # Widget has been deleted - can't show it
            logger.debug("Trigger button widget has been deleted, skipping show")
            return
        
        
        self.update_autohide_trigger_position()
        
        # Stop any existing animation and clean up any existing effect
        if self.trigger_btn_animation:
            try:
                self.trigger_btn_animation.stop()
            except RuntimeError:
                pass  # Animation or effect already deleted
            self.trigger_btn_animation = None
        
        # Clean up any existing graphics effect
        try:
            existing_effect = self.autohide_trigger_btn.graphicsEffect()
            if existing_effect:
                self.autohide_trigger_btn.setGraphicsEffect(None)
        except RuntimeError:
            pass  # Widget or effect already deleted
        
        if animated:
            try:
                # Verify widget is still valid before creating effect
                if not self.autohide_trigger_btn:
                    return
                
                # Create fade in animation with fresh effect
                effect = QGraphicsOpacityEffect(self.autohide_trigger_btn)
                # Store effect reference to prevent garbage collection
                self._trigger_btn_effect = effect
                self.autohide_trigger_btn.setGraphicsEffect(effect)
                effect.setOpacity(0.0)
                
                # Verify effect is still valid before creating animation
                if not effect or not self.autohide_trigger_btn:
                    return
                
                self.autohide_trigger_btn.show()
                self.autohide_trigger_btn.raise_()
                
                # Create animation with effect - verify effect is still valid
                try:
                    self.trigger_btn_animation = QPropertyAnimation(effect, b"opacity")
                    self.trigger_btn_animation.setDuration(250)  # Same duration as address bar fade
                    self.trigger_btn_animation.setStartValue(0.0)
                    self.trigger_btn_animation.setEndValue(1.0)
                    self.trigger_btn_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)
                    
                    def on_animation_finished():
                        try:
                            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
                                self.autohide_trigger_btn.setGraphicsEffect(None)
                            if hasattr(self, '_trigger_btn_effect'):
                                self._trigger_btn_effect = None
                        except RuntimeError:
                            pass  # Widget already deleted
                        self.trigger_btn_animation = None
                    
                    self.trigger_btn_animation.finished.connect(on_animation_finished)
                    self.trigger_btn_animation.start()
                except RuntimeError as anim_error:
                    # Effect was deleted before animation could be created
                    logger.debug(f"Error creating trigger button animation: {anim_error}, falling back to non-animated")
                    try:
                        self.autohide_trigger_btn.setGraphicsEffect(None)
                        self._trigger_btn_effect = None
                        self.autohide_trigger_btn.show()
                        self.autohide_trigger_btn.raise_()
                    except RuntimeError:
                        pass  # Widget already deleted
            except RuntimeError as e:
                # Widget or effect was deleted during setup - fall back to non-animated show
                logger.debug(f"Error creating trigger button animation: {e}, falling back to non-animated")
                try:
                    if hasattr(self, '_trigger_btn_effect'):
                        self._trigger_btn_effect = None
                    if self.autohide_trigger_btn:
                        self.autohide_trigger_btn.show()
                        self.autohide_trigger_btn.raise_()
                        self.autohide_trigger_btn.setGraphicsEffect(None)
                except RuntimeError:
                    pass  # Widget already deleted
        else:
            # Show immediately without animation
            try:
                self.autohide_trigger_btn.show()
                self.autohide_trigger_btn.raise_()
                self.autohide_trigger_btn.setGraphicsEffect(None)
            except RuntimeError:
                pass  # Widget already deleted
    
    def hide_trigger_button(self, animated=True):
        """Hide trigger button with fade out animation"""
        if not hasattr(self, 'autohide_trigger_btn') or not self.autohide_trigger_btn:
            return
        
        # Check if widget is still valid (not deleted)
        try:
            is_visible = self.autohide_trigger_btn.isVisible()
        except RuntimeError:
            # Widget has been deleted - can't hide it
            logger.debug("Trigger button widget has been deleted, skipping hide")
            return
        
        # Stop any existing animation and clean up any existing effect
        if self.trigger_btn_animation:
            try:
                self.trigger_btn_animation.stop()
            except RuntimeError:
                pass  # Animation or effect already deleted
            self.trigger_btn_animation = None
        
        # Clean up any existing graphics effect
        try:
            existing_effect = self.autohide_trigger_btn.graphicsEffect()
            if existing_effect:
                self.autohide_trigger_btn.setGraphicsEffect(None)
        except RuntimeError:
            pass  # Widget or effect already deleted
        
        if animated and is_visible:
            try:
                # Verify widget is still valid before creating effect
                if not self.autohide_trigger_btn:
                    return
                
                # Create fade out animation with fresh effect
                effect = QGraphicsOpacityEffect(self.autohide_trigger_btn)
                # Store effect reference to prevent garbage collection
                self._trigger_btn_effect = effect
                self.autohide_trigger_btn.setGraphicsEffect(effect)
                effect.setOpacity(1.0)
                
                # Verify effect is still valid before creating animation
                if not effect or not self.autohide_trigger_btn:
                    return
                
                # Create animation with effect - verify effect is still valid
                try:
                    self.trigger_btn_animation = QPropertyAnimation(effect, b"opacity")
                    self.trigger_btn_animation.setDuration(250)  # Same duration as address bar fade
                    self.trigger_btn_animation.setStartValue(1.0)
                    self.trigger_btn_animation.setEndValue(0.0)
                    self.trigger_btn_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)
                    
                    def on_animation_finished():
                        try:
                            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
                                self.autohide_trigger_btn.hide()
                                self.autohide_trigger_btn.setGraphicsEffect(None)
                            if hasattr(self, '_trigger_btn_effect'):
                                self._trigger_btn_effect = None
                        except RuntimeError:
                            pass  # Widget already deleted
                        self.trigger_btn_animation = None
                    
                    self.trigger_btn_animation.finished.connect(on_animation_finished)
                    self.trigger_btn_animation.start()
                except RuntimeError as anim_error:
                    # Effect was deleted before animation could be created
                    logger.debug(f"Error creating trigger button hide animation: {anim_error}, falling back to non-animated")
                    try:
                        self.autohide_trigger_btn.setGraphicsEffect(None)
                        self._trigger_btn_effect = None
                        self.autohide_trigger_btn.hide()
                    except RuntimeError:
                        pass  # Widget already deleted
            except RuntimeError as e:
                # Widget or effect was deleted during setup - fall back to non-animated hide
                logger.debug(f"Error creating trigger button hide animation: {e}, falling back to non-animated")
                try:
                    if hasattr(self, '_trigger_btn_effect'):
                        self._trigger_btn_effect = None
                    if self.autohide_trigger_btn:
                        self.autohide_trigger_btn.hide()
                        self.autohide_trigger_btn.setGraphicsEffect(None)
                except RuntimeError:
                    pass  # Widget already deleted
        else:
            # Hide immediately without animation
            try:
                self.autohide_trigger_btn.hide()
                self.autohide_trigger_btn.setGraphicsEffect(None)
            except RuntimeError:
                pass  # Widget already deleted
    
    def run_javascript_safe(self, code, callback=None):
        """Safely execute JavaScript code with error handling.
        
        Args:
            code: JavaScript code string to execute
            callback: Optional callback function for result
            
        Returns:
            bool: True if JavaScript was executed, False otherwise
        """
        if not self.web_view or not self.web_view.page():
            logger.debug("Cannot run JavaScript: webview not ready")
            if callback:
                try:
                    callback(None)
                except Exception:
                    pass
            return False
        
        try:
            # Only pass callback if it's not None (PyQt6 doesn't accept None for callback)
            if callback is not None:
                self.web_view.page().runJavaScript(code, callback)
            else:
                self.web_view.page().runJavaScript(code)
            return True
        except (AttributeError, RuntimeError) as e:
            logger.debug(f"JavaScript execution failed: {e}")
            if callback:
                try:
                    callback(None)
                except Exception:
                    pass
            return False
    
    def setup_webengine_storage(self):
        """Setup persistent storage for WebEngine (enables dev tools settings persistence)"""
        # Use a named profile instead of default for better persistence
        # Named profiles have more reliable persistent storage for DevTools
        storage_path = Path(__file__).parent / "webengine_storage"
        storage_path.mkdir(exist_ok=True)
        
        # Create a named persistent profile (better for DevTools settings)
        profile_name = "BandcampPlayerProfile"
        try:
            # Try to get existing named profile or create new one
            profile = QWebEngineProfile(profile_name)
        except Exception as e:
            # Fallback to default profile if named profile creation fails
            logger.warning(f"Could not create named profile, using default: {e}")
            profile = QWebEngineProfile.defaultProfile()
        
        # Set persistent storage path (for cookies, localStorage, IndexedDB, dev tools settings, etc.)
        # Must be set before creating any pages
        profile.setPersistentStoragePath(str(storage_path))
        profile.setCachePath(str(storage_path / "cache"))
        
        # Force persistent cookies (ensures storage is actually used)
        # This is more aggressive than AllowPersistentCookies
        profile.setPersistentCookiesPolicy(QWebEngineProfile.PersistentCookiesPolicy.ForcePersistentCookies)
        
        # Store profile reference for dev tools
        self.webengine_profile = profile
    
    def _debounced_setup_button_interception(self):
        """Debounced version of button interception setup to avoid multiple rapid calls"""
        if not hasattr(self, '_button_interception_timer'):
            self._button_interception_timer = QTimer(self)
            self._button_interception_timer.setSingleShot(True)
            self._button_interception_timer.timeout.connect(self._setup_next_prev_button_interception)
        
        # Stop existing timer and restart with delay (debounce)
        self._button_interception_timer.stop()
        self._button_interception_timer.start(200)  # 200ms debounce delay
    
    def setup_web_view(self):
        """Setup the web engine view with mobile user agent"""
        self.web_view = QWebEngineView()
        
        # Note: Scrollbar hiding code removed - webview is hidden when using Qt widgets,
        # so scrollbar styling is handled via CSS injection instead
        
        # Enable drag and drop on web view
        self.web_view.setAcceptDrops(True)
        
        # Override drag/drop handlers to catch URL drops
        def web_view_drag_enter(event):
            # Only accept if it's a URL or text (not web content)
            if event.mimeData().hasUrls() or event.mimeData().hasText():
                event.acceptProposedAction()
            else:
                event.ignore()
        
        def web_view_drop(event):
            # Handle URL drops (only first URL - player can only handle one at a time)
            url = None
            if event.mimeData().hasUrls():
                urls = event.mimeData().urls()
                if urls:
                    url = urls[0].toString()
            elif event.mimeData().hasText():
                # Get text and take first URL only
                text = event.mimeData().text().strip()
                if text:
                    # Split by newlines and take first line
                    lines = [line.strip() for line in text.split('\n') if line.strip()]
                    if lines:
                        url = lines[0]
            
            if url:
                self._handle_global_drop(url)
                event.acceptProposedAction()
            else:
                event.ignore()
        
        self.web_view.dragEnterEvent = web_view_drag_enter
        self.web_view.dropEvent = web_view_drop
        
        # Initially hide the web view (it's hidden when using Qt widgets)
        # Minimal stylesheet - scrollbar hiding is handled via CSS injection
        self.web_view.setStyleSheet("""
            QWebEngineView {
                background-color: #212121;
            }
        """)
        self.web_view.hide()
        # Make webview transparent to mouse events when hidden (so it doesn't block clicks on cover art)
        self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        # Lower webview to ensure it doesn't block clicks (will be raised when shown)
        self.web_view.lower()
        
        # Custom context menu with native Inspect action for proper functionality
        def context_menu_event(position):
            """Custom context menu with proper dark theme styling and native Inspect action"""
            # Disable right-click during loading to prevent crashes
            if self.is_loading:
                return
            
            menu = QMenu(self)
            
            # Apply dark theme styling to context menu
            menu.setStyleSheet("""
                QMenu {
                    background-color: #2b2b2b;
                    border: 1px solid #3a3a3a;
                    color: #e0e0e0;
                    padding: 4px;
                }
                QMenu::item {
                    background-color: transparent;
                    padding: 6px 20px 6px 30px;
                    color: #e0e0e0;
                }
                QMenu::item:selected {
                    background-color: #3a3a3a;
                    color: #ffffff;
                }
                QMenu::item:disabled {
                    color: #666666;
                }
                QMenu::separator {
                    height: 1px;
                    background-color: #3a3a3a;
                    margin: 4px 0px;
                }
            """)
            
            # Get page actions
            page = self.web_view.page()
            
            # Navigation actions
            back_action = page.action(QWebEnginePage.WebAction.Back)
            if back_action and back_action.isEnabled():
                # Add icon to back action
                if HAS_QT_AWESOME:
                    icon = get_icon('ei.arrow-left', color='#e0e0e0')
                    if icon:
                        back_action.setIcon(icon)
                menu.addAction(back_action)
            
            forward_action = page.action(QWebEnginePage.WebAction.Forward)
            if forward_action and forward_action.isEnabled():
                # Add icon to forward action
                if HAS_QT_AWESOME:
                    icon = get_icon('ei.arrow-right', color='#e0e0e0')
                    if icon:
                        forward_action.setIcon(icon)
                menu.addAction(forward_action)
            
            # Reload action with custom icon
            reload_action = page.action(QWebEnginePage.WebAction.Reload)
            if reload_action:
                # Try to add icon to reload action
                if HAS_QT_AWESOME:
                    icon = get_icon('mdi.reload', color='#e0e0e0')
                    if not icon:
                        icon = get_icon('mdi6.reload', color='#e0e0e0')
                    if icon:
                        reload_action.setIcon(icon)
                menu.addAction(reload_action)
            
            menu.addSeparator()
            
            # Copy action
            copy_action = page.action(QWebEnginePage.WebAction.Copy)
            if copy_action and copy_action.isEnabled():
                menu.addAction(copy_action)
            
            # Paste URL action - uses the same handler as the paste URL button
            paste_url_action = QAction("Paste URL", self)
            if HAS_QT_AWESOME:
                icon = get_icon('paste', color='#e0e0e0')
                if icon:
                    paste_url_action.setIcon(icon)
            else:
                paste_url_action.setText(" Paste URL")
            paste_url_action.triggered.connect(self.on_paste_url)
            menu.addAction(paste_url_action)
            
            menu.addSeparator()
            
            # Get current page URL for "Open in Browser" and "Copy URL"
            current_url = self.web_view.url().toString() if self.web_view else None
            if current_url and current_url != "about:blank":
                # Open in Browser
                open_browser_action = QAction("Open in Browser", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('external-link-alt', color='#e0e0e0')
                    if icon:
                        open_browser_action.setIcon(icon)
                else:
                    open_browser_action.setText(" Open in Browser")
                open_browser_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl(current_url)))
                menu.addAction(open_browser_action)
                
                # Copy URL
                copy_url_action = QAction("Copy URL", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('copy', color='#e0e0e0')
                    if icon:
                        copy_url_action.setIcon(icon)
                else:
                    copy_url_action.setText(" Copy URL")
                def copy_url_with_feedback():
                    QApplication.clipboard().setText(current_url)
                    global_pos = self.web_view.mapToGlobal(self.web_view.rect().center())
                    QToolTip.showText(global_pos, "URL copied", self.web_view, QRect(), 1500)
                copy_url_action.triggered.connect(copy_url_with_feedback)
                menu.addAction(copy_url_action)
                
                menu.addSeparator()
            
            # Add Inspect Element action - always available, opens dev tools if needed
            menu.addSeparator()
            # Try to use native InspectElement action if dev tools is already open
            if self.dev_tools_window and self.dev_tools_window.isVisible():
                try:
                    native_inspect_action = page.action(QWebEnginePage.WebAction.InspectElement)
                    if native_inspect_action:
                        # Add icon to native inspect action
                        if HAS_QT_AWESOME:
                            icon = get_icon('fa6s.magnifying-glass', color='#e0e0e0')
                            if icon:
                                native_inspect_action.setIcon(icon)
                        menu.addAction(native_inspect_action)
                    else:
                        # Fallback to custom inspect
                        inspect_action = QAction("Inspect", self)
                        if HAS_QT_AWESOME:
                            icon = get_icon('fa6s.magnifying-glass', color='#e0e0e0')
                            if icon:
                                inspect_action.setIcon(icon)
                        inspect_action.triggered.connect(lambda: self._trigger_inspect_at_position(position))
                        menu.addAction(inspect_action)
                except AttributeError:
                    # InspectElement might not be available in all PyQt6 versions
                    inspect_action = QAction("Inspect", self)
                    if HAS_QT_AWESOME:
                        icon = get_icon('fa6s.magnifying-glass', color='#e0e0e0')
                        if icon:
                            inspect_action.setIcon(icon)
                    inspect_action.triggered.connect(lambda: self._trigger_inspect_at_position(position))
                    menu.addAction(inspect_action)
            else:
                # Dev tools not open - use custom action that opens dev tools first
                inspect_action = QAction("Inspect", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('fa6s.magnifying-glass', color='#e0e0e0')
                    if icon:
                        inspect_action.setIcon(icon)
                def handle_inspect():
                    # Store position for inspection
                    self.inspect_position = position
                    # Open dev tools if not already open
                    if not self.dev_tools_window or not self.dev_tools_window.isVisible():
                        self.toggle_dev_tools()
                        # Wait a bit for dev tools to open, then trigger inspect
                        QTimer.singleShot(500, lambda: self._trigger_inspect_at_position(position))
                    else:
                        # Dev tools already open, trigger inspect immediately
                        self._trigger_inspect_at_position(position)
                inspect_action.triggered.connect(handle_inspect)
                menu.addAction(inspect_action)
            
            menu.addSeparator()
            
            # Close Menu
            close_menu_action = QAction("Close Menu", self)
            if HAS_QT_AWESOME:
                icon = get_icon('times', color='#e0e0e0')
                if icon:
                    close_menu_action.setIcon(icon)
            else:
                close_menu_action.setText(" Close Menu")
            close_menu_action.triggered.connect(lambda: menu.close())
            menu.addAction(close_menu_action)
            
            # Show menu at cursor position (convert local position to global)
            global_pos = self.web_view.mapToGlobal(position)
            menu.exec(global_pos)
        
        self.web_view.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.web_view.customContextMenuRequested.connect(context_menu_event)
        
        # Set mobile user agent to get mobile Bandcamp view
        mobile_user_agent = (
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) "
            "AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
        )
        self.web_view.page().profile().setHttpUserAgent(mobile_user_agent)
        
        # Configure web engine settings to allow autoplay
        settings = self.web_view.page().settings()
        # Disable autoplay restrictions - this allows programmatic playback
        try:
            settings.setAttribute(QWebEngineSettings.WebAttribute.PlaybackRequiresUserGesture, False)
            logger.debug("Disabled PlaybackRequiresUserGesture - autoplay should now work!")
        except Exception as e:
            logger.warning(f"Could not disable autoplay restriction: {e}", exc_info=True)
        
        # Set default zoom to 75%
        self.web_view.setZoomFactor(0.75)
        
        # Show loading overlay when page starts loading
        self.web_view.page().loadStarted.connect(self.on_page_load_started)
        
        # Show page progressively as it loads (at 30% progress)
        self.web_view.page().loadProgress.connect(self.on_page_load_progress)
        
        # Inject CSS when page loads
        self.web_view.page().loadFinished.connect(self.on_page_loaded)
        
        
        # Add to layout
        layout = self.centralWidget().layout()
        # Set size policy to prevent centering - web view should expand but not cause centering
        self.web_view.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        # Insert before playlist with stretch factor 1 (takes available space)
        layout.insertWidget(1, self.web_view, 1)
        
        # Create animated loading overlay widget as a true overlay
        # Make it a child of the main window, NOT in the layout, positioned absolutely
        self.loading_overlay = AnimatedLoadingOverlay(self)
        self.loading_overlay.hide()
        # Initialize geometry to zero to prevent dark block on startup
        self.loading_overlay.setGeometry(0, 0, 0, 0)
        # Don't update geometry when overlay is hidden - it will be updated when shown
        # Position it to cover entire web view area (playlist will sit on top)
        # Geometry will be updated when overlay is shown (when is_loading is True)
        # Note: We don't use WA_AlwaysStackOnTop here so playlist can be raised above overlay
        # The overlay will still cover the web view, but playlist container can sit on top
    
    def setup_menu(self):
        """Setup the context menu"""
        self.menu = QMenu(self)
        
        # Apply dark theme styling to match the rest of the app
        self.menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #4a90e2;
                border-top: 1px solid #4a90e2;
                border-right: 1px solid #4a90e2;
                border-bottom: 1px solid #4a90e2;
                border-left: 1px solid #4a90e2;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        
        # Version info at top (non-clickable, styled)
        version_string = self._get_version_string()
        # Use QWidgetAction to create a styled label (QAction doesn't support setStyleSheet)
        version_label = QLabel(version_string)
        version_label.setStyleSheet("""
            QLabel {
                color: #4a90e2;
                padding: 6px 20px;
                background-color: transparent;
            }
        """)
        version_label.setEnabled(False)  # Non-clickable
        version_action = QWidgetAction(self)
        version_action.setDefaultWidget(version_label)
        self.menu.addAction(version_action)
        
        # Separator
        self.menu.addSeparator()
        
        # Check for Updates
        check_updates_action = QAction("Check for Updates...", self)
        check_updates_action.triggered.connect(self.check_for_updates)
        self.menu.addAction(check_updates_action)
        
        # Auto-check for updates (checkbox)
        self.auto_check_updates_action = QAction("Automatically Check for Updates", self)
        self.auto_check_updates_action.setCheckable(True)
        self.auto_check_updates_action.setChecked(self.settings.get("auto_check_updates", True))
        self.auto_check_updates_action.triggered.connect(self.on_auto_check_updates_change)
        self.menu.addAction(self.auto_check_updates_action)
        
        # Separator
        self.menu.addSeparator()
        
        # View mode
        # Developer options (hidden by default, shown when dev tools is open)
        self.bandcamp_action = QAction("Bandcamp Mode", self)
        self.bandcamp_action.setCheckable(True)
        self.bandcamp_action.setChecked(self.bandcamp_mode)
        self.bandcamp_action.triggered.connect(self.toggle_bandcamp_mode)
        self.menu.addAction(self.bandcamp_action)
        self.bandcamp_action.setVisible(False)  # Hidden by default
        
        self.compact_action = QAction("Compact Mode", self)
        self.compact_action.setCheckable(True)
        self.compact_action.setChecked(self.compact_mode)
        self.compact_action.triggered.connect(self.toggle_compact_mode)
        self.menu.addAction(self.compact_action)
        self.compact_action.setVisible(False)  # Hidden by default
        
        self.menu.addSeparator()
        
        # Frameless window (hidden by default, shown when dev tools is open)
        self.frameless_action = QAction("Frameless Window", self)
        self.frameless_action.setCheckable(True)
        self.frameless_action.setChecked(self.frameless_mode)
        self.frameless_action.triggered.connect(self.toggle_frameless_mode)
        self.menu.addAction(self.frameless_action)
        self.frameless_action.setVisible(False)  # Hidden by default
        
        self.menu.addSeparator()
        
        # Autoplay
        self.autoplay_action = QAction("Autoplay", self)
        self.autoplay_action.setCheckable(True)
        self.autoplay_action.setChecked(self.autoplay)
        self.autoplay_action.triggered.connect(self.toggle_autoplay)
        self.menu.addAction(self.autoplay_action)
        
        # Autoplay on Startup (independent of regular autoplay)
        self.autoplay_on_startup_action = QAction("Autoplay on Startup", self)
        self.autoplay_on_startup_action.setCheckable(True)
        self.autoplay_on_startup_action.setChecked(self.autoplay_on_startup)
        self.autoplay_on_startup_action.triggered.connect(self.toggle_autoplay_on_startup)
        self.menu.addAction(self.autoplay_on_startup_action)
        
        # Transparent Loading Overlay (hidden by default, shown when dev tools is open)
        self.transparent_overlay_action = QAction("Transparent Loading Overlay", self)
        self.transparent_overlay_action.setCheckable(True)
        self.transparent_overlay_action.setChecked(self.transparent_overlay)
        self.transparent_overlay_action.triggered.connect(self.toggle_transparent_overlay)
        self.menu.addAction(self.transparent_overlay_action)
        self.transparent_overlay_action.setVisible(False)  # Hidden by default
        
        self.menu.addSeparator()
        
        # Keyboard Shortcuts
        keyboard_shortcuts_action = QAction("Keyboard Shortcuts...", self)
        keyboard_shortcuts_action.triggered.connect(self.show_keyboard_shortcuts_dialog)
        self.menu.addAction(keyboard_shortcuts_action)
        
        self.menu.addSeparator()
        
        # About
        about_action = QAction("About", self)
        about_action.triggered.connect(self._show_about_dialog)
        self.menu.addAction(about_action)
        
        # GitHub Repository
        github_action = QAction("GitHub Repository", self)
        github_action.triggered.connect(lambda: webbrowser.open("https://github.com/kameryn1811/Bandcamp-Player"))
        self.menu.addAction(github_action)
        
        # Report Issue
        report_issue_action = QAction("Report Issue", self)
        report_issue_action.triggered.connect(lambda: webbrowser.open("https://github.com/kameryn1811/Bandcamp-Player/issues"))
        self.menu.addAction(report_issue_action)
        
        self.menu.addSeparator()
        
        # Developer Tools
        dev_tools_action = QAction("Developer Tools", self)
        dev_tools_action.setShortcut(QKeySequence("F12"))
        dev_tools_action.triggered.connect(self.toggle_dev_tools)
        self.menu.addAction(dev_tools_action)
        
        self.menu.addSeparator()
        
        # Quit
        quit_action = QAction("Quit", self)
        quit_action.triggered.connect(self.close)
        self.menu.addAction(quit_action)
    
    def open_image_viewer(self):
        """Open image viewer from top nav button - calls current player widget's method."""
        # Find the currently visible player widget
        current_widget = None
        if hasattr(self, 'regular_player_widget') and self.regular_player_widget and self.regular_player_widget.isVisible():
            current_widget = self.regular_player_widget
        elif hasattr(self, 'mini_player_widget') and self.mini_player_widget and self.mini_player_widget.isVisible():
            current_widget = self.mini_player_widget
        elif hasattr(self, 'micro_player_widget') and self.micro_player_widget and self.micro_player_widget.isVisible():
            current_widget = self.micro_player_widget
        
        if current_widget and hasattr(current_widget, '_on_cover_art_clicked'):
            current_widget._on_cover_art_clicked()
        else:
            logger.debug("Image viewer: No visible player widget found")
    
    def setup_tray(self):
        """Setup system tray icon"""
        if not QSystemTrayIcon.isSystemTrayAvailable():
            return
        
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setToolTip("Bandcamp Player")
        
        # Set icon if available
        if self.app_icon:
            self.tray_icon.setIcon(self.app_icon)
        
        # Create tray menu
        tray_menu = QMenu(self)
        # Apply dark theme styling to match the rest of the app
        tray_menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        show_action = QAction("Show", self)
        show_action.triggered.connect(self.show)
        tray_menu.addAction(show_action)
        
        hide_action = QAction("Hide", self)
        hide_action.triggered.connect(self.hide)
        tray_menu.addAction(hide_action)
        
        tray_menu.addSeparator()
        quit_action = QAction("Quit", self)
        quit_action.triggered.connect(self.close)
        tray_menu.addAction(quit_action)
        
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.activated.connect(self.tray_icon_activated)
        self.tray_icon.show()
    
    def setup_shortcuts(self):
        """Setup keyboard shortcuts"""
        # F12 for developer tools
        dev_tools_shortcut = QShortcut(QKeySequence("F12"), self)
        dev_tools_shortcut.activated.connect(self.toggle_dev_tools)
    
    def tray_icon_activated(self, reason):
        """Handle tray icon activation"""
        if reason == QSystemTrayIcon.ActivationReason.DoubleClick:
            self.show()
            self.raise_()
            self.activateWindow()
    
    def show_menu(self):
        """Show the context menu"""
        menu_btn = self.sender()
        
        # Set JavaScript flag to indicate menu is open (do this before menu opens)
        if self.web_view and self.web_view.page():
            self.web_view.page().runJavaScript("""
                window._bandcampPlayerMenuOpen = true;
                if (typeof window._updateCoverArtCursor === 'function') {
                    window._updateCoverArtCursor();
                }
            """)
        
        # Show menu (blocking call)
        self.menu.exec(menu_btn.mapToGlobal(menu_btn.rect().bottomLeft()))
        
        # After menu closes, wait a bit before clearing the flag to handle any queued click events
        # This prevents clicks that happened while menu was open from opening the image viewer
        def clear_menu_flag():
            if self.web_view and self.web_view.page():
                self.web_view.page().runJavaScript("""
                    window._bandcampPlayerMenuOpen = false;
                    if (typeof window._updateCoverArtCursor === 'function') {
                        window._updateCoverArtCursor();
                    }
                """)
        
        # Clear flag after a short delay to catch any queued click events
        QTimer.singleShot(200, clear_menu_flag)
        
        # After menu closes, check if mouse is outside address bar and hide if autohide is enabled
        if self.autohide_address_bar:
            # Use a small delay to allow menu to fully close
            QTimer.singleShot(50, self.check_and_hide_address_bar_after_menu)
    
    def show_volume_control(self, auto_hide=True, delay_ms=1200, source_btn=None):
        """Show volume control popup with optional auto-hide
        
        Args:
            auto_hide: Whether to auto-hide the popup after delay
            delay_ms: Delay in milliseconds before auto-hiding
            source_btn: Optional button that triggered this (for positioning)
        """
        if not self.volume_popup:
            # Create volume popup widget
            self.volume_popup = QWidget(self)
            # Use ToolTip instead of Popup to avoid stealing keyboard focus
            # ToolTip windows don't interfere with keyboard shortcuts
            self.volume_popup.setWindowFlags(Qt.WindowType.ToolTip | Qt.WindowType.FramelessWindowHint)
            # Don't use WA_TranslucentBackground - it makes the background disappear
            # Window opacity will still work for fade animations without this attribute
            self.volume_popup.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, False)
            # Prevent popup from accepting keyboard focus (allows shortcuts to work)
            self.volume_popup.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            # Set fixed width to prevent resizing when volume percentage changes
            self.volume_popup.setFixedWidth(60)
            # Use solid background color (semi-transparency will be handled by window opacity)
            self.volume_popup.setStyleSheet("""
                QWidget {
                    background-color: #2b2b2b;
                    border: 1px solid #3a3a3a;
                    border-radius: 20px;
                }
            """)
            # Keep opaque paint event for proper background rendering
            self.volume_popup.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, True)
            # Enable mouse tracking to detect enter/leave events
            self.volume_popup.setMouseTracking(True)
            
            layout = QVBoxLayout(self.volume_popup)
            layout.setContentsMargins(15, 15, 15, 15)
            layout.setSpacing(10)
            
            # Volume label
            self.volume_label = QLabel(f"{self.volume_level}%")
            self.volume_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.volume_label.setStyleSheet("""
                QLabel {
                    color: #e0e0e0;
                    font-size: 14px;
                    font-weight: bold;
                    background-color: transparent;
                    border: none;
                }
            """)
            # Allow text overflow to be visible
            self.volume_label.setWordWrap(False)
            layout.addWidget(self.volume_label)
            
            # Volume slider (vertical, 0-100) - using custom widget that fills from bottom up
            self.volume_slider = VolumeSlider(self.volume_popup)
            self.volume_slider.setMinimum(0)
            self.volume_slider.setMaximum(100)
            self.volume_slider.setValue(self.volume_level)
            self.volume_slider.valueChanged.connect(self.on_volume_changed)
            # Add with fixed size policy to prevent width changes
            self.volume_slider.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
            layout.addWidget(self.volume_slider, 0, Qt.AlignmentFlag.AlignHCenter)
            
            # Mute button (icon, checkable)
            self.mute_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('fa5s.volume-mute', color='#e0e0e0')
                if icon:
                    self.mute_btn.setIcon(icon)
                else:
                    self.mute_btn.setText("")
            else:
                self.mute_btn.setText("")
            self.mute_btn.setFixedSize(30, 30)
            self.mute_btn.setCheckable(True)
            self.mute_btn.setChecked(self.volume_level == 0)  # Initialize checked state based on current volume
            self.mute_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
                QPushButton:checked {
                    color: #4a90e2;
                    background-color: #3a3a3a;
                    border: 1px solid #4a90e2;
                    border-radius: 3px;
                }
            """)
            self.mute_btn.clicked.connect(self.toggle_mute)
            layout.addWidget(self.mute_btn, 0, Qt.AlignmentFlag.AlignHCenter)
            
            # Install event filter on popup to reset timer on any mouse interaction
            self.volume_popup.installEventFilter(self)
            
            # Install event filter to close popup when clicking outside
            QApplication.instance().installEventFilter(self)
        
        # Position popup near volume button (if called from button) or top-right (if called from shortcut)
        # Use provided source_btn if available, otherwise try sender(), otherwise fallback to volume_btn
        volume_btn = source_btn
        if not volume_btn:
            volume_btn = self.sender()
        if not volume_btn and hasattr(self, 'volume_btn') and self.volume_btn:
            volume_btn = self.volume_btn
        self._position_volume_popup_onscreen(volume_btn if (volume_btn and hasattr(volume_btn, 'mapToGlobal')) else None)
        
        # Apply rounded corner mask to clip children to rounded corners
        # Wait for widget to be shown and sized before applying mask
        QTimer.singleShot(10, lambda: self._apply_rounded_mask())
        # Reposition after show/layout so final size is used for clamping (prevents offscreen cut-off)
        QTimer.singleShot(0, lambda: self._position_volume_popup_onscreen(volume_btn if (volume_btn and hasattr(volume_btn, 'mapToGlobal')) else None))
        
        # Cancel any ongoing fade out animation
        if self.volume_popup_fade_animation:
            self.volume_popup_fade_animation.stop()
            self.volume_popup_fade_animation = None
        
        # Check if popup is already visible (just resetting timer)
        is_already_visible = self.volume_popup.isVisible()
        
        # Set initial opacity to 0 before showing (for fade in)
        if not is_already_visible:
            self.volume_popup.setWindowOpacity(0.0)
        
        # Show popup first
        self.volume_popup.show()
        self.volume_popup.raise_()
        
        # Always set JavaScript flag to indicate volume popup is open (whether newly shown or already visible)
        # This ensures the flag is set whenever the popup is visible
        # Use a callback to ensure it's set before any clicks can happen
        if self.web_view and self.web_view.page():
            def set_flag_callback(result):
                # Flag is now set - popup is protected from image viewer clicks
                pass
            self.web_view.page().runJavaScript("""
                window._bandcampPlayerVolumePopupOpen = true;
                if (typeof window._updateCoverArtCursor === 'function') {
                    window._updateCoverArtCursor();
                }
            """, set_flag_callback)
        
        # Fade in animation only if popup wasn't already visible
        if not is_already_visible:
            # Use QTimer to ensure widget is fully shown before starting animation
            QTimer.singleShot(10, self._start_fade_in_animation)
        else:
            # Already visible - ensure it's fully opaque
            self.volume_popup.setWindowOpacity(1.0)
        
        # Setup auto-hide timer if requested and mouse is not over popup
        if auto_hide:
            # Check if mouse is currently over the popup
            mouse_over_popup = False
            if self.volume_popup and self.volume_popup.isVisible():
                popup_rect = QRect(
                    self.volume_popup.mapToGlobal(QPoint(0, 0)),
                    self.volume_popup.size()
                )
                mouse_pos = QCursor.pos()
                mouse_over_popup = popup_rect.contains(mouse_pos)
            
            # Only schedule hide if mouse is not over popup
            if not mouse_over_popup:
                self._schedule_volume_popup_hide(delay_ms)

    def _position_volume_popup_onscreen(self, source_btn=None):
        """Position the volume popup so it stays fully on-screen (flip up if needed near bottom edge)."""
        if not hasattr(self, 'volume_popup') or not self.volume_popup:
            return

        try:
            # Choose an anchor button if caller didn't provide one
            btn = source_btn
            if (btn is None) and hasattr(self, 'volume_btn') and self.volume_btn:
                btn = self.volume_btn

            # Ensure the popup has an up-to-date size hint before positioning
            try:
                self.volume_popup.adjustSize()
            except Exception:
                pass

            popup_hint = self.volume_popup.sizeHint()
            popup_w = max(int(self.volume_popup.width()), int(popup_hint.width()))
            popup_h = max(int(self.volume_popup.height()), int(popup_hint.height()))

            # Even with fixed width, height can be 0 before first show; keep a sensible fallback
            if popup_w <= 0:
                popup_w = 60
            if popup_h <= 0:
                popup_h = 180

            # Determine desired position (default: below button)
            x_offset = -20
            gap = 5

            if btn and hasattr(btn, 'mapToGlobal'):
                below_anchor = btn.mapToGlobal(btn.rect().bottomLeft())
                above_anchor = btn.mapToGlobal(btn.rect().topLeft())
                desired_x = below_anchor.x() + x_offset
                desired_y_below = below_anchor.y() + gap
                desired_y_above = above_anchor.y() - popup_h - gap
                anchor_for_screen = below_anchor
            else:
                # Fallback: near top-right of the main window
                anchor_for_screen = self.mapToGlobal(QPoint(self.width(), 0))
                desired_x = anchor_for_screen.x() - popup_w - 20
                desired_y_below = anchor_for_screen.y() + 50
                desired_y_above = desired_y_below

            # Pick the screen that contains the anchor point (multi-monitor safe)
            screen = None
            try:
                screen = QApplication.screenAt(anchor_for_screen)
            except Exception:
                screen = None
            if not screen:
                try:
                    screen = self.screen()
                except Exception:
                    screen = None
            if not screen:
                screen = QApplication.primaryScreen()

            if not screen:
                # As a last resort, just move to the desired position
                self.volume_popup.move(desired_x, desired_y_below)
                return

            avail = screen.availableGeometry()

            # Determine if button is from a player widget (vs top nav)
            # Player widgets are BasePlayerWidget or its subclasses (RegularPlayerWidget, MiniPlayerWidget, MicroPlayerWidget)
            is_from_player = False
            is_from_image_viewer = False
            if btn:
                # Check if button is from image viewer controls
                # Image viewer controls are stored in _image_viewer_controls dictionary
                if hasattr(self, '_image_viewer_controls') and self._image_viewer_controls:
                    # Check if button is the volume button from image viewer
                    if 'volume_btn' in self._image_viewer_controls and btn == self._image_viewer_controls.get('volume_btn'):
                        is_from_image_viewer = True
                    # Also check if button's parent is the controls widget (image viewer controls)
                    elif 'controls_widget' in self._image_viewer_controls:
                        controls_widget = self._image_viewer_controls.get('controls_widget')
                        parent = btn.parent()
                        while parent:
                            if parent == controls_widget:
                                is_from_image_viewer = True
                                break
                            parent = parent.parent()
                
                # Check if button's parent is a player widget
                if not is_from_image_viewer:
                    parent = btn.parent()
                    while parent:
                        if isinstance(parent, (RegularPlayerWidget, MiniPlayerWidget, MicroPlayerWidget)):
                            is_from_player = True
                            break
                        parent = parent.parent()

            # Choose direction based on source:
            # - Image viewer: always open upward
            # - Player widgets: prefer opening upward (default to above)
            # - Top nav: prefer opening downward (default to below)
            if is_from_image_viewer:
                # From image viewer: always open upward
                desired_y = desired_y_above
            elif is_from_player:
                # From player: prefer upward, but flip down if not enough room above
                if desired_y_above < avail.top():
                    desired_y = desired_y_below
                else:
                    desired_y = desired_y_above
            else:
                # From top nav: prefer downward, but flip up if not enough room below
                if desired_y_below + popup_h > avail.bottom():
                    desired_y = desired_y_above
                else:
                    desired_y = desired_y_below

            # Clamp fully on-screen
            min_x = avail.left()
            min_y = avail.top()
            max_x = avail.right() - popup_w
            max_y = avail.bottom() - popup_h
            if max_x < min_x:
                max_x = min_x
            if max_y < min_y:
                max_y = min_y

            final_x = max(min_x, min(int(desired_x), int(max_x)))
            final_y = max(min_y, min(int(desired_y), int(max_y)))

            self.volume_popup.move(final_x, final_y)
        except Exception:
            # Never let positioning logic crash the app or block the popup
            try:
                self.volume_popup.move(self.width() - 80, 50)
            except Exception:
                pass
    
    def _preload_cover_art(self):
        """Preload cover art for all modes when page loads."""
        if not self.web_view or not self.web_view.page():
            return
        
        # JavaScript to get cover art image URL (same as used in player widgets)
        js_code = """
        (function() {
            try {
                var albumArt = document.querySelector('#tralbum-art-carousel');
                if (!albumArt) {
                    return null;
                }
                
                var visibleImg = null;
                var activeItem = albumArt.querySelector('.carousel-item.active, [class*="active"]');
                if (activeItem) {
                    visibleImg = activeItem.querySelector('img');
                }
                
                if (!visibleImg) {
                    var allImgs = albumArt.querySelectorAll('img');
                    for (var i = 0; i < allImgs.length; i++) {
                        var img = allImgs[i];
                        var style = window.getComputedStyle(img);
                        if (style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
                            var rect = img.getBoundingClientRect();
                            if (rect && rect.width > 0 && rect.height > 0) {
                                visibleImg = img;
                                break;
                            }
                        }
                    }
                }
                
                if (!visibleImg) {
                    visibleImg = albumArt.querySelector('img');
                }
                
                if (!visibleImg) {
                    return null;
                }
                
                var imgSrc = visibleImg.getAttribute('data-src') || visibleImg.getAttribute('data-lazy-src');
                if (!imgSrc) {
                    var srcset = visibleImg.getAttribute('srcset');
                    if (srcset) {
                        var srcsetParts = srcset.split(',').map(function(s) { return s.trim(); });
                        if (srcsetParts.length > 0) {
                            var lastEntry = srcsetParts[srcsetParts.length - 1];
                            imgSrc = lastEntry.split(/\\s+/)[0];
                        }
                    }
                }
                if (!imgSrc) {
                    imgSrc = visibleImg.src || visibleImg.getAttribute('src');
                }
                
                return imgSrc;
            } catch (e) {
                console.log('Bandcamp Player: Error getting cover art URL:', e);
                return null;
            }
        })();
        """
        
        def on_url_received(url):
            if url:
                # Check if we already have this URL cached
                if url != self._current_cover_art_url:
                    self._current_cover_art_url = url
                    # Clear old cache entries (keep only current)
                    self._cover_art_cache.clear()
                    
                    # Preload the image
                    if hasattr(self, '_cover_art_network_manager') and self._cover_art_network_manager:
                        try:
                            request = QNetworkRequest(QUrl(url))
                            reply = self._cover_art_network_manager.get(request)
                            reply.setProperty('url', url)
                        except Exception as e:
                            logger.debug(f"Error preloading cover art: {e}")
                    else:
                        # Initialize network manager if not already done
                        self._cover_art_network_manager = QNetworkAccessManager(self)
                        self._cover_art_network_manager.finished.connect(self._on_cover_art_preloaded)
                        try:
                            request = QNetworkRequest(QUrl(url))
                            reply = self._cover_art_network_manager.get(request)
                            reply.setProperty('url', url)
                        except Exception as e:
                            logger.debug(f"Error preloading cover art: {e}")
                else:
                    # URL hasn't changed, update all modes with cached pixmap
                    self._update_all_modes_cover_art()
            else:
                # No URL found, retry after delay
                QTimer.singleShot(1000, self._preload_cover_art)
        
        self.web_view.page().runJavaScript(js_code, on_url_received)
    
    def _on_cover_art_preloaded(self, reply):
        """Handle preloaded cover art image."""
        try:
            if reply.error() == QNetworkReply.NetworkError.NoError:
                url = reply.property('url')
                if url and url == self._current_cover_art_url:
                    data = reply.readAll()
                    pixmap = QPixmap()
                    if pixmap.loadFromData(data):
                        # Cache the pixmap
                        self._cover_art_cache[url] = pixmap
                        # Update all modes immediately
                        self._update_all_modes_cover_art()
            reply.deleteLater()
        except Exception as e:
            logger.debug(f"Error processing preloaded cover art: {e}")
            if hasattr(reply, 'deleteLater'):
                reply.deleteLater()
    
    def _update_all_modes_cover_art(self):
        """Update cover art in all modes from cache."""
        if not self._current_cover_art_url or self._current_cover_art_url not in self._cover_art_cache:
            return
        
        pixmap = self._cover_art_cache[self._current_cover_art_url]
        
        # Update regular mode
        if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
            if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                self.regular_player_widget.cover_art_label.setPixmap(pixmap)
                self.regular_player_widget.cover_art_label.update()
        
        # Update mini mode (uses regular_player_widget)
        # Already updated above
        
        # Update micro mode (has its own micro_player_widget)
        if hasattr(self, 'micro_player_widget') and self.micro_player_widget:
            if hasattr(self.micro_player_widget, 'cover_art_label') and self.micro_player_widget.cover_art_label:
                # Ensure geometry is updated first so label has correct size
                if hasattr(self.micro_player_widget, '_update_geometry'):
                    self.micro_player_widget._update_geometry()
                label_size = self.micro_player_widget.cover_art_label.size()
                # Use widget size if label size is not ready yet
                if label_size.width() <= 0:
                    label_size = self.micro_player_widget.size()
                if label_size.width() > 0:
                    # Scale to fit width while maintaining aspect ratio (top-aligned, crop from bottom)
                    # Use scaledToWidth to ensure it fits exactly to the width
                    scaled_pixmap = pixmap.scaledToWidth(
                        label_size.width(),
                        Qt.TransformationMode.SmoothTransformation
                    )
                    # Crop to show top portion (top-aligned)
                    if label_size.height() > 0 and scaled_pixmap.height() > label_size.height():
                        cropped_pixmap = scaled_pixmap.copy(
                            0, 0,  # Start from top-left
                            label_size.width(),
                            label_size.height()  # Crop to label height
                        )
                        self.micro_player_widget.cover_art_label.setPixmap(cropped_pixmap)
                    else:
                        # Pixmap fits, use as-is
                        self.micro_player_widget.cover_art_label.setPixmap(scaled_pixmap)
                    # Store original for future rescaling
                    if hasattr(self.micro_player_widget, '_original_cover_art_pixmap'):
                        self.micro_player_widget._original_cover_art_pixmap = pixmap
                    self.micro_player_widget.cover_art_label.update()
        
        # Update nano mode
        if hasattr(self, 'nano_player_window') and self.nano_player_window:
            if hasattr(self.nano_player_window, 'cover_art_label') and self.nano_player_window.cover_art_label:
                # Scale pixmap for nano mode (50px width)
                scaled_pixmap = pixmap.scaled(50, 50, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                self.nano_player_window.cover_art_label.setPixmap(scaled_pixmap)
                self.nano_player_window.cover_art_label.update()
                # Hide loading animation if visible
                if hasattr(self.nano_player_window, 'cover_art_loading_widget'):
                    self.nano_player_window.cover_art_loading_widget.hide()
    
    def _schedule_volume_popup_hide(self, delay_ms=1200):
        """Schedule volume popup to hide after delay"""
        # Cancel existing timer if any
        if self.volume_hide_timer:
            self.volume_hide_timer.stop()
        
        # Create new timer
        self.volume_hide_timer = QTimer(self)
        self.volume_hide_timer.setSingleShot(True)
        self.volume_hide_timer.timeout.connect(self._hide_volume_popup)
        self.volume_hide_timer.start(delay_ms)
    
    def _start_fade_in_animation(self):
        """Start the fade in animation (called after widget is shown)"""
        if not self.volume_popup or not self.volume_popup.isVisible():
            return
        
        # Ensure initial opacity is 0
        self.volume_popup.setWindowOpacity(0.0)
        
        # Create fade in animation using window opacity
        fade_in = QPropertyAnimation(self.volume_popup, b"windowOpacity")
        fade_in.setDuration(150)  # 150ms fade in
        fade_in.setStartValue(0.0)
        fade_in.setEndValue(1.0)
        fade_in.setEasingCurve(QEasingCurve.Type.OutQuad)
        
        # Store animation reference
        self.volume_popup_fade_animation = fade_in
        fade_in.start()
    
    def _hide_volume_popup(self):
        """Hide volume popup with fade out animation"""
        if not self.volume_popup or not self.volume_popup.isVisible():
            return
        
        # Cancel any ongoing fade in animation
        if self.volume_popup_fade_animation:
            self.volume_popup_fade_animation.stop()
        
        # Get current opacity (should be 1.0 if fully visible)
        current_opacity = self.volume_popup.windowOpacity()
        if current_opacity < 0.1:
            # Already mostly transparent, just hide immediately
            self.volume_popup.hide()
            self.volume_popup.setWindowOpacity(1.0)  # Reset for next show
            self.volume_popup_fade_animation = None
            
            # Clear JavaScript flag after a delay to handle any queued click events
            def clear_volume_flag():
                if self.web_view and self.web_view.page():
                    self.web_view.page().runJavaScript("""
                        window._bandcampPlayerVolumePopupOpen = false;
                        if (typeof window._updateCoverArtCursor === 'function') {
                            window._updateCoverArtCursor();
                        }
                    """)
            
            # Clear flag after a short delay to catch any queued click events
            QTimer.singleShot(200, clear_volume_flag)
            return
        
        # Create fade out animation using window opacity
        fade_out = QPropertyAnimation(self.volume_popup, b"windowOpacity")
        fade_out.setDuration(150)  # 150ms fade out
        fade_out.setStartValue(current_opacity)
        fade_out.setEndValue(0.0)
        fade_out.setEasingCurve(QEasingCurve.Type.InQuad)
        
        # Store animation reference
        self.volume_popup_fade_animation = fade_out
        
        # Hide popup after animation completes
        def hide_after_fade():
            if self.volume_popup:
                self.volume_popup.hide()
                # Reset opacity for next show
                self.volume_popup.setWindowOpacity(1.0)
            self.volume_popup_fade_animation = None
            
            # Clear JavaScript flag after a delay to handle any queued click events
            def clear_volume_flag():
                if self.web_view and self.web_view.page():
                    self.web_view.page().runJavaScript("""
                        window._bandcampPlayerVolumePopupOpen = false;
                        if (typeof window._updateCoverArtCursor === 'function') {
                            window._updateCoverArtCursor();
                        }
                    """)
            
            # Clear flag after a short delay to catch any queued click events
            QTimer.singleShot(200, clear_volume_flag)
        
        fade_out.finished.connect(hide_after_fade)
        fade_out.start()
    
    def _apply_rounded_mask(self):
        """Apply rounded corner mask to volume popup"""
        if self.volume_popup and self.volume_popup.isVisible():
            path = QPainterPath()
            path.addRoundedRect(0, 0, self.volume_popup.width(), self.volume_popup.height(), 20, 20)
            region = QRegion(path.toFillPolygon().toPolygon())
            self.volume_popup.setMask(region)
    
    def on_volume_changed(self, value):
        """Handle volume slider change"""
        self.volume_level = value
        # Update label if popup exists
        if hasattr(self, 'volume_label') and self.volume_label:
            self.volume_label.setText(f"{value}%")
        
        # Update mute button checked state
        if hasattr(self, 'mute_btn') and self.mute_btn:
            self.mute_btn.setChecked(value == 0)
        
        # Update volume in JavaScript using standard volume control
        # Note: Boost (100-200%) is disabled due to Web Audio API compatibility issues
        volume_js = f"""
        (function() {{
            var audio = document.querySelector('audio');
            if (audio) {{
                // Clamp volume to 0.0-1.0 (0-100%)
                var volume = Math.max(0.0, Math.min(1.0, {value / 100.0}));
                audio.volume = volume;
            }}
        }})();
        """
        if self.web_view and self.web_view.page():
            self.web_view.page().runJavaScript(volume_js)
        
        # Save to settings
        self.settings['volume_level'] = value
        self.save_settings()
        
        # Reset hide timer when volume is changed manually (user interaction)
        if self.volume_popup and self.volume_popup.isVisible():
            self._schedule_volume_popup_hide(delay_ms=1200)
    
    def toggle_mute(self):
        """Toggle mute (set to 0% or restore previous volume)"""
        if self.volume_level > 0:
            # Store current volume and mute
            self._previous_volume = self.volume_level
            new_volume = 0
        else:
            # Restore previous volume (cap at 100%)
            previous = getattr(self, '_previous_volume', 100)
            new_volume = min(100, previous)  # Cap at 100%
        
        # Update volume immediately (don't go through slider to avoid delays)
        self.volume_level = new_volume
        self.on_volume_changed(new_volume)
        
        # Update slider if it exists (but don't wait for its signal)
        if hasattr(self, 'volume_slider') and self.volume_slider:
            # Temporarily block signals to avoid triggering valueChanged
            self.volume_slider.blockSignals(True)
            self.volume_slider.setValue(new_volume)
            self.volume_slider.blockSignals(False)
        
        # Update mute button checked state
        if hasattr(self, 'mute_btn') and self.mute_btn:
            self.mute_btn.setChecked(self.volume_level == 0)
        
        # Show volume popup if not visible, or reset timer if already visible
        if not (hasattr(self, 'volume_popup') and self.volume_popup and self.volume_popup.isVisible()):
            self.show_volume_control(auto_hide=True, delay_ms=1200)
        else:
            # Popup is already visible, just reset the timer
            self._schedule_volume_popup_hide(delay_ms=1200)
    
    def volume_up(self):
        """Increase volume by 10%"""
        new_volume = min(100, self.volume_level + 10)  # Cap at 100%
        # Update volume immediately (don't go through slider to avoid delays)
        self.volume_level = new_volume
        self.on_volume_changed(new_volume)
        
        # Update slider if it exists (but don't wait for its signal)
        if hasattr(self, 'volume_slider') and self.volume_slider:
            # Temporarily disconnect to avoid triggering valueChanged signal
            self.volume_slider.blockSignals(True)
            self.volume_slider.setValue(new_volume)
            self.volume_slider.blockSignals(False)
        
        # Show volume popup and reset hide timer (this allows rapid volume changes)
        # The timer will be reset on each call, allowing continuous adjustments
        self.show_volume_control(auto_hide=True, delay_ms=1200)
    
    def volume_down(self):
        """Decrease volume by 10%"""
        new_volume = max(0, self.volume_level - 10)
        # Update volume immediately (don't go through slider to avoid delays)
        self.volume_level = new_volume
        self.on_volume_changed(new_volume)
        
        # Update slider if it exists (but don't wait for its signal)
        if hasattr(self, 'volume_slider') and self.volume_slider:
            # Temporarily disconnect to avoid triggering valueChanged signal
            self.volume_slider.blockSignals(True)
            self.volume_slider.setValue(new_volume)
            self.volume_slider.blockSignals(False)
        
        # Show volume popup and reset hide timer (this allows rapid volume changes)
        # The timer will be reset on each call, allowing continuous adjustments
        self.show_volume_control(auto_hide=True, delay_ms=1200)
    
    def apply_volume(self):
        """Apply saved volume level to audio element"""
        # Use the same volume change logic
        self.on_volume_changed(self.volume_level)
        # Update slider value
        if hasattr(self, 'volume_slider') and self.volume_slider:
            self.volume_slider.setValue(self.volume_level)
    
    def on_paste_url(self):
        """Paste URL from clipboard and auto-load"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        if text:
            # Take first URL only (player can only handle one at a time)
            # Split by newlines and take first line
            lines = [line.strip() for line in text.split('\n') if line.strip()]
            url = lines[0] if lines else text
            
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Auto-add to playlist and switch if it's a Bandcamp URL
            if 'bandcamp.com' in url.lower():
                # Add to playlist if not already there
                playlist = self.playlist_manager.get_playlist()
                if url not in playlist:
                    self.playlist_manager.add_url(url)
                    self.update_playlist_display()
                # Switch to this URL automatically
            self.load_url(url)
    
    def changeEvent(self, event):
        """Handle window state changes (minimize/restore) to sync detached playlist and nano mode."""
        if event.type() == QEvent.Type.WindowStateChange:
            # Skip nano mode activation if we're doing a quick sync cycle
            if self._doing_quick_sync:
                return
            
            # Check if main window is minimized
            if self.isMinimized():
                # If minimize button was clicked, don't trigger nano mode (regular minimize)
                if self._minimize_button_clicked:
                    self._minimize_button_clicked = False  # Reset flag
                    # Regular minimize - minimize detached playlist if it exists and isn't already minimized
                    if (self.playlist_detached and 
                        hasattr(self, 'detached_playlist_window') and 
                        self.detached_playlist_window and 
                        not self.detached_playlist_window.isMinimized()):
                        try:
                            # Set flag BEFORE minimizing to avoid race condition with eventFilter
                            self._detached_playlist_minimized_by_main = True
                            self.detached_playlist_window.showMinimized()
                        except Exception:
                            self._detached_playlist_minimized_by_main = False
                # Check if nano mode is enabled (only if minimize button wasn't clicked)
                elif self.nano_mode_on_minimize:
                    # Hide main window and detached playlist, show nano player
                    self._enter_nano_mode()
                else:
                    # Regular minimize - minimize detached playlist if it exists and isn't already minimized
                    if (self.playlist_detached and 
                        hasattr(self, 'detached_playlist_window') and 
                        self.detached_playlist_window and 
                        not self.detached_playlist_window.isMinimized()):
                        try:
                            # Set flag BEFORE minimizing to avoid race condition with eventFilter
                            self._detached_playlist_minimized_by_main = True
                            self.detached_playlist_window.showMinimized()
                        except Exception:
                            self._detached_playlist_minimized_by_main = False
            else:
                # Main window was restored
                self._minimize_button_clicked = False  # Reset flag on restore
                if self._main_window_hidden_for_nano:
                    # Restore from nano mode
                    self._exit_nano_mode()
                else:
                    # Regular restore - restore detached playlist if we minimized it
                    if (self._detached_playlist_minimized_by_main and 
                        self.playlist_detached and 
                        hasattr(self, 'detached_playlist_window') and 
                        self.detached_playlist_window):
                        try:
                            if self.detached_playlist_window.isMinimized():
                                self.detached_playlist_window.showNormal()
                            self._detached_playlist_minimized_by_main = False
                        except Exception:
                            self._detached_playlist_minimized_by_main = False
        
        # Call parent's changeEvent
        super().changeEvent(event)
    
    def eventFilter(self, obj, event):
        """Event filter to detect paste events in URL input and handle drag/drop on central widget"""
        # Handle interactions with volume popup
        if obj == self.volume_popup and self.volume_popup and self.volume_popup.isVisible():
            # Cancel hide timer when mouse enters popup - keep it visible while hovering
            if event.type() == QEvent.Type.Enter:
                if self.volume_hide_timer:
                    self.volume_hide_timer.stop()
            # Restart hide timer when mouse leaves popup
            elif event.type() == QEvent.Type.Leave:
                self._schedule_volume_popup_hide(delay_ms=1200)
            # Handle mouse wheel to adjust volume
            elif event.type() == QEvent.Type.Wheel:
                # Cancel any hide timer since user is interacting
                if self.volume_hide_timer:
                    self.volume_hide_timer.stop()
                # Get wheel delta (positive = scroll up, negative = scroll down)
                delta = event.angleDelta().y()
                if delta > 0:
                    # Scroll up = increase volume
                    self.volume_up()
                elif delta < 0:
                    # Scroll down = decrease volume
                    self.volume_down()
                # Don't restart timer - keep visible while hovering
                return True  # Event handled
            # Reset timer on any mouse interaction with the popup (except wheel, handled above)
            elif event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.MouseMove):
                # Cancel timer on interaction, but don't restart - keep visible while hovering
                if self.volume_hide_timer:
                    self.volume_hide_timer.stop()
        
        # Handle clicks outside volume popup to close it with fade out
        if self.volume_popup and self.volume_popup.isVisible():
            if event.type() == QEvent.Type.MouseButtonPress:
                # Check if click is outside the popup
                click_pos = event.globalPosition().toPoint() if hasattr(event, 'globalPosition') else QCursor.pos()
                popup_rect = QRect(
                    self.volume_popup.mapToGlobal(QPoint(0, 0)),
                    self.volume_popup.size()
                )
                if not popup_rect.contains(click_pos):
                    # Also check if click is on the volume button (which should toggle)
                    if obj != self.volume_btn:
                        # Fade out when clicking away
                        self._hide_volume_popup()
        
        # Handle mouse events in controls bar to keep address bar visible
        if obj == self.controls_bar_widget:
            # In all modes (including regular), don't show address bar on mouse events - only show on trigger button hover
            if event.type() == QEvent.Type.MouseMove:
                # Mouse is moving within address bar
                if self.autohide_address_bar:
                    # In all modes, don't show on mouse move - only show on trigger button hover
                    return False
            elif event.type() == QEvent.Type.Enter:
                # Mouse entered address bar
                if self.autohide_address_bar:
                    # In all modes, don't show on enter - only show on trigger button hover
                    return False
            elif event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.MouseButtonRelease, QEvent.Type.Wheel):
                # Reset failsafe timer on any mouse interaction
                if self.autohide_address_bar:
                    self._reset_address_bar_failsafe_timer()
        
        # Handle drag and drop on central widget
        if obj == self.centralWidget():
            if event.type() == event.Type.DragEnter:
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                    return True
            elif event.type() == event.Type.Drop:
                url = None
                if event.mimeData().hasUrls():
                    urls = event.mimeData().urls()
                    if urls:
                        url = urls[0].toString()
                elif event.mimeData().hasText():
                    # Get text and take first URL only (player can only handle one at a time)
                    text = event.mimeData().text().strip()
                    if text:
                        # Split by newlines and take first line
                        lines = [line.strip() for line in text.split('\n') if line.strip()]
                        if lines:
                            url = lines[0]
                
                if url:
                    self._handle_global_drop(url)
                    event.acceptProposedAction()
                    return True
        
        # Handle keyboard events to reset failsafe timer when typing
        if self.autohide_address_bar and hasattr(self, 'controls_bar_widget'):
            if obj == self.controls_bar_widget or (hasattr(self, 'url_input') and obj == self.url_input):
                if event.type() in (QEvent.Type.KeyPress, QEvent.Type.KeyRelease, QEvent.Type.FocusIn):
                    # Reset failsafe timer on keyboard input or focus
                    self._reset_address_bar_failsafe_timer()
        
        # Handle detached playlist window move/resize events
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and obj == self.detached_playlist_window:
            # Handle window state changes (independent minimize/restore)
            if event.type() == QEvent.Type.WindowStateChange:
                # If the detached playlist window state changed independently (not by main window),
                # clear the flag so we don't try to restore it when main window restores
                # We detect this by checking if the change wasn't triggered by our changeEvent
                # (which would have set the flag). If the flag is not set, this is an independent change.
                if not self._detached_playlist_minimized_by_main:
                    # Independent state change - clear any pending restore
                    self._detached_playlist_minimized_by_main = False
                # If flag is set but window was independently restored, clear the flag
                elif self._detached_playlist_minimized_by_main and not self.detached_playlist_window.isMinimized():
                    # User independently restored it, so clear our flag
                    self._detached_playlist_minimized_by_main = False
            
            if event.type() == QEvent.Type.Move or event.type() == QEvent.Type.Resize:
                # If this Move is from our own link-mode programmatic move, use it to clear the guard
                if event.type() == QEvent.Type.Move and self._moving_detached_playlist_programmatically:
                    try:
                        if self._last_programmatic_detached_pos:
                            target_x, target_y = self._last_programmatic_detached_pos
                            cur_x = self.detached_playlist_window.x()
                            cur_y = self.detached_playlist_window.y()
                            if cur_x == target_x and cur_y == target_y:
                                # Only clear the guard if we're not actively moving via link-mode throttle
                                if not (hasattr(self, '_linked_move_timer') and self._linked_move_timer and self._linked_move_timer.isActive()):
                                    self._moving_detached_playlist_programmatically = False
                                    self._last_programmatic_detached_pos = None
                    except Exception:
                        if not (hasattr(self, '_linked_move_timer') and self._linked_move_timer and self._linked_move_timer.isActive()):
                            self._moving_detached_playlist_programmatically = False
                            self._last_programmatic_detached_pos = None

                # Check for automatic docking at screen edges
                if event.type() == QEvent.Type.Move:
                    if hasattr(self, '_check_windows_dock_to_screen_edge'):
                        self._check_windows_dock_to_screen_edge()
                
                # Handle window snapping when moving (only while dragging, not in release window, and not broken away)
                # Don't snap while link mode is enabled (snapping fights the link motion)
                # Release window gives a brief grace period after unlinking to allow easy breakaway
                if event.type() == QEvent.Type.Move and (not self.playlist_window_linked) and not self._moving_detached_playlist_programmatically and self._is_dragging_playlist_window and not self._playlist_release_window_active and not self._playlist_breakaway_activated:
                    # Check breakaway: if playlist is moving away from main window, disable snapping
                    current_pos = self.detached_playlist_window.pos()
                    current_dist = self._calculate_distance_to_main_window(current_pos)
                    breakaway_threshold = 10  # Fixed 10px threshold for breakaway
                    
                    if self._playlist_drag_start_pos:
                        start_dist = self._calculate_distance_to_main_window(self._playlist_drag_start_pos)
                        
                        # If distance increased by breakaway threshold, activate breakaway
                        if current_dist > start_dist + breakaway_threshold:
                            self._playlist_breakaway_activated = True
                        # If distance decreased (dragging back toward main window), reset breakaway
                        elif current_dist < start_dist:
                            self._playlist_breakaway_activated = False
                            # Update start position to current position for new reference
                            self._playlist_drag_start_pos = current_pos
                    
                    # Enable snapping if not linked, not in release window, and (not broken away OR windows are close enough to snap)
                    # Release window gives a brief grace period after unlinking to allow easy breakaway
                    # This allows snapping to re-engage if user drags back toward main window
                    can_snap = (not self.playlist_window_linked and 
                               not self._playlist_release_window_active and
                               (not self._playlist_breakaway_activated or current_dist <= self._snap_threshold))
                    if can_snap:
                        # Snap immediately while dragging (more forceful, like nano player)
                        if self._handle_playlist_window_snapping():
                            self._snapped_during_drag = True
                            # Reset breakaway if we snap (user is dragging toward main window)
                            self._playlist_breakaway_activated = False
                            # Reset drag start position since we snapped (new reference point)
                            self._playlist_drag_start_pos = current_pos
                
                # Handle window linking if enabled
                if self.playlist_window_linked and event.type() == QEvent.Type.Move:
                    self._handle_detached_playlist_window_movement(event)
                
                # Update bottom resize handle position on resize
                if event.type() == QEvent.Type.Resize:
                    if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                        QTimer.singleShot(10, self._update_detached_bottom_resize_handle_position)
                    # Update rounded corners on resize
                    if hasattr(self, '_apply_detached_rounded_corners'):
                        QTimer.singleShot(10, self._apply_detached_rounded_corners)
                
                # Save position/size when window is moved or resized (debounced)
                try:
                    pos = self.detached_playlist_window.pos()
                    size = self.detached_playlist_window.size()
                    # Save absolute position
                    self.playlist_detached_position = (pos.x(), pos.y())
                    # Also save relative offset for backward compatibility
                    main_pos = self.pos()
                    self.playlist_detached_offset = (pos.x() - main_pos.x(), pos.y() - main_pos.y())
                    self.playlist_detached_size = f"{size.width()}x{size.height()}"
                    # Debounce saves to avoid too many writes
                    if not hasattr(self, '_playlist_detach_save_timer'):
                        self._playlist_detach_save_timer = QTimer(self)
                        self._playlist_detach_save_timer.setSingleShot(True)
                        self._playlist_detach_save_timer.timeout.connect(self._save_playlist_detach_state)
                    self._playlist_detach_save_timer.stop()
                    self._playlist_detach_save_timer.start(500)  # Save after 500ms of no changes
                except Exception as e:
                    logger.debug(f"Error saving detached playlist position: {e}")
        
        # Handle main window move events for link mode (handled in moveEvent override instead)
        
        return super().eventFilter(obj, event)
    
    def setup_keyboard_shortcuts(self):
        """Setup customizable keyboard shortcuts"""
        # Load shortcuts from settings or use defaults
        shortcuts = self.settings.get("keyboard_shortcuts", {})
        default_shortcuts = KeyboardShortcutsDialog.DEFAULT_SHORTCUTS
        
        # Merge defaults with saved shortcuts
        all_shortcuts = {**default_shortcuts, **shortcuts}
        
        # Store shortcuts for later use
        self.keyboard_shortcuts = {}
        
        # Action mapping
        action_map = {
            "play_pause": self._trigger_play_pause,
            "next_track": self._trigger_next_track,
            "previous_track": self._trigger_previous_track,
            "next_album": lambda: self.playlist_sidebar.load_next_album() if hasattr(self, 'playlist_sidebar') else None,
            "previous_album": lambda: self.playlist_sidebar.load_previous_album() if hasattr(self, 'playlist_sidebar') else None,
            "volume_up": self.volume_up,
            "volume_down": self.volume_down,
            "mute": self.toggle_mute,
            "toggle_playlist": self.toggle_playlist,
            "toggle_playlist_expand": self.toggle_playlist_expand,
            "cycle_app_mode": self.toggle_mini_mode,  # toggle_mini_mode already cycles through modes
            "save_playlist": self.save_current_playlist_shortcut,
        }
        
        # Create shortcuts
        for key, action in action_map.items():
            shortcut_str = all_shortcuts.get(key)
            if shortcut_str:
                try:
                    shortcut = QShortcut(QKeySequence(shortcut_str), self)
                    shortcut.setContext(Qt.ShortcutContext.WindowShortcut)  # Make shortcuts work when window has focus
                    shortcut.activated.connect(action)
                    self.keyboard_shortcuts[key] = shortcut
                    logger.debug(f"Keyboard shortcut set: {shortcut_str} for {key}")
                except Exception as e:
                    logger.warning(f"Could not set shortcut {shortcut_str} for {key}: {e}")
                    # Only log full traceback in debug mode
                    if os.environ.get('DEBUG'):
                        import traceback
                        logger.warning(traceback.format_exc())
        
        logger.debug(f"Keyboard shortcuts loaded: {len(self.keyboard_shortcuts)} shortcuts active")
    
    def save_current_playlist_shortcut(self):
        """Save current playlist (called from keyboard shortcut)"""
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            self.playlist_sidebar.save_current_playlist()
        else:
            # If playlist sidebar doesn't exist, try to save directly
            if hasattr(self, 'playlist_manager') and self.playlist_manager:
                if self.playlist_manager.save_playlist():
                    self.save_settings()
                    # Show tooltip feedback
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        global_pos = self.playlist_sidebar.list_widget.mapToGlobal(self.playlist_sidebar.list_widget.rect().center())
                        playlist_name = self.playlist_manager.get_current_playlist_name()
                        QToolTip.showText(global_pos, f"Saved: {playlist_name}", self.playlist_sidebar.list_widget, QRect(), 1500)
    
    def show_keyboard_shortcuts_dialog(self):
        """Show keyboard shortcuts configuration dialog"""
        current_shortcuts = self.settings.get("keyboard_shortcuts", {})
        dialog = KeyboardShortcutsDialog(self, current_shortcuts)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Save new shortcuts
            new_shortcuts = dialog.get_shortcuts()
            self.settings["keyboard_shortcuts"] = new_shortcuts
            self.save_settings()
            
            # Recreate shortcuts with new values
            # First, remove old shortcuts
            for shortcut in self.keyboard_shortcuts.values():
                shortcut.setParent(None)
            self.keyboard_shortcuts.clear()
            
            # Create new shortcuts
            self.setup_keyboard_shortcuts()
            
            logger.debug("Keyboard shortcuts updated")
    
    def setup_media_key_listener(self):
        """Legacy method name - now calls setup_keyboard_shortcuts"""
        self.setup_keyboard_shortcuts()
    
    def setup_ipc_server(self):
        """Setup named pipe server for AutoHotkey communication"""
        if sys.platform != 'win32':
            return
        
        try:
            # Create local server (named pipe on Windows)
            self.ipc_server = QLocalServer(self)
            server_name = "BandcampPlayerIPC"
            
            # Remove any existing server with the same name
            QLocalServer.removeServer(server_name)
            
            # Start listening
            if self.ipc_server.listen(server_name):
                self.ipc_server.newConnection.connect(self._handle_ipc_connection)
                # On Windows, QLocalServer creates a pipe at \\.\pipe\ServerName
                # Log the full pipe path for debugging
                full_pipe_name = f"\\\\.\\pipe\\{server_name}"
                logger.info(f"IPC server started: {server_name} (pipe: {full_pipe_name})")
            else:
                error_msg = self.ipc_server.errorString()
                logger.warning(f"Failed to start IPC server: {error_msg}")
        except Exception as e:
            logger.warning(f"Error setting up IPC server: {e}")
            import traceback
            logger.debug(traceback.format_exc())
    
    def _handle_ipc_connection(self):
        """Handle new IPC connection from AutoHotkey"""
        try:
            socket = self.ipc_server.nextPendingConnection()
            if socket:
                logger.info("IPC client connected from AutoHotkey")
                # Connect readyRead signal - use a lambda that captures the socket
                def read_command():
                    self._read_ipc_command(socket)
                socket.readyRead.connect(read_command)
                socket.disconnected.connect(socket.deleteLater)
        except Exception as e:
            logger.warning(f"Error handling IPC connection: {e}")
            import traceback
            logger.debug(traceback.format_exc())
    
    def _read_ipc_command(self, socket):
        """Read command from IPC socket"""
        try:
            # Read all available data
            while socket.bytesAvailable() > 0:
                data = socket.readAll().data()
                command = data.decode('utf-8').strip()
                
                logger.info(f"IPC command received: {command}")
                
                # Process commands
                if command == "next":
                    QTimer.singleShot(0, self._trigger_next_track)
                elif command == "prev":
                    QTimer.singleShot(0, self._trigger_previous_track)
                elif command == "playpause":
                    QTimer.singleShot(0, self._trigger_play_pause)
                elif command == "next_album":
                    QTimer.singleShot(0, lambda: self.playlist_sidebar.load_next_album() if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else None)
                elif command == "prev_album":
                    QTimer.singleShot(0, lambda: self.playlist_sidebar.load_previous_album() if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else None)
                elif command == "volume_up":
                    QTimer.singleShot(0, self.volume_up)
                elif command == "volume_down":
                    QTimer.singleShot(0, self.volume_down)
                elif command == "mute":
                    QTimer.singleShot(0, self.toggle_mute)
                elif command == "toggle_playlist":
                    QTimer.singleShot(0, self.toggle_playlist)
                elif command == "toggle_playlist_expand":
                    QTimer.singleShot(0, self.toggle_playlist_expand)
                elif command == "cycle_app_mode":
                    QTimer.singleShot(0, self.toggle_mini_mode)
        except Exception as e:
            logger.warning(f"Error reading IPC command: {e}")
            import traceback
            logger.debug(traceback.format_exc())
    
    def _trigger_next_track(self):
        """Trigger next track via JavaScript"""
        logger.debug("_trigger_next_track called")
        if not self.web_view or not self.web_view.page():
            logger.warning("_trigger_next_track: web_view or page not available")
            return
        
        js_code = """
        (function() {
            console.log('Bandcamp Player: Attempting to trigger next track...');
            
            // Try multiple methods to trigger next track
            // Method 1: Click the next button directly
            var nextBtn = document.querySelector('button[aria-label="Skip to next song"]');
            if (nextBtn) {
                var isDisabled = nextBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found next button, disabled:', isDisabled);
                if (!isDisabled) {
                    nextBtn.click();
                    console.log('Bandcamp Player: Clicked next button');
                    return;
                }
            } else {
                console.log('Bandcamp Player: Next button not found with aria-label="Skip to next song"');
            }
            
            // Method 2: Try alternative selectors for next button
            var altNextBtn = document.querySelector('.next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
            if (altNextBtn) {
                var isDisabled = altNextBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found alternative next button, disabled:', isDisabled);
                if (!isDisabled) {
                    altNextBtn.click();
                    console.log('Bandcamp Player: Clicked alternative next button');
                    return;
                }
            }
            
            // Method 3: Try to access Knockout.js view model and call player.next()
            try {
                // Bandcamp uses Knockout.js - try to find the player view model
                var playerElement = document.querySelector('#player');
                if (playerElement) {
                    // Try ko.contextFor
                    if (typeof ko !== 'undefined' && ko.contextFor) {
                        var context = ko.contextFor(playerElement);
                        if (context && context.$data && context.$data.player && typeof context.$data.player.next === 'function') {
                            context.$data.player.next();
                            console.log('Bandcamp Player: Called player.next() via Knockout context');
                            return;
                        }
                    }
                    
                    // Try __ko__ property
                    if (playerElement.__ko__) {
                        var context = playerElement.__ko__;
                        if (context && context.$data && context.$data.player && typeof context.$data.player.next === 'function') {
                            context.$data.player.next();
                            console.log('Bandcamp Player: Called player.next() via __ko__');
                            return;
                        }
                    }
                }
                
                // Try global player object
                if (typeof window.player !== 'undefined' && typeof window.player.next === 'function') {
                    window.player.next();
                    console.log('Bandcamp Player: Called window.player.next()');
                    return;
                }
            } catch (e) {
                console.log('Bandcamp Player: Could not access player.next() via view model:', e);
            }
            
            console.log('Bandcamp Player: Could not find next track button or method');
        })();
        """
        self.run_javascript_safe(js_code)
    
    def _trigger_previous_track(self):
        """Trigger previous track via JavaScript"""
        logger.debug("_trigger_previous_track called")
        if not self.web_view or not self.web_view.page():
            logger.warning("_trigger_previous_track: web_view or page not available")
            return
        
        js_code = """
        (function() {
            console.log('Bandcamp Player: Attempting to trigger previous track...');
            
            // Try multiple methods to trigger previous track
            // Method 1: Click the previous button directly
            var prevBtn = document.querySelector('button[aria-label="Skip to previous song"]');
            if (prevBtn) {
                var isDisabled = prevBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found previous button, disabled:', isDisabled);
                if (!isDisabled) {
                    prevBtn.click();
                    console.log('Bandcamp Player: Clicked previous button');
                    return;
                }
            } else {
                console.log('Bandcamp Player: Previous button not found with aria-label="Skip to previous song"');
            }
            
            // Method 2: Try alternative selectors for previous button
            var altPrevBtn = document.querySelector('.next-prev-controls button[aria-label*="previous"], .next-prev-controls button[aria-label*="Previous"], button[aria-label*="Skip to previous"]');
            if (altPrevBtn) {
                var isDisabled = altPrevBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found alternative previous button, disabled:', isDisabled);
                if (!isDisabled) {
                    altPrevBtn.click();
                    console.log('Bandcamp Player: Clicked alternative previous button');
                    return;
                }
            }
            
            // Method 3: Try to access Knockout.js view model and call player.prev()
            try {
                // Bandcamp uses Knockout.js - try to find the player view model
                var playerElement = document.querySelector('#player');
                if (playerElement) {
                    // Try ko.contextFor
                    if (typeof ko !== 'undefined' && ko.contextFor) {
                        var context = ko.contextFor(playerElement);
                        if (context && context.$data && context.$data.player && typeof context.$data.player.prev === 'function') {
                            context.$data.player.prev();
                            console.log('Bandcamp Player: Called player.prev() via Knockout context');
                            return;
                        }
                    }
                    
                    // Try __ko__ property
                    if (playerElement.__ko__) {
                        var context = playerElement.__ko__;
                        if (context && context.$data && context.$data.player && typeof context.$data.player.prev === 'function') {
                            context.$data.player.prev();
                            console.log('Bandcamp Player: Called player.prev() via __ko__');
                            return;
                        }
                    }
                }
                
                // Try global player object
                if (typeof window.player !== 'undefined' && typeof window.player.prev === 'function') {
                    window.player.prev();
                    console.log('Bandcamp Player: Called window.player.prev()');
                    return;
                }
            } catch (e) {
                console.log('Bandcamp Player: Could not access player.prev() via view model:', e);
            }
            
            console.log('Bandcamp Player: Could not find previous track button or method');
        })();
        """
        self.run_javascript_safe(js_code)
    
    def _trigger_play_pause(self):
        """Trigger play/pause via JavaScript"""
        logger.debug("_trigger_play_pause called")
        if not self.web_view or not self.web_view.page():
            logger.warning("_trigger_play_pause: web_view or page not available")
            return
        
        js_code = """
        (function() {
            console.log('Bandcamp Player: Attempting to trigger play/pause...');
            
            // Try multiple methods to trigger play/pause
            // Method 1: Click the play/pause button directly
            var playPauseBtn = document.querySelector('button[aria-label="Play"], button[aria-label="Pause"], button[aria-label="Play song"], button[aria-label="Pause song"]');
            if (playPauseBtn) {
                var isDisabled = playPauseBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found play/pause button, disabled:', isDisabled);
                if (!isDisabled) {
                    playPauseBtn.click();
                    console.log('Bandcamp Player: Clicked play/pause button');
                    return;
                }
            } else {
                console.log('Bandcamp Player: Play/pause button not found with standard aria-label');
            }
            
            // Method 2: Try alternative selectors for play/pause button
            var altPlayPauseBtn = document.querySelector('.playbutton, .pausebutton, .play-btn, .pause-btn, button[title*="play"], button[title*="Play"], button[title*="pause"], button[title*="Pause"]');
            if (altPlayPauseBtn) {
                var isDisabled = altPlayPauseBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found alternative play/pause button, disabled:', isDisabled);
                if (!isDisabled) {
                    altPlayPauseBtn.click();
                    console.log('Bandcamp Player: Clicked alternative play/pause button');
                    return;
                }
            }
            
            // Method 3: Try to access Knockout.js view model and call player.play() or player.pause()
            try {
                // Bandcamp uses Knockout.js - try to find the player view model
                var playerElement = document.querySelector('#player');
                if (playerElement) {
                    // Try ko.contextFor
                    if (typeof ko !== 'undefined' && ko.contextFor) {
                        var context = ko.contextFor(playerElement);
                        if (context && context.$data && context.$data.player) {
                            // Check if playing and toggle
                            if (context.$data.player.playing && typeof context.$data.player.pause === 'function') {
                                context.$data.player.pause();
                                console.log('Bandcamp Player: Called player.pause() via Knockout context');
                                return;
                            } else if (typeof context.$data.player.play === 'function') {
                                context.$data.player.play();
                                console.log('Bandcamp Player: Called player.play() via Knockout context');
                                return;
                            }
                        }
                    }
                    
                    // Try __ko__ property
                    if (playerElement.__ko__) {
                        var context = playerElement.__ko__;
                        if (context && context.$data && context.$data.player) {
                            // Check if playing and toggle
                            if (context.$data.player.playing && typeof context.$data.player.pause === 'function') {
                                context.$data.player.pause();
                                console.log('Bandcamp Player: Called player.pause() via __ko__');
                                return;
                            } else if (typeof context.$data.player.play === 'function') {
                                context.$data.player.play();
                                console.log('Bandcamp Player: Called player.play() via __ko__');
                                return;
                            }
                        }
                    }
                }
                
                // Try global player object
                if (typeof window.player !== 'undefined') {
                    if (window.player.playing && typeof window.player.pause === 'function') {
                        window.player.pause();
                        console.log('Bandcamp Player: Called window.player.pause()');
                        return;
                    } else if (typeof window.player.play === 'function') {
                        window.player.play();
                        console.log('Bandcamp Player: Called window.player.play()');
                        return;
                    }
                }
            } catch (e) {
                console.log('Bandcamp Player: Could not access player.play()/pause() via view model:', e);
            }
            
            console.log('Bandcamp Player: Could not find play/pause button or method');
        })();
        """
        self.run_javascript_safe(js_code)
    
    def resolve_url_redirects(self, url):
        """Resolve URL redirects to get final destination.
        
        Only resolves URLs that don't already contain 'bandcamp.com'.
        If the URL already contains 'bandcamp.com', returns it unchanged.
        If resolution succeeds and final URL contains 'bandcamp.com', returns the final URL.
        If resolution fails or final URL doesn't contain 'bandcamp.com', returns None.
        
        Args:
            url: URL string to resolve
            
        Returns:
            Final URL after redirects (if it resolves to Bandcamp), original URL (if already Bandcamp),
            or None (if resolution fails or doesn't resolve to Bandcamp)
        """
        if not url or not isinstance(url, str):
            return None
        
        url = url.strip()
        url_lower = url.lower()
        
        # If URL already contains bandcamp.com, no need to resolve
        if 'bandcamp.com' in url_lower:
            return url
        
        # Only resolve URLs that start with http:// or https://
        if not (url_lower.startswith('http://') or url_lower.startswith('https://')):
            return None
        
        try:
            # Create a request with a timeout and follow redirects
            # Use HEAD request first (faster, doesn't download body)
            req = urllib.request.Request(url, method='HEAD')
            req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
            
            # Open with redirect handling and timeout
            with urllib.request.urlopen(req, timeout=5) as response:
                # Get the final URL after redirects
                final_url = response.geturl()
                
                # Check if final URL contains bandcamp.com
                if 'bandcamp.com' in final_url.lower():
                    return final_url
                else:
                    # Resolved but not to Bandcamp - reject
                    return None
                    
        except urllib.error.HTTPError as e:
            # HTTP error (404, 500, etc.) - try GET request as fallback
            # Some servers don't respond to HEAD requests
            try:
                req = urllib.request.Request(url)
                req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
                with urllib.request.urlopen(req, timeout=5) as response:
                    final_url = response.geturl()
                    if 'bandcamp.com' in final_url.lower():
                        return final_url
                    return None
            except Exception as e:
                logger.debug(f"URL resolution fallback failed: {e}")
                return None
        except (urllib.error.URLError, TimeoutError, OSError) as e:
            # Network error, timeout, or connection refused
            logger.debug(f"URL resolution failed (network error): {e}")
            return None
        except Exception as e:
            # Any other error
            logger.warning(f"URL resolution failed (unexpected error): {e}")
            return None
    
    def handle_paste(self):
        """Handle paste event - auto-add to playlist and switch (only first URL)"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        if text:
            # Take first URL only (player can only handle one at a time)
            # Split by newlines and take first line
            lines = [line.strip() for line in text.split('\n') if line.strip()]
            url = lines[0] if lines else text
            
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Check if it's a Bandcamp URL (either original or resolved)
            if 'bandcamp.com' in url.lower():
                # Add to playlist if not already there
                playlist = self.playlist_manager.get_playlist()
                if url not in playlist:
                    self.playlist_manager.add_url(url)
                    self.update_playlist_display()
                # Switch to this URL automatically
                self.load_url(url)
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event for the entire window"""
        # Check if the event is coming from a child widget
        source = event.source()
        if source and source != self:
            # If it's from a child widget, accept it here
            if event.mimeData().hasUrls() or event.mimeData().hasText():
                event.acceptProposedAction()
                return
        
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def dropEvent(self, event: QDropEvent):
        """Handle drop event anywhere on the window - route to paste handler"""
        # Check if the drop target is the playlist sidebar - if so, let it handle it
        # Get position relative to this widget
        try:
            pos = event.position().toPoint()
        except AttributeError:
            # Fallback for older PyQt6 versions
            pos = event.pos()
        
        widget_at_pos = self.childAt(pos)
        
        # Walk up the widget hierarchy to check if we're dropping on the playlist sidebar
        current_widget = widget_at_pos
        while current_widget:
            if isinstance(current_widget, PlaylistSidebar):
                # Let the playlist sidebar handle the drop (it will add to playlist)
                event.ignore()
                return
            current_widget = current_widget.parentWidget()
        
        # Also check if playlist sidebar is visible and position is within its bounds
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar.isVisible() and not self.playlist_detached:
            global_pos = self.mapToGlobal(pos)
            sidebar_global_rect = QRect(
                self.playlist_sidebar.mapToGlobal(QPoint(0, 0)),
                self.playlist_sidebar.size()
            )
            if sidebar_global_rect.contains(global_pos):
                # Drop is on the playlist sidebar, let it handle it
                event.ignore()
                return
        
        url = None
        
        # Try to get URL from dropped data
        if event.mimeData().hasUrls():
            # Get first URL from dropped files/links
            urls = event.mimeData().urls()
            if urls:
                url = urls[0].toString()
        elif event.mimeData().hasText():
            # Get text and take first URL only (player can only handle one at a time)
            text = event.mimeData().text().strip()
            if text:
                # Split by newlines and take first line
                lines = [line.strip() for line in text.split('\n') if line.strip()]
                if lines:
                    url = lines[0]
        
        if url:
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Auto-load if it's a Bandcamp URL
            if 'bandcamp.com' in url.lower():
                # Add to playlist if not already there
                playlist = self.playlist_manager.get_playlist()
                if url not in playlist:
                    self.playlist_manager.add_url(url)
                    self.update_playlist_display()
                # Load the URL
                self.load_url(url)
        
        event.acceptProposedAction()
    
    def _handle_global_drop(self, url):
        """Helper method to handle dropped URLs from anywhere"""
        if url:
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Auto-load if it's a Bandcamp URL
            if 'bandcamp.com' in url.lower():
                # Add to playlist if not already there
                playlist = self.playlist_manager.get_playlist()
                if url not in playlist:
                    self.playlist_manager.add_url(url)
                    self.update_playlist_display()
                # Load the URL
                self.load_url(url)
            else:
                # Not a Bandcamp URL, just set it in the field
                self.url_input.setFocus()
    
    def load_url(self, url, is_startup_load=None):
        """Load a URL in the web view
        
        Args:
            url: The URL to load
            is_startup_load: Optional flag to explicitly mark this as a startup load.
                           If None, will check if _is_startup_load is already set.
        """
        # Lazy initialization of WebEngine storage (deferred from startup for faster startup)
        if not self._webengine_storage_setup:
            self.setup_webengine_storage()
            self._webengine_storage_setup = True
        
        # If is_startup_load is explicitly provided, use it
        # Otherwise, if _is_startup_load is already True, preserve it (it was set in deferred_init)
        # Only reset to False if it's not a startup load and wasn't already set
        if is_startup_load is not None:
            self._is_startup_load = is_startup_load
        elif not hasattr(self, '_is_startup_load') or not self._is_startup_load:
            # Not a startup load - ensure flag is False
            self._is_startup_load = False
        
        # Clear Super Shuffle flag if this is not a Super Shuffle load
        # (Super Shuffle sets this flag before calling load_url)
        if not hasattr(self, '_is_super_shuffle_load') or not self._is_super_shuffle_load:
            self._is_super_shuffle_load = False
            self._super_shuffle_album_url = None
        
        # If in mini or micro mode, minimize playlist if it's expanded
        # BUT: never auto-minimize when the playlist is detached (it breaks detached UX).
        if (self.mini_mode_state == 1 or self.mini_mode_state == 2):
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                try:
                    if getattr(self, 'playlist_detached', False):
                        # Detached playlist should stay usable/expanded.
                        # If it somehow is minimized, un-minimize it (safe no-op otherwise).
                        if getattr(self.playlist_sidebar, 'is_minimized', False):
                            self.playlist_sidebar._toggle_minimize_state()
                    else:
                        if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized:
                            # Minimize the attached playlist
                            self.playlist_sidebar._toggle_minimize_state()
                except Exception:
                    # Never let playlist minimize logic interfere with loading a URL
                    pass
        
        # Reset first playback detection flag for new URL load
        self._first_playback_detected = False
        # Stop any existing first playback check timer
        if hasattr(self, '_first_playback_check_timer') and self._first_playback_check_timer:
            self._first_playback_check_timer.stop()
        # Reset JavaScript flag for new URL load
        if self.web_view:
            self.run_javascript_safe("window.bandcampFirstPlaybackDetected = false; window.bandcampFirstPlaybackSetup = false;")
        
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
        
        # Try to resolve redirects if it's not already a Bandcamp URL
        resolved_url = self.resolve_url_redirects(url)
        if resolved_url:
            url = resolved_url
        
        # Ensure it's a Bandcamp URL
        if 'bandcamp.com' not in url.lower():
            QMessageBox.warning(self, "Invalid URL", "Please enter a Bandcamp URL")
            return
        
        # Hide welcome widget if it's visible (URL is being loaded)
        if self.welcome_widget and self.welcome_widget.isVisible():
            self.welcome_widget.hide()
            self._has_url_loaded = True
            # Re-enable mode switching now that URL is loaded
            self.update_mini_mode_button()
            self.update_mini_mode_menu_text()
        
        # Show player widget if it was hidden on startup (no URLs/playlist)
        use_qt = getattr(self, 'use_qt_widgets', True)
        if use_qt and hasattr(self, 'regular_player_widget') and self.regular_player_widget:
            if not self.regular_player_widget.isVisible() and self.mini_mode_state == 0:
                self.regular_player_widget.show()
        # Also show webview if not using Qt widgets
        if not use_qt and self.web_view and not self.web_view.isVisible():
            self.web_view.show()
            # Re-enable mouse events when webview is shown
            self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        
        # Set loading state to prevent overlay flicker
        self.is_loading = True
        
        # Clear tracklist widget immediately when URL changes (if tracks tab is active)
        # This prevents showing a mix of old and new tracks during loading
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            if hasattr(self.playlist_sidebar, 'active_tab') and self.playlist_sidebar.active_tab == 'tracks':
                if hasattr(self.playlist_sidebar, 'tracklist_widget') and self.playlist_sidebar.tracklist_widget:
                    self.playlist_sidebar.tracklist_widget.clear()
                    placeholder_item = QListWidgetItem("Loading tracks...")
                    placeholder_item.setForeground(QColor("#888888"))
                    placeholder_item.setFlags(Qt.ItemFlag.NoItemFlags)
                    self.playlist_sidebar.tracklist_widget.addItem(placeholder_item)
            
            # Clear album list selection when URL changes to prevent confusion
            # (e.g., right-click showing "delete x albums" when user didn't manually select them)
            if hasattr(self.playlist_sidebar, 'list_widget') and self.playlist_sidebar.list_widget:
                self.playlist_sidebar.list_widget.clearSelection()
        
        # Show loading animation in nano mode if it exists
        if hasattr(self, 'nano_player_window') and self.nano_player_window:
            if hasattr(self.nano_player_window, '_check_and_show_loading_animation'):
                self.nano_player_window._check_and_show_loading_animation()
        
        # Disable context menu on web view during loading to prevent crashes
        if self.web_view:
            # Store original context menu policy if not already stored
            if self._original_context_menu_policy is None:
                self._original_context_menu_policy = self.web_view.contextMenuPolicy()
            # Disable context menu during loading
            self.web_view.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)
            self.web_view.hide()  # Hide completely, not just transparent
            # Make webview transparent to mouse events so it doesn't block clicks on cover art
            self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self.web_view.setWindowOpacity(0.0)
        
        # Show loading overlay covering entire web view area (playlist will sit on top)
        if self.loading_overlay:
            # Position overlay to cover full height (playlist can be raised above it)
            # This will set the correct geometry based on current window size
            self.update_loading_overlay_geometry()
            # Show overlay and raise it above web view (but playlist container can be raised above overlay)
            # Restore opacity when showing (in case it was set to 0 when hidden)
            self.loading_overlay.setWindowOpacity(1.0)
            self.loading_overlay.show()
            self.loading_overlay.raise_()
            # Ensure playlist stays above overlay if it's visible
            if hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible():
                # CRITICAL Z-ORDER FIX: Ensure proper stacking order in mini mode
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 1:
                    # In mini mode, ensure z-order is: cover art (bottom) < player overlay < playlist (top)
                    if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                        if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                            self.regular_player_widget.cover_art_label.lower()
                        if hasattr(self.regular_player_widget, 'player_overlay') and self.regular_player_widget.player_overlay:
                            self.regular_player_widget.player_overlay.raise_()
                    # Now raise playlist to top
                    self.playlist_container.raise_()
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        self.playlist_sidebar.raise_()
                else:
                    self.playlist_container.raise_()
                # Force playlist widget repaint after raising (fixes black display in mini mode when switching URLs)
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    if hasattr(self.playlist_sidebar, 'list_widget') and self.playlist_sidebar.list_widget:
                        list_widget = self.playlist_sidebar.list_widget
                        # Alternative approach: Force stylesheet refresh and ensure background is drawn
                        # Re-apply stylesheet to ensure background color is set
                        current_stylesheet = list_widget.styleSheet()
                        if current_stylesheet:
                            list_widget.setStyleSheet("")  # Clear first
                            # Defer re-application instead of forcing immediate processing
                            QTimer.singleShot(0, lambda: list_widget.setStyleSheet(current_stylesheet) if list_widget else None)
                        # Ensure auto-fill background is enabled
                        list_widget.setAutoFillBackground(True)
                        # Force geometry update
                        list_widget.updateGeometry()
                        self.playlist_sidebar.updateGeometry()
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            self.playlist_container.updateGeometry()
                        # Explicitly repaint the entire widget area
                        list_widget.viewport().update(list_widget.viewport().rect())
                        list_widget.update()  # QListWidget.update() doesn't accept QRect
                        # Force immediate repaint of entire widget
                        list_widget.repaint(list_widget.rect())
                        # Also repaint the sidebar and container
                        self.playlist_sidebar.repaint(self.playlist_sidebar.rect())
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            self.playlist_container.repaint(self.playlist_container.rect())
                        # Defer UI update instead of forcing immediate processing
                        def update_widgets():
                            if list_widget:
                                list_widget.update()
                            if self.playlist_sidebar:
                                self.playlist_sidebar.update()
                        QTimer.singleShot(0, update_widgets)
            # Clear any existing graphics effects first
            self.loading_overlay.setGraphicsEffect(None)
            # Apply transparency based on setting
            self.apply_overlay_transparency()
        
        # Now load the new URL (web view is hidden, overlay is showing)
        self.web_view.setUrl(QUrl(url))
        # Set placeholder title from URL
        placeholder_title = self.extract_artist_album_from_url(url)
        if not placeholder_title:
            placeholder_title = url
        # Always append "- Bandcamp Player" to the title for reliable window detection
        full_title = f"{placeholder_title} - Bandcamp Player"
        QMainWindow.setWindowTitle(self, full_title)
        if self.window_title_label:
            self.window_title_label.setText(self._truncate_title_text(placeholder_title))
        
        # Update playlist sidebar to highlight current item
        # This must happen after URL is resolved and validated
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            # Use a small delay to ensure playlist is ready (in case it's being created)
            def update_and_repaint():
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    self.playlist_sidebar.update_current_item(url)
                    # Force additional repaint after update (fixes black display in mini mode)
                    if hasattr(self.playlist_sidebar, 'list_widget') and self.playlist_sidebar.list_widget:
                        self.playlist_sidebar.list_widget.viewport().update()
                        self.playlist_sidebar.list_widget.update()
            QTimer.singleShot(50, update_and_repaint)
        
        # Save last played URL to settings
        self.settings['last_played_url'] = url
        self.save_settings()
    
    def on_page_load_started(self):
        """Handle page load start - ensure loading overlay is visible and covering everything"""
        # Set loading state
        self.is_loading = True
        
        # Reset JavaScript injection flag - new page is loading, JavaScript needs to be injected again
        self._js_injected_on_current_page = False
        
        # Disable context menu on web view during loading to prevent crashes
        if self.web_view:
            # Store original context menu policy if not already stored
            if self._original_context_menu_policy is None:
                self._original_context_menu_policy = self.web_view.contextMenuPolicy()
            # Disable context menu during loading
            self.web_view.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)
            self.web_view.hide()
            # Make webview transparent to mouse events so it doesn't block clicks on cover art
            self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self.web_view.setWindowOpacity(0.0)
        
        # Ensure loading overlay is visible and covering entire web view area
        if self.loading_overlay:
            # Stop any existing animations first to prevent overlay from getting stuck
            if self.loading_overlay.graphicsEffect():
                effect = self.loading_overlay.graphicsEffect()
                if isinstance(effect, QPropertyAnimation):
                    effect.stop()
                # Clear the effect so we can start fresh
                self.loading_overlay.setGraphicsEffect(None)
            # Position overlay to cover full height (playlist can be raised above it)
            self.update_loading_overlay_geometry()
            # Show and raise overlay above web view (but playlist container can be raised above overlay)
            if not self.loading_overlay.isVisible():
                self.loading_overlay.show()
            self.loading_overlay.raise_()
            # Ensure playlist stays above overlay if it's visible
            if hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible():
                self.playlist_container.raise_()
            # Apply transparency based on setting (after clearing old effects)
            self.apply_overlay_transparency()
    
    def on_page_load_progress(self, progress):
        """Handle page load progress - show page early for faster perceived loading"""
        # Don't show webview if using Qt widgets
        use_qt = getattr(self, 'use_qt_widgets', True)
        if use_qt:
            return
        
        # Show the page when it's 30% loaded (much faster perceived loading)
        if progress >= 30 and self.web_view and not self.web_view.isVisible():
            # Show web view early so user sees content loading
            self.web_view.show()
            # Re-enable mouse events when webview is shown
            self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
            self.web_view.raise_()
            # Start with low opacity, will fade in fully after CSS injection
            self.web_view.setWindowOpacity(0.3)
            # Inject CSS early (at 30% load) for faster styling
            # But only if this isn't the first launch - on first launch, wait for full load
            if progress == 30:  # Only inject once at 30%
                is_first_launch = not self.settings.get('mini_mode_js_fixed', False)
                if not is_first_launch:
                    # Not first launch - safe to inject early
                    self.inject_css_with_callback()
                # On first launch, wait for full load to ensure DOM is ready
    
    def on_page_loaded(self, success):
        """Handle page load completion"""
        logger.debug(f"[PLAYLIST DEBUG] on_page_loaded called, success={success}, mini_mode_state={getattr(self, 'mini_mode_state', 'N/A')}")
        
        # Preload cover art for all modes when page loads
        self._preload_cover_art()
        
        # Update Qt widgets if they're active
        use_qt = getattr(self, 'use_qt_widgets', True)  # Default to True if not set
        if use_qt:
            if self.mini_mode_state == 0 and self.regular_player_widget:
                # Update cover art and tracklist in regular mode
                QTimer.singleShot(300, self.regular_player_widget._update_cover_art)
                QTimer.singleShot(500, self.regular_player_widget._update_tracklist)
            elif self.mini_mode_state == 1 and self.regular_player_widget:
                print("[PLAYLIST DEBUG] Mini mode detected, scheduling cover art update")
                logger.debug("[PLAYLIST DEBUG] Mini mode detected, scheduling cover art update")
                # Check playlist state before cover art update
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    print(f"[PLAYLIST DEBUG] Playlist state before cover art update: visible={self.playlist_sidebar.isVisible()}, "
                               f"minimized={getattr(self.playlist_sidebar, 'is_minimized', 'N/A')}")
                    logger.debug(f"[PLAYLIST DEBUG] Playlist state before cover art update: visible={self.playlist_sidebar.isVisible()}, "
                               f"minimized={getattr(self.playlist_sidebar, 'is_minimized', 'N/A')}")
                    if hasattr(self.playlist_sidebar, 'list_widget') and self.playlist_sidebar.list_widget:
                        print(f"[PLAYLIST DEBUG] list_widget state before: visible={self.playlist_sidebar.list_widget.isVisible()}, "
                                   f"geometry={self.playlist_sidebar.list_widget.geometry()}")
                        logger.debug(f"[PLAYLIST DEBUG] list_widget state before: visible={self.playlist_sidebar.list_widget.isVisible()}, "
                                   f"geometry={self.playlist_sidebar.list_widget.geometry()}")
                # Mini mode uses regular_player_widget (tracklist is hidden)
                # Update cover art in mini mode
                QTimer.singleShot(300, self.regular_player_widget._update_cover_art)
                # AUTOMATED TOGGLE FIX: Automatically toggle playlist off/on after cover art loads
                # This replicates the manual toggle that fixes the black display issue
                def auto_toggle_playlist_fix():
                    print("[PLAYLIST DEBUG] auto_toggle_playlist_fix called")
                    logger.debug("[PLAYLIST DEBUG] auto_toggle_playlist_fix called")
                    # Only do this if playlist is visible and we're in mini mode
                    if (hasattr(self, 'mini_mode_state') and self.mini_mode_state == 1 and
                        hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and
                        self.playlist_sidebar.isVisible() and
                        not self.playlist_detached):  # Don't toggle if detached
                        print("[PLAYLIST DEBUG] Conditions met, performing toggle")
                        logger.debug("[PLAYLIST DEBUG] Conditions met, performing toggle")
                        # Store minimized state
                        was_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
                        print(f"[PLAYLIST DEBUG] was_minimized={was_minimized}")
                        logger.debug(f"[PLAYLIST DEBUG] was_minimized={was_minimized}")
                        
                        # If playlist is minimized, we need to expand it first to toggle the list_widget
                        # If it's expanded, we can toggle the list_widget directly
                        if hasattr(self.playlist_sidebar, 'list_widget') and self.playlist_sidebar.list_widget:
                            list_widget = self.playlist_sidebar.list_widget
                            list_visible_before = list_widget.isVisible()
                            print(f"[PLAYLIST DEBUG] list_widget visible before toggle: {list_visible_before}")
                            logger.debug(f"[PLAYLIST DEBUG] list_widget visible before toggle: {list_visible_before}")
                            
                            # If minimized, expand first to make list_widget visible
                            if was_minimized:
                                print("[PLAYLIST DEBUG] Playlist is minimized, expanding first")
                                logger.debug("[PLAYLIST DEBUG] Playlist is minimized, expanding first")
                                self.playlist_sidebar._toggle_minimize_state()
                                # Small delay to let expand complete
                                QTimer.singleShot(10, lambda: QApplication.processEvents())
                                # Now list_widget should be visible
                                if list_widget.isVisible():
                                    print("[PLAYLIST DEBUG] List widget is now visible, toggling it")
                                    logger.debug("[PLAYLIST DEBUG] List widget is now visible, toggling it")
                                    # Toggle list_widget visibility to force repaint (very quickly to minimize flash)
                                    list_widget.hide()
                                    # Use singleShot with minimal delay instead of processEvents for smoother transition
                                    QTimer.singleShot(1, lambda: (
                                        list_widget.show() if hasattr(self, 'playlist_sidebar') and 
                                        self.playlist_sidebar and 
                                        hasattr(self.playlist_sidebar, 'list_widget') and 
                                        self.playlist_sidebar.list_widget else None,
                                        # Restore minimized state immediately after showing
                                        QTimer.singleShot(1, lambda: (
                                            self.playlist_sidebar._toggle_minimize_state() if 
                                            hasattr(self, 'playlist_sidebar') and 
                                            self.playlist_sidebar and 
                                            not getattr(self.playlist_sidebar, 'is_minimized', False) else None
                                        ))
                                    ))
                                else:
                                    print("[PLAYLIST DEBUG] List widget still not visible after expand")
                                    logger.debug("[PLAYLIST DEBUG] List widget still not visible after expand")
                            else:
                                # Playlist is expanded, toggle list_widget directly (very quickly to minimize flash)
                                print("[PLAYLIST DEBUG] Playlist is expanded, toggling list_widget directly")
                                logger.debug("[PLAYLIST DEBUG] Playlist is expanded, toggling list_widget directly")
                                list_widget.hide()
                                # Use singleShot with minimal delay for smoother transition
                                QTimer.singleShot(1, lambda: (
                                    list_widget.show() if hasattr(self, 'playlist_sidebar') and 
                                    self.playlist_sidebar and 
                                    hasattr(self.playlist_sidebar, 'list_widget') and 
                                    self.playlist_sidebar.list_widget else None
                                ))
                            
                            # Check list widget state after toggle
                            list_visible_after = list_widget.isVisible()
                            print(f"[PLAYLIST DEBUG] list_widget visible after toggle: {list_visible_after}")
                            logger.debug(f"[PLAYLIST DEBUG] list_widget visible after toggle: {list_visible_after}")
                            print(f"[PLAYLIST DEBUG] list_widget geometry: {list_widget.geometry()}")
                            print(f"[PLAYLIST DEBUG] list_widget size: {list_widget.size()}")
                            logger.debug(f"[PLAYLIST DEBUG] list_widget geometry: {list_widget.geometry()}")
                            logger.debug(f"[PLAYLIST DEBUG] list_widget size: {list_widget.size()}")
                        
                        # Ensure container is visible and raised
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            print(f"[PLAYLIST DEBUG] Container visible: {self.playlist_container.isVisible()}, raising")
                            logger.debug(f"[PLAYLIST DEBUG] Container visible: {self.playlist_container.isVisible()}, raising")
                            self.playlist_container.show()
                            self.playlist_container.raise_()
                        print("[PLAYLIST DEBUG] Raising playlist sidebar")
                        logger.debug("[PLAYLIST DEBUG] Raising playlist sidebar")
                        self.playlist_sidebar.raise_()
                        # Defer UI update instead of forcing immediate processing
                        QTimer.singleShot(0, lambda: (self.playlist_sidebar.update() if self.playlist_sidebar else None))
                        print("[PLAYLIST DEBUG] Toggle complete")
                        logger.debug("[PLAYLIST DEBUG] Toggle complete")
                    else:
                        print(f"[PLAYLIST DEBUG] Conditions not met: mini_mode_state={getattr(self, 'mini_mode_state', 'N/A')}, "
                                   f"playlist_sidebar exists={hasattr(self, 'playlist_sidebar')}, "
                                   f"playlist_visible={hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible()}, "
                                   f"detached={getattr(self, 'playlist_detached', False)}")
                        logger.debug(f"[PLAYLIST DEBUG] Conditions not met: mini_mode_state={getattr(self, 'mini_mode_state', 'N/A')}, "
                                   f"playlist_sidebar exists={hasattr(self, 'playlist_sidebar')}, "
                                   f"playlist_visible={hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible()}, "
                                   f"detached={getattr(self, 'playlist_detached', False)}")
                # Wait for cover art to load, then toggle (cover art loads ~300-700ms after page load)
                # Use shorter delays to reduce the time the playlist appears black
                QTimer.singleShot(600, auto_toggle_playlist_fix)   # After cover art should be loaded (reduced from 800ms)
                QTimer.singleShot(900, auto_toggle_playlist_fix)   # Safety net (reduced from 1200ms)
            elif self.mini_mode_state == 2 and self.micro_player_widget:
                # Update cover art in micro mode
                QTimer.singleShot(300, self.micro_player_widget._update_cover_art)
            
            # Update playlist sidebar tracklist if tracks tab is active (independent of mode)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                if hasattr(self.playlist_sidebar, 'active_tab') and self.playlist_sidebar.active_tab == 'tracks':
                    QTimer.singleShot(500, self.playlist_sidebar._update_playlist_tracklist)
        
        # Keep loading state until fade-in completes
        if success:
            # Mark that page has loaded at least once
            self._page_loaded_at_least_once = True
            
            # Reset JavaScript injection flag - new page means we need to inject again
            self._js_injected_on_current_page = False
            
            # Inject CSS if not already injected (fallback)
            if self.web_view and self.web_view.isVisible() and self.web_view.windowOpacity() < 0.5:
                # CSS wasn't injected at 30%, inject now
                self.inject_css_with_callback()
            else:
                # CSS already injected, just ensure it's applied and fade in
                # Always re-inject on page load to ensure image viewer and mini mode JavaScript is set up
                # Use inject_css_with_callback to wait for CSS injection before fading in
                # This prevents showing unstyled content (especially important for fast-loading Super Shuffle)
                self.inject_css_with_callback()
            
            # CRITICAL: Re-inject JavaScript after delays to ensure DOM elements are ready
            # This fixes issues where image viewer and mini mode player don't initialize on startup
            # The delays allow the page to fully render before setting up event handlers
            # Use longer delays for startup to ensure everything is ready
            # On first launch, use even longer delays to ensure everything is properly initialized
            def ensure_js_setup():
                if hasattr(self, 'web_view') and self.web_view and self.web_view.page():
                    # On first launch, ensure welcome widget is hidden before injecting JavaScript
                    # The welcome widget might interfere with DOM setup
                    is_first_launch = not self.settings.get('mini_mode_js_fixed', False)
                    if is_first_launch and hasattr(self, 'welcome_widget') and self.welcome_widget:
                        if self.welcome_widget.isVisible():
                            # Welcome widget still visible, hide it first
                            self.welcome_widget.hide()
                            # Wait a bit more before injecting to ensure DOM is stable
                            QTimer.singleShot(200, lambda: self.inject_css())
                            return
                    
                    # Re-inject to ensure all JavaScript is properly set up
                    # This is especially important on startup when DOM might not be ready yet
                    self.inject_css()
            
            # Check if this is a startup load - use longer delays if so
            is_startup = getattr(self, '_is_startup_load', False)
            # Check if this is first launch (settings file didn't exist) - use even longer delays
            # This works for both startup loads and manually loaded URLs on first launch
            is_first_launch = not self.settings.get('mini_mode_js_fixed', False)
            
            if is_startup or is_first_launch:
                # Startup or first launch: use longer delays to ensure page is fully ready
                # First launch needs even more time as everything is being initialized for the first time
                # This applies to both startup loads AND manually loaded URLs on first launch
                # Optimized delays: reduced from original values since webview setup is now faster
                if is_first_launch:
                    # First launch: optimized delays (reduced from 2s/4s/6s/8s to 1s/2s/3s/4s)
                    QTimer.singleShot(1000, ensure_js_setup)   # After initial load
                    QTimer.singleShot(2000, ensure_js_setup)   # After more elements load
                    QTimer.singleShot(3000, ensure_js_setup)   # After even more elements load
                    QTimer.singleShot(4000, ensure_js_setup)   # Final catch-all for first launch
                    # Mark that we've done this fix so it doesn't happen again (persists in settings)
                    # Only set the flag after the first successful injection to ensure it works
                    def mark_fixed():
                        self.settings['mini_mode_js_fixed'] = True
                        self.save_settings()
                    QTimer.singleShot(4500, mark_fixed)  # Set flag after all injections complete
                else:
                    # Regular startup: optimized delays (reduced from 1s/2s/3.5s/5s to 500ms/1s/2s/3s)
                    QTimer.singleShot(500, ensure_js_setup)   # After initial load
                    QTimer.singleShot(1000, ensure_js_setup)   # After more elements load
                    QTimer.singleShot(2000, ensure_js_setup)   # After even more elements load
                    QTimer.singleShot(3000, ensure_js_setup)   # Final catch-all for startup
            else:
                # Regular load: shorter delays (page is usually ready faster)
                QTimer.singleShot(500, ensure_js_setup)   # After initial load
                QTimer.singleShot(1000, ensure_js_setup)   # After more elements load
                QTimer.singleShot(2000, ensure_js_setup)   # Final catch-all
            
            # Force light page detection after page load with multiple retries
            # This ensures light-page class is applied even if detection ran too early
            def trigger_light_page_detection():
                if self.web_view and self.web_view.page():
                    # Call the global function we created in JavaScript
                    self.web_view.page().runJavaScript("""
                        if (typeof window._runLightPageDetection === 'function') {
                            window._runLightPageDetection();
                        }
                    """)
            
            # Run detection multiple times with increasing delays to catch styles as they load
            QTimer.singleShot(300, trigger_light_page_detection)  # After CSS injection
            QTimer.singleShot(600, trigger_light_page_detection)  # After styles compute
            QTimer.singleShot(1000, trigger_light_page_detection)  # Final check
            
            # Check for updates after page has loaded (only once, and only if auto-check is enabled)
            # Delay to ensure JavaScript injection is complete and won't be interfered with
            if not self._update_check_done:
                auto_check_enabled = self.settings.get("auto_check_updates", True)
                if auto_check_enabled:
                    # Determine delay based on whether this is first launch
                    is_first_launch = not self.settings.get('mini_mode_js_fixed', False)
                    if is_first_launch:
                        # First launch: wait until after all JavaScript injections complete (optimized from 10s to 5s)
                        delay = 5000
                    else:
                        # Regular load: wait until after JavaScript injections complete (optimized: 3s for startup, 2s for regular)
                        if is_startup:
                            delay = 3000
                        else:
                            delay = 2000
                    
                    def check_updates_after_load():
                        if not self._update_check_done:
                            self._update_check_done = True
                            self._check_for_updates_background()
                    
                    QTimer.singleShot(delay, check_updates_after_load)
            
            # Extract title from page and update title bar
            self.update_title_from_page()
            
            # Extract metadata from page DOM and update playlist item
            # Small delay to ensure DOM is fully ready
            QTimer.singleShot(500, self.extract_metadata_from_page)
            
            # Create shuffled track list if Shuffle Tracks mode is active
            # Check both playlist sidebar and main window shuffle mode
            shuffle_mode_1_active = False
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                if self.playlist_sidebar.shuffle_mode == 1:
                    shuffle_mode_1_active = True
            elif hasattr(self, 'shuffle_mode') and self.shuffle_mode == 1:
                shuffle_mode_1_active = True
            
            if shuffle_mode_1_active:
                current_url = self.web_view.url().toString()
                # Delay to ensure tracklist is loaded, with retry mechanism
                def create_list_with_retry():
                    # Only create if not already created for this album
                    if (not hasattr(self, '_shuffled_track_list') or 
                        not self._shuffled_track_list or 
                        not hasattr(self, '_shuffled_track_album_url') or 
                        self._shuffled_track_album_url != current_url):
                        self._create_shuffled_track_list(current_url)
                QTimer.singleShot(500, create_list_with_retry)  # First attempt
                QTimer.singleShot(1000, create_list_with_retry)  # Retry if first fails
                QTimer.singleShot(2000, create_list_with_retry)  # Final retry
            
            # Pick random track for Super Shuffle mode when page is ready
            if hasattr(self, '_is_super_shuffle_load') and self._is_super_shuffle_load:
                # Small delay to ensure tracklist DOM is ready
                QTimer.singleShot(500, self._pick_super_shuffle_track)
            
            # Check if we should activate mini/micro mode after page load (startup)
            # Similar to nano mode, we start in regular mode and switch after initialization
            if hasattr(self, '_activate_mini_mode_after_page_load') and self._activate_mini_mode_after_page_load is not None:
                target_mode = self._activate_mini_mode_after_page_load
                print(f"[STARTUP DEBUG] Activating mini mode {target_mode} after page load")
                
                def activate_mini_mode_after_load():
                    try:
                        # Switch to the saved mode
                        self.mini_mode_state = target_mode
                        self.apply_mini_mode()
                        
                        # CRITICAL: Ensure tracklist is hidden in mini/micro mode
                        # This is especially important when switching from regular mode after startup
                        if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                            if hasattr(self.regular_player_widget, 'tracklist_widget') and self.regular_player_widget.tracklist_widget:
                                self.regular_player_widget.tracklist_widget.hide()
                                self.regular_player_widget.tracklist_widget.setVisible(False)
                                print(f"[STARTUP DEBUG] Hid tracklist when switching to mode {target_mode}")
                        
                        # Also ensure tracklist is hidden with a delayed check (in case it becomes visible again)
                        def ensure_tracklist_hidden():
                            if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                                if hasattr(self.regular_player_widget, 'tracklist_widget') and self.regular_player_widget.tracklist_widget:
                                    if self.regular_player_widget.tracklist_widget.isVisible():
                                        self.regular_player_widget.tracklist_widget.hide()
                                        self.regular_player_widget.tracklist_widget.setVisible(False)
                                        print(f"[STARTUP DEBUG] Tracklist was visible, hid it again")
                        QTimer.singleShot(100, ensure_tracklist_hidden)
                        QTimer.singleShot(300, ensure_tracklist_hidden)
                        
                        # Update UI to reflect the mode
                        self.update_mini_mode_button()
                        self.update_mini_mode_menu_text()
                        print(f"[STARTUP DEBUG] Successfully switched to mode {target_mode}")
                        # Clear the flag
                        self._activate_mini_mode_after_page_load = None
                    except Exception as e:
                        logger.error(f"Error activating mini mode after page load: {e}")
                        print(f"[STARTUP DEBUG] Error activating mini mode: {e}")
                        self._activate_mini_mode_after_page_load = None
                
                # Delay activation to ensure everything is initialized
                QTimer.singleShot(500, activate_mini_mode_after_load)
            
            # Check if we should activate nano mode after page load (startup)
            if hasattr(self, '_activate_nano_after_page_load') and self._activate_nano_after_page_load:
                # Wait a bit more for CSS injection and mini mode resizing to complete
                # Also ensure playlist is created and restored before entering nano mode
                def activate_nano_after_load():
                    # Ensure playlist is created and restored before entering nano mode
                    # This ensures shuffle/repeat buttons can sync correctly
                    playlist_visible = self.settings.get("playlist_visible", True)  # Default to visible
                    playlist_was_closed = not playlist_visible
                    
                    if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
                        # Playlist doesn't exist - create it to initialize shuffle/repeat states
                        # This is needed even if playlist is closed, so nano player can sync buttons
                        self.toggle_playlist()
                        # If playlist was supposed to be closed, hide it again after initialization
                        if playlist_was_closed:
                            # Small delay to ensure playlist is fully initialized, then hide it
                            def hide_playlist_and_enter_nano():
                                self.toggle_playlist()  # Hide playlist
                                # Now enter nano mode and sync buttons
                                if self.nano_mode_on_minimize and not self._main_window_hidden_for_nano:
                                    self._enter_nano_mode()
                                    # Mark that we started in nano mode (for first restore workaround)
                                    self._first_restore_from_nano = True
                                    logger.debug(f"Set _first_restore_from_nano=True after entering nano mode on startup")
                                    # Sync buttons after nano player is created
                                    if hasattr(self, 'nano_player_window') and self.nano_player_window:
                                        QTimer.singleShot(100, self.nano_player_window._sync_shuffle_repeat_buttons)
                                self._activate_nano_after_page_load = False
                            QTimer.singleShot(100, hide_playlist_and_enter_nano)
                        else:
                            # Playlist should be visible - enter nano mode normally
                            if self.nano_mode_on_minimize and not self._main_window_hidden_for_nano:
                                self._enter_nano_mode()
                                # Mark that we started in nano mode (for first restore workaround)
                                self._first_restore_from_nano = True
                                logger.debug(f"Set _first_restore_from_nano=True after entering nano mode on startup")
                            self._activate_nano_after_page_load = False
                    elif hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        # Playlist exists - ensure state is restored
                        if hasattr(self, '_restore_playlist_state_pending') and self._restore_playlist_state_pending:
                            self._restore_playlist_state()
                            self._restore_playlist_state_pending = False
                        
                        if self.nano_mode_on_minimize and not self._main_window_hidden_for_nano:
                            self._enter_nano_mode()
                            # Mark that we started in nano mode (for first restore workaround)
                            self._first_restore_from_nano = True
                            logger.debug(f"Set _first_restore_from_nano=True after entering nano mode on startup")
                        self._activate_nano_after_page_load = False
                    else:
                        # No playlist and shouldn't create it (shouldn't happen, but handle gracefully)
                        if self.nano_mode_on_minimize and not self._main_window_hidden_for_nano:
                            self._enter_nano_mode()
                        self._first_restore_from_nano = True
                        logger.debug(f"Set _first_restore_from_nano=True after entering nano mode on startup")
                    self._activate_nano_after_page_load = False
                QTimer.singleShot(500, activate_nano_after_load)
            
            # Update playlist current item selection after page is loaded
            # This ensures the playlist item is selected on startup when loading last played URL
            # Use a delay to ensure playlist is fully loaded and ready
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                # Get the current URL from the web view
                current_url = self.web_view.url().toString() if self.web_view else None
                if current_url:
                    # Delay to ensure playlist is ready (especially on startup)
                    QTimer.singleShot(200, lambda: self.playlist_sidebar.update_current_item(current_url) if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else None)
            
            # Apply mini/micro mode resize now that page is loaded
            # This ensures dimensions are available for accurate resizing
            if hasattr(self, 'mini_mode_state'):
                # Ensure original size is set before resizing
                # IMPORTANT: Only set original size if we're actually in mini/micro mode
                # and if the current size is NOT micro mode size (to avoid saving micro size as original)
                # Only resize if we're still in the same mode (don't resize if user switched modes)
                if self.mini_mode_state == 1:
                    # Mini mode: wait a bit for carousel to be ready, then resize
                    QTimer.singleShot(200, self.resize_to_mini_mode)
                elif self.mini_mode_state == 2:
                    # Micro mode: resize to player size
                    # Only resize if we're still in micro mode (user hasn't switched)
                    QTimer.singleShot(100, self.resize_to_micro_mode)
            
            # Apply volume setting
            QTimer.singleShot(500, self.apply_volume)
            
            # Set up playback monitoring for repeat functionality
            QTimer.singleShot(1000, self.setup_playback_monitoring)
            
            # Set up first playback detection for micro mode layout refresh
            if self.mini_mode_state == 2:
                QTimer.singleShot(1000, self.setup_first_playback_detection)
            # Auto-play first track if loaded via repeat - trigger when overlay is hidden
            if hasattr(self, '_auto_play_next_album') and self._auto_play_next_album:
                # Don't set a timer here - we'll trigger it when the overlay is hidden
                # This ensures the page is fully loaded and ready
                pass
            # Safety fallback: force hide after 1 second (reduced from 2 seconds)
            QTimer.singleShot(1000, self.force_hide_overlay)
        else:
            # If load failed, still show the page
            # Clear Super Shuffle flags if they were set (page load failed)
            if hasattr(self, '_is_super_shuffle_load') and self._is_super_shuffle_load:
                logger.debug("Page load failed, clearing Super Shuffle flags")
                self._is_super_shuffle_load = False
                self._super_shuffle_album_url = None
            # Don't show webview if using Qt widgets
            use_qt = getattr(self, 'use_qt_widgets', True)
            if not use_qt and self.web_view:
                self.web_view.show()
                self.web_view.setWindowOpacity(1.0)
            QTimer.singleShot(100, self.fade_in_page)
            QTimer.singleShot(1000, self.force_hide_overlay)
    
    def force_hide_overlay(self):
        """Force hide the loading overlay (safety fallback)"""
        # Clear loading state
        self.is_loading = False
        # Restore context menu policy on web view
        if self.web_view and self._original_context_menu_policy is not None:
            self.web_view.setContextMenuPolicy(self._original_context_menu_policy)
            self._original_context_menu_policy = None
        if self.loading_overlay:
            # Stop any animations
            if self.loading_overlay.graphicsEffect():
                effect = self.loading_overlay.graphicsEffect()
                if isinstance(effect, QPropertyAnimation):
                    effect.stop()
            # Hide completely
            self.loading_overlay.hide()
            self.loading_overlay.setVisible(False)
            self.loading_overlay.setGraphicsEffect(None)
            self.loading_overlay.lower()  # Move behind other widgets
            # Ensure it's not taking up space
            self.loading_overlay.setGeometry(0, 0, 0, 0)
        # Don't show webview if using Qt widgets
        use_qt = getattr(self, 'use_qt_widgets', True)
        if not use_qt and self.web_view:
            self.web_view.show()
            # Re-enable mouse events when webview is shown
            self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
            self.web_view.setWindowOpacity(1.0)
            self.web_view.raise_()
            if self.web_view.graphicsEffect():
                effect = self.web_view.graphicsEffect()
                if isinstance(effect, QGraphicsOpacityEffect):
                    effect.setOpacity(1.0)
        
        # Auto-play specific track if set (for Repeat 1 Track, Super Shuffle, Shuffle Tracks)
        if hasattr(self, '_auto_play_track_number') and self._auto_play_track_number is not None:
            track_num = self._auto_play_track_number
            self._auto_play_track_number = None  # Reset flag
            logger.debug(f"Auto-playing specific track: {track_num}")
            self.auto_play_first_track(track_number=track_num)
        # Auto-play first track if loaded via repeat (now that overlay is hidden and page is ready)
        elif hasattr(self, '_auto_play_next_album') and self._auto_play_next_album:
            self._auto_play_next_album = False  # Reset flag
            # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
            self.auto_play_first_track()
        # Auto-play logic: check startup autoplay first if it's a startup load, otherwise check regular autoplay
        elif hasattr(self, '_is_startup_load') and self._is_startup_load:
            # This is a startup load - only check autoplay_on_startup (independent of regular autoplay)
            if self.autoplay_on_startup:
                # Get saved track number from settings (if available)
                saved_track_number = self.settings.get("last_played_track_number")
                logger.debug(f"force_hide_overlay autoplay: Retrieved saved_track_number from settings: {saved_track_number}")
                # Ensure it's an integer if it exists
                if saved_track_number is not None:
                    try:
                        saved_track_number = int(saved_track_number)
                        logger.debug(f"force_hide_overlay autoplay: Converted to integer: {saved_track_number}")
                    except (ValueError, TypeError):
                        logger.debug(f"force_hide_overlay autoplay: Failed to convert to integer, using None")
                        saved_track_number = None
                else:
                    logger.debug(f"force_hide_overlay autoplay: No saved track number found, will play first track")
                # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
                # Scroll prevention is now handled inside auto_play_first_track() to prevent jitter
                logger.debug(f"force_hide_overlay autoplay: Calling auto_play_first_track with track_number={saved_track_number}")
                self.auto_play_first_track(track_number=saved_track_number)
            # Reset startup flag after checking (regardless of whether autoplay happened)
            self._is_startup_load = False
        # Regular autoplay (for non-startup loads)
        elif self.autoplay:
            # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
            self.auto_play_first_track()
    
    def fade_in_page(self):
        """Fade in the web view and hide loading overlay"""
        logger.debug("[PLAYLIST DEBUG] fade_in_page called")
        # Check playlist state during fade
        if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 1:
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                logger.debug(f"[PLAYLIST DEBUG] Playlist state during fade: visible={self.playlist_sidebar.isVisible()}, "
                           f"minimized={getattr(self.playlist_sidebar, 'is_minimized', 'N/A')}")
                if hasattr(self.playlist_sidebar, 'list_widget') and self.playlist_sidebar.list_widget:
                    logger.debug(f"[PLAYLIST DEBUG] list_widget state during fade: visible={self.playlist_sidebar.list_widget.isVisible()}, "
                               f"geometry={self.playlist_sidebar.list_widget.geometry()}")
        # Don't show webview if using Qt widgets
        use_qt = getattr(self, 'use_qt_widgets', True)
        if use_qt:
            if self.loading_overlay:
                self.loading_overlay.hide()
            return
        
        if not self.web_view or not self.loading_overlay:
            # Fallback: just hide overlay if something is wrong
            if self.loading_overlay:
                self.loading_overlay.hide()
            if self.web_view:
                self.web_view.show()
                # Re-enable mouse events when webview is shown
                self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
            return
        
        # Show web view (was hidden during load)
        self.web_view.show()
        # Re-enable mouse events when webview is shown
        self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        self.web_view.raise_()
        
        # Set initial opacity for fade-in
        self.web_view.setWindowOpacity(0.0)
        
        try:
            # Create graphics opacity effects for smooth animation
            web_view_effect = QGraphicsOpacityEffect(self.web_view)
            self.web_view.setGraphicsEffect(web_view_effect)
            web_view_effect.setOpacity(0.0)
            
            # Ensure overlay is visible and raised above web view before applying fade effect
            # (playlist container can be raised above overlay separately)
            # Update geometry before showing to ensure it's correct
            if self.is_loading:
                self.update_loading_overlay_geometry()
            if not self.loading_overlay.isVisible():
                self.loading_overlay.show()
            self.loading_overlay.raise_()
            # Ensure playlist stays above overlay if it's visible
            if hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible():
                self.playlist_container.raise_()
            
            overlay_effect = QGraphicsOpacityEffect(self.loading_overlay)
            self.loading_overlay.setGraphicsEffect(overlay_effect)
            # Use the transparency setting to determine initial opacity
            initial_opacity = 0.7 if self.transparent_overlay else 1.0
            overlay_effect.setOpacity(initial_opacity)
            
            # Create fade animation for web view
            fade_animation = QPropertyAnimation(web_view_effect, b"opacity")
            fade_animation.setDuration(150)  # Faster fade (reduced from 300ms)
            # Start from current opacity (might be 0.3 if shown early)
            current_opacity = web_view_effect.opacity() if web_view_effect else 0.0
            fade_animation.setStartValue(current_opacity)
            fade_animation.setEndValue(1.0)
            fade_animation.setEasingCurve(QEasingCurve.Type.InOutQuad)
            
            # Fade out loading overlay smoothly
            # Use the transparency setting to determine start opacity
            start_opacity = 0.7 if self.transparent_overlay else 1.0
            overlay_fade = QPropertyAnimation(overlay_effect, b"opacity")
            overlay_fade.setDuration(150)  # Faster fade (reduced from 300ms)
            overlay_fade.setStartValue(start_opacity)
            overlay_fade.setEndValue(0.0)
            overlay_fade.setEasingCurve(QEasingCurve.Type.InOutQuad)
            
            def hide_overlay():
                # Clear loading state
                self.is_loading = False
                # Restore context menu policy on web view
                if self.web_view and self._original_context_menu_policy is not None:
                    self.web_view.setContextMenuPolicy(self._original_context_menu_policy)
                    self._original_context_menu_policy = None
                if self.loading_overlay:
                    # Animation finished, now hide it completely
                    self.loading_overlay.hide()
                    self.loading_overlay.setVisible(False)
                    self.loading_overlay.setGraphicsEffect(None)
                    self.loading_overlay.lower()
                    # Ensure it's not taking up space - set geometry to zero
                    self.loading_overlay.setGeometry(0, 0, 0, 0)
                if self.web_view:
                    web_view_effect.setOpacity(1.0)
                    self.web_view.setWindowOpacity(1.0)
                    self.web_view.raise_()
                
                # Auto-play first track if loaded via repeat (now that overlay is hidden and page is ready)
                if hasattr(self, '_auto_play_next_album') and self._auto_play_next_album:
                    self._auto_play_next_album = False  # Reset flag
                    # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
                    self.auto_play_first_track()
                # Auto-play logic: check Super Shuffle first (if track was selected), then startup, then regular
                elif hasattr(self, '_auto_play_track_number') and self._auto_play_track_number is not None:
                    # Super Shuffle (or other modes) has selected a specific track - play it immediately
                    track_num = self._auto_play_track_number
                    self._auto_play_track_number = None  # Reset flag
                    logger.debug(f"Super Shuffle autoplay: Playing track {track_num}")
                    self.auto_play_first_track(track_number=track_num)
                # Auto-play logic: check startup autoplay first if it's a startup load, otherwise check regular autoplay
                elif hasattr(self, '_is_startup_load') and self._is_startup_load:
                    # This is a startup load - only check autoplay_on_startup (independent of regular autoplay)
                    if self.autoplay_on_startup:
                        # Get saved track number from settings (if available)
                        saved_track_number = self.settings.get("last_played_track_number")
                        logger.debug(f"Startup autoplay: Retrieved saved_track_number from settings: {saved_track_number}")
                        # Ensure it's an integer if it exists
                        if saved_track_number is not None:
                            try:
                                saved_track_number = int(saved_track_number)
                                logger.debug(f"Startup autoplay: Converted to integer: {saved_track_number}")
                            except (ValueError, TypeError):
                                logger.debug(f"Startup autoplay: Failed to convert to integer, using None")
                                saved_track_number = None
                        else:
                            logger.debug(f"Startup autoplay: No saved track number found, will play first track")
                        # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
                        logger.debug(f"Startup autoplay: Calling auto_play_first_track with track_number={saved_track_number}")
                        self.auto_play_first_track(track_number=saved_track_number)
                        # Scroll to top in regular mode when autoplay happens on startup
                        if self.mini_mode_state == 0:  # Regular mode only
                            scroll_to_top_js = """
                            (function() {
                                window.scrollTo({ top: 0, left: 0, behavior: 'instant' });
                                document.documentElement.scrollTop = 0;
                                document.body.scrollTop = 0;
                            })();
                            """
                            self.web_view.page().runJavaScript(scroll_to_top_js)
                    # Reset startup flag after checking (regardless of whether autoplay happened)
                    self._is_startup_load = False
                # Regular autoplay (for non-startup loads)
                elif self.autoplay:
                    # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
                    self.auto_play_first_track()
            
            overlay_fade.finished.connect(hide_overlay)
            
            # Fallback timer to force hide overlay if animation doesn't complete
            # Set to longer than animation duration to allow fade to complete
            def force_hide_local():
                # Only force hide if overlay is still visible (animation might have failed)
                if self.loading_overlay and self.loading_overlay.isVisible():
                    # Check if animation is still running by checking opacity
                    current_effect = self.loading_overlay.graphicsEffect()
                    if current_effect and isinstance(current_effect, QGraphicsOpacityEffect):
                        # Animation might still be running, give it a bit more time
                        if current_effect.opacity() > 0.1:
                            QTimer.singleShot(200, force_hide_local)
                            return
                    # Animation finished or failed, hide it
                    self.is_loading = False
                    # Hide loading animation in nano mode if it exists
                    if hasattr(self, 'nano_player_window') and self.nano_player_window:
                        if hasattr(self.nano_player_window, '_check_and_show_loading_animation'):
                            self.nano_player_window._check_and_show_loading_animation()
                    # Restore context menu policy on web view
                    if self.web_view and self._original_context_menu_policy is not None:
                        self.web_view.setContextMenuPolicy(self._original_context_menu_policy)
                        self._original_context_menu_policy = None
                    self.loading_overlay.hide()
                    self.loading_overlay.setVisible(False)
                    self.loading_overlay.setGraphicsEffect(None)
                    self.loading_overlay.lower()
                    # Ensure it's not taking up space - set geometry to zero
                    self.loading_overlay.setGeometry(0, 0, 0, 0)
                if self.web_view:
                    self.web_view.setWindowOpacity(1.0)
                    self.web_view.raise_()
                    if self.web_view.graphicsEffect():
                        effect = self.web_view.graphicsEffect()
                        if isinstance(effect, QGraphicsOpacityEffect):
                            effect.setOpacity(1.0)
            
            QTimer.singleShot(600, force_hide_local)  # Force hide after 600ms (longer than 300ms animation)
            
            # Start both animations
            fade_animation.start()
            overlay_fade.start()
        except Exception as e:
            # If animation fails, just hide the overlay immediately
            logger.error(f"Fade animation error: {e}", exc_info=True)
            if self.loading_overlay:
                self.loading_overlay.hide()
                self.loading_overlay.setGraphicsEffect(None)
            # Don't show webview if using Qt widgets
            use_qt = getattr(self, 'use_qt_widgets', True)
            if not use_qt and self.web_view:
                self.web_view.show()
                self.web_view.setWindowOpacity(1.0)
                self.web_view.setGraphicsEffect(None)
    
    def inject_css_with_callback(self):
        """Inject CSS with callback to know when it's complete, then fade in immediately"""
        # Skip CSS injection if using Qt widgets (webview is hidden, CSS not needed for visuals)
        use_qt = getattr(self, 'use_qt_widgets', True)
        if use_qt:
            logger.debug("inject_css_with_callback: Skipping CSS injection (using Qt widgets, webview hidden)")
            # Still call fade_in_page since CSS injection is skipped
            QTimer.singleShot(10, self.fade_in_page)
            return
        
        # Safety check: ensure web_view and page exist before injecting
        if not hasattr(self, 'web_view') or not self.web_view:
            logger.warning("inject_css_with_callback: web_view not available, skipping injection")
            return
        if not self.web_view.page():
            logger.warning("inject_css_with_callback: web_view.page() not available, skipping injection")
            return
        
        css = self.css_injector.get_css(self.compact_mode, self.bandcamp_mode, self.mini_mode_state, False)  # webview_scrollbar_visible removed - always False
        if css:
            # Get the full JavaScript code (same as inject_css but with callback)
            js = self._get_css_injection_js(css)
            # Inject with callback - when CSS is injected, immediately fade in
            def on_css_injected(result):
                # Mark that JavaScript has been injected (image viewer and mini mode setup)
                self._js_injected_on_current_page = True
                # CSS injection complete, fade in immediately (minimal delay)
                QTimer.singleShot(10, self.fade_in_page)
            
            self.web_view.page().runJavaScript(js, on_css_injected)
    
    def _get_bandcamp_mode_hide_js(self):
        """Get JavaScript code to hide unwanted Bandcamp elements"""
        return """
                    var elementsToHide = [
                        '#sticky-player',
                        '.sticky-player-container',
                        '#sticky-player-marker',
                        'nav#menubar.logged-in',
                        'header#tralbum-header.tralbum-header',
                        'div#tralbum-actions.tralbum-actions-container.desktop-right',
                        'div#tralbum-digital-only.tralbum-digital-only-container.desktop-left',
                        'section#supporters.supporters-container.desktop-right',
                        'section#tags.tags-container.desktop-left',
                        'section#artist-profile.desktop-sidebar.artist-profile-container',
                        'section#recommendations-footer.recommendations-footer-container.desktop-footer',
                        'section#tralbum-credits',
                        'section#purchase-options'
                    ];
                    
                    elementsToHide.forEach(function(selector) {
                        var elements = document.querySelectorAll(selector);
                        elements.forEach(function(el) {
                            el.style.display = 'none';
                            el.style.visibility = 'hidden';
                            el.style.opacity = '0';
                            el.style.pointerEvents = 'none';
                        });
                    });
                """
    
    def _get_mini_mode_class_js(self):
        """Get JavaScript code to apply mini mode classes"""
        return f"""
                // Windows 10 fix: Check if document.body exists before accessing classList
                // This prevents crashes when switching modes during page transitions
                if (document.body) {{
                    // ALWAYS remove deprecated 'mini-mode-player-hidden' class (fully hidden mode removed)
                    // This ensures the player is never stuck in hidden state
                    document.body.classList.remove('mini-mode-player-hidden');
                    
                    if ({self.mini_mode_state} === 1) {{
                        document.body.classList.add('mini-mode');
                        document.body.classList.remove('micro-mode');
                        
                        // Apply mini mode player autohide class if enabled
                        // Autohide event listeners will be set up on-demand when user interacts with mini mode
                        if ({'true' if self.mini_mode_player_autohide else 'false'}) {{
                            document.body.classList.add('mini-mode-autohide');
                        }}
                        
                        // Function to set up autohide hover listeners on-demand
                        // This is called when user actually interacts with mini mode, ensuring DOM is ready
                        function setupAutohideOnDemand() {{
                            // Verify DOM is ready
                            if (!document.body) {{
                                return; // Body doesn't exist yet
                            }}
                            
                            // Only set up if autohide is enabled and we're in mini mode
                            if (!document.body.classList.contains('mini-mode-autohide')) {{
                                return;
                            }}
                            
                            var player = document.querySelector('#player');
                            if (!player) {{
                                return; // Player doesn't exist yet
                            }}
                            
                            // Verify player is actually in DOM and has dimensions
                            var rect = player.getBoundingClientRect();
                            if (!rect || (rect.width === 0 && rect.height === 0)) {{
                                return; // Player exists but not rendered yet
                            }}
                            
                            // If already set up, skip
                            if (player.hasAttribute('data-autohide-setup')) {{
                                return;
                            }}
                            
                            // Remove old listeners if they exist (cleanup)
                            var oldEnterHandler = player._bandcampAutohideEnterHandler;
                            var oldLeaveHandler = player._bandcampAutohideLeaveHandler;
                            if (oldEnterHandler) {{
                                player.removeEventListener('mouseenter', oldEnterHandler);
                            }}
                            if (oldLeaveHandler) {{
                                player.removeEventListener('mouseleave', oldLeaveHandler);
                            }}
                            
                            // Create new event handlers and store references
                            var enterHandler = function() {{
                                player.classList.add('player-hovered');
                            }};
                            var leaveHandler = function() {{
                                player.classList.remove('player-hovered');
                            }};
                            
                            // Store handlers so we can remove them later
                            player._bandcampAutohideEnterHandler = enterHandler;
                            player._bandcampAutohideLeaveHandler = leaveHandler;
                            
                            // Add new event listeners
                            player.addEventListener('mouseenter', enterHandler);
                            player.addEventListener('mouseleave', leaveHandler);
                            
                            // Mark as set up
                            player.setAttribute('data-autohide-setup', 'true');
                        }}
                        
                        // Set up autohide on-demand when switching to mini mode
                        // Since this is triggered by user action (mode switch), DOM should be ready
                        if (document.body.classList.contains('mini-mode-autohide')) {{
                            // Verify setup succeeded
                            function verifySetup() {{
                                var player = document.querySelector('#player');
                                if (player && player.hasAttribute('data-autohide-setup')) {{
                                    // Setup succeeded - verify handlers exist
                                    if (player._bandcampAutohideEnterHandler && player._bandcampAutohideLeaveHandler) {{
                                        return true; // Setup verified
                                    }}
                                }}
                                return false; // Setup not complete
                            }}
                            
                            // Try to set up immediately (user just switched to mini mode, DOM should be ready)
                            setupAutohideOnDemand();
                            
                            // Verify setup succeeded after a short delay
                            setTimeout(function() {{
                                if (!verifySetup()) {{
                                    // Setup didn't succeed, retry
                                    setupAutohideOnDemand();
                                }}
                            }}, 100);
                            
                            // If player doesn't exist yet, set up when it appears
                            // Use a simple retry with short delay (user action means page is likely ready)
                            var retryCount = 0;
                            var maxRetries = 8; // Increased retries for startup reliability
                            var checkPlayer = function() {{
                                var player = document.querySelector('#player');
                                if (player && !player.hasAttribute('data-autohide-setup')) {{
                                    setupAutohideOnDemand();
                                    // Verify after setup
                                    setTimeout(function() {{
                                        if (!verifySetup()) {{
                                            setupAutohideOnDemand(); // Retry if failed
                                        }}
                                    }}, 100);
                                }} else if (!player && retryCount < maxRetries) {{
                                    retryCount++;
                                    setTimeout(checkPlayer, 150); // Slightly longer delay
                                }}
                            }};
                            
                            // Start checking after a small delay to ensure DOM is stable
                            setTimeout(checkPlayer, 100);
                            
                            // Also set up when player is added dynamically
                            if (typeof MutationObserver !== 'undefined') {{
                                var observer = new MutationObserver(function(mutations) {{
                                    var player = document.querySelector('#player');
                                    if (player && !player.hasAttribute('data-autohide-setup')) {{
                                        setupAutohideOnDemand();
                                    }}
                                }});
                                observer.observe(document.body, {{
                                    childList: true,
                                    subtree: true
                                }});
                            }}
                        }} else {{
                            // Autohide disabled - clean up
                            document.body.classList.remove('mini-mode-autohide');
                            
                            var player = document.querySelector('#player');
                            if (player) {{
                                player.classList.remove('player-hovered');
                                
                                // Remove event listeners if they exist
                                var oldEnterHandler = player._bandcampAutohideEnterHandler;
                                var oldLeaveHandler = player._bandcampAutohideLeaveHandler;
                                if (oldEnterHandler) {{
                                    player.removeEventListener('mouseenter', oldEnterHandler);
                                    delete player._bandcampAutohideEnterHandler;
                                }}
                                if (oldLeaveHandler) {{
                                    player.removeEventListener('mouseleave', oldLeaveHandler);
                                    delete player._bandcampAutohideLeaveHandler;
                                }}
                                
                                player.removeAttribute('data-autohide-setup');
                            }}
                        }}
                        
                        // Setup player visibility toggle button in mini mode only (not micro mode)
                        function setupPlayerVisibilityToggleButton() {{
                            var player = document.querySelector('#player');
                            var existingBtn = document.getElementById('bandcamp-player-visibility-toggle');
                            
                            // Check current mode
                            var isMiniMode = document.body.classList.contains('mini-mode');
                            var isMicroMode = document.body.classList.contains('micro-mode');
                            var isRegularMode = !isMiniMode && !isMicroMode;
                            
                            // Hide button if not in mini mode (regular mode or micro mode)
                            if (!player || {self.mini_mode_state} !== 1 || isMicroMode || isRegularMode) {{
                                if (existingBtn) {{
                                    // Hide button instead of removing it (so it can be shown again if needed)
                                    existingBtn.style.display = 'none';
                                    existingBtn.style.visibility = 'hidden';
                                    existingBtn.style.pointerEvents = 'none';
                                }}
                                return;
                            }}
                            
                            // Also check if we're in micro mode (shouldn't happen if state is 1, but double-check)
                            if (isMicroMode) {{
                                if (existingBtn) {{
                                    existingBtn.style.display = 'none';
                                    existingBtn.style.visibility = 'hidden';
                                    existingBtn.style.pointerEvents = 'none';
                                }}
                                return;
                            }}
                            
                            // Button is only visible in mini mode (not regular or micro mode)
                            // Check if button already exists
                            var toggleBtn = existingBtn;
                            if (!toggleBtn) {{
                                // Create toggle button
                                toggleBtn = document.createElement('div');
                                toggleBtn.id = 'bandcamp-player-visibility-toggle';
                                toggleBtn.setAttribute('aria-label', 'Toggle Player Visibility');
                                toggleBtn.title = 'Toggle Player Visibility: Visible  Autohide';
                                
                                // Set icon based on current state
                                var isAutohide = document.body.classList.contains('mini-mode-autohide');
                                if (isAutohide) {{
                                    toggleBtn.textContent = '';
                                }} else {{
                                    toggleBtn.textContent = '';
                                }}
                                
                                // Add click handler
                                toggleBtn.addEventListener('click', function(e) {{
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    
                                    // Set global variable for Python to poll
                                    window._bandcampPlayerVisibilityToggle = true;
                                }});
                                
                                // Append to body instead of player so it stays visible when player is hidden
                                document.body.appendChild(toggleBtn);
                            }} else {{
                                // Update icon if button exists
                                var isAutohide = document.body.classList.contains('mini-mode-autohide');
                                if (isAutohide) {{
                                    toggleBtn.textContent = '';
                                }} else {{
                                    toggleBtn.textContent = '';
                                }}
                                
                                // Only show button in mini mode (not regular or micro mode)
                                var isMiniMode = document.body.classList.contains('mini-mode');
                                var isMicroMode = document.body.classList.contains('micro-mode');
                                if (isMiniMode && !isMicroMode) {{
                                    toggleBtn.style.display = 'flex';
                                    toggleBtn.style.visibility = 'visible';
                                }} else {{
                                    // Hide button in regular mode or micro mode
                                    toggleBtn.style.display = 'none';
                                    toggleBtn.style.visibility = 'hidden';
                                }}
                            }}
                        }}
                        
                        // Setup button when in mini mode (with retry logic for startup)
                        if ({self.mini_mode_state} === 1) {{
                            // Setup with retry logic - player might not exist yet on startup
                            function setupButtonWithRetry(retryCount) {{
                                retryCount = retryCount || 0;
                                var maxRetries = 20;
                                var retryDelay = retryCount < 10 ? 100 : 300;
                                
                                var player = document.querySelector('#player');
                                if (player) {{
                                    // Player exists, set up button
                                    setupPlayerVisibilityToggleButton();
                                }} else if (retryCount < maxRetries) {{
                                    // Player doesn't exist yet, retry after delay
                                    setTimeout(function() {{
                                        setupButtonWithRetry(retryCount + 1);
                                    }}, retryDelay);
                                }}
                            }}
                            
                            // Start setup with retry - also check if page is ready
                            if (document.readyState === 'complete' || document.readyState === 'interactive') {{
                                // Page is ready, start setup immediately
                                setupButtonWithRetry();
                            }} else {{
                                // Page not ready yet, wait for it
                                document.addEventListener('DOMContentLoaded', function() {{
                                    setupButtonWithRetry();
                                }});
                                // Also try after a delay in case DOMContentLoaded already fired
                                setTimeout(function() {{
                                    setupButtonWithRetry();
                                }}, 100);
                            }}
                            
                            // Also setup when player is added dynamically or when classes change
                            if (typeof MutationObserver !== 'undefined') {{
                                var observer = new MutationObserver(function(mutations) {{
                                    // Only setup if player exists (avoid unnecessary calls)
                                    var player = document.querySelector('#player');
                                    if (player) {{
                                        setupPlayerVisibilityToggleButton();
                                    }}
                                }});
                                observer.observe(document.body, {{
                                    childList: true,
                                    subtree: true,
                                    attributes: true,
                                    attributeFilter: ['class']
                                }});
                            }}
                        }} else {{
                            // Remove button when not in mini mode
                            var toggleBtn = document.getElementById('bandcamp-player-autohide-toggle');
                            if (toggleBtn) {{
                                toggleBtn.remove();
                            }}
                        }}
                        
                        // Restore cover art visibility when switching to mini mode (with retry for startup)
                        function restoreCoverArtVisibility(retryCount) {{
                            retryCount = retryCount || 0;
                            var maxRetries = 20;
                            var retryDelay = retryCount < 10 ? 100 : 300;
                            
                            var coverArt = document.querySelector('#tralbum-art-carousel');
                            if (coverArt) {{
                                coverArt.style.display = '';
                                coverArt.style.visibility = '';
                                coverArt.style.height = '';
                                coverArt.style.maxHeight = '';
                                coverArt.style.width = '';
                                coverArt.style.margin = '';
                                coverArt.style.padding = '';
                            }} else if (retryCount < maxRetries) {{
                                // Cover art doesn't exist yet, retry after delay
                                setTimeout(function() {{
                                    restoreCoverArtVisibility(retryCount + 1);
                                }}, retryDelay);
                            }}
                        }}
                        
                        // Start restoration with retry - also check if page is ready
                        if (document.readyState === 'complete' || document.readyState === 'interactive') {{
                            // Page is ready, start restoration immediately
                            restoreCoverArtVisibility();
                        }} else {{
                            // Page not ready yet, wait for it
                            document.addEventListener('DOMContentLoaded', function() {{
                                restoreCoverArtVisibility();
                            }});
                            // Also try after a delay in case DOMContentLoaded already fired
                            setTimeout(function() {{
                                restoreCoverArtVisibility();
                            }}, 100);
                        }}
                        // Clear CSS custom property for micro mode player height
                        document.documentElement.style.removeProperty('--micro-mode-player-height');
                        
                        // Restore footer visibility when switching to mini mode
                        var footer = document.querySelector('#TralbumPageFooter');
                        if (footer) {{
                            footer.style.display = '';
                            footer.style.visibility = '';
                            footer.style.height = '';
                            footer.style.width = '';
                            footer.style.margin = '';
                            footer.style.padding = '';
                        }}
                        var tralbumFooter = document.querySelector('#tralbum-footer, footer#tralbum-footer');
                        if (tralbumFooter) {{
                            tralbumFooter.style.display = '';
                            tralbumFooter.style.visibility = '';
                            tralbumFooter.style.height = '';
                            tralbumFooter.style.width = '';
                            tralbumFooter.style.margin = '';
                            tralbumFooter.style.padding = '';
                        }}
                        
                        // Restore body/html height when switching to mini mode
                        document.body.style.height = '';
                        document.body.style.minHeight = '';
                        document.body.style.maxHeight = '';
                        document.documentElement.style.height = '';
                        document.documentElement.style.minHeight = '';
                        document.documentElement.style.maxHeight = '';
                        
                        // Also restore page containers
                        var pgBd = document.querySelector('#pgBd');
                        if (pgBd) {{
                            pgBd.style.height = '';
                            pgBd.style.minHeight = '';
                            pgBd.style.maxHeight = '';
                            pgBd.style.paddingBottom = '';
                            pgBd.style.marginBottom = '';
                        }}
                        var pageContainer = document.querySelector('.p-tralbum-page-container');
                        if (pageContainer) {{
                            pageContainer.style.height = '';
                            pageContainer.style.minHeight = '';
                            pageContainer.style.maxHeight = '';
                            pageContainer.style.paddingBottom = '';
                            pageContainer.style.marginBottom = '';
                        }}
                        var mainElement = document.querySelector('main#p-tralbum-page');
                        if (mainElement) {{
                            mainElement.style.height = '';
                            mainElement.style.minHeight = '';
                            mainElement.style.maxHeight = '';
                            mainElement.style.paddingBottom = '';
                            mainElement.style.marginBottom = '';
                        }}
                    }} else if ({self.mini_mode_state} === 2) {{
                        document.body.classList.add('micro-mode');
                        document.body.classList.remove('mini-mode');
                        document.body.classList.remove('mini-mode-autohide'); // Remove autohide class when not in mini mode
                        
                        // Micro mode: hide cover art completely and constrain body height
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            coverArt.style.display = 'none';
                            coverArt.style.visibility = 'hidden';
                            coverArt.style.height = '0';
                            coverArt.style.width = '0';
                            coverArt.style.margin = '0';
                            coverArt.style.padding = '0';
                        }}
                        
                        // Hide footer elements that add space below player
                        var footer = document.querySelector('#TralbumPageFooter');
                        if (footer) {{
                            footer.style.display = 'none';
                            footer.style.visibility = 'hidden';
                            footer.style.height = '0';
                            footer.style.width = '0';
                            footer.style.margin = '0';
                            footer.style.padding = '0';
                        }}
                        var tralbumFooter = document.querySelector('#tralbum-footer, footer#tralbum-footer');
                        if (tralbumFooter) {{
                            tralbumFooter.style.display = 'none';
                            tralbumFooter.style.visibility = 'hidden';
                            tralbumFooter.style.height = '0';
                            tralbumFooter.style.width = '0';
                            tralbumFooter.style.margin = '0';
                            tralbumFooter.style.padding = '0';
                        }}
                        
                        // Constrain body/html height to player height (no extra space)
                        var player = document.querySelector('#player');
                        if (player) {{
                            // Use setTimeout to ensure player is rendered
                            setTimeout(function() {{
                                var playerRect = player.getBoundingClientRect();
                                // Get the exact bottom position of the player element
                                var exactBottom = playerRect.bottom + window.scrollY;
                                // Subtract 44 pixels to account for extra space
                                var adjustedBottom = Math.max(50, exactBottom - 33);
                                
                                // Set body and html height to match adjusted player bottom position
                                document.body.style.height = adjustedBottom + 'px';
                                document.body.style.minHeight = adjustedBottom + 'px';
                                document.body.style.maxHeight = adjustedBottom + 'px';
                                document.documentElement.style.height = adjustedBottom + 'px';
                                document.documentElement.style.minHeight = adjustedBottom + 'px';
                                document.documentElement.style.maxHeight = adjustedBottom + 'px';
                                
                                // Also ensure page containers match exactly
                                var pgBd = document.querySelector('#pgBd');
                                if (pgBd) {{
                                    pgBd.style.height = adjustedBottom + 'px';
                                    pgBd.style.minHeight = adjustedBottom + 'px';
                                    pgBd.style.maxHeight = adjustedBottom + 'px';
                                    pgBd.style.paddingBottom = '0';
                                    pgBd.style.marginBottom = '0';
                                }}
                                var pageContainer = document.querySelector('.p-tralbum-page-container');
                                if (pageContainer) {{
                                    pageContainer.style.height = adjustedBottom + 'px';
                                    pageContainer.style.minHeight = adjustedBottom + 'px';
                                    pageContainer.style.maxHeight = adjustedBottom + 'px';
                                    pageContainer.style.paddingBottom = '0';
                                    pageContainer.style.marginBottom = '0';
                                }}
                                // Also target the main element
                                var mainElement = document.querySelector('main#p-tralbum-page');
                                if (mainElement) {{
                                    mainElement.style.height = adjustedBottom + 'px';
                                    mainElement.style.minHeight = adjustedBottom + 'px';
                                    mainElement.style.maxHeight = adjustedBottom + 'px';
                                    mainElement.style.paddingBottom = '0';
                                    mainElement.style.marginBottom = '0';
                                }}
                            }}, 50);
                        }}
                    }} else {{
                        document.body.classList.remove('mini-mode', 'micro-mode', 'mini-mode-autohide');
                        
                        // Hide visibility toggle button when switching to regular mode (CSS will handle it)
                        // Don't remove it, just let CSS hide it
                        
                        // Restore cover art visibility when switching to regular mode
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            coverArt.style.display = '';
                            coverArt.style.visibility = '';
                            coverArt.style.height = '';
                            coverArt.style.width = '';
                            coverArt.style.margin = '';
                            coverArt.style.padding = '';
                        }}
                        
                        // Restore footer visibility when switching to regular mode
                        var footer = document.querySelector('#TralbumPageFooter');
                        if (footer) {{
                            footer.style.display = '';
                            footer.style.visibility = '';
                            footer.style.height = '';
                            footer.style.width = '';
                            footer.style.margin = '';
                            footer.style.padding = '';
                        }}
                        var tralbumFooter = document.querySelector('#tralbum-footer, footer#tralbum-footer');
                        if (tralbumFooter) {{
                            tralbumFooter.style.display = '';
                            tralbumFooter.style.visibility = '';
                            tralbumFooter.style.height = '';
                            tralbumFooter.style.width = '';
                            tralbumFooter.style.margin = '';
                            tralbumFooter.style.padding = '';
                        }}
                        
                        // Restore body/html height when switching to regular mode
                        document.body.style.height = '';
                        document.body.style.minHeight = '';
                        document.body.style.maxHeight = '';
                        document.documentElement.style.height = '';
                        document.documentElement.style.minHeight = '';
                        document.documentElement.style.maxHeight = '';
                        
                        // Also restore page containers
                        var pgBd = document.querySelector('#pgBd');
                        if (pgBd) {{
                            pgBd.style.height = '';
                            pgBd.style.minHeight = '';
                            pgBd.style.maxHeight = '';
                            pgBd.style.paddingBottom = '';
                            pgBd.style.marginBottom = '';
                        }}
                        var pageContainer = document.querySelector('.p-tralbum-page-container');
                        if (pageContainer) {{
                            pageContainer.style.height = '';
                            pageContainer.style.minHeight = '';
                            pageContainer.style.maxHeight = '';
                            pageContainer.style.paddingBottom = '';
                            pageContainer.style.marginBottom = '';
                        }}
                        var mainElement = document.querySelector('main#p-tralbum-page');
                        if (mainElement) {{
                            mainElement.style.height = '';
                            mainElement.style.minHeight = '';
                            mainElement.style.maxHeight = '';
                            mainElement.style.paddingBottom = '';
                            mainElement.style.marginBottom = '';
                        }}
                    }}
                }} else {{
                    // Body not ready yet - retry after a short delay
                    setTimeout(function() {{
                        if (document.body) {{
                            if ({self.mini_mode_state} === 1) {{
                                document.body.classList.add('mini-mode');
                                document.body.classList.remove('micro-mode');
                                
                                // Restore cover art visibility when switching to mini mode
                                var coverArt = document.querySelector('#tralbum-art-carousel');
                                if (coverArt) {{
                                    coverArt.style.display = '';
                                    coverArt.style.visibility = '';
                                    coverArt.style.height = '';
                                    coverArt.style.maxHeight = '';
                                    coverArt.style.width = '';
                                    coverArt.style.margin = '';
                                    coverArt.style.padding = '';
                                }}
                                // Clear CSS custom property for micro mode player height
                                document.documentElement.style.removeProperty('--micro-mode-player-height');
                                
                                // Restore body/html height when switching to mini mode
                                document.body.style.height = '';
                                document.body.style.minHeight = '';
                                document.body.style.maxHeight = '';
                                document.documentElement.style.height = '';
                                document.documentElement.style.minHeight = '';
                                document.documentElement.style.maxHeight = '';
                            }} else if ({self.mini_mode_state} === 2) {{
                                document.body.classList.add('micro-mode');
                                document.body.classList.remove('mini-mode', 'mini-mode-autohide');
                                
                                // Micro mode: show cover art behind player (semi-transparent player)
                                var coverArt = document.querySelector('#tralbum-art-carousel');
                                if (coverArt) {{
                                    coverArt.style.display = 'block';
                                    coverArt.style.visibility = 'visible';
                                    coverArt.style.position = 'absolute';
                                    coverArt.style.top = '0';
                                    coverArt.style.left = '0';
                                    coverArt.style.right = '0';
                                    coverArt.style.zIndex = '1';
                                    coverArt.style.width = '100%';
                                    coverArt.style.height = '100%';
                                    coverArt.style.overflow = 'hidden';
                                    coverArt.style.pointerEvents = 'none';
                                    coverArt.style.margin = '0';
                                    coverArt.style.padding = '0';
                                }}
                                
                                // Constrain body/html height to player height (no extra space)
                                var player = document.querySelector('#player');
                                if (player) {{
                                    setTimeout(function() {{
                                        var playerRect = player.getBoundingClientRect();
                                        // Get the exact bottom position of the player element
                                        var exactBottom = playerRect.bottom + window.scrollY;
                                        
                                        // Set body and html height to match player bottom position exactly
                                        document.body.style.height = exactBottom + 'px';
                                        document.body.style.minHeight = exactBottom + 'px';
                                        document.body.style.maxHeight = exactBottom + 'px';
                                        document.documentElement.style.height = exactBottom + 'px';
                                        document.documentElement.style.minHeight = exactBottom + 'px';
                                        document.documentElement.style.maxHeight = exactBottom + 'px';
                                        
                                        // Also ensure page containers match exactly
                                        var pgBd = document.querySelector('#pgBd');
                                        if (pgBd) {{
                                            pgBd.style.height = exactBottom + 'px';
                                            pgBd.style.minHeight = exactBottom + 'px';
                                            pgBd.style.maxHeight = exactBottom + 'px';
                                            pgBd.style.paddingBottom = '0';
                                            pgBd.style.marginBottom = '0';
                                        }}
                                        var pageContainer = document.querySelector('.p-tralbum-page-container');
                                        if (pageContainer) {{
                                            pageContainer.style.height = exactBottom + 'px';
                                            pageContainer.style.minHeight = exactBottom + 'px';
                                            pageContainer.style.maxHeight = exactBottom + 'px';
                                            pageContainer.style.paddingBottom = '0';
                                            pageContainer.style.marginBottom = '0';
                                        }}
                                        var mainElement = document.querySelector('main#p-tralbum-page');
                                        if (mainElement) {{
                                            mainElement.style.height = exactBottom + 'px';
                                            mainElement.style.minHeight = exactBottom + 'px';
                                            mainElement.style.maxHeight = exactBottom + 'px';
                                            mainElement.style.paddingBottom = '0';
                                            mainElement.style.marginBottom = '0';
                                        }}
                                    }}, 50);
                                }}
                            }} else {{
                                document.body.classList.remove('mini-mode', 'micro-mode', 'mini-mode-autohide');
                                
                                // Hide visibility toggle button when switching to regular mode (CSS will handle it)
                                // Don't remove it, just let CSS hide it
                                
                                // Restore cover art visibility when switching to regular mode
                                var coverArt = document.querySelector('#tralbum-art-carousel');
                                if (coverArt) {{
                                    coverArt.style.display = '';
                                    coverArt.style.visibility = '';
                                    coverArt.style.height = '';
                                    coverArt.style.width = '';
                                    coverArt.style.margin = '';
                                    coverArt.style.padding = '';
                                }}
                                
                                // Restore body/html height when switching to regular mode
                                document.body.style.height = '';
                                document.body.style.minHeight = '';
                                document.body.style.maxHeight = '';
                                document.documentElement.style.height = '';
                                document.documentElement.style.minHeight = '';
                                document.documentElement.style.maxHeight = '';
                            }}
                        }}
                    }}, 100);
                }}
                """
    
    def _get_cover_art_modal_js(self):
        """Get JavaScript code to handle cover art modal functionality - DEPRECATED: No longer used (webview removed)"""
        # This method is kept for compatibility but returns empty string since webview is no longer used
        return ""
    
    def _get_css_injection_js(self, css):
        """Get the JavaScript code for CSS injection (shared by both methods)"""
        mini_mode_js = self._get_mini_mode_class_js()
        bandcamp_hide_js = self._get_bandcamp_mode_hide_js() if self.bandcamp_mode else ""
        
        return f"""
            (function injectCSS() {{
                try {{
                    // CRITICAL: Always remove deprecated 'mini-mode-player-hidden' class on every CSS injection
                    // This prevents the player from getting stuck in hidden state (fully hidden mode was removed)
                    if (document.body) {{
                        document.body.classList.remove('mini-mode-player-hidden');
                    }}
                    
                    // Initialize menu state flag (prevents image viewer from opening when menu is open)
                    if (typeof window._bandcampPlayerMenuOpen === 'undefined') {{
                        window._bandcampPlayerMenuOpen = false;
                    }}
                    
                    // Initialize volume popup state flag (prevents image viewer from opening when volume popup is open)
                    if (typeof window._bandcampPlayerVolumePopupOpen === 'undefined') {{
                        window._bandcampPlayerVolumePopupOpen = false;
                    }}
                    
                    // Helper function to check if volume popup is actually visible
                    // This provides a fallback check in case the flag gets out of sync
                    window._checkVolumePopupVisible = function() {{
                        // The flag should be the source of truth, but we can add additional checks if needed
                        return window._bandcampPlayerVolumePopupOpen === true;
                    }};
                    
                    // Function to update cover art cursor based on menu/volume popup state
                    window._updateCoverArtCursor = function() {{
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            var menuOpen = window._bandcampPlayerMenuOpen === true;
                            var volumeOpen = window._bandcampPlayerVolumePopupOpen === true;
                            
                            if (menuOpen || volumeOpen) {{
                                coverArt.classList.add('cursor-disabled');
                            }} else {{
                                coverArt.classList.remove('cursor-disabled');
                            }}
                        }}
                    }};
                    
                    // Update cursor on initial load
                    if (document.readyState === 'loading') {{
                        document.addEventListener('DOMContentLoaded', window._updateCoverArtCursor);
                    }} else {{
                        window._updateCoverArtCursor();
                    }}
                    
                    // Detect light-colored pages and add class to body for CSS targeting
                    // Made more robust with retry logic and better error handling
                    function detectLightPage() {{
                        try {{
                            var body = document.body;
                            if (!body) {{
                                // Retry if body isn't ready yet
                                if (document.readyState === 'loading') {{
                                    setTimeout(detectLightPage, 50);
                                }}
                                return;
                            }}
                            
                            // Check multiple elements for background color (in order of preference)
                            var elements = [];
                            
                            // First, try to get the main content container (most reliable)
                            try {{
                                var mainContainer = document.querySelector('.p-tralbum-page-container, #pgBd, .leftColumn');
                                if (mainContainer) {{
                                    elements.push(mainContainer);
                                }}
                            }} catch (e) {{
                                // Ignore errors
                            }}
                            
                            // Then try body and documentElement
                            elements.push(body);
                            elements.push(document.documentElement);
                            
                            // Try to get carousel element, but don't fail if it doesn't exist
                            try {{
                                var carousel = document.querySelector('#tralbum-art-carousel');
                                if (carousel) {{
                                    elements.push(carousel);
                                }}
                            }} catch (e) {{
                                // Ignore errors getting carousel
                            }}
                            
                            var foundValidBackground = false;
                            var isLight = false;
                            
                            for (var i = 0; i < elements.length; i++) {{
                                try {{
                                    var element = elements[i];
                                    if (!element) continue;
                                    
                                    // Check if getComputedStyle is available
                                    if (typeof window.getComputedStyle === 'undefined') {{
                                        continue;
                                    }}
                                    
                                    var computedStyle = window.getComputedStyle(element);
                                    if (!computedStyle) continue;
                                    
                                    var backgroundColor = computedStyle.backgroundColor;
                                    if (!backgroundColor) continue;
                                    
                                    // Parse RGB values (handle both rgb() and rgba() formats)
                                    var rgbMatch = backgroundColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*[\\d.]+)?\\)/);
                                    if (rgbMatch) {{
                                        var r = parseInt(rgbMatch[1]);
                                        var g = parseInt(rgbMatch[2]);
                                        var b = parseInt(rgbMatch[3]);
                                        
                                        // Validate RGB values
                                        if (isNaN(r) || isNaN(g) || isNaN(b)) continue;
                                        
                                        // Calculate luminance to determine if background is light or dark
                                        var luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                                        
                                        // If we find a meaningful background (not transparent), use it
                                        if (backgroundColor !== 'rgba(0, 0, 0, 0)' && backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {{
                                            foundValidBackground = true;
                                            if (luminance > 0.6) {{
                                                isLight = true;
                                                break; // Found light background, stop checking
                                            }} else if (luminance < 0.4) {{
                                                // Definitely dark, can stop checking
                                                isLight = false;
                                                break;
                                            }}
                                            // If luminance is between 0.4 and 0.6, continue checking other elements
                                        }}
                                    }}
                                }} catch (e) {{
                                    // Continue to next element if this one fails
                                    continue;
                                }}
                            }}
                            
                            // Apply or remove light-page class based on detection
                            // Also add dark-page class for dark pages to ensure consistent styling
                            if (foundValidBackground) {{
                                if (isLight) {{
                                    body.classList.add('light-page');
                                    body.classList.remove('dark-page');
                                }} else {{
                                    body.classList.remove('light-page');
                                    body.classList.add('dark-page');
                                }}
                            }} else {{
                                // If no valid background found, default to dark-page
                                body.classList.remove('light-page');
                                body.classList.add('dark-page');
                            }}
                        }} catch (e) {{
                            // Log error but don't let it break other initialization
                            console.error('Bandcamp Player: Error detecting light page:', e);
                        }}
                    }}
                    
                    // Run detection with retry logic - don't block other initialization
                    function runLightPageDetection(retryCount) {{
                        retryCount = retryCount || 0;
                        var maxRetries = 10;
                        var baseDelay = 50;
                        
                        try {{
                            detectLightPage();
                            
                            // If detection didn't find a valid background, retry after styles load
                            // This handles cases where styles aren't computed yet
                            if (retryCount < maxRetries) {{
                                var body = document.body;
                                if (body) {{
                                    var hasLightClass = body.classList.contains('light-page');
                                    // If we haven't determined light/dark yet, retry
                                    // Check if we got a valid computed style
                                    var computedStyle = window.getComputedStyle(body);
                                    var bgColor = computedStyle.backgroundColor;
                                    
                                    // If background is still transparent/unset, retry
                                    if (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent' || !bgColor) {{
                                        var delay = baseDelay * Math.pow(1.5, retryCount);
                                        setTimeout(function() {{
                                            runLightPageDetection(retryCount + 1);
                                        }}, delay);
                                    }}
                                }}
                            }}
                        }} catch (e) {{
                            // Don't let light page detection errors break anything
                            console.error('Bandcamp Player: Error in light page detection wrapper:', e);
                            // Retry on error if we haven't exceeded max retries
                            if (retryCount < maxRetries) {{
                                var delay = baseDelay * Math.pow(1.5, retryCount);
                                setTimeout(function() {{
                                    runLightPageDetection(retryCount + 1);
                                }}, delay);
                            }}
                        }}
                    }}
                    
                    // Run detection immediately if body is ready, otherwise wait
                    if (document.body) {{
                        // Use setTimeout to avoid blocking other initialization
                        // Start with a small delay to let styles begin loading
                        setTimeout(function() {{
                            runLightPageDetection(0);
                        }}, 50);
                    }} else {{
                        // Wait for body to be available
                        if (document.readyState === 'loading') {{
                            document.addEventListener('DOMContentLoaded', function() {{
                                setTimeout(function() {{
                                    runLightPageDetection(0);
                                }}, 50);
                            }});
                        }} else {{
                            // If document is already loaded but body isn't ready, retry
                            setTimeout(function() {{
                                runLightPageDetection(0);
                            }}, 50);
                        }}
                    }}
                    
                    // Also run detection after window load (when all styles are definitely loaded)
                    if (document.readyState !== 'complete') {{
                        window.addEventListener('load', function() {{
                            setTimeout(function() {{
                                runLightPageDetection(0);
                            }}, 100);
                        }});
                    }} else {{
                        // Already loaded, run after a short delay
                        setTimeout(function() {{
                            runLightPageDetection(0);
                        }}, 100);
                    }}
                    
                    // Re-run detection when body classes change (e.g., when switching modes)
                    // This ensures light-page treatments apply reliably in all modes
                    // Made more robust with error handling
                    if (typeof MutationObserver !== 'undefined') {{
                        try {{
                            var lastModeState = null;
                            var lightPageObserver = null;
                            
                            var setupObserver = function() {{
                                try {{
                                    var body = document.body;
                                    if (!body) {{
                                        // Retry if body isn't ready
                                        if (document.readyState === 'loading') {{
                                            document.addEventListener('DOMContentLoaded', setupObserver);
                                        }} else {{
                                            setTimeout(setupObserver, 50);
                                        }}
                                        return;
                                    }}
                                    
                                    if (lightPageObserver) {{
                                        // Observer already set up
                                        return;
                                    }}
                                    
                                    lightPageObserver = new MutationObserver(function(mutations) {{
                                        try {{
                                            var body = document.body;
                                            if (!body) return;
                                            
                                            // Check if mode classes changed (mini-mode, micro-mode, or regular mode)
                                            var currentModeState = body.classList.contains('mini-mode') ? 'mini' : 
                                                                  body.classList.contains('micro-mode') ? 'micro' : 'regular';
                                            
                                            // Only re-run if mode actually changed
                                            if (lastModeState !== null && lastModeState !== currentModeState) {{
                                                // Small delay to ensure CSS has been applied
                                                setTimeout(detectLightPage, 150);
                                            }}
                                            
                                            lastModeState = currentModeState;
                                        }} catch (e) {{
                                            // Don't let observer errors break anything
                                            console.error('Bandcamp Player: Error in light page observer:', e);
                                        }}
                                    }});
                                    
                                    // Initialize mode state
                                    lastModeState = body.classList.contains('mini-mode') ? 'mini' : 
                                                   body.classList.contains('micro-mode') ? 'micro' : 'regular';
                                    
                                    lightPageObserver.observe(body, {{
                                        attributes: true,
                                        attributeFilter: ['class']
                                    }});
                                }} catch (e) {{
                                    console.error('Bandcamp Player: Error setting up light page observer:', e);
                                }}
                            }};
                            
                            setupObserver();
                        }} catch (e) {{
                            // Don't let observer setup errors break anything
                            console.error('Bandcamp Player: Error initializing light page observer:', e);
                        }}
                    }}
                    
                    // Windows 10 fix: Check if document is ready before manipulating DOM
                    // This is critical - if head isn't ready, we can't inject CSS
                    if (!document.head) {{
                        console.log('Bandcamp Player: document.head not ready, retrying...');
                        setTimeout(injectCSS, 50);
                        return;
                    }}
                    
                    // Remove existing injected styles (with error handling)
                    try {{
                        var existingStyle = document.getElementById('bandcamp-player-style');
                        if (existingStyle) {{
                            existingStyle.remove();
                        }}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error removing existing style:', e);
                        // Continue anyway - might not exist
                    }}
                    
                    // Inject CSS (critical - must not fail)
                    function reRunLightPageDetectionAfterCSS() {{
                    // Make runLightPageDetection globally accessible so it can be called from Python
                    window._runLightPageDetection = function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }};
                    
                    // Re-run light page detection after CSS is injected
                    // This ensures light-page class is applied after our styles are loaded
                    // Use longer delay to ensure styles are computed
                    setTimeout(function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }}, 200);
                    
                    // Also run again after a longer delay to catch late-loading styles
                    setTimeout(function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }}, 500);
                    }}
                    
                    try {{
                        var style = document.createElement('style');
                        style.id = 'bandcamp-player-style';
                        style.textContent = {repr(css)};
                        document.head.appendChild(style);
                        // Re-run light page detection after CSS injection
                        reRunLightPageDetectionAfterCSS();
                    }} catch (e) {{
                        console.error('Bandcamp Player: Critical error injecting CSS:', e);
                        // This is critical - retry if it fails
                        setTimeout(function() {{
                            try {{
                                var style = document.createElement('style');
                                style.id = 'bandcamp-player-style';
                                style.textContent = {repr(css)};
                                document.head.appendChild(style);
                                // Re-run light page detection after retry CSS injection
                                reRunLightPageDetectionAfterCSS();
                            }} catch (e2) {{
                                console.error('Bandcamp Player: Retry CSS injection also failed:', e2);
                            }}
                        }}, 100);
                    }}
                    
                    // Apply mini mode classes if active (with null check in mini_mode_js)
                    // Wrap in try-catch to prevent errors from blocking other initialization
                    try {{
                        {mini_mode_js}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error applying mini mode classes:', e);
                    }}
                    
                    // If Bandcamp mode is active, ensure elements are properly hidden
                    // Wrap in try-catch to prevent errors from blocking other initialization
                    try {{
                        if ({str(self.bandcamp_mode).lower()}) {{
                            {bandcamp_hide_js}
                        }}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error applying bandcamp mode:', e);
                    }}
                    
                    // Force body styles to persist - apply directly to body element
                    function applyBodyStyles() {{
                        try {{
                            var body = document.body;
                            if (body) {{
                                // Remove pointer cursor and ensure default cursor
                                body.style.setProperty('cursor', 'default', 'important');
                                
                                // Remove opacity and filter on hover by adding event listeners
                                body.addEventListener('mouseenter', function(e) {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}, true);
                                
                                body.addEventListener('mouseleave', function(e) {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}, true);
                                
                                // Also set initial values
                                body.style.setProperty('opacity', '1', 'important');
                                body.style.setProperty('filter', 'brightness(1)', 'important');
                            }}
                        }} catch (e) {{
                            console.error('Bandcamp Player: Error applying body styles:', e);
                        }}
                    }}
                    
                    // Apply body styles immediately
                    applyBodyStyles();
                    
                    // Re-apply on DOM ready if body wasn't ready yet
                    if (document.readyState === 'loading') {{
                        document.addEventListener('DOMContentLoaded', applyBodyStyles);
                    }}
                    
                    // Use MutationObserver to ensure body styles persist even if page tries to change them
                    if (typeof MutationObserver !== 'undefined') {{
                        var bodyStyleObserver = new MutationObserver(function(mutations) {{
                            var body = document.body;
                            if (body) {{
                                // Re-apply cursor if it was changed
                                var currentCursor = window.getComputedStyle(body).cursor;
                                if (currentCursor === 'pointer') {{
                                    body.style.setProperty('cursor', 'default', 'important');
                                }}
                                
                                // Re-apply opacity and filter if they were changed
                                var currentOpacity = window.getComputedStyle(body).opacity;
                                var currentFilter = window.getComputedStyle(body).filter;
                                if (currentOpacity !== '1' || currentFilter !== 'none') {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}
                            }}
                        }});
                        
                        // Observe body for style attribute changes
                        var body = document.body;
                        if (body) {{
                            bodyStyleObserver.observe(body, {{
                                attributes: true,
                                attributeFilter: ['style', 'class'],
                                subtree: false
                            }});
                        }} else {{
                            // Wait for body to be available
                            if (document.readyState === 'loading') {{
                                document.addEventListener('DOMContentLoaded', function() {{
                                    var body = document.body;
                                    if (body) {{
                                        bodyStyleObserver.observe(body, {{
                                            attributes: true,
                                            attributeFilter: ['style', 'class'],
                                            subtree: false
                                        }});
                                    }}
                                }});
                            }}
                        }}
                    }}
                }} catch (e) {{
                    console.error('Bandcamp Player: Error in CSS injection:', e);
                    // Don't crash - just log the error
                }}
            }})();
            """
    
    def _inject_javascript_with_retry(self, js_code, retry_count=0, max_retries=3, callback=None):
        """Inject JavaScript with retry logic and error handling
        
        Args:
            js_code: JavaScript code to inject
            retry_count: Current retry attempt (internal use)
            max_retries: Maximum number of retry attempts
            callback: Optional callback function(result) called after injection
        """
        if not hasattr(self, 'web_view') or not self.web_view or not self.web_view.page():
            logger.warning("_inject_javascript_with_retry: web_view not available")
            if callback:
                callback(None)
            return
        
        try:
            # Wrap the entire JS code (which may already be an IIFE) in a new IIFE that returns a value
            # This allows us to catch errors and verify execution
            js_with_return = f"""
            (function() {{
                try {{
                    {js_code}
                    return true; // Success indicator
                }} catch (e) {{
                    console.error('Bandcamp Player: JavaScript injection error:', e);
                    return false; // Error indicator
                }}
            }})();
            """
            
            # Use callback to verify injection succeeded
            def on_result(result):
                if result is None or result is False:
                    # Injection failed or returned false
                    if retry_count < max_retries:
                        # Retry with exponential backoff
                        delay = 100 * (2 ** retry_count)  # 100ms, 200ms, 400ms
                        logger.debug(f"_inject_javascript_with_retry: Retry {retry_count + 1}/{max_retries} after {delay}ms")
                        QTimer.singleShot(delay, lambda: self._inject_javascript_with_retry(
                            js_code, retry_count + 1, max_retries, callback
                        ))
                    else:
                        logger.warning(f"_inject_javascript_with_retry: Max retries ({max_retries}) reached, injection may have failed")
                        if callback:
                            callback(False)
                else:
                    # Injection succeeded
                    if callback:
                        callback(True)
            
            # Check if page is ready before injecting
            check_ready_js = """
            (function() {
                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    return true;
                }
                return false;
            })();
            """
            
            def on_ready_check(result):
                if result:
                    # Page is ready, inject the code
                    self.web_view.page().runJavaScript(js_with_return, on_result)
                else:
                    # Page not ready, wait and retry
                    if retry_count < max_retries:
                        delay = 50 * (retry_count + 1)
                        QTimer.singleShot(delay, lambda: self._inject_javascript_with_retry(
                            js_code, retry_count, max_retries, callback
                        ))
                    else:
                        logger.warning("_inject_javascript_with_retry: Page not ready and max retries reached")
                        if callback:
                            callback(False)
            
            # First check if page is ready
            self.web_view.page().runJavaScript(check_ready_js, on_ready_check)
            
        except Exception as e:
            logger.error(f"_inject_javascript_with_retry: Exception: {e}")
            if callback:
                callback(False)
    
    def _get_css_injection_js(self, css):
        """Get the JavaScript code for CSS injection (shared by both methods)"""
        mini_mode_js = self._get_mini_mode_class_js()
        bandcamp_hide_js = self._get_bandcamp_mode_hide_js() if self.bandcamp_mode else ""
        
        return f"""
            (function injectCSS() {{
                try {{
                    // CRITICAL: Always remove deprecated 'mini-mode-player-hidden' class on every CSS injection
                    // This prevents the player from getting stuck in hidden state (fully hidden mode was removed)
                    if (document.body) {{
                        document.body.classList.remove('mini-mode-player-hidden');
                    }}
                    
                    // Initialize menu state flag (prevents image viewer from opening when menu is open)
                    if (typeof window._bandcampPlayerMenuOpen === 'undefined') {{
                        window._bandcampPlayerMenuOpen = false;
                    }}
                    
                    // Initialize volume popup state flag (prevents image viewer from opening when volume popup is open)
                    if (typeof window._bandcampPlayerVolumePopupOpen === 'undefined') {{
                        window._bandcampPlayerVolumePopupOpen = false;
                    }}
                    
                    // Helper function to check if volume popup is actually visible
                    // This provides a fallback check in case the flag gets out of sync
                    window._checkVolumePopupVisible = function() {{
                        // The flag should be the source of truth, but we can add additional checks if needed
                        return window._bandcampPlayerVolumePopupOpen === true;
                    }};
                    
                    // Function to update cover art cursor based on menu/volume popup state
                    window._updateCoverArtCursor = function() {{
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            var menuOpen = window._bandcampPlayerMenuOpen === true;
                            var volumeOpen = window._bandcampPlayerVolumePopupOpen === true;
                            
                            if (menuOpen || volumeOpen) {{
                                coverArt.classList.add('cursor-disabled');
                            }} else {{
                                coverArt.classList.remove('cursor-disabled');
                            }}
                        }}
                    }};
                    
                    // Update cursor on initial load
                    if (document.readyState === 'loading') {{
                        document.addEventListener('DOMContentLoaded', window._updateCoverArtCursor);
                    }} else {{
                        window._updateCoverArtCursor();
                    }}
                    
                    // Windows 10 fix: Check if document is ready before manipulating DOM
                    // This is critical - if head isn't ready, we can't inject CSS
                    if (!document.head) {{
                        console.log('Bandcamp Player: document.head not ready, retrying...');
                        setTimeout(injectCSS, 50);
                        return;
                    }}
                    
                    // Remove existing injected styles (with error handling)
                    try {{
                        var existingStyle = document.getElementById('bandcamp-player-style');
                        if (existingStyle) {{
                            existingStyle.remove();
                        }}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error removing existing style:', e);
                        // Continue anyway - might not exist
                    }}
                    
                    // Inject CSS (critical - must not fail)
                    try {{
                        var style = document.createElement('style');
                        style.id = 'bandcamp-player-style';
                        style.textContent = {repr(css)};
                        document.head.appendChild(style);
                    }} catch (e) {{
                        console.error('Bandcamp Player: Critical error injecting CSS:', e);
                        // This is critical - retry if it fails
                        setTimeout(function() {{
                            try {{
                                var style = document.createElement('style');
                                style.id = 'bandcamp-player-style';
                                style.textContent = {repr(css)};
                                document.head.appendChild(style);
                            }} catch (e2) {{
                                console.error('Bandcamp Player: Retry CSS injection also failed:', e2);
                            }}
                        }}, 100);
                    }}
                    
                    // Apply mini mode classes if active (with null check in mini_mode_js)
                    // Wrap in try-catch to prevent errors from blocking other initialization
                    try {{
                        {mini_mode_js}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error applying mini mode classes:', e);
                    }}
                    
                    // If Bandcamp mode is active, ensure elements are properly hidden
                    // Wrap in try-catch to prevent errors from blocking other initialization
                    try {{
                        if ({str(self.bandcamp_mode).lower()}) {{
                            {bandcamp_hide_js}
                        }}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error applying bandcamp mode:', e);
                    }}
                }} catch (e) {{
                    console.error('Bandcamp Player: Error in CSS injection:', e);
                    // Don't crash - just log the error
                }}
            }})();
            """
    
    def _inject_javascript_with_retry(self, js_code, retry_count=0, max_retries=3, callback=None):
        """Inject JavaScript with retry logic and error handling
        
        Args:
            js_code: JavaScript code to inject
            retry_count: Current retry attempt (internal use)
            max_retries: Maximum number of retry attempts
            callback: Optional callback function(result) called after injection
        """
        if not hasattr(self, 'web_view') or not self.web_view or not self.web_view.page():
            logger.warning("_inject_javascript_with_retry: web_view not available")
            if callback:
                callback(None)
            return
        
        try:
            # Wrap the entire JS code (which may already be an IIFE) in a new IIFE that returns a value
            # This allows us to catch errors and verify execution
            js_with_return = f"""
            (function() {{
                try {{
                    {js_code}
                    return true; // Success indicator
                }} catch (e) {{
                    console.error('Bandcamp Player: JavaScript injection error:', e);
                    return false; // Error indicator
                }}
            }})();
            """
            
            # Use callback to verify injection succeeded
            def on_result(result):
                if result is None or result is False:
                    # Injection failed or returned false
                    if retry_count < max_retries:
                        # Retry with exponential backoff
                        delay = 100 * (2 ** retry_count)  # 100ms, 200ms, 400ms
                        logger.debug(f"_inject_javascript_with_retry: Retry {retry_count + 1}/{max_retries} after {delay}ms")
                        QTimer.singleShot(delay, lambda: self._inject_javascript_with_retry(
                            js_code, retry_count + 1, max_retries, callback
                        ))
                    else:
                        logger.warning(f"_inject_javascript_with_retry: Max retries ({max_retries}) reached, injection may have failed")
                        if callback:
                            callback(False)
                else:
                    # Injection succeeded
                    if callback:
                        callback(True)
            
            # Check if page is ready before injecting
            check_ready_js = """
            (function() {
                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    return true;
                }
                return false;
            })();
            """
            
            def on_ready_check(result):
                if result:
                    # Page is ready, inject the code
                    self.web_view.page().runJavaScript(js_with_return, on_result)
                else:
                    # Page not ready, wait and retry
                    if retry_count < max_retries:
                        delay = 50 * (retry_count + 1)
                        QTimer.singleShot(delay, lambda: self._inject_javascript_with_retry(
                            js_code, retry_count, max_retries, callback
                        ))
                    else:
                        logger.warning("_inject_javascript_with_retry: Page not ready and max retries reached")
                        if callback:
                            callback(False)
            
            # First check if page is ready
            self.web_view.page().runJavaScript(check_ready_js, on_ready_check)
            
        except Exception as e:
            logger.error(f"_inject_javascript_with_retry: Exception: {e}")
            if callback:
                callback(False)
    
    def _get_css_injection_js(self, css):
        """Get the JavaScript code for CSS injection (shared by both methods)"""
        mini_mode_js = self._get_mini_mode_class_js()
        bandcamp_hide_js = self._get_bandcamp_mode_hide_js() if self.bandcamp_mode else ""
        
        return f"""
            (function injectCSS() {{
                try {{
                    // CRITICAL: Always remove deprecated 'mini-mode-player-hidden' class on every CSS injection
                    // This prevents the player from getting stuck in hidden state (fully hidden mode was removed)
                    if (document.body) {{
                        document.body.classList.remove('mini-mode-player-hidden');
                    }}
                    
                    // Initialize menu state flag (prevents image viewer from opening when menu is open)
                    if (typeof window._bandcampPlayerMenuOpen === 'undefined') {{
                        window._bandcampPlayerMenuOpen = false;
                    }}
                    
                    // Initialize volume popup state flag (prevents image viewer from opening when volume popup is open)
                    if (typeof window._bandcampPlayerVolumePopupOpen === 'undefined') {{
                        window._bandcampPlayerVolumePopupOpen = false;
                    }}
                    
                    // Helper function to check if volume popup is actually visible
                    // This provides a fallback check in case the flag gets out of sync
                    window._checkVolumePopupVisible = function() {{
                        // The flag should be the source of truth, but we can add additional checks if needed
                        return window._bandcampPlayerVolumePopupOpen === true;
                    }};
                    
                    // Function to update cover art cursor based on menu/volume popup state
                    window._updateCoverArtCursor = function() {{
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            var menuOpen = window._bandcampPlayerMenuOpen === true;
                            var volumeOpen = window._bandcampPlayerVolumePopupOpen === true;
                            
                            if (menuOpen || volumeOpen) {{
                                coverArt.classList.add('cursor-disabled');
                            }} else {{
                                coverArt.classList.remove('cursor-disabled');
                            }}
                        }}
                    }};
                    
                    // Update cursor on initial load
                    if (document.readyState === 'loading') {{
                        document.addEventListener('DOMContentLoaded', window._updateCoverArtCursor);
                    }} else {{
                        window._updateCoverArtCursor();
                    }}
                    
                    // Detect light-colored pages and add class to body for CSS targeting
                    // Made more robust with retry logic and better error handling
                    function detectLightPage() {{
                        try {{
                            var body = document.body;
                            if (!body) {{
                                // Retry if body isn't ready yet
                                if (document.readyState === 'loading') {{
                                    setTimeout(detectLightPage, 50);
                                }}
                                return;
                            }}
                            
                            // Check multiple elements for background color (in order of preference)
                            var elements = [];
                            
                            // First, try to get the main content container (most reliable)
                            try {{
                                var mainContainer = document.querySelector('.p-tralbum-page-container, #pgBd, .leftColumn');
                                if (mainContainer) {{
                                    elements.push(mainContainer);
                                }}
                            }} catch (e) {{
                                // Ignore errors
                            }}
                            
                            // Then try body and documentElement
                            elements.push(body);
                            elements.push(document.documentElement);
                            
                            // Try to get carousel element, but don't fail if it doesn't exist
                            try {{
                                var carousel = document.querySelector('#tralbum-art-carousel');
                                if (carousel) {{
                                    elements.push(carousel);
                                }}
                            }} catch (e) {{
                                // Ignore errors getting carousel
                            }}
                            
                            var foundValidBackground = false;
                            var isLight = false;
                            
                            for (var i = 0; i < elements.length; i++) {{
                                try {{
                                    var element = elements[i];
                                    if (!element) continue;
                                    
                                    // Check if getComputedStyle is available
                                    if (typeof window.getComputedStyle === 'undefined') {{
                                        continue;
                                    }}
                                    
                                    var computedStyle = window.getComputedStyle(element);
                                    if (!computedStyle) continue;
                                    
                                    var backgroundColor = computedStyle.backgroundColor;
                                    if (!backgroundColor) continue;
                                    
                                    // Parse RGB values (handle both rgb() and rgba() formats)
                                    var rgbMatch = backgroundColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*[\\d.]+)?\\)/);
                                    if (rgbMatch) {{
                                        var r = parseInt(rgbMatch[1]);
                                        var g = parseInt(rgbMatch[2]);
                                        var b = parseInt(rgbMatch[3]);
                                        
                                        // Validate RGB values
                                        if (isNaN(r) || isNaN(g) || isNaN(b)) continue;
                                        
                                        // Calculate luminance to determine if background is light or dark
                                        var luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                                        
                                        // If we find a meaningful background (not transparent), use it
                                        if (backgroundColor !== 'rgba(0, 0, 0, 0)' && backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {{
                                            foundValidBackground = true;
                                            if (luminance > 0.6) {{
                                                isLight = true;
                                                break; // Found light background, stop checking
                                            }} else if (luminance < 0.4) {{
                                                // Definitely dark, can stop checking
                                                isLight = false;
                                                break;
                                            }}
                                            // If luminance is between 0.4 and 0.6, continue checking other elements
                                        }}
                                    }}
                                }} catch (e) {{
                                    // Continue to next element if this one fails
                                    continue;
                                }}
                            }}
                            
                            // Apply or remove light-page class based on detection
                            // Also add dark-page class for dark pages to ensure consistent styling
                            if (foundValidBackground) {{
                                if (isLight) {{
                                    body.classList.add('light-page');
                                    body.classList.remove('dark-page');
                                }} else {{
                                    body.classList.remove('light-page');
                                    body.classList.add('dark-page');
                                }}
                            }} else {{
                                // If no valid background found, default to dark-page
                                body.classList.remove('light-page');
                                body.classList.add('dark-page');
                            }}
                        }} catch (e) {{
                            // Log error but don't let it break other initialization
                            console.error('Bandcamp Player: Error detecting light page:', e);
                        }}
                    }}
                    
                    // Run detection with retry logic - don't block other initialization
                    function runLightPageDetection(retryCount) {{
                        retryCount = retryCount || 0;
                        var maxRetries = 10;
                        var baseDelay = 50;
                        
                        try {{
                            detectLightPage();
                            
                            // If detection didn't find a valid background, retry after styles load
                            // This handles cases where styles aren't computed yet
                            if (retryCount < maxRetries) {{
                                var body = document.body;
                                if (body) {{
                                    var hasLightClass = body.classList.contains('light-page');
                                    // If we haven't determined light/dark yet, retry
                                    // Check if we got a valid computed style
                                    var computedStyle = window.getComputedStyle(body);
                                    var bgColor = computedStyle.backgroundColor;
                                    
                                    // If background is still transparent/unset, retry
                                    if (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent' || !bgColor) {{
                                        var delay = baseDelay * Math.pow(1.5, retryCount);
                                        setTimeout(function() {{
                                            runLightPageDetection(retryCount + 1);
                                        }}, delay);
                                    }}
                                }}
                            }}
                        }} catch (e) {{
                            // Don't let light page detection errors break anything
                            console.error('Bandcamp Player: Error in light page detection wrapper:', e);
                            // Retry on error if we haven't exceeded max retries
                            if (retryCount < maxRetries) {{
                                var delay = baseDelay * Math.pow(1.5, retryCount);
                                setTimeout(function() {{
                                    runLightPageDetection(retryCount + 1);
                                }}, delay);
                            }}
                        }}
                    }}
                    
                    // Run detection immediately if body is ready, otherwise wait
                    if (document.body) {{
                        // Use setTimeout to avoid blocking other initialization
                        // Start with a small delay to let styles begin loading
                        setTimeout(function() {{
                            runLightPageDetection(0);
                        }}, 50);
                    }} else {{
                        // Wait for body to be available
                        if (document.readyState === 'loading') {{
                            document.addEventListener('DOMContentLoaded', function() {{
                                setTimeout(function() {{
                                    runLightPageDetection(0);
                                }}, 50);
                            }});
                        }} else {{
                            // If document is already loaded but body isn't ready, retry
                            setTimeout(function() {{
                                runLightPageDetection(0);
                            }}, 50);
                        }}
                    }}
                    
                    // Also run detection after window load (when all styles are definitely loaded)
                    if (document.readyState !== 'complete') {{
                        window.addEventListener('load', function() {{
                            setTimeout(function() {{
                                runLightPageDetection(0);
                            }}, 100);
                        }});
                    }} else {{
                        // Already loaded, run after a short delay
                        setTimeout(function() {{
                            runLightPageDetection(0);
                        }}, 100);
                    }}
                    
                    // Re-run detection when body classes change (e.g., when switching modes)
                    // This ensures light-page treatments apply reliably in all modes
                    // Made more robust with error handling
                    if (typeof MutationObserver !== 'undefined') {{
                        try {{
                            var lastModeState = null;
                            var lightPageObserver = null;
                            
                            var setupObserver = function() {{
                                try {{
                                    var body = document.body;
                                    if (!body) {{
                                        // Retry if body isn't ready
                                        if (document.readyState === 'loading') {{
                                            document.addEventListener('DOMContentLoaded', setupObserver);
                                        }} else {{
                                            setTimeout(setupObserver, 50);
                                        }}
                                        return;
                                    }}
                                    
                                    if (lightPageObserver) {{
                                        // Observer already set up
                                        return;
                                    }}
                                    
                                    lightPageObserver = new MutationObserver(function(mutations) {{
                                        try {{
                                            var body = document.body;
                                            if (!body) return;
                                            
                                            // Check if mode classes changed (mini-mode, micro-mode, or regular mode)
                                            var currentModeState = body.classList.contains('mini-mode') ? 'mini' : 
                                                                  body.classList.contains('micro-mode') ? 'micro' : 'regular';
                                            
                                            // Only re-run if mode actually changed
                                            if (lastModeState !== null && lastModeState !== currentModeState) {{
                                                // Small delay to ensure CSS has been applied
                                                setTimeout(detectLightPage, 150);
                                            }}
                                            
                                            lastModeState = currentModeState;
                                        }} catch (e) {{
                                            // Don't let observer errors break anything
                                            console.error('Bandcamp Player: Error in light page observer:', e);
                                        }}
                                    }});
                                    
                                    // Initialize mode state
                                    lastModeState = body.classList.contains('mini-mode') ? 'mini' : 
                                                   body.classList.contains('micro-mode') ? 'micro' : 'regular';
                                    
                                    lightPageObserver.observe(body, {{
                                        attributes: true,
                                        attributeFilter: ['class']
                                    }});
                                }} catch (e) {{
                                    console.error('Bandcamp Player: Error setting up light page observer:', e);
                                }}
                            }};
                            
                            setupObserver();
                        }} catch (e) {{
                            // Don't let observer setup errors break anything
                            console.error('Bandcamp Player: Error initializing light page observer:', e);
                        }}
                    }}
                    
                    // Windows 10 fix: Check if document is ready before manipulating DOM
                    // This is critical - if head isn't ready, we can't inject CSS
                    if (!document.head) {{
                        console.log('Bandcamp Player: document.head not ready, retrying...');
                        setTimeout(injectCSS, 50);
                        return;
                    }}
                    
                    // Remove existing injected styles (with error handling)
                    try {{
                        var existingStyle = document.getElementById('bandcamp-player-style');
                        if (existingStyle) {{
                            existingStyle.remove();
                        }}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error removing existing style:', e);
                        // Continue anyway - might not exist
                    }}
                    
                    // Inject CSS (critical - must not fail)
                    function reRunLightPageDetectionAfterCSS() {{
                    // Make runLightPageDetection globally accessible so it can be called from Python
                    window._runLightPageDetection = function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }};
                    
                    // Re-run light page detection after CSS is injected
                    // This ensures light-page class is applied after our styles are loaded
                    // Use longer delay to ensure styles are computed
                    setTimeout(function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }}, 200);
                    
                    // Also run again after a longer delay to catch late-loading styles
                    setTimeout(function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }}, 500);
                    }}
                    
                    try {{
                        var style = document.createElement('style');
                        style.id = 'bandcamp-player-style';
                        style.textContent = {repr(css)};
                        document.head.appendChild(style);
                        // Re-run light page detection after CSS injection
                        reRunLightPageDetectionAfterCSS();
                    }} catch (e) {{
                        console.error('Bandcamp Player: Critical error injecting CSS:', e);
                        // This is critical - retry if it fails
                        setTimeout(function() {{
                            try {{
                                var style = document.createElement('style');
                                style.id = 'bandcamp-player-style';
                                style.textContent = {repr(css)};
                                document.head.appendChild(style);
                                // Re-run light page detection after retry CSS injection
                                reRunLightPageDetectionAfterCSS();
                            }} catch (e2) {{
                                console.error('Bandcamp Player: Retry CSS injection also failed:', e2);
                            }}
                        }}, 100);
                    }}
                    
                    // Apply mini mode classes if active (with null check in mini_mode_js)
                    // Wrap in try-catch to prevent errors from blocking other initialization
                    try {{
                        {mini_mode_js}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error applying mini mode classes:', e);
                    }}
                    
                    // If Bandcamp mode is active, ensure elements are properly hidden
                    // Wrap in try-catch to prevent errors from blocking other initialization
                    try {{
                        if ({str(self.bandcamp_mode).lower()}) {{
                            {bandcamp_hide_js}
                        }}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error applying bandcamp mode:', e);
                    }}
                    
                    // Force body styles to persist - apply directly to body element
                    function applyBodyStyles() {{
                        try {{
                            var body = document.body;
                            if (body) {{
                                // Remove pointer cursor and ensure default cursor
                                body.style.setProperty('cursor', 'default', 'important');
                                
                                // Remove opacity and filter on hover by adding event listeners
                                body.addEventListener('mouseenter', function(e) {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}, true);
                                
                                body.addEventListener('mouseleave', function(e) {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}, true);
                                
                                // Also set initial values
                                body.style.setProperty('opacity', '1', 'important');
                                body.style.setProperty('filter', 'brightness(1)', 'important');
                            }}
                        }} catch (e) {{
                            console.error('Bandcamp Player: Error applying body styles:', e);
                        }}
                    }}
                    
                    // Apply body styles immediately
                    applyBodyStyles();
                    
                    // Re-apply on DOM ready if body wasn't ready yet
                    if (document.readyState === 'loading') {{
                        document.addEventListener('DOMContentLoaded', applyBodyStyles);
                    }}
                    
                    // Use MutationObserver to ensure body styles persist even if page tries to change them
                    if (typeof MutationObserver !== 'undefined') {{
                        var bodyStyleObserver = new MutationObserver(function(mutations) {{
                            var body = document.body;
                            if (body) {{
                                // Re-apply cursor if it was changed
                                var currentCursor = window.getComputedStyle(body).cursor;
                                if (currentCursor === 'pointer') {{
                                    body.style.setProperty('cursor', 'default', 'important');
                                }}
                                
                                // Re-apply opacity and filter if they were changed
                                var currentOpacity = window.getComputedStyle(body).opacity;
                                var currentFilter = window.getComputedStyle(body).filter;
                                if (currentOpacity !== '1' || currentFilter !== 'none') {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}
                            }}
                        }});
                        
                        // Observe body for style attribute changes
                        var body = document.body;
                        if (body) {{
                            bodyStyleObserver.observe(body, {{
                                attributes: true,
                                attributeFilter: ['style', 'class'],
                                subtree: false
                            }});
                        }} else {{
                            // Wait for body to be available
                            if (document.readyState === 'loading') {{
                                document.addEventListener('DOMContentLoaded', function() {{
                                    var body = document.body;
                                    if (body) {{
                                        bodyStyleObserver.observe(body, {{
                                            attributes: true,
                                            attributeFilter: ['style', 'class'],
                                            subtree: false
                                        }});
                                    }}
                                }});
                            }}
                        }}
                    }}
                }} catch (e) {{
                    console.error('Bandcamp Player: Error in CSS injection:', e);
                    // Don't crash - just log the error
                }}
            }})();
            """
    
    def _inject_javascript_with_retry(self, js_code, retry_count=0, max_retries=3, callback=None):
        """Inject JavaScript with retry logic and error handling
        
        Args:
            js_code: JavaScript code to inject
            retry_count: Current retry attempt (internal use)
            max_retries: Maximum number of retry attempts
            callback: Optional callback function(result) called after injection
        """
        if not hasattr(self, 'web_view') or not self.web_view or not self.web_view.page():
            logger.warning("_inject_javascript_with_retry: web_view not available")
            if callback:
                callback(None)
            return
        
        try:
            # Wrap the entire JS code (which may already be an IIFE) in a new IIFE that returns a value
            # This allows us to catch errors and verify execution
            js_with_return = f"""
            (function() {{
                try {{
                    {js_code}
                    return true; // Success indicator
                }} catch (e) {{
                    console.error('Bandcamp Player: JavaScript injection error:', e);
                    return false; // Error indicator
                }}
            }})();
            """
            
            # Use callback to verify injection succeeded
            def on_result(result):
                if result is None or result is False:
                    # Injection failed or returned false
                    if retry_count < max_retries:
                        # Retry with exponential backoff
                        delay = 100 * (2 ** retry_count)  # 100ms, 200ms, 400ms
                        logger.debug(f"_inject_javascript_with_retry: Retry {retry_count + 1}/{max_retries} after {delay}ms")
                        QTimer.singleShot(delay, lambda: self._inject_javascript_with_retry(
                            js_code, retry_count + 1, max_retries, callback
                        ))
                    else:
                        logger.warning(f"_inject_javascript_with_retry: Max retries ({max_retries}) reached, injection may have failed")
                        if callback:
                            callback(False)
                else:
                    # Injection succeeded
                    if callback:
                        callback(True)
            
            # Check if page is ready before injecting
            check_ready_js = """
            (function() {
                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    return true;
                }
                return false;
            })();
            """
            
            def on_ready_check(result):
                if result:
                    # Page is ready, inject the code
                    self.web_view.page().runJavaScript(js_with_return, on_result)
                else:
                    # Page not ready, wait and retry
                    if retry_count < max_retries:
                        delay = 50 * (retry_count + 1)
                        QTimer.singleShot(delay, lambda: self._inject_javascript_with_retry(
                            js_code, retry_count, max_retries, callback
                        ))
                    else:
                        # Max retries reached, inject anyway
                        logger.warning("_inject_javascript_with_retry: Page not ready after checks, injecting anyway")
                        self.web_view.page().runJavaScript(js_with_return, on_result)
            
            # Check if page is ready first
            self.web_view.page().runJavaScript(check_ready_js, on_ready_check)
            
        except Exception as e:
            logger.error(f"_inject_javascript_with_retry: Exception: {e}", exc_info=True)
            if retry_count < max_retries:
                delay = 100 * (2 ** retry_count)
                QTimer.singleShot(delay, lambda: self._inject_javascript_with_retry(
                    js_code, retry_count + 1, max_retries, callback
                ))
            else:
                if callback:
                    callback(False)
    
    def inject_css(self):
        """Inject CSS for compact/dark/bandcamp/mini modes"""
        # Skip CSS injection if using Qt widgets (webview is hidden, CSS not needed for visuals)
        use_qt = getattr(self, 'use_qt_widgets', True)
        if use_qt:
            logger.debug("inject_css: Skipping CSS injection (using Qt widgets, webview hidden)")
            return
        
        # Safety check: ensure web_view and page exist before injecting
        if not hasattr(self, 'web_view') or not self.web_view:
            logger.warning("inject_css: web_view not available, skipping injection")
            return
        if not self.web_view.page():
            logger.warning("inject_css: web_view.page() not available, skipping injection")
            return
        
        # Only use print statements if DEBUG environment variable is set
        debug_mode = os.environ.get('DEBUG')
        if debug_mode:
            print(f"[DEBUG] inject_css: START - compact={self.compact_mode}, bandcamp={self.bandcamp_mode}, mini_state={getattr(self, 'mini_mode_state', 'N/A')}")
            sys.stdout.flush()
        logger.debug(f"inject_css: Starting (compact={self.compact_mode}, bandcamp={self.bandcamp_mode}, mini_mode_state={getattr(self, 'mini_mode_state', 'N/A')})")
        try:
            css = self.css_injector.get_css(self.compact_mode, self.bandcamp_mode, self.mini_mode_state, False)  # webview_scrollbar_visible removed - always False
            if css:
                if debug_mode:
                    print(f"[DEBUG] inject_css: CSS generated, length={len(css)} chars")
                    sys.stdout.flush()
                logger.debug(f"inject_css: CSS generated, length={len(css)} chars")
                js = self._get_css_injection_js(css)
                if debug_mode:
                    print(f"[DEBUG] inject_css: JavaScript generated, executing...")
                    sys.stdout.flush()
                logger.debug(f"inject_css: JavaScript generated, executing...")
                
                # Use retry-enabled injection
                def on_injection_complete(success):
                    if success:
                        # Mark that JavaScript has been injected (image viewer and mini mode setup)
                        self._js_injected_on_current_page = True
                        if debug_mode:
                            print(f"[DEBUG] inject_css: JavaScript injection completed successfully")
                            sys.stdout.flush()
                        logger.debug(f"inject_css: JavaScript injection completed successfully")
                    else:
                        logger.warning("inject_css: JavaScript injection may have failed after retries")
                        # Still mark as injected to prevent infinite retries, but log the warning
                        self._js_injected_on_current_page = True
                
                self._inject_javascript_with_retry(js, callback=on_injection_complete)
            else:
                if debug_mode:
                    print("[WARNING] inject_css: No CSS generated")
                    sys.stdout.flush()
                logger.warning("inject_css: No CSS generated")
        except Exception as e:
            print(f"[ERROR] inject_css: Error injecting CSS: {e}")
            if debug_mode:
                import traceback
                traceback.print_exc()
                sys.stdout.flush()
            logger.error(f"inject_css: Error injecting CSS: {e}", exc_info=True)
    
    def toggle_bandcamp_mode(self):
        """Toggle Bandcamp mode (hides unwanted elements, shows only player content)"""
        self.bandcamp_mode = not self.bandcamp_mode
        self.bandcamp_action.setChecked(self.bandcamp_mode)
        self.inject_css()
        # Update mini mode button visibility
        self.update_mini_mode_button()
        # If bandcamp mode is disabled and mini mode is active, reset mini mode
        if not self.bandcamp_mode and self.mini_mode_state != 0:
            self.mini_mode_state = 0
            # Always use default regular mode size
            self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            # Clear any playlist container height restrictions from mini/micro mode
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.setMinimumHeight(0)
                self.playlist_container.setMaximumHeight(16777215)  # Qt max
                self.playlist_container.updateGeometry()
            # Clear playlist sidebar height restrictions to allow proper resizing in regular mode
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                # Clear fixed height to allow resizing
                self.playlist_sidebar.setFixedHeight(16777215)  # Qt max to clear fixed height
                self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                # Restore to saved height if available
                if hasattr(self.playlist_sidebar, '_restore_height') and self.playlist_sidebar._restore_height:
                    restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, self.playlist_sidebar._restore_height))
                    if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized:
                        self.playlist_sidebar.setFixedHeight(restore_height)
                self.playlist_sidebar.updateGeometry()
            self.inject_css()
            self.update_mini_mode_button()
            self.update_mini_mode_menu_text()
        self.save_settings()
    
    def toggle_compact_mode(self):
        """Toggle compact mode"""
        self.compact_mode = not self.compact_mode
        self.compact_action.setChecked(self.compact_mode)
        self.inject_css()
        self.save_settings()
    
    def toggle_mini_mode(self):
        """Toggle mini mode (cycles through: Regular -> Mini -> Micro -> Regular)"""
        # Disable mode switching if welcome message is visible (no URLs loaded, empty playlist)
        if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
            playlist = self.playlist_manager.get_playlist()
            if not playlist or len(playlist) == 0:
                # Welcome message is visible and playlist is empty - disable mode switching
                return
        
        # Only allow mini mode when bandcamp mode is active
        if not self.bandcamp_mode and self.mini_mode_state == 0:
            QMessageBox.information(self, "Mini Mode", "Bandcamp Mode must be enabled to use Mini Mode.")
            return
        
        # Cycle through states: 0 -> 1 -> 2 -> 0
        self.mini_mode_state = (self.mini_mode_state + 1) % 3
        
        # Apply mini mode (no need to store original size - always use defaults)
        self.apply_mini_mode()
        
        # Update minimize button icon when mode changes
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            QTimer.singleShot(100, self.playlist_sidebar._update_minimize_button_icon)
        
        # If windows are docked together (linked), reposition playlist to maintain docked relationship
        if (self.playlist_detached and self.playlist_window_linked and self._windows_docked and
            hasattr(self, 'detached_playlist_window') and self.detached_playlist_window):
            # Get current link offset to determine docking relationship
            if hasattr(self, '_playlist_window_link_offset') and self._playlist_window_link_offset:
                offset_x, offset_y = self._playlist_window_link_offset
                # Calculate new position based on offset
                new_playlist_x = self.x() + offset_x
                new_playlist_y = self.y() + offset_y
                
                # Check if playlist is at bottom of main window
                main_bottom = self.y() + self.height()
                playlist_top = self.detached_playlist_window.y()
                is_at_bottom = abs(playlist_top - main_bottom) <= self._snap_threshold
                
                # If at bottom or offset indicates bottom docking, reposition to maintain it
                if is_at_bottom or offset_y > self.height() * 0.8:  # Playlist is at or near bottom
                    new_playlist_y = self.y() + self.height()
                    self._moving_detached_playlist_programmatically = True
                    self.detached_playlist_window.move(new_playlist_x, new_playlist_y)
                    # Update link offset
                    self._playlist_window_link_offset = (offset_x, new_playlist_y - self.y())
                    QTimer.singleShot(50, lambda: setattr(self, '_moving_detached_playlist_programmatically', False))
                else:
                    # For other docking positions (top, left, right), maintain the offset
                    self._moving_detached_playlist_programmatically = True
                    self.detached_playlist_window.move(new_playlist_x, new_playlist_y)
                    QTimer.singleShot(50, lambda: setattr(self, '_moving_detached_playlist_programmatically', False))
        
        # Update UI
        self.update_mini_mode_button()
        self.update_mini_mode_menu_text()
        
        # Update hover area position for micro mode changes
        if hasattr(self, 'update_hover_area_position') and self.autohide_address_bar:
            QTimer.singleShot(100, self.update_hover_area_position)
        
        # Update image viewer button visibility (immediate) and position (delayed)
        if hasattr(self, 'image_viewer_btn') and self.image_viewer_btn:
            # Update visibility immediately for quick response
            self.update_image_viewer_btn_visibility()
            # Update position with slight delay to avoid layout interference
            QTimer.singleShot(50, self.update_image_viewer_btn_position)
        # Update trigger button position (moves to top right in micro mode)
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
            self.update_autohide_trigger_position()
        
        # Save settings
        self.save_settings()
    
    def _ensure_window_on_screen(self):
        """Ensure the window is fully visible on screen, adjusting position if needed"""
        try:
            # Get the screen that contains the window
            screen = self.screen()
            if not screen:
                # Fallback to primary screen
                screen = QApplication.primaryScreen()
            
            if not screen:
                return  # Can't determine screen, skip adjustment
            
            # Get available screen geometry (excluding taskbar, etc.)
            available_geometry = screen.availableGeometry()
            
            # Get current window geometry
            window_geometry = self.geometry()
            window_bottom = window_geometry.y() + window_geometry.height()
            screen_bottom = available_geometry.y() + available_geometry.height()
            
            # Check if window would go off the bottom of the screen
            if window_bottom > screen_bottom:
                # Calculate how much we need to move up
                offset = window_bottom - screen_bottom
                new_y = window_geometry.y() - offset
                
                # Ensure we don't move above the top of the screen
                if new_y < available_geometry.y():
                    new_y = available_geometry.y()
                
                # Move window up to keep it on screen
                self.move(window_geometry.x(), new_y)
                logger.debug(f"Adjusted window position from ({window_geometry.x()}, {window_geometry.y()}) to ({window_geometry.x()}, {new_y}) to keep on screen")
        except Exception as e:
            logger.warning(f"Error ensuring window on screen: {e}")
    
    def _apply_mini_mode_qt_widgets(self):
        """Apply mini mode using Qt widgets (new implementation)."""
        logger.debug(f"_apply_mini_mode_qt_widgets: state={self.mini_mode_state}")
        
        layout = self.centralWidget().layout()
        if not layout:
            logger.warning("_apply_mini_mode_qt_widgets: no layout available")
            return
        
        # Hide webview (but keep it loaded for playback)
        if self.web_view:
            self.web_view.hide()
            # Make webview transparent to mouse events so it doesn't block clicks on cover art
            self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            # Lower webview below player widget to ensure it doesn't block clicks
            self.web_view.lower()
            if self.regular_player_widget:
                self.regular_player_widget.raise_()
        
        # Hide all player widgets first
        if self.regular_player_widget:
            self.regular_player_widget.hide()
        if self.mini_player_widget:
            self.mini_player_widget.hide()
        if self.micro_player_widget:
            self.micro_player_widget.hide()
        
        if self.mini_mode_state == 0:
            # Regular mode
            if not self.regular_player_widget:
                self.regular_player_widget = RegularPlayerWidget(self)
            
            # CRITICAL: If widget was created in mini mode, it's in the layout with fixed height
            # We need to remove it from layout and use absolute positioning for regular mode
            layout = self.centralWidget().layout()
            if layout:
                # Check if widget is in the central widget's layout (from mini mode)
                widget_in_central_layout = False
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if item and item.widget() == self.regular_player_widget:
                        widget_in_central_layout = True
                        # Remove from layout - regular mode uses absolute positioning
                        layout.removeWidget(self.regular_player_widget)
                        print(f"[REGULAR MODE DEBUG] Removed regular_player_widget from layout (was in mini mode)")
                        break
            
            # Position absolutely to fill central widget (not in layout, so playlist can overlay)
            central_widget = self.centralWidget()
            if central_widget:
                # Ensure widget is parented to central widget (not in layout)
                if self.regular_player_widget.parent() != central_widget:
                    self.regular_player_widget.setParent(central_widget)
                    print(f"[REGULAR MODE DEBUG] Reparented regular_player_widget to central_widget")
                
                # Remove size constraints from mini mode (fixed height, size policy)
                # In mini mode, the widget has: setSizePolicy(Expanding, Fixed) and setFixedHeight(260)
                # In regular mode, we need: setSizePolicy(Expanding, Expanding) and no fixed height
                self.regular_player_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
                self.regular_player_widget.setMinimumHeight(0)
                self.regular_player_widget.setMaximumHeight(16777215)
                
                # CRITICAL: Remove any opacity effects that might have been applied in mini mode
                current_effect = self.regular_player_widget.graphicsEffect()
                if current_effect:
                    self.regular_player_widget.setGraphicsEffect(None)
                    print(f"[REGULAR MODE DEBUG] Removed opacity effect from regular_player_widget")
                
                # Force update of size hint to allow natural sizing
                self.regular_player_widget.updateGeometry()
                # Update the widget's internal layout to reflect the new size policy
                internal_layout = self.regular_player_widget.layout()
                if internal_layout:
                    internal_layout.update()
                    internal_layout.activate()
                
                # Position to fill central widget area, but account for title bar if present
                def update_player_widget_geometry():
                    if central_widget and self.regular_player_widget:
                        rect = central_widget.rect()
                        # Account for title bar if it exists and is visible
                        top_offset = 0
                        if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                            top_offset = self.title_bar.height()
                        # Position player widget below title bar
                        self.regular_player_widget.setGeometry(0, top_offset, rect.width(), rect.height() - top_offset)
                        print(f"[REGULAR MODE DEBUG] Updated geometry: {self.regular_player_widget.geometry()}")
                        # CRITICAL: Raise player widget above webview to ensure clicks work
                        self.regular_player_widget.raise_()
                        # Update player section position (floats above playlist when needed)
                        self._update_player_section_position()
                        # Ensure playlist is above player widget, and title bar is above everything
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            self.playlist_container.raise_()
                        if hasattr(self, 'title_bar') and self.title_bar:
                            self.title_bar.raise_()
                # Update geometry immediately and after a short delay
                update_player_widget_geometry()
                QTimer.singleShot(10, update_player_widget_geometry)
                QTimer.singleShot(100, update_player_widget_geometry)
                QTimer.singleShot(10, self._update_player_section_position)
                QTimer.singleShot(100, self._update_player_section_position)
            
            # Hide blurred cover art label in regular mode (only used in mini mode)
            if hasattr(self.regular_player_widget, 'blurred_cover_art_label') and self.regular_player_widget.blurred_cover_art_label:
                self.regular_player_widget.blurred_cover_art_label.hide()
            
            # Hide autohide toggle button in regular mode (only available in mini mode)
            if hasattr(self.regular_player_widget, '_update_autohide_for_mini_mode'):
                self.regular_player_widget._update_autohide_for_mini_mode()
            
            # Show tracklist in regular mode
            if hasattr(self.regular_player_widget, 'tracklist_widget') and self.regular_player_widget.tracklist_widget:
                self.regular_player_widget.tracklist_widget.show()
            
            # CRITICAL: Clear playlist container restrictions when switching to regular mode
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.setMinimumHeight(0)
                self.playlist_container.setMaximumHeight(16777215)  # Qt max
                self.playlist_container.updateGeometry()
            
            # CRITICAL: Clear playlist sidebar height restrictions when switching to regular mode
            # BUT: Skip all playlist_sidebar manipulation if playlist is detached (it's in a separate window)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
                # Clear any fixed height (including 230px from micro mode)
                self.playlist_sidebar.setFixedHeight(16777215)  # Qt max to clear fixed height
                self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                self.playlist_sidebar.updateGeometry()
                # Check if playlist is expanded with 230px restriction and clear it
                if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized:
                    current_height = self.playlist_sidebar.height()
                    if current_height == 230:
                        # Clear 230px restriction and restore proper height
                        if hasattr(self.playlist_sidebar, '_restore_height') and self.playlist_sidebar._restore_height:
                            restore_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, self.playlist_sidebar._restore_height)))
                            self.playlist_sidebar.setFixedHeight(restore_height)
                        else:
                            default_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, PLAYLIST_DEFAULT_HEIGHT))
                            self.playlist_sidebar.setFixedHeight(default_height)
                        self.playlist_sidebar.updateGeometry()
                        # Defer UI update instead of forcing immediate processing
                        QTimer.singleShot(0, lambda: self.playlist_sidebar.update() if self.playlist_sidebar else None)
            
            # CRITICAL: Restore playlist state when switching to regular mode
            # Preserve the current state (expanded/collapsed) rather than always using settings
            # BUT: Skip all playlist_sidebar manipulation if playlist is detached (it's in a separate window)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
                # Get CURRENT minimized state (preserve what it is now)
                current_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
                
                # Get saved playlist height from settings (for when expanded)
                attached_height = self.settings.get('playlist_attached_height')
                if attached_height:
                    restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, attached_height))
                else:
                    playlist_height = self.settings.get('playlist_height', PLAYLIST_DEFAULT_HEIGHT)
                    if playlist_height == 135:  # Don't use micro mode height
                        playlist_height = self.settings.get('playlist_height_regular', PLAYLIST_DEFAULT_HEIGHT)
                    restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, playlist_height))
                
                # Remove fixed height constraint from mini mode (230px or minimized height)
                # CRITICAL: Clear any fixed height first (including 230px from micro mode)
                self.playlist_sidebar.setFixedHeight(16777215)  # Clear fixed height
                self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                self.playlist_sidebar.updateGeometry()
                
                # CRITICAL: Preserve the current minimized state (don't toggle)
                # If coming from mini/micro mode, the state should already be correct
                # We just need to adjust the height constraints, not change the state
                print(f"[REGULAR MODE DEBUG] Preserving playlist minimized state: {current_minimized}")
                
                # If not minimized, restore to saved height
                if not current_minimized:
                    # Clear fixed height again to ensure 230px restriction is gone, then set new height
                    self.playlist_sidebar.setFixedHeight(16777215)  # Clear fixed height
                    self.playlist_sidebar.setFixedHeight(restore_height)
                    if hasattr(self.playlist_sidebar, '_restore_height'):
                        self.playlist_sidebar._restore_height = restore_height
                    print(f"[REGULAR MODE DEBUG] Playlist is expanded, restored height from settings: {restore_height}px")
                else:
                    # If minimized, ensure the minimized height is correctly calculated for regular mode
                    # Recalculate to ensure it's correct for regular mode (not mini/micro mode dimensions)
                    def recalculate_minimized_height():
                        # Skip if playlist is detached (it's in a separate window)
                        if self.playlist_detached:
                            return
                        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                            if getattr(self.playlist_sidebar, 'is_minimized', False):
                                # Recalculate minimized height for regular mode
                                title_bar_height = self.playlist_sidebar.title_bar_widget.sizeHint().height() if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget else 30
                                layout = self.playlist_sidebar.layout()
                                if layout:
                                    margins = layout.getContentsMargins()
                                    total_height = title_bar_height + margins[1] + margins[3]  # top + bottom margins
                                else:
                                    total_height = title_bar_height + 10  # Add some padding
                                
                                # Set the correct minimized height
                                self.playlist_sidebar.setFixedHeight(total_height)
                                print(f"[REGULAR MODE DEBUG] Recalculated minimized playlist height: {total_height}px")
                                
                                # Force geometry update
                                self.playlist_sidebar.updateGeometry()
                                if hasattr(self, 'playlist_container') and self.playlist_container:
                                    self.playlist_container.updateGeometry()
                                    layout = self.centralWidget().layout()
                                    if layout:
                                        layout.update()
                                        layout.activate()
                    # Also trigger the recompute function that handles edge cases
                    if hasattr(self.playlist_sidebar, '_recompute_minimized_geometry_if_needed'):
                        QTimer.singleShot(50, self.playlist_sidebar._recompute_minimized_geometry_if_needed)
                        QTimer.singleShot(100, self.playlist_sidebar._recompute_minimized_geometry_if_needed)
                    
                    QTimer.singleShot(50, recalculate_minimized_height)
                    QTimer.singleShot(100, recalculate_minimized_height)
                    print(f"[REGULAR MODE DEBUG] Playlist is minimized, recalculating minimized height for regular mode")
                
                # Ensure playlist container is properly positioned for regular mode
                # Remove from absolute positioning if it was used in mini mode
                # BUT: Skip if playlist is detached (it's in a separate window)
                if hasattr(self, 'playlist_container') and self.playlist_container and not self.playlist_detached:
                    layout = self.centralWidget().layout()
                    if layout:
                        # Check if container is in layout
                        container_in_layout = False
                        for i in range(layout.count()):
                            item = layout.itemAt(i)
                            if item and item.widget() == self.playlist_container:
                                container_in_layout = True
                                break
                        # If not in layout, add it back (regular mode uses layout)
                        if not container_in_layout:
                            layout.addWidget(self.playlist_container, 0, Qt.AlignmentFlag.AlignBottom)
                            layout.update()
                            layout.activate()
                            print(f"[REGULAR MODE DEBUG] Added playlist_container back to layout for regular mode")
            
            # Playlist is now available in mini mode, so no need to restore visibility
            # (it was never hidden in the new implementation)
            
            # Restore player section to layout in regular mode (if it was removed for mini mode)
            if hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                player_section = self.regular_player_widget.player_section
                # Check if player section is not in layout (was positioned absolutely in mini mode)
                if player_section.parent() == self.regular_player_widget:
                    # Restore to layout
                    main_layout = self.regular_player_widget.layout()
                    if main_layout:
                        # Remove from absolute positioning
                        player_section.setParent(self.regular_player_widget)
                        # CRITICAL: Restore original styling (remove mini mode transparency)
                        # In mini mode, player section has: rgba(20, 20, 20, 0.85) with border-radius
                        # In regular mode, it should be: solid #2b2b2b with no border-radius
                        player_section.setStyleSheet("background-color: #2b2b2b;")
                        # Remove any opacity effects that might have been applied
                        current_effect = player_section.graphicsEffect()
                        if current_effect:
                            player_section.setGraphicsEffect(None)
                        # Re-add to layout (it should already be in layout, but ensure it's visible)
                        player_section.show()
                
                # CRITICAL: Also ensure player section styling is restored even if already in layout
                # This handles the case where it's in layout but still has mini mode styling
                player_section = self.regular_player_widget.player_section
                # Check if it has mini mode styling (transparent background)
                current_style = player_section.styleSheet()
                if "rgba" in current_style or "0.85" in current_style:
                    # Has mini mode styling - restore regular mode styling
                    player_section.setStyleSheet("background-color: #2b2b2b;")
                    print(f"[REGULAR MODE DEBUG] Restored player section styling from mini mode (removed transparency)")
                # Remove any opacity effects
                current_effect = player_section.graphicsEffect()
                if current_effect:
                    player_section.setGraphicsEffect(None)
                    print(f"[REGULAR MODE DEBUG] Removed opacity effect from player section")
            
            # Restore cover art to layout in regular mode (if it was removed for mini mode)
            if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                cover_art = self.regular_player_widget.cover_art_label
                # Check if cover art is not in layout (was positioned absolutely in mini mode)
                main_layout = self.regular_player_widget.layout()
                if main_layout and cover_art.parent() == self.regular_player_widget:
                    # Re-add to layout at position 0 (before player section)
                    main_layout.insertWidget(0, cover_art)
                    # Restore fixed height
                    cover_art.setFixedHeight(260)
            
            self.regular_player_widget.show()
            
            # Update cover art when switching to regular mode (in case page was already loaded)
            if hasattr(self.regular_player_widget, '_update_cover_art'):
                QTimer.singleShot(100, self.regular_player_widget._update_cover_art)
            
            # Update tracklist when switching to regular mode (in case page was already loaded)
            # This ensures the tracklist reflects the currently loaded album when switching from mini/micro mode
            if hasattr(self.regular_player_widget, '_update_tracklist'):
                QTimer.singleShot(500, self.regular_player_widget._update_tracklist)
            
            # Set window size - increase height to accommodate tracklist
            # Cover art (260px) + Player section (105px fixed) + Tracklist (min 150px) + Controls bar (~40px) = ~555px minimum
            # Use 650px to give tracklist more room
            regular_mode_height = 650
            self.setMinimumSize(WINDOW_DEFAULT_WIDTH, regular_mode_height)
            self.setMaximumSize(WINDOW_DEFAULT_WIDTH, regular_mode_height)
            self.resize(WINDOW_DEFAULT_WIDTH, regular_mode_height)
            QApplication.processEvents()
            
            # Sync shuffle/repeat buttons with centralized state
            QTimer.singleShot(100, self._sync_shuffle_repeat_buttons)
            
            self._ensure_window_on_screen()
            logger.debug(f"Switched to regular mode (Qt widget): {WINDOW_DEFAULT_WIDTH}x{WINDOW_DEFAULT_HEIGHT}")
            
        elif self.mini_mode_state == 1:
            # Mini mode - reuse regular player widget but hide tracklist
            # CONVERTED TO USE LAYOUT like regular mode for easier management
            if not self.regular_player_widget:
                self.regular_player_widget = RegularPlayerWidget(self)
            
            # CRITICAL: If widget was in regular mode (absolute positioning), remove it and add to layout
            layout = self.centralWidget().layout()
            if layout:
                # Check if widget is in the central widget's layout
                widget_in_central_layout = False
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if item and item.widget() == self.regular_player_widget:
                        widget_in_central_layout = True
                        break
                
                if not widget_in_central_layout:
                    # Widget was positioned absolutely in regular mode - add it to layout for mini mode
                    # Find playlist container index
                    playlist_index = -1
                    for i in range(layout.count()):
                        item = layout.itemAt(i)
                        if item and item.widget() == getattr(self, 'playlist_container', None):
                            playlist_index = i
                            break
                    if playlist_index >= 0:
                        layout.insertWidget(playlist_index, self.regular_player_widget)
                    else:
                        layout.addWidget(self.regular_player_widget)
                    print(f"[MINI MODE DEBUG] Added regular_player_widget to layout (was in regular mode)")
                
                # Set size policy - expanding horizontally, fixed height (260px for cover art)
                self.regular_player_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
                self.regular_player_widget.setFixedHeight(260)  # Cover art height
            else:
                # Fallback to absolute positioning if no layout
                central_widget = self.centralWidget()
                if central_widget:
                    self.regular_player_widget.setParent(central_widget)
                    self.regular_player_widget.setGeometry(0, 0, central_widget.width(), 260)
            
            # CRITICAL: Ensure player section is in the widget's internal layout (not positioned absolutely)
            # In regular mode, player section might be positioned absolutely when floating above playlist
            # In mini mode, it must be in the layout at the bottom of the widget
            if hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                player_section = self.regular_player_widget.player_section
                main_layout = self.regular_player_widget.layout()
                
                # Check if player section is in the widget's layout
                player_section_in_layout = False
                if main_layout:
                    for i in range(main_layout.count()):
                        item = main_layout.itemAt(i)
                        if item and item.widget() == player_section:
                            player_section_in_layout = True
                            break
                
                # If not in layout, add it back (it might have been positioned absolutely in regular mode)
                if not player_section_in_layout and main_layout:
                    print(f"[MINI MODE DEBUG] Player section not in layout, adding it back")
                    # Ensure it's parented to the widget
                    if player_section.parent() != self.regular_player_widget:
                        player_section.setParent(self.regular_player_widget)
                    # Add to layout (should be after cover art)
                    # Find cover art position
                    cover_art_index = -1
                    for i in range(main_layout.count()):
                        item = main_layout.itemAt(i)
                        if item and item.widget() == getattr(self.regular_player_widget, 'cover_art_label', None):
                            cover_art_index = i
                            break
                    if cover_art_index >= 0:
                        main_layout.insertWidget(cover_art_index + 1, player_section)
                    else:
                        main_layout.addWidget(player_section)
                    # Reset any absolute geometry that might have been set
                    player_section.setGeometry(0, 0, 0, 0)  # Let layout handle positioning
                
                # Reset size policy and constraints for layout-based positioning
                player_section.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
                player_section.setFixedHeight(129)  # Updated height to account for 15px padding (was 105px with smaller padding)
                player_section.setMinimumHeight(0)
                player_section.setMaximumHeight(16777215)
                
                # Make it semi-transparent overlay
                # Only round top corners - bottom corners should be square (0px) to align with playlist
                # This prevents corners from poking out when playlist is displayed below
                player_section.setStyleSheet("""
                    QWidget {
                        background-color: rgba(20, 20, 20, 0.75);
                        border-top-left-radius: 8px;
                        border-top-right-radius: 8px;
                        border-bottom-left-radius: 0px;
                        border-bottom-right-radius: 0px;
                    }
                """)
                
                # Force layout update
                if main_layout:
                    main_layout.update()
                    main_layout.activate()
                    player_section.updateGeometry()
            
            # CRITICAL: Hide tracklist in mini mode
            # This must be done explicitly to ensure it's hidden when switching from regular mode
            if hasattr(self.regular_player_widget, 'tracklist_widget') and self.regular_player_widget.tracklist_widget:
                self.regular_player_widget.tracklist_widget.hide()
                self.regular_player_widget.tracklist_widget.setVisible(False)
                print(f"[MINI MODE DEBUG] Hid tracklist widget")
            
            # Ensure cover art is in layout and has fixed height
            if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                cover_art = self.regular_player_widget.cover_art_label
                # Keep in layout - set fixed height
                cover_art.setFixedHeight(260)  # Cover art height
            
            self.regular_player_widget.show()
            
            # CRITICAL: Force update of mini mode layout to reset player section position
            # This ensures player section is at the bottom (not offset from regular mode)
            QTimer.singleShot(10, self._update_mini_mode_layout)
            QTimer.singleShot(50, self._update_mini_mode_layout)
            QTimer.singleShot(100, self._update_mini_mode_layout)
            
            # Trigger cover art update to load
            if hasattr(self.regular_player_widget, '_update_cover_art'):
                QTimer.singleShot(100, self.regular_player_widget._update_cover_art)
            
            # CRITICAL: Clear regular mode playlist height constraints and set mini mode specific heights
            # Each mode should have independent sizing, but preserve open/closed/minimized/expanded state
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
                # Clear any regular mode height constraints first
                self.playlist_sidebar.setFixedHeight(16777215)  # Clear fixed height
                self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                self.playlist_sidebar.updateGeometry()
                
                # Get current minimized state (preserve it)
                is_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
                
                # Set mini mode specific height based on state
                if is_minimized:
                    # Minimized: use actual minimized height (title bar + margins)
                    title_bar_height = self.playlist_sidebar.title_bar_widget.sizeHint().height() if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget else 30
                    layout = self.playlist_sidebar.layout()
                    if layout:
                        margins = layout.getContentsMargins()
                        minimized_height = title_bar_height + margins[1] + margins[3]  # top + bottom margins
                    else:
                        minimized_height = title_bar_height + 10  # Add some padding
                    self.playlist_sidebar.setFixedHeight(minimized_height)
                    print(f"[MINI MODE DEBUG] Set playlist sidebar to minimized height: {minimized_height}px")
                else:
                    # Expanded: always 230px in mini mode
                    self.playlist_sidebar.setFixedHeight(230)
                    print(f"[MINI MODE DEBUG] Set playlist sidebar to expanded height: 230px (mini mode)")
                
                self.playlist_sidebar.updateGeometry()
                QApplication.processEvents()
            
            # Set window size: Cover art only (260px) - player overlays it
            # Resize to account for playlist visibility - preserve playlist state
            playlist_visible = False
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible():
                playlist_visible = True
            elif hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible():
                playlist_visible = True
            
            # Ensure playlist container is visible if playlist sidebar is visible
            if playlist_visible and hasattr(self, 'playlist_container') and self.playlist_container:
                if not self.playlist_container.isVisible():
                    self.playlist_container.show()
            
            # Resize with delays to ensure geometry is correct
            self._debounced_resize_mini_mode(playlist_visible, delay=100)
            
            # Sync shuffle/repeat buttons with centralized state
            QTimer.singleShot(100, self._sync_shuffle_repeat_buttons)
            
            self._ensure_window_on_screen()
            logger.debug("Switched to mini mode (Qt widget)")
            
        elif self.mini_mode_state == 2:
            # Micro mode - Qt-only implementation
            # CRITICAL: Ensure regular player widget is hidden in micro mode
            if self.regular_player_widget:
                if self.regular_player_widget.isVisible():
                    print(f"[MICRO MODE DEBUG] _apply_mini_mode_qt_widgets: WARNING - regular_player_widget is visible! Hiding it...")
                    self.regular_player_widget.hide()
            
            if not self.micro_player_widget:
                self.micro_player_widget = MicroPlayerWidget(self)
                layout.insertWidget(1, self.micro_player_widget, 1)
            
            self.micro_player_widget.show()
            
            # CRITICAL: Double-check regular player widget is hidden after showing micro player
            # This prevents duplicate player from appearing when playlist expands
            if self.regular_player_widget:
                if self.regular_player_widget.isVisible():
                    print(f"[MICRO MODE DEBUG] _apply_mini_mode_qt_widgets: WARNING - regular_player_widget became visible! Hiding it again...")
                    self.regular_player_widget.hide()
            
            # Update cover art when switching to micro mode
            QTimer.singleShot(50, self.micro_player_widget._update_cover_art)
            QTimer.singleShot(300, self.micro_player_widget._update_cover_art)  # Retry after page settles
            
            # CRITICAL: Clear regular mode playlist height constraints and set micro mode specific heights
            # Each mode should have independent sizing, but preserve open/closed/minimized/expanded state
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
                # Clear any regular mode height constraints first
                self.playlist_sidebar.setFixedHeight(16777215)  # Clear fixed height
                self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                self.playlist_sidebar.updateGeometry()
                
                # Get current minimized state (preserve it)
                is_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
                
                # Set micro mode specific height based on state
                if is_minimized:
                    # Minimized: use actual minimized height (title bar + margins)
                    title_bar_height = self.playlist_sidebar.title_bar_widget.sizeHint().height() if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget else 30
                    layout = self.playlist_sidebar.layout()
                    if layout:
                        margins = layout.getContentsMargins()
                        minimized_height = title_bar_height + margins[1] + margins[3]  # top + bottom margins
                    else:
                        minimized_height = title_bar_height + 10  # Add some padding
                    self.playlist_sidebar.setFixedHeight(minimized_height)
                    print(f"[MICRO MODE DEBUG] Set playlist sidebar to minimized height: {minimized_height}px")
                else:
                    # Expanded: always 230px in micro mode
                    self.playlist_sidebar.setFixedHeight(230)
                    print(f"[MICRO MODE DEBUG] Set playlist sidebar to expanded height: 230px (micro mode)")
                
                self.playlist_sidebar.updateGeometry()
                QApplication.processEvents()
            
            # Get playlist visibility state
            playlist_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
            
            # CRITICAL: Use _resize_mini_mode_for_playlist to ensure proper positioning and resizing
            # This function handles playlist container positioning, height calculations, and window resizing
            # It also ensures the playlist respects the player's padding
            def resize_micro_mode():
                if not self.micro_player_widget or self.mini_mode_state != 2:
                    return
                
                # Get current playlist visibility (may have changed)
                current_playlist_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
                
                # Use the comprehensive resize function that handles all positioning
                self._resize_mini_mode_for_playlist(current_playlist_visible)
            
            # Resize after widget is shown and has calculated its height
            # Use multiple delays to ensure layout has settled
            QTimer.singleShot(10, resize_micro_mode)
            QTimer.singleShot(50, resize_micro_mode)
            QTimer.singleShot(100, resize_micro_mode)
            QTimer.singleShot(200, resize_micro_mode)
            
            # Sync shuffle/repeat buttons with centralized state
            QTimer.singleShot(100, self._sync_shuffle_repeat_buttons)
            
            # CRITICAL: Sync playlist button state with actual playlist visibility
            # This ensures the button shows the correct state when entering micro mode
            def sync_playlist_button():
                if self.mini_mode_state != 2:
                    return
                playlist_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
                self._update_playlist_button_icon(playlist_visible)
            # Sync immediately and with delays to ensure it happens after widget is shown
            sync_playlist_button()
            QTimer.singleShot(10, sync_playlist_button)
            QTimer.singleShot(50, sync_playlist_button)
            QTimer.singleShot(100, sync_playlist_button)
            
            self._ensure_window_on_screen()
            logger.debug("Switched to micro mode (Qt widget)")
    
    def _debounced_resize_mini_mode(self, playlist_visible, delay=150):
        """Debounced version of _resize_mini_mode_for_playlist to avoid multiple rapid calls"""
        if not hasattr(self, '_resize_mini_mode_timer'):
            self._resize_mini_mode_timer = QTimer(self)
            self._resize_mini_mode_timer.setSingleShot(True)
            self._resize_mini_mode_timer.timeout.connect(
                lambda: self._resize_mini_mode_for_playlist(playlist_visible)
            )
        
        # Update the playlist_visible value for the next call
        # Store it so the timer callback uses the latest value
        self._pending_resize_playlist_visible = playlist_visible
        
        # Stop existing timer and restart with delay (debounce)
        self._resize_mini_mode_timer.stop()
        # Update timeout connection to use latest value
        self._resize_mini_mode_timer.timeout.disconnect()
        self._resize_mini_mode_timer.timeout.connect(
            lambda: self._resize_mini_mode_for_playlist(self._pending_resize_playlist_visible)
        )
        self._resize_mini_mode_timer.start(delay)
    
    def _resize_mini_mode_for_playlist(self, playlist_visible):
        """Resize mini/micro mode window to account for playlist visibility"""
        print(f"[DEBUG] _resize_mini_mode_for_playlist called: playlist_visible={playlist_visible}, mini_mode_state={self.mini_mode_state if hasattr(self, 'mini_mode_state') else 'N/A'}")
        if self.mini_mode_state not in (1, 2):
            print(f"[DEBUG] _resize_mini_mode_for_playlist: Not in mini/micro mode, returning")
            return
        
        # CRITICAL: In micro mode, ensure regular player widget stays hidden
        # This prevents duplicate player from appearing when playlist expands
        if self.mini_mode_state == 2:
            if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                if self.regular_player_widget.isVisible():
                    print(f"[MICRO MODE DEBUG] _resize_mini_mode_for_playlist: WARNING - regular_player_widget is visible! Hiding it...")
                    self.regular_player_widget.hide()
            # Ensure webview stays hidden in micro mode
            if self.web_view and self.web_view.isVisible():
                print(f"[MICRO MODE DEBUG] _resize_mini_mode_for_playlist: Ensuring webview is hidden")
                self.web_view.hide()
                # Make webview transparent to mouse events so it doesn't block clicks on cover art
                self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        
        # Get title bar height
        title_bar_height = 0
        if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
            title_bar_height = self.title_bar.height()
        
        # Base height depends on mode:
        # Mini mode (state 1): cover art (260px) + title bar
        # Micro mode (state 2): player height + title bar (will be calculated from player)
        if self.mini_mode_state == 1:
            base_height = 260 + title_bar_height
            print(f"[DEBUG] _resize_mini_mode_for_playlist: MINI MODE - base_height={base_height} (260 + {title_bar_height})")
        else:  # micro mode (state 2) - Qt-only implementation
            # Get player height from Qt widget
            if hasattr(self, 'micro_player_widget') and self.micro_player_widget:
                player_height = self.micro_player_widget.height()
                if player_height <= 0:
                    # Fallback: use size hint
                    player_height = self.micro_player_widget.sizeHint().height()
                    if player_height <= 0:
                        player_height = 140  # Default fallback
                base_height = player_height + title_bar_height
                print(f"[DEBUG] _resize_mini_mode_for_playlist: MICRO MODE - base_height={base_height} (player: {player_height} + title: {title_bar_height})")
            else:
                # Widget not created yet, use fallback
                base_height = 140 + title_bar_height
                print(f"[DEBUG] _resize_mini_mode_for_playlist: MICRO MODE - widget not available, using fallback base_height={base_height}")
        
        # Add playlist height if visible
        playlist_height = 0
        
        # CRITICAL: If playlist is not visible, ensure container height is cleared
        # This prevents using stale height values from when it was visible
        if not playlist_visible:
            if hasattr(self, 'playlist_container') and self.playlist_container:
                # Clear any height constraints on hidden container
                self.playlist_container.setMinimumHeight(0)
                self.playlist_container.setMaximumHeight(16777215)  # Qt max
                self.playlist_container.updateGeometry()
            # Set playlist_height to 0 and continue to calculate total_height
            playlist_height = 0
            print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist_visible=False, playlist_height=0")
        else:
            # CRITICAL: Double-check actual visibility - container must be visible
            container_actually_visible = (hasattr(self, 'playlist_container') and self.playlist_container and 
                                          self.playlist_container.isVisible())
            sidebar_actually_visible = (hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and 
                                        self.playlist_sidebar.isVisible())
            playlist_actually_visible = container_actually_visible and sidebar_actually_visible
            
            if not playlist_actually_visible:
                # Container or sidebar is not actually visible, don't add height
                print(f"[DEBUG] _resize_mini_mode_for_playlist: Container or sidebar not actually visible, playlist_height=0")
                playlist_height = 0
            else:
                print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist_visible=True, checking playlist container")
                # CRITICAL: Don't show container if playlist is detached (causes black overlay)
                if getattr(self, 'playlist_detached', False):
                    print(f"[DEBUG] _resize_mini_mode_for_playlist: Playlist is detached, skipping all container/sidebar operations")
                    logger.debug(f"[DEBUG] _resize_mini_mode_for_playlist: Playlist is detached, skipping all container/sidebar operations")
                    playlist_height = 0  # Don't add playlist height when detached
                elif hasattr(self, 'playlist_container') and self.playlist_container:
                    print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist_container exists, visible={self.playlist_container.isVisible()}")
                    # Ensure playlist container is visible (only if not detached)
                    if not self.playlist_container.isVisible():
                        print(f"[DEBUG] _resize_mini_mode_for_playlist: Showing playlist container")
                        self.playlist_container.show()
                    # Ensure playlist sidebar is visible (only if not detached)
                    if not getattr(self, 'playlist_detached', False) and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist_sidebar exists, visible={self.playlist_sidebar.isVisible()}")
                        if not self.playlist_sidebar.isVisible():
                            print(f"[DEBUG] _resize_mini_mode_for_playlist: Showing playlist sidebar")
                            self.playlist_sidebar.show()
                        # Force geometry update
                        self.playlist_sidebar.updateGeometry()
                    
                    # CRITICAL: After showing playlist, ensure regular player widget and webview stay hidden in micro mode
                    # Add multiple delayed checks to catch any widgets that might have been shown
                    if self.mini_mode_state == 2:
                        def ensure_micro_mode_widgets_hidden():
                            if self.mini_mode_state != 2:
                                return  # No longer in micro mode
                            if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                                if self.regular_player_widget.isVisible():
                                    print(f"[MICRO MODE DEBUG] _resize_mini_mode_for_playlist: Delayed check - regular_player_widget is visible! Hiding it...")
                                    self.regular_player_widget.hide()
                            if self.web_view and self.web_view.isVisible():
                                print(f"[MICRO MODE DEBUG] _resize_mini_mode_for_playlist: Delayed check - webview is visible! Hiding it...")
                                self.web_view.hide()
                                # Make webview transparent to mouse events so it doesn't block clicks on cover art
                                self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
                        # Run checks at multiple intervals to catch any delayed shows
                        QTimer.singleShot(10, ensure_micro_mode_widgets_hidden)
                        QTimer.singleShot(50, ensure_micro_mode_widgets_hidden)
                        QTimer.singleShot(100, ensure_micro_mode_widgets_hidden)
                        QTimer.singleShot(200, ensure_micro_mode_widgets_hidden)
                        QTimer.singleShot(500, ensure_micro_mode_widgets_hidden)
                    elif getattr(self, 'playlist_detached', False):
                        print(f"[DEBUG] _resize_mini_mode_for_playlist: Playlist is detached, skipping sidebar operations")
                        logger.debug(f"[DEBUG] _resize_mini_mode_for_playlist: Playlist is detached, skipping sidebar operations")
                    
                    # CRITICAL: Ensure playlist container is in layout (layout-based approach)
                    layout = self.centralWidget().layout()
                    if layout:
                        container_in_layout = False
                        for i in range(layout.count()):
                            item = layout.itemAt(i)
                            if item and item.widget() == self.playlist_container:
                                container_in_layout = True
                                break
                        if not container_in_layout and not getattr(self, 'playlist_detached', False):
                            # Add to layout if not already there
                            layout.addWidget(self.playlist_container, 0, Qt.AlignmentFlag.AlignBottom)
                    
                    # CRITICAL: Set container height to match sidebar height in micro mode only
                    # This ensures micro mode playlist expands properly like mini mode
                    # Only apply this in micro mode (state 2) to avoid affecting regular mode
                    # Clear restrictions first if NOT in micro mode
                    if self.mini_mode_state != 2:
                        # Not in micro mode - clear any container height restrictions
                        self.playlist_container.setMinimumHeight(0)
                        self.playlist_container.setMaximumHeight(16777215)  # Qt max
                    
                    if self.mini_mode_state == 2 and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        is_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
                        if not is_minimized:
                            # Expanded: container should be 230px in micro mode (same as mini mode)
                            container_height = 230
                            print(f"[MICRO MODE DEBUG] _resize_mini_mode_for_playlist: Setting playlist_container height to 230px for micro mode")
                            self.playlist_container.setMinimumHeight(container_height)
                            self.playlist_container.setMaximumHeight(container_height)
                        else:
                            # Minimized: use actual sidebar height (includes title bar + margins/padding + outline)
                            # This ensures the full title bar and its outline are visible without cutoff
                            container_height = self.playlist_sidebar.height()
                            if container_height == 0:
                                container_height = self.playlist_sidebar.sizeHint().height()
                            if container_height == 0:
                                # Fallback: use title bar widget height + padding for margins + outline
                                if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                                    title_bar_height = self.playlist_sidebar.title_bar_widget.height()
                                    if title_bar_height == 0:
                                        title_bar_height = self.playlist_sidebar.title_bar_widget.sizeHint().height()
                                    # Add 8px for container margins and title bar outline
                                    container_height = title_bar_height + 4
                                else:
                                    container_height = 34  # Safe fallback (30px title bar + 8px margin/outline)
                            else:
                                # If we got the actual height, add 8px to account for outline
                                container_height = container_height + 4
                            print(f"[MICRO MODE DEBUG] _resize_mini_mode_for_playlist: Setting playlist_container height to {container_height}px (minimized) for micro mode")
                            self.playlist_container.setMinimumHeight(container_height)
                            self.playlist_container.setMaximumHeight(container_height)
                    
                    # Force geometry update on container
                    self.playlist_container.updateGeometry()
                    QApplication.processEvents()
                    
                    playlist_height = self.playlist_container.height()
                    print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist_container.height()={playlist_height}")
                    if playlist_height == 0:
                        # Get preferred height if not set
                        playlist_height = self.playlist_container.sizeHint().height()
                        print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist_container.sizeHint().height()={playlist_height}")
                    if playlist_height == 0 and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        # Try to get height from playlist sidebar
                        playlist_height = self.playlist_sidebar.height()
                        print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist_sidebar.height()={playlist_height}")
                        if playlist_height == 0:
                            playlist_height = self.playlist_sidebar.sizeHint().height()
                            print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist_sidebar.sizeHint().height()={playlist_height}")
                        # Add title bar height if playlist is not minimized
                        is_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
                        print(f"[DEBUG] _resize_mini_mode_for_playlist: playlist is_minimized={is_minimized}")
                        if not is_minimized:
                            # CRITICAL: In mini/micro mode, expanded playlist should always be 230px
                            # Clear any regular mode height constraints first
                            self.playlist_sidebar.setFixedHeight(16777215)  # Clear fixed height
                            self.playlist_sidebar.updateGeometry()
                            QApplication.processEvents()
                            # Now set mini/micro mode specific height
                            playlist_height = 230
                            print(f"[DEBUG] _resize_mini_mode_for_playlist: Expanded playlist, using fixed height=230px (cleared regular mode constraints)")
                            # Set fixed height on playlist sidebar to enforce 230px
                            self.playlist_sidebar.setFixedHeight(230)
                            self.playlist_sidebar.updateGeometry()
                            if hasattr(self.playlist_sidebar, '_restore_height'):
                                # Don't overwrite restore height - it's for regular mode
                                pass
                        else:
                            # If minimized, use actual container height (includes margins/padding + outline)
                            # This ensures the full title bar and its outline are visible without cutoff
                            playlist_height = self.playlist_container.height()
                            if playlist_height == 0:
                                playlist_height = self.playlist_container.sizeHint().height()
                            if playlist_height == 0:
                                # Fallback: use sidebar height
                                playlist_height = self.playlist_sidebar.height()
                                if playlist_height == 0:
                                    playlist_height = self.playlist_sidebar.sizeHint().height()
                            if playlist_height == 0:
                                # Final fallback: use title bar widget height + padding for margins + outline
                                if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                                    playlist_title_height = self.playlist_sidebar.title_bar_widget.height()
                                    if playlist_title_height == 0:
                                        playlist_title_height = self.playlist_sidebar.title_bar_widget.sizeHint().height()
                                    # Add 8px for container margins and title bar outline
                                    playlist_height = playlist_title_height + 8
                                else:
                                    playlist_height = 38  # Safe fallback (30px title bar + 8px margin/outline)
                            else:
                                # If we got the actual height, add 8px to account for outline
                                playlist_height = playlist_height + 8
                            print(f"[DEBUG] _resize_mini_mode_for_playlist: Minimized, using container height={playlist_height}px (includes margins + outline)")
                    
                    # If still 0, use a default height
                    if playlist_height == 0:
                        # Default to minimized height (title bar only) or expanded height
                        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                            if hasattr(self.playlist_sidebar, 'is_minimized') and self.playlist_sidebar.is_minimized:
                                playlist_height = 30  # Approximate title bar height
                            else:
                                playlist_height = 230  # Fixed expanded height for mini/micro mode
                                # Clear any regular mode height constraints first
                                self.playlist_sidebar.setFixedHeight(16777215)  # Clear fixed height
                                self.playlist_sidebar.updateGeometry()
                                QApplication.processEvents()
                                # Set fixed height on playlist sidebar
                                self.playlist_sidebar.setFixedHeight(230)
                                self.playlist_sidebar.updateGeometry()
                        else:
                            playlist_height = 30  # Fallback
                        print(f"[DEBUG] _resize_mini_mode_for_playlist: Using default height={playlist_height}")
                else:
                    print(f"[DEBUG] _resize_mini_mode_for_playlist: No playlist_container found!")
        
        # Total window height
        total_height = base_height + playlist_height
        print(f"[DEBUG] _resize_mini_mode_for_playlist: total_height={total_height} (base={base_height} + playlist={playlist_height})")
        
        # Set window size
        # Set flag to allow programmatic resize (prevents resizeEvent from blocking it)
        self._mini_mode_playlist_resizing = True
        self.setMinimumSize(WINDOW_DEFAULT_WIDTH, total_height)
        self.setMaximumSize(WINDOW_DEFAULT_WIDTH, total_height)
        self.resize(WINDOW_DEFAULT_WIDTH, total_height)
        print(f"[DEBUG] _resize_mini_mode_for_playlist: Resized window to {WINDOW_DEFAULT_WIDTH}x{total_height}, actual size: {self.width()}x{self.height()}")
        QApplication.processEvents()
        # Clear flag after resize completes
        QTimer.singleShot(50, lambda: setattr(self, '_mini_mode_playlist_resizing', False))
        
        # Layout handles positioning automatically - just update layout
        layout = self.centralWidget().layout()
        if layout:
            layout.update()
            layout.activate()
        
        # CRITICAL: In micro mode, ensure playlist container is positioned correctly below player
        # The layout should handle this automatically, but we need to ensure it's done
        if self.mini_mode_state == 2:
            # Force layout update to ensure playlist is positioned below player
            def ensure_micro_mode_layout():
                if self.mini_mode_state != 2:
                    return
                layout = self.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                    QApplication.processEvents()
                    # Double-check window size is correct
                    if hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible():
                        # Recalculate and resize if needed
                        current_playlist_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
                        if current_playlist_visible:
                            # Get actual heights
                            if hasattr(self, 'micro_player_widget') and self.micro_player_widget:
                                player_height = self.micro_player_widget.height()
                                if player_height > 0:
                                    title_bar_height = 0
                                    if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                                        title_bar_height = self.title_bar.height()
                                    playlist_height = self.playlist_container.height()
                                    if playlist_height == 0:
                                        playlist_height = self.playlist_container.sizeHint().height()
                                    expected_height = player_height + title_bar_height + playlist_height
                                    if abs(self.height() - expected_height) > 5:  # Allow 5px tolerance
                                        print(f"[MICRO MODE DEBUG] Window height mismatch: expected={expected_height}, actual={self.height()}, resizing...")
                                        self.setMinimumSize(WINDOW_DEFAULT_WIDTH, expected_height)
                                        self.setMaximumSize(WINDOW_DEFAULT_WIDTH, expected_height)
                                        self.resize(WINDOW_DEFAULT_WIDTH, expected_height)
                                        QApplication.processEvents()
            # Run checks at multiple intervals to ensure layout settles
            QTimer.singleShot(10, ensure_micro_mode_layout)
            QTimer.singleShot(50, ensure_micro_mode_layout)
            QTimer.singleShot(100, ensure_micro_mode_layout)
            QTimer.singleShot(200, ensure_micro_mode_layout)
        
        # Still need to update internal widget positioning (cover art, player section)
        QTimer.singleShot(10, self._update_mini_mode_layout)
        QTimer.singleShot(100, self._update_mini_mode_layout)
    
    def _update_mini_mode_layout(self):
        """Update player section and playlist container positions in mini mode"""
        if self.mini_mode_state != 1:
            return
        
        # With layout-based approach, we only need to update internal widget positioning
        # The player widget itself is managed by the layout
        if hasattr(self, 'regular_player_widget') and self.regular_player_widget and self.regular_player_widget.isVisible():
            widget_width = self.regular_player_widget.width()
            widget_height = self.regular_player_widget.height()
            
            # Position cover art within widget (still needs absolute positioning for overlay effect)
            if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                cover_art = self.regular_player_widget.cover_art_label
                # Reset geometry to fill widget (removes any offset from regular mode)
                cover_art.setGeometry(0, 0, widget_width, widget_height)
                cover_art.lower()
            
            # Position player section at bottom of cover art - ALWAYS at the bottom
            # CRITICAL: Reset any geometry from regular mode (floating above playlist)
            if hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                player_section = self.regular_player_widget.player_section
                player_height = player_section.height()
                if player_height == 0:
                    player_height = 105  # Default player section height
                
                # Calculate bottom position relative to widget (not window)
                # Widget is 260px tall, player section is 105px, so bottom_y = 260 - 105 = 155
                bottom_y = widget_height - player_height
                
                # CRITICAL: Reset geometry to ensure it's at the bottom (removes any offset from regular mode)
                # This fixes the issue where player section is pushed up by ~30px when switching from regular mode
                player_section.setGeometry(0, bottom_y, widget_width, player_height)
                player_section.raise_()  # Above cover art, below playlist
                
                # Check if autohide is enabled - if so, hide player section (only show on hover)
                autohide_enabled = (hasattr(self.regular_player_widget, '_autohide_enabled') and 
                                   self.regular_player_widget._autohide_enabled)
                if autohide_enabled:
                    # Hide player section and blurred background - it should only show when user hovers over hotzone
                    # Use _hide_player_section() to ensure blurred background is also hidden
                    if hasattr(self.regular_player_widget, '_hide_player_section'):
                        self.regular_player_widget._hide_player_section()
                    else:
                        # Fallback: hide directly if method doesn't exist
                        player_section.hide()
                        if hasattr(self.regular_player_widget, '_player_section_visible'):
                            self.regular_player_widget._player_section_visible = False
                        # Also hide blurred background
                        if hasattr(self.regular_player_widget, 'blurred_cover_art_label') and self.regular_player_widget.blurred_cover_art_label:
                            self.regular_player_widget.blurred_cover_art_label.hide()
                    # Start autohide timer to keep it hidden
                    if hasattr(self.regular_player_widget, '_start_autohide_timer'):
                        QTimer.singleShot(50, self.regular_player_widget._start_autohide_timer)
                else:
                    # Autohide disabled - show player section normally
                    player_section.show()  # Ensure it's visible
                
                # Update autohide button position and state
                if hasattr(self.regular_player_widget, '_update_autohide_for_mini_mode'):
                    self.regular_player_widget._update_autohide_for_mini_mode()
                # Also update button position after geometry change
                if hasattr(self.regular_player_widget, '_position_autohide_button'):
                    QTimer.singleShot(50, self.regular_player_widget._position_autohide_button)
                
                # Update blurred cover art region position to match player section
                # Only update position/pixmap if autohide is disabled (if enabled, it will be shown on hover)
                if not autohide_enabled:
                    if hasattr(self.regular_player_widget, '_update_blurred_cover_art_position'):
                        self.regular_player_widget._update_blurred_cover_art_position()
                    if hasattr(self.regular_player_widget, '_update_blurred_cover_art_pixmap'):
                        QTimer.singleShot(50, self.regular_player_widget._update_blurred_cover_art_pixmap)
                else:
                    # Autohide enabled - ensure blurred background is hidden
                    if hasattr(self.regular_player_widget, 'blurred_cover_art_label') and self.regular_player_widget.blurred_cover_art_label:
                        self.regular_player_widget.blurred_cover_art_label.hide()
                
                # Update autohide hotzone position to match player section
                if hasattr(self.regular_player_widget, '_update_autohide_hotzone_position'):
                    self.regular_player_widget._update_autohide_hotzone_position()
                
                print(f"[MINI MODE DEBUG] Updated player section geometry: widget_height={widget_height}, player_height={player_height}, bottom_y={bottom_y}, geometry={player_section.geometry()}")
        
        # Update playlist container position (still needs absolute positioning for overlay)
        self._update_playlist_position_in_mini_mode()
    
    def _update_playlist_position_in_mini_mode(self):
        """Update playlist container in mini mode - remember collapsed position and match it when expanded"""
        if self.mini_mode_state != 1:
            return
        
        if hasattr(self, 'playlist_container') and self.playlist_container:
            # Ensure playlist container is visible if playlist sidebar is visible
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible():
                if not self.playlist_container.isVisible():
                    self.playlist_container.show()
                    # Clear any constraints that might have been set when closing
                    self.playlist_container.setMinimumHeight(0)
                    self.playlist_container.setMaximumHeight(16777215)  # Qt max
                # Force geometry update
                self.playlist_container.updateGeometry()
                self.playlist_sidebar.updateGeometry()
                QApplication.processEvents()
                
                # CRITICAL: Remember the top position of the title bar when minimized
                # This ensures expanded playlist starts at the same position
                is_minimized = getattr(self.playlist_sidebar, 'is_minimized', True)
                if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                    title_bar = self.playlist_sidebar.title_bar_widget
                    if is_minimized:
                        # Playlist is collapsed - remember the title bar's Y position
                        # Use a small delay to ensure geometry is settled
                        def remember_collapsed_position():
                            if hasattr(self, 'playlist_container') and self.playlist_container:
                                container_y = self.playlist_container.y()
                                if container_y > 0:  # Only save if we have a valid position
                                    # Store the collapsed position for use when expanded
                                    if not hasattr(self, '_mini_mode_playlist_collapsed_y'):
                                        self._mini_mode_playlist_collapsed_y = None
                                    self._mini_mode_playlist_collapsed_y = container_y
                                    print(f"[MINI MODE DEBUG] Remembered collapsed playlist Y position: {container_y}")
                        QTimer.singleShot(50, remember_collapsed_position)
                        QTimer.singleShot(100, remember_collapsed_position)
                    else:
                        # Playlist is expanded - use the remembered collapsed position
                        if hasattr(self, '_mini_mode_playlist_collapsed_y') and self._mini_mode_playlist_collapsed_y is not None:
                            # Position container so title bar is at the remembered Y position
                            central_widget = self.centralWidget()
                            if central_widget:
                                rect = central_widget.rect()
                                container_height = self.playlist_container.height()
                                if container_height == 0:
                                    container_height = self.playlist_container.sizeHint().height()
                                
                                # Position container so it starts at the remembered Y position
                                target_y = self._mini_mode_playlist_collapsed_y
                                current_y = self.playlist_container.y()
                                
                                if abs(current_y - target_y) > 1:  # Only adjust if difference is significant
                                    # Remove from layout to use absolute positioning
                                    layout = self.centralWidget().layout()
                                    if layout:
                                        # Check if in layout and remove it
                                        for i in range(layout.count()):
                                            item = layout.itemAt(i)
                                            if item and item.widget() == self.playlist_container:
                                                layout.removeWidget(self.playlist_container)
                                                break
                                    
                                    # Use absolute positioning to maintain exact position
                                    self.playlist_container.setParent(central_widget)
                                    self.playlist_container.setGeometry(0, target_y, rect.width(), container_height)
                                    print(f"[MINI MODE DEBUG] Positioned expanded playlist to match collapsed position: Y={target_y} (was {current_y})")
                                    
                                    # Update layout
                                    if layout:
                                        layout.update()
                                        layout.activate()
            
            # With layout-based approach for minimized state, ensure it's in the layout
            layout = self.centralWidget().layout()
            if layout:
                # Check if container is in layout
                container_in_layout = False
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if item and item.widget() == self.playlist_container:
                        container_in_layout = True
                        break
                
                # If minimized, use layout; if expanded, use absolute positioning (handled above)
                is_minimized = getattr(self.playlist_sidebar, 'is_minimized', True) if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else True
                if not container_in_layout and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and is_minimized:
                    # Add to layout when minimized (collapsed state uses layout)
                    layout.addWidget(self.playlist_container, 0, Qt.AlignmentFlag.AlignBottom)
                    layout.update()
                    layout.activate()
    
    def _resize_mini_mode_to_cover_art(self):
        """Resize mini mode window to match cover art height."""
        if not self.mini_player_widget or self.mini_mode_state != 1:
            return
        
        # Get cover art dimensions from webview
        if not self.web_view or not self.web_view.page():
            return
        
        js_code = """
        (function() {
            var albumArt = document.querySelector('#tralbum-art-carousel');
            if (!albumArt) {
                albumArt = document.querySelector('#tralbum-art-carousel');
            }
            if (!albumArt) {
                return null;
            }
            
            var img = albumArt.querySelector('img');
            if (!img) {
                return null;
            }
            
            // Get natural dimensions or computed dimensions
            var width = img.naturalWidth || img.width || 260;
            var height = img.naturalHeight || img.height || 260;
            
            // If dimensions are 0, try to get from computed style
            if (width === 0 || height === 0) {
                var rect = img.getBoundingClientRect();
                if (rect && rect.width > 0 && rect.height > 0) {
                    width = rect.width;
                    height = rect.height;
                }
            }
            
            return {width: width, height: height};
        })();
        """
        
        def on_dimensions_received(result):
            if result and isinstance(result, dict):
                width = result.get('width', 260)
                height = result.get('height', 260)
                
                # Calculate window height: cover art height + player overlay height
                player_height = 80  # Approximate
                if hasattr(self.mini_player_widget, 'player_overlay') and self.mini_player_widget.player_overlay:
                    player_height = self.mini_player_widget.player_overlay.sizeHint().height()
                
                window_height = int(height) + player_height
                window_height = max(200, min(window_height, 1000))  # Clamp to reasonable range
                
                self.setMinimumSize(WINDOW_DEFAULT_WIDTH, window_height)
                self.setMaximumSize(WINDOW_DEFAULT_WIDTH, window_height)
                self.resize(WINDOW_DEFAULT_WIDTH, window_height)
                QApplication.processEvents()
                self._ensure_window_on_screen()
                logger.debug(f"Resized mini mode to cover art height: {WINDOW_DEFAULT_WIDTH}x{window_height}")
        
        self.web_view.page().runJavaScript(js_code, on_dimensions_received)
    
    def apply_mini_mode(self):
        """Apply mini mode state (resize window and inject CSS, or use Qt widgets)"""
        use_qt = getattr(self, 'use_qt_widgets', True)  # Default to True if not set
        logger.debug(f"apply_mini_mode: state={self.mini_mode_state}, use_qt_widgets={use_qt}")
        print(f"[MODE SWITCH DEBUG] apply_mini_mode: state={self.mini_mode_state}, playlist_detached={getattr(self, 'playlist_detached', False)}")
        
        # Debug detached playlist window state
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            layout = self.detached_playlist_window.layout()
            print(f"[MODE SWITCH DEBUG] Detached window exists, layout has {layout.count() if layout else 0} items")
            if layout:
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if item and item.widget():
                        widget = item.widget()
                        widget_type = type(widget).__name__
                        widget_visible = widget.isVisible()
                        print(f"[MODE SWITCH DEBUG]   Layout item {i}: {widget_type}, visible={widget_visible}, parent={widget.parent()}")
                        # Check if it's the playlist sidebar and what children it has
                        if widget == self.playlist_sidebar:
                            print(f"[MODE SWITCH DEBUG]     This is playlist_sidebar, checking children...")
                            if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                                print(f"[MODE SWITCH DEBUG]       title_bar_widget exists, visible={self.playlist_sidebar.title_bar_widget.isVisible()}")
                        elif widget == self.detached_playlist_title_bar:
                            print(f"[MODE SWITCH DEBUG]     This is detached_playlist_title_bar")
        
        # Close image viewer modal when switching modes
        if self.web_view and self.web_view.page():
            close_modal_js = """
            (function() {
                var modal = document.getElementById('bandcamp-player-cover-modal');
                if (modal && modal.classList.contains('active')) {
                    modal.classList.remove('active');
                    var img = document.getElementById('bandcamp-player-cover-modal-content');
                    if (img) {
                        img.src = '';
                        img.alt = '';
                    }
                    document.body.style.overflow = '';
                }
            })();
            """
            self.web_view.page().runJavaScript(close_modal_js)
        
        if not self.web_view:
            logger.warning("apply_mini_mode: web_view not available")
            return
        
        # Check if we should use Qt widgets
        if use_qt:
            self._apply_mini_mode_qt_widgets()
            # Keep playlist quick button in sync
            try:
                QTimer.singleShot(0, self.update_playlist_quick_btn_visibility)
            except Exception:
                pass
            # Update minimize button icon when mode changes
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                QTimer.singleShot(50, self.playlist_sidebar._update_minimize_button_icon)
            # CRITICAL: If playlist is detached, ensure its title bar stays hidden
            # The detached window has its own title bar, so the sidebar's title bar should never be visible
            if self.playlist_detached and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                print(f"[MODE SWITCH DEBUG] Playlist is detached, ensuring title_bar_widget is hidden")
                if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                    was_visible = self.playlist_sidebar.title_bar_widget.isVisible()
                    self.playlist_sidebar.title_bar_widget.hide()
                    self.playlist_sidebar.title_bar_widget.setVisible(False)
                    print(f"[MODE SWITCH DEBUG]   title_bar_widget was_visible={was_visible}, now hidden")
                # CRITICAL: Check the detached window layout for duplicates and ensure correct structure
                if hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
                    layout = self.detached_playlist_window.layout()
                    if layout:
                        print(f"[MODE SWITCH DEBUG]   Detached window layout has {layout.count()} items after mode switch")
                        # Track what widgets we expect: detached_playlist_title_bar and playlist_sidebar
                        found_title_bar = False
                        found_playlist_sidebar = False
                        widgets_to_remove = []
                        
                        for i in range(layout.count()):
                            item = layout.itemAt(i)
                            if item and item.widget():
                                widget = item.widget()
                                widget_type = type(widget).__name__
                                print(f"[MODE SWITCH DEBUG]     Item {i}: {widget_type}, visible={widget.isVisible()}")
                                
                                # Check if this is the detached title bar
                                if widget == self.detached_playlist_title_bar:
                                    if found_title_bar:
                                        # Duplicate title bar found!
                                        print(f"[MODE SWITCH DEBUG]     DUPLICATE: Found duplicate detached_playlist_title_bar at index {i}, removing")
                                        widgets_to_remove.append((i, widget))
                                    else:
                                        found_title_bar = True
                                
                                # Check if this is the playlist sidebar
                                elif widget == self.playlist_sidebar:
                                    if found_playlist_sidebar:
                                        # Duplicate playlist_sidebar found!
                                        print(f"[MODE SWITCH DEBUG]     DUPLICATE: Found duplicate playlist_sidebar at index {i}, removing")
                                        widgets_to_remove.append((i, widget))
                                    else:
                                        found_playlist_sidebar = True
                                        # Ensure playlist_sidebar's title_bar_widget is hidden
                                        if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                                            if self.playlist_sidebar.title_bar_widget.isVisible():
                                                print(f"[MODE SWITCH DEBUG]     WARNING: playlist_sidebar.title_bar_widget is visible, hiding it")
                                                self.playlist_sidebar.title_bar_widget.hide()
                                                self.playlist_sidebar.title_bar_widget.setVisible(False)
                                
                                # Check for any unexpected widgets (should only be title bar and sidebar)
                                elif widget not in [self.detached_playlist_title_bar, self.playlist_sidebar]:
                                    print(f"[MODE SWITCH DEBUG]     UNEXPECTED: Found unexpected widget {widget_type} at index {i}")
                        
                        # Remove any duplicate widgets (iterate in reverse to maintain indices)
                        for i, widget in reversed(widgets_to_remove):
                            try:
                                layout.removeWidget(widget)
                                print(f"[MODE SWITCH DEBUG]     Removed duplicate widget at index {i}")
                            except Exception as e:
                                print(f"[MODE SWITCH DEBUG]     Error removing duplicate widget: {e}")
                        
                        # Ensure we have exactly 2 items: title bar and playlist_sidebar
                        if layout.count() != 2:
                            print(f"[MODE SWITCH DEBUG]     WARNING: Layout has {layout.count()} items, expected 2")
                            # If missing title bar, add it (shouldn't happen, but be safe)
                            if not found_title_bar and self.detached_playlist_title_bar:
                                # Check if it's already in layout but not found (shouldn't happen)
                                title_bar_in_layout = False
                                for i in range(layout.count()):
                                    item = layout.itemAt(i)
                                    if item and item.widget() == self.detached_playlist_title_bar:
                                        title_bar_in_layout = True
                                        break
                                if not title_bar_in_layout:
                                    layout.insertWidget(0, self.detached_playlist_title_bar)
                                    print(f"[MODE SWITCH DEBUG]     Added missing detached_playlist_title_bar")
                            
                            # If missing playlist_sidebar, add it (shouldn't happen, but be safe)
                            if not found_playlist_sidebar and self.playlist_sidebar:
                                # Check if it's already in layout but not found (shouldn't happen)
                                sidebar_in_layout = False
                                for i in range(layout.count()):
                                    item = layout.itemAt(i)
                                    if item and item.widget() == self.playlist_sidebar:
                                        sidebar_in_layout = True
                                        break
                                if not sidebar_in_layout:
                                    # Ensure it's parented to the detached window
                                    if self.playlist_sidebar.parent() != self.detached_playlist_window:
                                        self.playlist_sidebar.setParent(self.detached_playlist_window)
                                    layout.addWidget(self.playlist_sidebar)
                                    print(f"[MODE SWITCH DEBUG]     Added missing playlist_sidebar")
                        
                        # Final check: ensure title_bar_widget is hidden
                        if found_playlist_sidebar and hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                            if self.playlist_sidebar.title_bar_widget.isVisible():
                                print(f"[MODE SWITCH DEBUG]     FINAL CHECK: title_bar_widget still visible, forcing hide")
                                self.playlist_sidebar.title_bar_widget.hide()
                                self.playlist_sidebar.title_bar_widget.setVisible(False)
                        
                        # Force layout update
                        layout.update()
                        layout.activate()
                        QApplication.processEvents()
            return
        
        # Legacy CSS-based implementation
        # Show webview (hide Qt widgets if any)
        if self.web_view:
            self.web_view.show()
            # Re-enable mouse events when webview is shown
            self.web_view.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        if self.regular_player_widget:
            self.regular_player_widget.hide()
        if self.mini_player_widget:
            self.mini_player_widget.hide()
        if self.micro_player_widget:
            self.micro_player_widget.hide()
        
        # Always inject CSS first - no delays needed since we're not using display:none
        self.inject_css()

        # Keep playlist quick button in sync when switching modes
        try:
            QTimer.singleShot(0, self.update_playlist_quick_btn_visibility)
        except Exception:
            pass
        
        # Update minimize button icon when mode changes
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            QTimer.singleShot(50, self.playlist_sidebar._update_minimize_button_icon)
        
        if self.mini_mode_state == 0:
            # Regular mode: always use fixed default size (not resizable)
            # Clear micro mode cover art height constraints after CSS injection
            # Use a small delay to ensure CSS injection JavaScript has run
            QTimer.singleShot(50, self._clear_micro_mode_cover_art_height)
            
            # Clear any stored constraint attributes (no longer needed)
            if hasattr(self, '_mini_mode_original_min_size'):
                delattr(self, '_mini_mode_original_min_size')
            if hasattr(self, '_mini_mode_original_max_size'):
                delattr(self, '_mini_mode_original_max_size')
            if hasattr(self, '_micro_mode_original_min_size'):
                delattr(self, '_micro_mode_original_min_size')
            if hasattr(self, '_micro_mode_original_max_size'):
                delattr(self, '_micro_mode_original_max_size')
            
            # Regular mode: fixed size, not resizable
            # Always use default size - no need to store/restore
            self.setMinimumSize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            self.setMaximumSize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            
            # Clear any playlist container height restrictions from mini/micro mode
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.setMinimumHeight(0)
                self.playlist_container.setMaximumHeight(16777215)  # Qt max
                self.playlist_container.updateGeometry()
            
            # Clear playlist sidebar height restrictions to allow proper resizing in regular mode
            # CRITICAL: Always clear fixed height restrictions when switching to regular mode
            # This fixes the issue where 230px restriction from micro mode persists
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                # Clear any fixed height (including 230px from micro mode)
                self.playlist_sidebar.setFixedHeight(16777215)  # Qt max to clear fixed height
                # Restore min/max height constraints
                self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                self.playlist_sidebar.updateGeometry()
                # Force a layout update to ensure restrictions are cleared
                QApplication.processEvents()
            
            # Always clear 230px restriction if playlist is expanded, even if we don't have a restored_height
            # This fixes the issue where expanded playlist in micro mode carries 230px restriction to regular mode
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                    # If playlist is expanded, check if it has 230px restriction and clear it
                    current_height = self.playlist_sidebar.height()
                    if current_height == 230:
                        # Likely has 230px restriction from micro mode - clear it
                        self.playlist_sidebar.setFixedHeight(16777215)  # Clear fixed height
                        self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
                        self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
                        # Restore to saved height if available
                        if hasattr(self.playlist_sidebar, '_restore_height') and self.playlist_sidebar._restore_height:
                            restore_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, self.playlist_sidebar._restore_height)))
                            self.playlist_sidebar.setFixedHeight(restore_height)
                            logger.debug(f"Cleared 230px restriction and restored playlist height: {restore_height}")
                        else:
                            # Use default height
                            default_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, PLAYLIST_DEFAULT_HEIGHT))
                            self.playlist_sidebar.setFixedHeight(default_height)
                            logger.debug(f"Cleared 230px restriction and set default playlist height: {default_height}")
                        self.playlist_sidebar.updateGeometry()
                        QApplication.processEvents()
            
            # Restore playlist height if we're leaving micro mode
            # Try to restore from _playlist_height_before_micro first, then from playlist_height_regular
            restored_height = None
            if hasattr(self, '_playlist_height_before_micro') and self._playlist_height_before_micro is not None:
                restored_height = self._playlist_height_before_micro
            elif self.settings.get('playlist_height_regular'):
                restored_height = self.settings.get('playlist_height_regular')
                logger.debug(f"Using playlist_height_regular for restoration: {restored_height}")
            
            if restored_height is not None and restored_height != 135:  # Don't restore micro mode height
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    restored_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, restored_height)))
                    # Only restore height if playlist is expanded (not minimized)
                    if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                        # Clear fixed height first, then set new height (ensures restrictions are cleared)
                        self.playlist_sidebar.setFixedHeight(16777215)  # Clear fixed height
                        self.playlist_sidebar.setFixedHeight(restored_height)
                        if hasattr(self.playlist_sidebar, '_restore_height'):
                            self.playlist_sidebar._restore_height = restored_height
                        # Update settings with restored height
                        self.settings['playlist_height'] = restored_height
                        self.settings['playlist_height_regular'] = restored_height
                        self.settings['playlist_attached_height'] = restored_height
                        self.save_settings()
                        logger.debug(f"Restored playlist height from micro mode: {restored_height}")
                    else:
                        # Playlist is minimized or hidden - just set the restore height for when it's expanded
                        restored_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, restored_height)))
                        if hasattr(self.playlist_sidebar, '_restore_height'):
                            self.playlist_sidebar._restore_height = restored_height
                        # Update settings with restored height (for when expanded)
                        self.settings['playlist_height'] = restored_height
                        self.settings['playlist_height_regular'] = restored_height
                        self.settings['playlist_attached_height'] = restored_height
                        self.save_settings()
                        logger.debug(f"Set playlist restore height from micro mode (will apply when expanded): {restored_height}")
                # Clear the stored height
                if hasattr(self, '_playlist_height_before_micro'):
                    delattr(self, '_playlist_height_before_micro')

            # If we were previously in mini mode and forced a fixed playlist height (300),
            # restore the user's attached regular-mode height now that we're back in regular mode.
            try:
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
                    # Prefer explicit snapshot captured when entering mini mode
                    desired_attached = getattr(self, '_playlist_height_before_mini', None)
                    if desired_attached is None:
                        desired_attached = self.settings.get('playlist_attached_height')

                    if desired_attached:
                        desired_attached = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, int(desired_attached))))

                        # Only apply if playlist is visible+expanded and currently at a fixed mode height
                        if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized:
                            current_h = int(self.playlist_sidebar.height())
                            if current_h in (135, 300) and current_h != desired_attached:
                                self.playlist_sidebar.setFixedHeight(desired_attached)
                                if hasattr(self.playlist_sidebar, '_restore_height'):
                                    self.playlist_sidebar._restore_height = desired_attached
                                # Keep settings consistent
                                self.settings['playlist_height'] = desired_attached
                                self.settings['playlist_height_regular'] = desired_attached
                                self.settings['playlist_attached_height'] = desired_attached
                                self.save_settings()
            except Exception:
                pass
            finally:
                # Clear snapshot if present so it doesn't override future user changes
                try:
                    if hasattr(self, '_playlist_height_before_mini'):
                        delattr(self, '_playlist_height_before_mini')
                except Exception:
                    pass
            
            # Always resize to default regular mode size (fixed, not resizable)
            self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            QApplication.processEvents()  # Force UI update
            # Ensure window stays on screen after resize
            self._ensure_window_on_screen()
            logger.debug(f"Switched to regular mode: {WINDOW_DEFAULT_WIDTH}x{WINDOW_DEFAULT_HEIGHT}")
            
            # Clear micro mode flag
            self._was_micro_mode = False
        elif self.mini_mode_state == 1:
            # Mini mode: resize to cover art size (image height)
            # Clear micro mode cover art height constraints after CSS injection
            # Use a small delay to ensure CSS injection JavaScript has run
            QTimer.singleShot(50, self._clear_micro_mode_cover_art_height)
            
            # Clear any stored constraint attributes (no longer needed)
            if hasattr(self, '_mini_mode_original_min_size'):
                delattr(self, '_mini_mode_original_min_size')
            if hasattr(self, '_mini_mode_original_max_size'):
                delattr(self, '_mini_mode_original_max_size')
            if hasattr(self, '_micro_mode_original_min_size'):
                delattr(self, '_micro_mode_original_min_size')
            if hasattr(self, '_micro_mode_original_max_size'):
                delattr(self, '_micro_mode_original_max_size')
            
            # Mini mode: always use WINDOW_DEFAULT_WIDTH for width
            # Height will be calculated dynamically by resize_to_mini_mode based on cover art + playlist
            
            # Restore playlist height if we're leaving micro mode
            # Try to restore from _playlist_height_before_micro first, then from playlist_height_regular
            restored_height = None
            if hasattr(self, '_playlist_height_before_micro') and self._playlist_height_before_micro is not None:
                restored_height = self._playlist_height_before_micro
            elif self.settings.get('playlist_height_regular'):
                restored_height = self.settings.get('playlist_height_regular')
                logger.debug(f"Using playlist_height_regular for restoration: {restored_height}")
            
            if restored_height is not None and restored_height != 135:  # Don't restore micro mode height
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    # Only restore height if playlist is expanded (not minimized)
                    if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                        restored_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, restored_height)))
                        self.playlist_sidebar.setFixedHeight(restored_height)
                        if hasattr(self.playlist_sidebar, '_restore_height'):
                            self.playlist_sidebar._restore_height = restored_height
                        # Update settings with restored height
                        self.settings['playlist_height'] = restored_height
                        self.settings['playlist_height_regular'] = restored_height
                        self.settings['playlist_attached_height'] = restored_height
                        self.save_settings()
                        logger.debug(f"Restored playlist height from micro mode: {restored_height}")
                    else:
                        # Playlist is minimized or hidden - just set the restore height for when it's expanded
                        restored_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, restored_height)))
                        if hasattr(self.playlist_sidebar, '_restore_height'):
                            self.playlist_sidebar._restore_height = restored_height
                        # Update settings with restored height (for when expanded)
                        self.settings['playlist_height'] = restored_height
                        self.settings['playlist_height_regular'] = restored_height
                        self.settings['playlist_attached_height'] = restored_height
                        self.save_settings()
                        logger.debug(f"Set playlist restore height from micro mode (will apply when expanded): {restored_height}")
                # Clear the stored height
                if hasattr(self, '_playlist_height_before_micro'):
                    delattr(self, '_playlist_height_before_micro')
            
            # If playlist is expanded when entering mini mode, set it to fixed height (300px)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                    # Snapshot attached regular-mode height BEFORE forcing fixed mini-mode height.
                    # This is the height we want to restore when returning to regular mode.
                    try:
                        pre_height = int(self.playlist_sidebar.height())
                        if PLAYLIST_MIN_HEIGHT <= pre_height <= PLAYLIST_MAX_HEIGHT and pre_height != 135:
                            self._playlist_height_before_mini = pre_height
                            self.settings['playlist_attached_height'] = pre_height
                            self.settings['playlist_height_regular'] = pre_height
                            self.settings['playlist_height'] = pre_height
                            self.save_settings()
                    except Exception:
                        pass
                    # Mini mode: always use fixed height of 300px (not resizable)
                    mini_mode_playlist_height = 300
                    self.playlist_sidebar.setFixedHeight(mini_mode_playlist_height)
                    # Don't save this height - it's fixed for mini mode
                    # Set restore height but don't save to settings
                    if hasattr(self.playlist_sidebar, '_restore_height'):
                        self.playlist_sidebar._restore_height = mini_mode_playlist_height
            
            # Resize after a brief delay to ensure CSS is applied
            QTimer.singleShot(100, self.resize_to_mini_mode)
            # Scroll to top of page when entering mini mode
            def scroll_to_top():
                if self.web_view and self.web_view.page():
                    scroll_js = """
                    (function() {
                        window.scrollTo({top: 0, behavior: 'smooth'});
                        // Also try scrolling document and body elements
                        if (document.documentElement) {
                            document.documentElement.scrollTop = 0;
                        }
                        if (document.body) {
                            document.body.scrollTop = 0;
                        }
                    })();
                    """
                    self.web_view.page().runJavaScript(scroll_js)
            QTimer.singleShot(150, scroll_to_top)  # Slight delay after resize to ensure page is ready
            # No longer using track change detection
            self._was_micro_mode = False
        elif self.mini_mode_state == 2:
            # Micro mode: resize to player size
            # Clear any stored constraint attributes (no longer needed)
            if hasattr(self, '_mini_mode_original_min_size'):
                delattr(self, '_mini_mode_original_min_size')
            if hasattr(self, '_mini_mode_original_max_size'):
                delattr(self, '_mini_mode_original_max_size')
            if hasattr(self, '_micro_mode_original_min_size'):
                delattr(self, '_micro_mode_original_min_size')
            if hasattr(self, '_micro_mode_original_max_size'):
                delattr(self, '_micro_mode_original_max_size')
            
            # Reset window minimum/maximum sizes to allow resizing
            # This must happen so the window can actually resize when resize_to_micro_mode is called
            # IMPORTANT: Clear mini mode's fixed size constraints first
            # When coming from mini mode, we need to aggressively clear the fixed size constraints
            current_size = self.size()
            is_coming_from_mini = current_size.height() > 300  # Likely coming from mini mode (mini mode is typically > 300px)
            
            if is_coming_from_mini:
                # Clear any resizing flags that might block the resize
                if hasattr(self, '_mini_mode_resizing'):
                    self._mini_mode_resizing = False
                if hasattr(self, '_micro_mode_resizing'):
                    self._micro_mode_resizing = False
                
                # Aggressively clear fixed size constraints by setting to unlimited first
                # This ensures Qt recognizes the constraints have changed
                self.setMinimumSize(0, 0)  # Temporarily set to 0 to break any fixed constraints
                self.setMaximumSize(QSize(16777215, 16777215))  # Qt's default maximum (effectively unlimited)
                # Force a small immediate resize to break the fixed size constraint
                # This ensures Qt actually recognizes the constraints have changed
                # Resize to a size that's definitely different from mini mode
                temp_height = max(200, min(250, current_size.height() // 2))
                self.resize(WINDOW_DEFAULT_WIDTH, temp_height)
                
                # Now set to proper minimums
                self.setMinimumSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT)
                
                # Force geometry update to ensure constraints are fully cleared
                self.updateGeometry()
                # Defer UI update instead of forcing immediate processing
                QTimer.singleShot(0, self.update)
                logger.debug(f"Cleared mini mode fixed size constraints (was {current_size.width()}x{current_size.height()}, temp resize to {temp_height}px)")
            else:
                # Not coming from mini mode - just set normal constraints
                self.setMinimumSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT)
                self.setMaximumSize(QSize(16777215, 16777215))
            
            # Micro mode: always use WINDOW_DEFAULT_WIDTH for width
            # Height will be calculated dynamically by resize_to_micro_mode based on player + playlist
            
            # Save current playlist height before entering micro mode (if not already saved)
            # Only save if we're coming from mini/regular mode (not already in micro)
            if not hasattr(self, '_playlist_height_before_micro') or self._playlist_height_before_micro is None:
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    # Save the *regular attached* height for restoration later.
                    # IMPORTANT: in mini mode, _restore_height is set to 300 (fixed), so prefer the persisted
                    # attached height from settings when attached.
                    candidate = None
                    try:
                        if not self.playlist_detached:
                            candidate = self.settings.get('playlist_attached_height')
                    except Exception:
                        candidate = None
                    if not candidate:
                        # Fallback to current restore height / actual height
                        if hasattr(self.playlist_sidebar, '_restore_height') and self.playlist_sidebar._restore_height:
                            candidate = self.playlist_sidebar._restore_height
                        else:
                            candidate = self.playlist_sidebar.height()
                    self._playlist_height_before_micro = candidate
                    logger.debug(f"Saving playlist height before micro mode: {self._playlist_height_before_micro}")
                    # Also save to settings as playlist_height_regular for persistence across app restarts
                    if self._playlist_height_before_micro != 135:  # Don't save micro mode height
                        self.settings['playlist_height_regular'] = self._playlist_height_before_micro
                        # Keep attached height stable across mode changes (do not overwrite with fixed heights).
                        # NOTE: If a user legitimately set 300 as their preferred height, we still want to remember it.
                        if not self.playlist_detached:
                            self.settings['playlist_attached_height'] = self._playlist_height_before_micro
                        self.save_settings()
                        logger.debug(f"Saved playlist_height_regular: {self._playlist_height_before_micro}")
            
            # Set playlist height to 135 when entering micro mode (for when expanded in micro mode)
            # Micro mode: always use fixed height of 135px (not resizable)
            # Close and reopen playlist if it's visible to ensure proper state on first launch
            # Only do this the first time entering micro mode (to fix first launch issue)
            # Flag persists in settings so it only happens once ever, unless settings are cleared
            playlist_was_visible = False
            should_fix_playlist = not self.settings.get('micro_mode_playlist_fixed', False)
            if should_fix_playlist and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached:
                playlist_was_visible = True
                # Close the playlist to reset its state
                self.playlist_sidebar.close_playlist()
                # Force layout update after closing
                layout = self.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                QApplication.processEvents()
                logger.debug("Closed playlist when entering micro mode (first time) - will reopen after delay")
                # Mark that we've done this fix so it doesn't happen again (persists in settings)
                self.settings['micro_mode_playlist_fixed'] = True
                self.save_settings()
            
            # Set the restore height to 135 (for when expanded in micro mode)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                if hasattr(self.playlist_sidebar, '_restore_height'):
                    self.playlist_sidebar._restore_height = 135
            
            # Resize after a delay to ensure CSS is applied
            # If coming from mini mode, use a longer delay to ensure the temporary resize completes
            # If playlist was visible, reopen it after a delay to ensure proper state restoration
            base_delay = 200 if is_coming_from_mini else 100
            delay = base_delay
            
            if playlist_was_visible:
                # Reopen playlist after a delay to ensure it's properly restored with minimized state
                def reopen_playlist():
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        # Reopen the playlist - this will restore its state properly
                        self.toggle_playlist()
                        # Ensure it's minimized if it should be
                        if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                            self.playlist_sidebar._toggle_minimize_state()
                        # Force geometry updates
                        self.playlist_sidebar.updateGeometry()
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            self.playlist_container.updateGeometry()
                        layout = self.centralWidget().layout()
                        if layout:
                            layout.update()
                            layout.activate()
                        QApplication.processEvents()
                        logger.debug(f"Reopened playlist in micro mode (minimized: {self.playlist_sidebar.is_minimized if self.playlist_sidebar.isVisible() else 'hidden'})")
                        # Trigger resize after playlist is reopened
                        playlist_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
                        QTimer.singleShot(100, lambda: self._resize_mini_mode_for_playlist(playlist_visible))
                    else:
                        # Playlist doesn't exist yet, just trigger resize
                        QTimer.singleShot(100, lambda: self._resize_mini_mode_for_playlist(False))
                
                QTimer.singleShot(150, reopen_playlist)
            else:
                # Simple Qt-based resize for micro mode
                playlist_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
                QTimer.singleShot(delay, lambda: self._resize_mini_mode_for_playlist(playlist_visible))
            self._was_micro_mode = True
    
    def _restore_regular_mode(self):
        """Restore regular mode size (immediate restore)"""
        try:
            # Always use default regular mode size
            self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            # Restore normal minimum height
            self.setMinimumHeight(WINDOW_MIN_HEIGHT)
        except Exception as e:
            logger.error(f"Error restoring regular mode: {e}", exc_info=True)
    
    def _inject_css_with_log(self, context=""):
        """Inject CSS with logging for debugging"""
        logger.debug(f"_inject_css_with_log: Injecting CSS (context: {context})")
        try:
            self.inject_css()
            logger.debug(f"_inject_css_with_log: CSS injection complete (context: {context})")
        except Exception as e:
            logger.error(f"_inject_css_with_log: Error injecting CSS (context: {context}): {e}", exc_info=True)
    
    def resize_to_mini_mode(self, retry_count=0):
        """Resize window to cover art height only (maintain width, player overlays via CSS)"""
        # CRITICAL: If using Qt widgets, use fixed 260px height instead of calculating from webview
        # The Qt widget approach uses a fixed 260px cover art, so we should use that
        use_qt = getattr(self, 'use_qt_widgets', True)
        if use_qt:
            # Use the fixed height calculation from _resize_mini_mode_for_playlist
            # This ensures consistent 260px height for Qt widgets
            playlist_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
            if hasattr(self, '_resize_mini_mode_for_playlist'):
                self._resize_mini_mode_for_playlist(playlist_visible)
            return
        
        if not self.web_view:
            return
        # Only resize if actually in mini mode (prevents late timers from resizing after mode switch)
        if getattr(self, 'mini_mode_state', 0) != 1:
            return
        
        # LEGACY CODE: The following code is for the old webview-based visual implementation
        # It queries the webview DOM to get cover art dimensions dynamically
        # This code should never execute when use_qt_widgets == True (protected by early return above)
        # Keeping it for backward compatibility with legacy mode
        
        # Ensure original size is set (needed for width)
        # Micro mode: always use WINDOW_DEFAULT_WIDTH for width
        # No need to store original size
        
        # Get cover art dimensions via JavaScript
        # Fixed: Handle carousels with multiple images by finding the currently visible image
        # Windows 10 fix: Add extra safety checks and error handling for carousel stability
        js_code = """
        (function() {
            try {
                // Wait a moment for carousel to stabilize (Windows 10 fix for multiple images)
                var albumArt = document.querySelector('#tralbum-art-carousel');
                if (!albumArt) {
                    return null;
                }
                
                // Ensure element is in the DOM and has layout
                if (!albumArt.offsetParent && albumArt.style.display === 'none') {
                    return null;
                }
                
                var albumArtRect = albumArt.getBoundingClientRect();
                if (!albumArtRect || albumArtRect.height === 0 || !isFinite(albumArtRect.height)) {
                    // Retry after a brief delay (carousel might still be loading)
                    return null;
                }
                
                // Find the currently visible/active image in the carousel
                // For carousels with multiple images, we need to find the one that's actually displayed
                var visibleImg = null;
                
                // Method 1: Look for images in active carousel items
                // Windows 10 fix: Add try-catch around DOM queries to prevent crashes
                try {
                var carouselItems = albumArt.querySelectorAll('.carousel-item, [class*="carousel-item"], [class*="active"]');
                for (var i = 0; i < carouselItems.length; i++) {
                        try {
                    var item = carouselItems[i];
                            if (!item || !item.parentNode) continue; // Skip if detached from DOM
                            
                    var style = window.getComputedStyle(item);
                    // Check if item is visible (not hidden)
                            if (style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
                        var img = item.querySelector('img');
                                if (img && img.parentNode) {
                            var imgStyle = window.getComputedStyle(img);
                                    if (imgStyle && imgStyle.display !== 'none' && imgStyle.visibility !== 'hidden') {
                                visibleImg = img;
                                break;
                            }
                        }
                    }
                        } catch (itemError) {
                            // Skip this item if there's an error
                            continue;
                        }
                    }
                } catch (carouselError) {
                    // If carousel query fails, fall back to other methods
                    console.log('Bandcamp Player: Error querying carousel items:', carouselError);
                }
                
                // Method 2: If no active item found, look for images that are actually visible
                // Windows 10 fix: Add safety checks to prevent crashes
                if (!visibleImg) {
                    try {
                    var allImgs = albumArt.querySelectorAll('img');
                    for (var i = 0; i < allImgs.length; i++) {
                            try {
                        var img = allImgs[i];
                                if (!img || !img.parentNode) continue; // Skip if detached
                                
                        var imgStyle = window.getComputedStyle(img);
                                if (!imgStyle) continue;
                                
                        var imgRect = img.getBoundingClientRect();
                                if (!imgRect) continue;
                                
                        // Check if image is visible and has dimensions
                        if (imgStyle.display !== 'none' && 
                            imgStyle.visibility !== 'hidden' && 
                            imgStyle.opacity !== '0' &&
                                    isFinite(imgRect.width) && isFinite(imgRect.height) &&
                            imgRect.width > 0 && imgRect.height > 0) {
                            visibleImg = img;
                            break;
                        }
                            } catch (imgError) {
                                // Skip this image if there's an error
                                continue;
                            }
                        }
                    } catch (allImgsError) {
                        console.log('Bandcamp Player: Error querying all images:', allImgsError);
                    }
                }
                
                // Method 3: Fallback to first image if still not found
                if (!visibleImg) {
                    visibleImg = albumArt.querySelector('img');
                }
                
                // Calculate cover art height safely
                var coverArtHeight = albumArtRect.height; // Default to container height
                
                if (visibleImg) {
                    try {
                        var imgRect = visibleImg.getBoundingClientRect();
                        var imgOffsetHeight = visibleImg.offsetHeight || 0;
                        var imgNaturalHeight = visibleImg.naturalHeight || 0;
                        var imgNaturalWidth = visibleImg.naturalWidth || 0;
                        var albumArtWidth = albumArtRect.width || 1; // Prevent division by zero
                        
                        // Calculate height based on aspect ratio if natural dimensions are available
                        if (imgNaturalWidth > 0 && imgNaturalHeight > 0 && albumArtWidth > 0) {
                            var aspectRatioHeight = imgNaturalHeight * (albumArtWidth / imgNaturalWidth);
                            coverArtHeight = Math.max(imgOffsetHeight, aspectRatioHeight, albumArtRect.height);
                        } else if (imgOffsetHeight > 0) {
                            coverArtHeight = Math.max(imgOffsetHeight, albumArtRect.height);
                        }
                    } catch (e) {
                        // If calculation fails, use container height
                        console.log('Bandcamp Player: Error calculating image height, using container height:', e);
                        coverArtHeight = albumArtRect.height;
                    }
                }
                
                // Ensure we have a valid height
                if (!coverArtHeight || coverArtHeight <= 0 || !isFinite(coverArtHeight)) {
                    coverArtHeight = albumArtRect.height || 400; // Fallback to 400 if all else fails
                }
                
                return {
                    coverArtHeight: coverArtHeight,
                    coverArtRectHeight: albumArtRect.height
                };
            } catch (e) {
                console.log('Bandcamp Player: Error in resize_to_mini_mode JavaScript:', e);
                return null;
            }
        })();
        """
        
        def on_dimensions_received(result):
            try:
                if result and isinstance(result, dict):
                    # Use the actual cover art image height, not the container height
                    cover_art_height = result.get('coverArtHeight')
                    if not cover_art_height:
                        cover_art_height = result.get('coverArtRectHeight', 400)
                    
                    # Ensure we have a valid number
                    try:
                        cover_art_height = int(float(cover_art_height))
                        if cover_art_height <= 0:
                            raise ValueError("Invalid height")
                    except (ValueError, TypeError):
                        # Use fallback if conversion fails
                        if self.mini_mode_cover_art_height:
                            cover_art_height = self.mini_mode_cover_art_height
                        else:
                            cover_art_height = 400
                    
                    # Calculate window padding (title bar + address bar)
                    window_padding = 0
                    if self.title_bar and self.title_bar.isVisible():
                        window_padding += self.title_bar.height()
                    if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                        if hasattr(self, 'controls_bar_in_layout') and self.controls_bar_in_layout:
                            window_padding += self.controls_bar_widget.height()
                    
                    # Account for playlist sidebar title bar if playlist is visible
                    # Treat detached playlist as closed for resizing purposes
                    playlist_title_bar_height = 0
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached:
                        # Always use 40px for playlist title bar height (includes borders)
                        playlist_title_bar_height = 35
                    
                    # Mini mode: window height = cover art height only (tracklist is scrollable below)
                    # Don't add playlist height - window should only be cover art height
                    base_height = cover_art_height + window_padding + playlist_title_bar_height
                    
                    # Store cover art height for future reference (just the cover art, not including padding)
                    self.mini_mode_cover_art_height = cover_art_height
                    
                    # Save to settings for next startup
                    self.settings["mini_mode_saved_height"] = cover_art_height
                    self.save_settings()
                    
                    # Window height is just cover art + padding + playlist title bar (tracklist scrolls below)
                    # Subtract 88px to reduce mini mode height, but never allow an unreasonably small window.
                    total_height = max(200, base_height - 88)
                    original_width = WINDOW_DEFAULT_WIDTH
                    
                    try:
                        # Set flag to allow programmatic resize (prevents resizeEvent from blocking it)
                        self._mini_mode_resizing = True
                        self.resize(original_width, total_height)
                        # Set fixed size to prevent user resizing in mini mode
                        self.setMinimumSize(original_width, total_height)
                        self.setMaximumSize(original_width, total_height)
                        logger.debug(f"Resized to mini mode: {original_width}x{total_height} (cover art: {cover_art_height}, padding: {window_padding})")
                        # Clear flag after resize completes
                        QTimer.singleShot(50, lambda: setattr(self, '_mini_mode_resizing', False))
                    except Exception as e:
                        logger.error(f"Could not resize to mini mode: {e}", exc_info=True)
                        # Clear flag on error too
                        self._mini_mode_resizing = False
                else:
                    # If we couldn't measure yet (common on first startup load), retry a couple times.
                    try:
                        current_retry = int(retry_count) if retry_count is not None else 0
                    except Exception:
                        current_retry = 0
                    if current_retry < 2:
                        QTimer.singleShot(250, lambda: self.resize_to_mini_mode(current_retry + 1))
                        return
                    
                    # Last-resort fallback if dimensions not available after retries
                    base_height = int(getattr(self, 'mini_mode_cover_art_height', 0) or 0)
                    if base_height <= 0:
                        base_height = int(self.settings.get("mini_mode_saved_height") or 0)
                    if base_height <= 0:
                        base_height = 400
                    
                    window_padding = 0
                    if getattr(self, 'title_bar', None) and self.title_bar.isVisible():
                        window_padding += self.title_bar.height()
                    if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                        if hasattr(self, 'controls_bar_in_layout') and self.controls_bar_in_layout:
                            window_padding += self.controls_bar_widget.height()
                    
                    # Account for playlist sidebar title bar if playlist is visible
                    # Treat detached playlist as closed for resizing purposes
                    playlist_title_bar_height = 0
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached:
                        playlist_title_bar_height = 35
                    
                    total_height = max(200, base_height + window_padding + playlist_title_bar_height - 88)
                    original_width = WINDOW_DEFAULT_WIDTH
                    try:
                        self._mini_mode_resizing = True
                        self.resize(original_width, total_height)
                        self.setMinimumSize(original_width, total_height)
                        self.setMaximumSize(original_width, total_height)
                        QTimer.singleShot(50, lambda: setattr(self, '_mini_mode_resizing', False))
                    except Exception as e:
                        logger.error(f"Could not resize to mini mode (fallback): {e}", exc_info=True)
                        self._mini_mode_resizing = False
            except Exception as e:
                logger.error(f"Error in resize_to_mini_mode callback: {e}", exc_info=True)
                # Use stored height as last resort
                if self.mini_mode_cover_art_height:
                    try:
                        original_width = WINDOW_DEFAULT_WIDTH
                        self.resize(original_width, self.mini_mode_cover_art_height)
                    except:
                        pass
        
        self.web_view.page().runJavaScript(js_code, on_dimensions_received)
    
    def resize_to_micro_mode(self):
        """Resize window to player size only - Qt-only implementation"""
        # Only resize if actually in micro mode
        if self.mini_mode_state != 2:
            logger.debug(f"resize_to_micro_mode: Not in micro mode (state={self.mini_mode_state}), skipping")
            return
        
        # Use Qt-based playlist resize function (handles all sizing logic)
        playlist_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
        self._resize_mini_mode_for_playlist(playlist_visible)
    
    def _set_micro_mode_cover_art_height(self):
        """Set cover art height to match player height in micro mode - Qt-only (no-op)"""
        # No longer needed - cover art is handled by Qt widget in micro mode
        pass
    
    def _clear_micro_mode_cover_art_height(self):
        """Clear cover art height constraints when switching from micro mode - Qt-only (no-op)"""
        # No longer needed - cover art is handled by Qt widget in micro mode
        pass
    
    def _resize_to_micro_mode_with_retry(self, retry_count=0):
        """Resize to micro mode with retry logic to ensure accurate measurements"""
        max_retries = 1  # Only retry once if needed
        
        # Force layout update before measuring
        if hasattr(self, 'playlist_container') and self.playlist_container:
            self.playlist_container.updateGeometry()
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            self.playlist_sidebar.updateGeometry()
        layout = self.centralWidget().layout()
        if layout:
            layout.update()
            layout.activate()
        # Defer UI update instead of forcing immediate processing
        QTimer.singleShot(0, lambda: (layout.update() if layout else None, self.update()))
        
        # Call the actual resize function
        self.resize_to_micro_mode()
        
        # If this is the first attempt, do one retry after a short delay to fine-tune
        # This helps catch cases where the layout hasn't fully settled
        if retry_count < max_retries:
            QTimer.singleShot(100, lambda: self._resize_to_micro_mode_with_retry(retry_count + 1))
    
    def setup_micro_mode_track_detection(self):
        """No longer used - kept for compatibility"""
        pass
    
    def remove_micro_mode_track_detection(self):
        """No longer used - kept for compatibility"""
        pass
    
    def check_micro_mode_resize_needed(self):
        """No longer used - kept for compatibility"""
        pass
    
    def _do_micro_mode_resize(self):
        """No longer used - kept for compatibility"""
        pass
    
    def _clear_micro_mode_resizing_flag(self):
        """No longer used - kept for compatibility"""
        pass
    
    def _get_playable_tracks_helper_js(self):
        """Generate JavaScript helper function to get all playable tracks from tracklist"""
        return """
            function getPlayableTracks() {
                var tracklist = document.querySelector('#tracklist');
                if (!tracklist) {
                    return [];
                }
                
                // Get all track elements - use comprehensive selector to match actual Bandcamp structure
                // Tracks can be: li.track, tr.track_row_view, or other variations
                var allTracks = tracklist.querySelectorAll('li.track, tr.track_row_view, .track, .track_row_view, tr[class*="track"], li[class*="track"]');
                var playableTracks = [];
                
                console.log('Bandcamp Player: getPlayableTracks found ' + allTracks.length + ' total tracks');
                
                for (var i = 0; i < allTracks.length; i++) {
                    var track = allTracks[i];
                    
                    // KEY INDICATOR: Check for .play_status.disabled - this marks unavailable tracks
                    // The play_status is inside a <td class="play-col"> which is inside the <tr>
                    var playStatus = track.querySelector('.play_status');
                    
                    // If not found directly, check inside play-col (for table row structure)
                    if (!playStatus) {
                        var playCol = track.querySelector('td.play-col, .play-col');
                        if (playCol) {
                            playStatus = playCol.querySelector('.play_status');
                        }
                    }
                    
                    // If play_status exists, use it as the definitive indicator
                    if (playStatus) {
                        // If play_status has 'disabled' class, track is NOT playable - skip it
                        if (playStatus.classList.contains('disabled')) {
                            console.log('Bandcamp Player: Track ' + (i+1) + ' has play_status.disabled - skipping (not playable)');
                            continue; // Skip this track
                        }
                        // If play_status exists and doesn't have 'disabled', track IS playable
                        console.log('Bandcamp Player: Track ' + (i+1) + ' has play_status without disabled - marking as playable');
                        playableTracks.push(track);
                        continue; // Move to next track
                    }
                    
                    // Fallback: if no play_status element found (mobile/regular albums), use other indicators
                    // Mobile version: playable tracks have 'playable' class AND data-bind="click: playTrack" on .info
                    var isPlayable = false;
                    
                    // Check for explicit 'playable' class (mobile version indicator)
                    if (track.classList.contains('playable')) {
                        // Additional check: .info div should have data-bind="click: playTrack"
                        var infoDiv = track.querySelector('.info');
                        if (infoDiv) {
                            var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                             infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                            if (hasClickBind) {
                                isPlayable = true;
                                console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has playable class and click: playTrack)');
                            } else {
                                console.log('Bandcamp Player: Track ' + (i+1) + ' has playable class but no click: playTrack - not playable');
                            }
                        } else {
                            // If no .info div but has playable class, still consider playable
                            isPlayable = true;
                            console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has playable class)');
                        }
                    } else if (track.classList.contains('has-audio')) {
                        // Track has has-audio but NOT playable class - check if it has click: playTrack
                        var infoDiv = track.querySelector('.info');
                        if (infoDiv) {
                            var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                             infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                            if (hasClickBind) {
                                isPlayable = true;
                                console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has-audio with click: playTrack)');
                            } else {
                                console.log('Bandcamp Player: Track ' + (i+1) + ' has has-audio but no click: playTrack - not playable');
                            }
                        }
                    } else {
                        // Check for .info div with track link (desktop/fallback)
                        var infoDiv = track.querySelector('.info');
                        if (infoDiv) {
                            var trackLink = infoDiv.querySelector('a');
                            if (trackLink) {
                                var href = trackLink.getAttribute('href');
                                if (href && href !== '#' && href.indexOf('/track/') !== -1) {
                                    isPlayable = true;
                                    console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has valid track link)');
                                }
                            }
                        } else {
                            // Check for play button
                            var playBtn = track.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]');
                            if (playBtn && playBtn.offsetParent !== null) {
                                isPlayable = true;
                                console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has play button)');
                            }
                        }
                    }
                    
                    if (isPlayable) {
                        playableTracks.push(track);
                    } else {
                        console.log('Bandcamp Player: Track ' + (i+1) + ' not playable (no indicators found)');
                    }
                }
                
                return playableTracks;
            }
            
            function isTrackPlayable(track) {
                // Helper function to check if a single track is playable
                // KEY INDICATOR: Check for .play_status.disabled - this marks unavailable tracks
                var playStatus = track.querySelector('.play_status');
                
                // If not found directly, check inside play-col (for table row structure)
                if (!playStatus) {
                    var playCol = track.querySelector('td.play-col, .play-col');
                    if (playCol) {
                        playStatus = playCol.querySelector('.play_status');
                    }
                }
                
                // If play_status exists, use it as the definitive indicator
                if (playStatus) {
                    if (playStatus.classList.contains('disabled')) {
                        return false; // Track is disabled/unavailable
                    }
                    // If play_status exists and doesn't have 'disabled', track IS playable
                    return true;
                }
                
                // Fallback: if no play_status, check for mobile version indicators
                // Mobile version: playable tracks have 'playable' class AND data-bind="click: playTrack"
                if (track.classList.contains('playable')) {
                    var infoDiv = track.querySelector('.info');
                    if (infoDiv) {
                        var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                         infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                        if (hasClickBind) {
                            return true;
                        }
                    } else {
                        // If no .info div but has playable class, still consider playable
                        return true;
                    }
                } else if (track.classList.contains('has-audio')) {
                    // Track has has-audio but NOT playable - check if it has click: playTrack
                    var infoDiv = track.querySelector('.info');
                    if (infoDiv) {
                        var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                         infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                        if (hasClickBind) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            """
    
    def _get_is_last_track_js(self):
        """Generate JavaScript function to check if current track is the last playable one"""
        playable_helper = self._get_playable_tracks_helper_js()
        return playable_helper + """
            
            function isLastTrack() {
                try {
                    // CRITICAL: If Shuffle Tracks mode (mode 1) is active, check shuffled list completion instead
                    if (window.bandcampShuffleMode === 1 && 
                        window.bandcampShuffledTrackList && 
                        window.bandcampShuffledTrackList.length > 0) {
                        // In shuffle mode, check if we've played all tracks in the shuffled list
                        var currentIndex = window.bandcampShuffledTrackIndex !== undefined ? window.bandcampShuffledTrackIndex : 0;
                        var isLastInShuffledList = (currentIndex >= window.bandcampShuffledTrackList.length - 1);
                        console.log('Bandcamp Player: Shuffle mode active - isLastTrack check: currentIndex=' + currentIndex + ', listLength=' + window.bandcampShuffledTrackList.length + ', isLast=' + isLastInShuffledList);
                        return isLastInShuffledList;
                    }
                    
                    // First, check if this is a single track page (no tracklist or URL contains /track/)
                    var isSingleTrackPage = false;
                    var url = window.location.href;
                    if (url.indexOf('/track/') !== -1) {
                        isSingleTrackPage = true;
                        console.log('Bandcamp Player: Detected single track page from URL');
                    }
                    
                    // Get tracklist
                    var tracklist = document.querySelector('#tracklist');
                    if (!tracklist) {
                        // No tracklist found - could be a single track page
                        console.log('Bandcamp Player: Tracklist not found - checking if single track page');
                        // If URL indicates single track, or if we have audio playing, treat as single
                        if (isSingleTrackPage || document.querySelector('audio')) {
                            console.log('Bandcamp Player: Single track page detected - this is the last (and only) track');
                            return true;
                        }
                        return false;
                    }
                    
                    // Get all track items - try multiple selectors (for finding current track)
                    var allTracks = tracklist.querySelectorAll('.track, .track_row_view, tr[class*="track"], li[class*="track"], .track_list .track');
                    if (allTracks.length === 0) {
                        // Try alternative: look for numbered tracks
                        allTracks = tracklist.querySelectorAll('[data-track-number], [data-index]');
                    }
                    
                    // Get playable tracks (for determining if current track is last playable)
                    var playableTracks = getPlayableTracks();
                    
                    // If no tracks found in tracklist, check if it's a single track page
                    if (allTracks.length === 0) {
                        console.log('Bandcamp Player: No tracks found in tracklist');
                        // If URL indicates single track or we have audio, treat as single
                        if (isSingleTrackPage || document.querySelector('audio')) {
                            console.log('Bandcamp Player: Single track page detected (empty tracklist) - this is the last track');
                            return true;
                        }
                        return false;
                    }
                    
                    // If only one track total, it's automatically the last track
                    if (allTracks.length === 1) {
                        console.log('Bandcamp Player: Only one track found - this is the last track');
                        return true;
                    }
                    
                    console.log('Bandcamp Player: Found ' + allTracks.length + ' total tracks, ' + playableTracks.length + ' playable tracks');
                    
                    // Get current track title from player
                    var currentTitle = null;
                    var titleElement = player.querySelector('.track-title, .title, [data-bind*="title"]');
                    if (titleElement) {
                        currentTitle = (titleElement.textContent || titleElement.innerText || '').trim();
                    }
                    
                    // Find which track is currently playing by looking for "playing" class or active state
                    var currentTrack = null;
                    var currentTrackIndexInAll = -1;
                    
                    // First, try to find track with "playing" class in all tracks
                    for (var i = 0; i < allTracks.length; i++) {
                        var track = allTracks[i];
                        if (track.classList.contains('playing') || 
                            track.classList.contains('current') ||
                            track.classList.contains('active') ||
                            track.getAttribute('aria-current') === 'true') {
                            currentTrack = track;
                            currentTrackIndexInAll = i;
                            console.log('Bandcamp Player: Found playing track at index ' + i);
                            break;
                        }
                    }
                    
                    // If not found by class, try matching by title
                    if (!currentTrack && currentTitle) {
                        for (var i = 0; i < allTracks.length; i++) {
                            var track = allTracks[i];
                            var trackTitle = (track.textContent || track.innerText || '').trim();
                            // Check if track title matches (be flexible with matching)
                            if (trackTitle && currentTitle && 
                                (trackTitle.includes(currentTitle) || 
                                 currentTitle.includes(trackTitle) ||
                                 trackTitle.toLowerCase() === currentTitle.toLowerCase())) {
                                currentTrack = track;
                                currentTrackIndexInAll = i;
                                console.log('Bandcamp Player: Found track by title match at index ' + i);
                                break;
                            }
                        }
                    }
                    
                    // If we found the current track, check if it's the last playable one
                    if (currentTrack) {
                        // Better approach: check if there are any playable tracks AFTER the current track
                        // This is more reliable than checking array positions
                        var hasPlayableTracksAfter = false;
                        
                        // Start checking from the track after the current one
                        for (var i = currentTrackIndexInAll + 1; i < allTracks.length; i++) {
                            var nextTrack = allTracks[i];
                            // Use the same logic as getPlayableTracks to check if track is playable
                            var nextTrackPlayStatus = nextTrack.querySelector('.play_status');
                            if (!nextTrackPlayStatus) {
                                var playCol = nextTrack.querySelector('td.play-col, .play-col');
                                if (playCol) {
                                    nextTrackPlayStatus = playCol.querySelector('.play_status');
                                }
                            }
                            
                            // If track has play_status.disabled, it's not playable
                            if (nextTrackPlayStatus && nextTrackPlayStatus.classList.contains('disabled')) {
                                console.log('Bandcamp Player: Track at index ' + i + ' has play_status.disabled - not playable');
                                continue; // Skip this track, check next one
                            }
                            
                            // If track has play_status without disabled, it IS playable
                            if (nextTrackPlayStatus && !nextTrackPlayStatus.classList.contains('disabled')) {
                                hasPlayableTracksAfter = true;
                                console.log('Bandcamp Player: Found playable track after current at index ' + i + ' (has play_status without disabled)');
                                break;
                            }
                            
                            // Fallback: if no play_status, check for mobile version indicators
                            if (!nextTrackPlayStatus) {
                                // Mobile version: playable tracks have 'playable' class AND data-bind="click: playTrack"
                                var hasPlayableClass = nextTrack.classList.contains('playable');
                                if (hasPlayableClass) {
                                    var infoDiv = nextTrack.querySelector('.info');
                                    if (infoDiv) {
                                        var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                                         infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                                        if (hasClickBind) {
                                            hasPlayableTracksAfter = true;
                                            console.log('Bandcamp Player: Found playable track after current at index ' + i + ' (has playable class and click: playTrack)');
                                            break;
                                        }
                                    }
                                } else if (nextTrack.classList.contains('has-audio')) {
                                    // Track has has-audio but NOT playable - check if it has click: playTrack
                                    var infoDiv = nextTrack.querySelector('.info');
                                    if (infoDiv) {
                                        var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                                         infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                                        if (hasClickBind) {
                                            hasPlayableTracksAfter = true;
                                            console.log('Bandcamp Player: Found playable track after current at index ' + i + ' (has-audio with click: playTrack)');
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        
                        if (!hasPlayableTracksAfter) {
                            // No playable tracks after current - this is the last playable track
                            console.log('Bandcamp Player: No playable tracks after current track at index ' + currentTrackIndexInAll + ' - this is the last playable track');
                            return true;
                        } else {
                            // There are playable tracks after - not the last one
                            console.log('Bandcamp Player: Found playable tracks after current track - not the last playable');
                            return false;
                        }
                    }
                    
                    // Fallback: if we can't find the current track, assume it might be last if title hasn't changed
                    // OR if it's a single track page
                    console.log('Bandcamp Player: Could not find current track, using fallback check');
                    if (isSingleTrackPage) {
                        console.log('Bandcamp Player: Single track page - treating as last track');
                        return true;
                    }
                    if (lastTrackTitle && currentTitle && lastTrackTitle === currentTitle) {
                        console.log('Bandcamp Player: Track title unchanged, might be last track');
                        return true;
                    }
                    
                    return false;
                } catch (e) {
                    console.log('Bandcamp Player: Error checking last track:', e);
                    return false;
                }
            }
            """
            
    def _get_handle_track_end_js(self):
        """Generate JavaScript function to handle track end"""
        return """
            function handleTrackEnd() {
                console.log('Bandcamp Player: Track ended');
                
                // Store the current track title before checking
                var titleElement = player.querySelector('.track-title, .title, [data-bind*="title"]');
                var endedTrackTitle = null;
                if (titleElement) {
                    endedTrackTitle = (titleElement.textContent || titleElement.innerText || '').trim();
                    if (!lastTrackTitle) {
                        lastTrackTitle = endedTrackTitle;
                    }
                }
                
                console.log('Bandcamp Player: Ended track title: ' + endedTrackTitle);
                
                // Clear any existing timeout
                if (trackEndedTimeout) {
                    clearTimeout(trackEndedTimeout);
                }
                
                // Wait a moment to see if next track starts
                trackEndedTimeout = setTimeout(function() {
                    // Check if a new track started (title changed or audio started playing)
                    var newTitleElement = player.querySelector('.track-title, .title, [data-bind*="title"]');
                    var newTitle = null;
                    if (newTitleElement) {
                        newTitle = (newTitleElement.textContent || newTitleElement.innerText || '').trim();
                    }
                    
                    // Check if audio is playing
                    var isPlaying = false;
                    if (audioElement) {
                        isPlaying = !audioElement.paused && audioElement.currentTime > 0;
                    }
                    
                    // Check if track changed (new track started)
                    var trackChanged = newTitle && newTitle !== endedTrackTitle && newTitle !== lastTrackTitle;
                    
                    console.log('Bandcamp Player: After track end - New title: ' + newTitle + ', Is playing: ' + isPlaying + ', Track changed: ' + trackChanged);
                    
                    // Check if Repeat 1 Track mode is active - if so, don't set flags (JavaScript handles restart)
                    if (window.bandcampRepeatMode === 3) {
                        console.log('Bandcamp Player: Repeat 1 Track mode active - JavaScript should have restarted track, skipping handleTrackEnd logic');
                        // Check if track actually restarted (audio is playing again)
                        if (audioElement && !audioElement.paused && audioElement.currentTime < 5) {
                            console.log('Bandcamp Player: Track restarted successfully in Repeat 1 Track mode');
                            // Track restarted, don't set any flags
                            return;
                        } else {
                            console.log('Bandcamp Player: Track did not restart, might need fallback');
                            // Track didn't restart, but don't set flag yet - let Python handle as fallback
                            return;
                        }
                    }
                    
                    // If no new track started and audio is not playing, track/album might be finished
                    if (!trackChanged && !isPlaying) {
                        // Always set track finished flag (for Super Shuffle, Shuffle Tracks, etc.)
                        window.bandcampTrackFinished = true;
                        console.log('Bandcamp Player: Track finished flag set');
                        
                        // Double-check: is this the last track?
                        var isLast = isLastTrack();
                        console.log('Bandcamp Player: No new track started, is last track: ' + isLast);
                        
                        if (isLast) {
                            console.log('Bandcamp Player: Album finished - last track ended and no new track started');
                            window.bandcampAlbumFinished = true;
                            // Also trigger immediate check by setting a flag that Python can poll
                            console.log('Bandcamp Player: Flag set to true, value is now: ' + window.bandcampAlbumFinished);
                        } else {
                            // Not the last track but no new track started - might still be loading
                            // Wait a bit more and check again
                            setTimeout(function() {
                                var stillNoNewTrack = !audioElement || audioElement.paused;
                                var stillSameTitle = newTitle === endedTrackTitle;
                                if (stillNoNewTrack && stillSameTitle) {
                                    // Check one more time if it's the last track
                                    if (isLastTrack()) {
                                        console.log('Bandcamp Player: Album finished (delayed check)');
                                        window.bandcampAlbumFinished = true;
                                        console.log('Bandcamp Player: Flag set to true (delayed), value is now: ' + window.bandcampAlbumFinished);
                                    }
                                    // Also set track finished if not already set (and not Repeat 1 Track mode)
                                    if (!window.bandcampTrackFinished && window.bandcampRepeatMode !== 3) {
                                        window.bandcampTrackFinished = true;
                                    }
                                }
                            }, 2000);
                        }
                    } else if (trackChanged) {
                        console.log('Bandcamp Player: New track started, album continuing');
                    }
                    
                    // Update last track title
                    if (newTitle) {
                        lastTrackTitle = newTitle;
                    }
                }, 2000); // Wait 2 seconds to see if next track starts
            }
            """
            
    def _get_audio_monitoring_js(self, repeat_mode=0, shuffle_mode=0, shuffled_track_list=None):
        """Generate JavaScript code for audio element monitoring
        
        Args:
            repeat_mode: Current repeat mode (0=off, 1=continuous, 2=album, 3=track)
            shuffle_mode: Current shuffle mode (0=off, 1=tracks, 2=albums, 3=super)
            shuffled_track_list: List of track numbers in shuffled order (for shuffle_mode=1)
        """
        # Inject shuffled track list if provided
        shuffled_list_js = ""
        if shuffled_track_list:
            shuffled_list_js = f"""
            window.bandcampShuffledTrackList = {shuffled_track_list};
            window.bandcampShuffledTrackIndex = 0;
            console.log('Bandcamp Player: Injected shuffled track list:', window.bandcampShuffledTrackList);
            """
        
        return f"""
            {shuffled_list_js}
            // Monitor audio element - most reliable way to detect track end
            var audioElement = document.querySelector('audio');
            if (audioElement) {{
                console.log('Bandcamp Player: Audio element found, setting up monitoring (repeat_mode={repeat_mode}, shuffle_mode={shuffle_mode})');
                
                // Store initial track title
                var titleElement = player.querySelector('.track-title, .title, [data-bind*="title"]');
                if (titleElement) {{
                    lastTrackTitle = titleElement.textContent || titleElement.innerText;
                }}
                
                // Function to restart current track (for Repeat 1 Track mode)
                function restartCurrentTrack() {{
                    if (audioElement && audioElement.duration > 0) {{
                        console.log('Bandcamp Player: Restarting current track (Repeat 1 Track mode)');
                        
                        // Method 1: Seek to beginning and play (most reliable, doesn't trigger Bandcamp's next-track logic)
                        audioElement.currentTime = 0;
                        // Small delay to ensure seek completes, then play
                        setTimeout(function() {{
                            if (audioElement && audioElement.duration > 0) {{
                                var playPromise = audioElement.play();
                                if (playPromise !== undefined) {{
                                    playPromise.then(function() {{
                                        console.log('Bandcamp Player: Track restarted successfully via seek+play');
                                    }}).catch(function(error) {{
                                        console.log('Bandcamp Player: Error restarting track via seek+play:', error);
                                        // Fallback: try clicking the current track in tracklist
                                        var tracklist = document.querySelector('#tracklist');
                                        if (tracklist) {{
                                            var currentTrack = tracklist.querySelector('li.track.playing, li.track.current');
                                            if (currentTrack) {{
                                                console.log('Bandcamp Player: Fallback - clicking current track in tracklist');
                                                var infoDiv = currentTrack.querySelector('.info');
                                                if (infoDiv) {{
                                                    infoDiv.click();
                                                }} else {{
                                                    currentTrack.click();
                                                }}
                                                // Also ensure we're at the beginning
                                                setTimeout(function() {{
                                                    if (audioElement && audioElement.duration > 0) {{
                                                        audioElement.currentTime = 0;
                                                    }}
                                                }}, 300);
                                            }}
                                        }}
                                    }});
                                }} else {{
                                    // No promise returned, assume it worked
                                    console.log('Bandcamp Player: Track play() called (no promise)');
                                }}
                            }}
                        }}, 50); // Shorter delay for faster restart
                    }}
                }}
                
                // Flag to prevent multiple restarts in Repeat 1 Track mode
                var isRestartingTrack = false;
                var lastRestartTime = 0;
                // Flag to prevent multiple album loops in Repeat Album mode
                var isLoopingAlbum = false;
                var lastLoopTime = 0;
                // Flag to prevent multiple track switches in Shuffle Tracks mode
                var isSwitchingShuffledTrack = false;
                var lastSwitchTime = 0;
                
                // Monitor timeupdate to detect when last track is near the end (switch sooner!)
                var timeUpdateHandler = function() {{
                    if (audioElement.currentTime > 0 && 
                        audioElement.duration > 0) {{
                        var timeRemaining = audioElement.duration - audioElement.currentTime;
                        var now = Date.now();
                        
                        // Super Shuffle mode: trigger next random album/track before track ends
                        if (window.bandcampShuffleMode === 3 && 
                            timeRemaining <= 0.3 && 
                            timeRemaining > 0 && 
                            !isSwitchingShuffledTrack &&
                            (now - lastSwitchTime) > 1000) {{  // At least 1 second between switches
                            isSwitchingShuffledTrack = true;
                            lastSwitchTime = now;
                            
                            console.log('Bandcamp Player: Super Shuffle mode - track ending, triggering next random selection');
                            // Set track finished flag to trigger Python handler for Super Shuffle
                            window.bandcampTrackFinished = true;
                            
                            // Reset flag after a short delay
                            setTimeout(function() {{
                                isSwitchingShuffledTrack = false;
                            }}, 1000);
                            return; // Exit early, let Python handle next random selection
                        }}
                        
                        // Shuffle Tracks mode: jump to next track in shuffled list before track ends
                        if (window.bandcampShuffleMode === 1 && 
                            window.bandcampShuffledTrackList && 
                            window.bandcampShuffledTrackList.length > 0 &&
                            timeRemaining <= 0.3 && 
                            timeRemaining > 0 && 
                            !isSwitchingShuffledTrack &&
                            (now - lastSwitchTime) > 1000) {{  // At least 1 second between switches
                            isSwitchingShuffledTrack = true;
                            lastSwitchTime = now;
                            
                            // Move to next track in shuffled list
                            if (window.bandcampShuffledTrackIndex === undefined) {{
                                window.bandcampShuffledTrackIndex = 0;
                            }}
                            var currentIndex = window.bandcampShuffledTrackIndex;
                            var nextIndex = (currentIndex + 1) % window.bandcampShuffledTrackList.length;
                            
                            // Check if we've reached the end of the shuffled list (wrapped back to 0)
                            var reachedEndOfShuffledList = (nextIndex === 0 && currentIndex === window.bandcampShuffledTrackList.length - 1);
                            
                            // If we've reached the end, check Repeat mode
                            if (reachedEndOfShuffledList) {{
                                // If Repeat mode is Continuous (1) or Off (0), move to next album
                                if (window.bandcampRepeatMode === 0 || window.bandcampRepeatMode === 1) {{
                                    console.log('Bandcamp Player: Shuffle Tracks mode - reached end of shuffled list, moving to next album (Repeat mode: ' + window.bandcampRepeatMode + ')');
                                    window.bandcampAlbumFinished = true;
                                    isSwitchingShuffledTrack = false;
                                    return; // Exit early, let Python handle next album
                                }}
                                // If Repeat Album mode (2) is active, reshuffle and continue
                                else if (window.bandcampRepeatMode === 2) {{
                                    console.log('Bandcamp Player: Shuffle Tracks mode - reached end of shuffled list, reshuffling (Repeat Album mode)');
                                    // Reshuffle the list (just reset index to 0, Python will reshuffle if needed)
                                    window.bandcampShuffledTrackIndex = 0;
                                    // Continue to play first track in reshuffled list
                                }}
                                // If Repeat 1 Track mode (3), just continue (shouldn't happen in shuffle mode, but handle it)
                                else {{
                                    window.bandcampShuffledTrackIndex = nextIndex;
                                }}
                            }} else {{
                                // Normal case: move to next track in list
                                window.bandcampShuffledTrackIndex = nextIndex;
                            }}
                            
                            var nextTrackNum = window.bandcampShuffledTrackList[window.bandcampShuffledTrackIndex];
                            console.log('Bandcamp Player: Shuffle Tracks mode - jumping to track ' + nextTrackNum + ' before end (' + timeRemaining.toFixed(2) + 's remaining)');
                            
                            // Find and click the next track
                            var tracklist = document.querySelector('#tracklist');
                            if (tracklist) {{
                                // Find track by data-num attribute
                                var targetTrack = tracklist.querySelector('li.track[data-num="' + nextTrackNum + '"]');
                                if (!targetTrack) {{
                                    // Fallback: find by index (0-based, so subtract 1)
                                    var allTracks = tracklist.querySelectorAll('li.track');
                                    if (allTracks.length >= nextTrackNum) {{
                                        targetTrack = allTracks[nextTrackNum - 1];
                                    }}
                                }}
                                
                                if (targetTrack) {{
                                    var infoDiv = targetTrack.querySelector('.info');
                                    if (infoDiv) {{
                                        try {{
                                            var clickEvent = new MouseEvent('click', {{
                                                bubbles: true,
                                                cancelable: true,
                                                view: window
                                            }});
                                            infoDiv.dispatchEvent(clickEvent);
                                            console.log('Bandcamp Player: Dispatched click event on shuffled track ' + nextTrackNum);
                                        }} catch (e) {{
                                            try {{
                                                infoDiv.click();
                                                console.log('Bandcamp Player: Called .click() on shuffled track ' + nextTrackNum);
                                            }} catch (e2) {{
                                                try {{
                                                    targetTrack.click();
                                                }} catch (e3) {{
                                                    console.log('Bandcamp Player: Error clicking shuffled track: ' + e3);
                                                }}
                                            }}
                                        }}
                                    }} else {{
                                        try {{
                                            targetTrack.click();
                                            console.log('Bandcamp Player: Clicked shuffled track ' + nextTrackNum + ' element directly');
                                        }} catch (e) {{
                                            console.log('Bandcamp Player: Error clicking shuffled track: ' + e);
                                        }}
                                    }}
                                }} else {{
                                    console.log('Bandcamp Player: Track ' + nextTrackNum + ' not found in tracklist');
                                }}
                            }} else {{
                                console.log('Bandcamp Player: Tracklist not found for shuffle track switch');
                            }}
                            
                            // Reset flag after a short delay
                            setTimeout(function() {{
                                isSwitchingShuffledTrack = false;
                            }}, 1000);
                            return; // Exit early, don't check for album end
                        }}
                        
                        // Repeat 1 Track mode: restart earlier (0.3s) to beat Bandcamp's handler
                        // Also check that we haven't restarted too recently (prevent rapid restarts)
                        if (window.bandcampRepeatMode === 3 && 
                            timeRemaining <= 0.3 && 
                            timeRemaining > 0 && 
                            !isRestartingTrack &&
                            (now - lastRestartTime) > 1000) {{  // At least 1 second between restarts
                            isRestartingTrack = true;
                            lastRestartTime = now;
                            console.log('Bandcamp Player: Repeat 1 Track mode - restarting track before end (' + timeRemaining.toFixed(2) + 's remaining)');
                            // Restart immediately by seeking to beginning and playing
                            audioElement.currentTime = 0;
                            // Ensure it keeps playing
                            if (audioElement.paused) {{
                                audioElement.play().catch(function(err) {{
                                    console.log('Bandcamp Player: Error playing after restart:', err);
                                }});
                            }}
                            // Reset flag after a short delay to allow next restart
                            setTimeout(function() {{
                                isRestartingTrack = false;
                            }}, 1000);
                            return; // Exit early, don't check for album end
                        }}
                        
                        // Repeat Album mode: jump to track 1 when last track is near the end
                        if (window.bandcampRepeatMode === 2 && 
                            isLastTrack() &&
                            timeRemaining <= 0.3 && 
                            timeRemaining > 0 && 
                            !isLoopingAlbum &&
                            (now - lastLoopTime) > 1000) {{  // At least 1 second between loops
                            isLoopingAlbum = true;
                            lastLoopTime = now;
                            console.log('Bandcamp Player: Repeat Album mode - jumping to track 1 before end (' + timeRemaining.toFixed(2) + 's remaining)');
                            
                            // Find track 1 (first playable track) and click it
                            var tracklist = document.querySelector('#tracklist');
                            if (tracklist) {{
                                var playableTracks = getPlayableTracks();
                                if (playableTracks.length > 0) {{
                                    var firstTrack = playableTracks[0];
                                    var infoDiv = firstTrack.querySelector('.info');
                                    if (infoDiv) {{
                                        try {{
                                            // Try mouse event first (more reliable)
                                            var clickEvent = new MouseEvent('click', {{
                                                bubbles: true,
                                                cancelable: true,
                                                view: window
                                            }});
                                            infoDiv.dispatchEvent(clickEvent);
                                            console.log('Bandcamp Player: Dispatched click event on track 1 .info div');
                                        }} catch (e) {{
                                            try {{
                                                infoDiv.click();
                                                console.log('Bandcamp Player: Called .click() on track 1 .info div');
                                            }} catch (e2) {{
                                                console.log('Bandcamp Player: Error clicking track 1: ' + e2);
                                                // Fallback: click the track element itself
                                                try {{
                                                    firstTrack.click();
                                                }} catch (e3) {{
                                                    console.log('Bandcamp Player: Error clicking track 1 element: ' + e3);
                                                }}
                                            }}
                                        }}
                                    }} else {{
                                        // No .info div, try clicking track element directly
                                        try {{
                                            firstTrack.click();
                                            console.log('Bandcamp Player: Clicked track 1 element directly');
                                        }} catch (e) {{
                                            console.log('Bandcamp Player: Error clicking track 1: ' + e);
                                        }}
                                    }}
                                }} else {{
                                    console.log('Bandcamp Player: No playable tracks found for album loop');
                                }}
                            }} else {{
                                console.log('Bandcamp Player: Tracklist not found for album loop');
                            }}
                            
                            // Reset flag after a short delay
                            setTimeout(function() {{
                                isLoopingAlbum = false;
                            }}, 1000);
                            return; // Exit early, don't check for album end
                        }}
                        
                        // If we're within the last 2 seconds of the last track, switch to next album
                        // (unless Repeat modes are active)
                        if (timeRemaining <= 2.0 && isLastTrack() && window.bandcampRepeatMode !== 3 && window.bandcampRepeatMode !== 2) {{
                            console.log('Bandcamp Player: Last track near end (' + timeRemaining.toFixed(1) + 's remaining) - switching to next album');
                            window.bandcampAlbumFinished = true;
                            // Remove listener to prevent multiple triggers
                            audioElement.removeEventListener('timeupdate', timeUpdateHandler);
                        }}
                    }}
                }};
                
                // Listen for time updates (fires frequently during playback)
                audioElement.addEventListener('timeupdate', timeUpdateHandler);
                
                // Listen for track end (fallback in case timeupdate didn't catch it)
                // Use capture phase with high priority to intercept before Bandcamp's handlers
                audioElement.addEventListener('ended', function(event) {{
                    console.log('Bandcamp Player: Audio ended event fired');
                    
                    // Check if Repeat 1 Track mode is active FIRST, before removing listeners
                    if (window.bandcampRepeatMode === 3) {{
                        // Try to prevent Bandcamp's default behavior immediately
                        if (event) {{
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                        }}
                        
                        // If we already restarted via timeupdate, ignore this event
                        if (isRestartingTrack || (audioElement.currentTime < 1.0 && audioElement.currentTime > 0)) {{
                            console.log('Bandcamp Player: Repeat 1 Track mode - already restarted, ignoring ended event');
                            return;
                        }}
                        
                        console.log('Bandcamp Player: Repeat 1 Track mode - ended event fired, restarting track (fallback)');
                        var now = Date.now();
                        if ((now - lastRestartTime) < 1000) {{
                            console.log('Bandcamp Player: Repeat 1 Track mode - restart too recent, ignoring');
                            return;
                        }}
                        
                        isRestartingTrack = true;
                        lastRestartTime = now;
                        // Restart the track immediately - don't wait
                        audioElement.currentTime = 0;
                        if (audioElement.paused) {{
                            audioElement.play().catch(function(err) {{
                                console.log('Bandcamp Player: Error playing after restart:', err);
                            }});
                        }}
                        setTimeout(function() {{
                            isRestartingTrack = false;
                        }}, 1000);
                        // DO NOT set window.bandcampTrackFinished - we're handling it in JavaScript
                        // This prevents Python from reloading the URL
                        return; // Exit early, don't call handleTrackEnd()
                    }}
                    
                    // Check if Shuffle Tracks mode is active
                    if (window.bandcampShuffleMode === 1 && 
                        window.bandcampShuffledTrackList && 
                        window.bandcampShuffledTrackList.length > 0) {{
                        // Try to prevent Bandcamp's default behavior immediately
                        if (event) {{
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                        }}
                        
                        // If we already switched via timeupdate, ignore this event
                        if (isSwitchingShuffledTrack) {{
                            console.log('Bandcamp Player: Shuffle Tracks mode - already switched, ignoring ended event');
                            return;
                        }}
                        
                        console.log('Bandcamp Player: Shuffle Tracks mode - ended event fired, jumping to next shuffled track (fallback)');
                        var now = Date.now();
                        if ((now - lastSwitchTime) < 1000) {{
                            console.log('Bandcamp Player: Shuffle Tracks mode - switch too recent, ignoring');
                            return;
                        }}
                        
                        isSwitchingShuffledTrack = true;
                        lastSwitchTime = now;
                        
                        // Move to next track in shuffled list
                        if (window.bandcampShuffledTrackIndex === undefined) {{
                            window.bandcampShuffledTrackIndex = 0;
                        }}
                        var currentIndex = window.bandcampShuffledTrackIndex;
                        var nextIndex = (currentIndex + 1) % window.bandcampShuffledTrackList.length;
                        
                        // Check if we've reached the end of the shuffled list
                        var reachedEndOfShuffledList = (nextIndex === 0 && currentIndex === window.bandcampShuffledTrackList.length - 1);
                        
                        // If we've reached the end, check Repeat mode
                        if (reachedEndOfShuffledList) {{
                            // If Repeat mode is Continuous (1) or Off (0), move to next album
                            if (window.bandcampRepeatMode === 0 || window.bandcampRepeatMode === 1) {{
                                console.log('Bandcamp Player: Shuffle Tracks mode - reached end of shuffled list, moving to next album (Repeat mode: ' + window.bandcampRepeatMode + ')');
                                window.bandcampAlbumFinished = true;
                                isSwitchingShuffledTrack = false;
                                return; // Exit early, let Python handle next album
                            }}
                            // If Repeat Album mode (2) is active, reshuffle and continue
                            else if (window.bandcampRepeatMode === 2) {{
                                console.log('Bandcamp Player: Shuffle Tracks mode - reached end of shuffled list, reshuffling (Repeat Album mode)');
                                window.bandcampShuffledTrackIndex = 0;
                            }}
                            else {{
                                window.bandcampShuffledTrackIndex = nextIndex;
                            }}
                        }} else {{
                            window.bandcampShuffledTrackIndex = nextIndex;
                        }}
                        
                        var nextTrackNum = window.bandcampShuffledTrackList[window.bandcampShuffledTrackIndex];
                        
                        // Find and click the next track (use cached lookup)
                        var tracklist = getCachedElement('tracklist', '#tracklist');
                        if (tracklist) {{
                            var targetTrack = tracklist.querySelector('li.track[data-num="' + nextTrackNum + '"]');
                            if (!targetTrack) {{
                                var allTracks = tracklist.querySelectorAll('li.track');
                                if (allTracks.length >= nextTrackNum) {{
                                    targetTrack = allTracks[nextTrackNum - 1];
                                }}
                            }}
                            
                            if (targetTrack) {{
                                var infoDiv = targetTrack.querySelector('.info');
                                if (infoDiv) {{
                                    try {{
                                        var clickEvent = new MouseEvent('click', {{
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        }});
                                        infoDiv.dispatchEvent(clickEvent);
                                        console.log('Bandcamp Player: Dispatched click event on shuffled track ' + nextTrackNum + ' (fallback)');
                                    }} catch (e) {{
                                        try {{
                                            infoDiv.click();
                                        }} catch (e2) {{
                                            try {{
                                                targetTrack.click();
                                            }} catch (e3) {{
                                                console.log('Bandcamp Player: Error clicking shuffled track: ' + e3);
                                            }}
                                        }}
                                    }}
                                }} else {{
                                    try {{
                                        targetTrack.click();
                                    }} catch (e) {{
                                        console.log('Bandcamp Player: Error clicking shuffled track: ' + e);
                                    }}
                                }}
                            }}
                        }}
                        
                        setTimeout(function() {{
                            isSwitchingShuffledTrack = false;
                        }}, 1000);
                        // DO NOT set window.bandcampTrackFinished - we're handling it in JavaScript
                        return; // Exit early, don't call handleTrackEnd()
                    }}
                    
                    // Check if Repeat Album mode is active
                    if (window.bandcampRepeatMode === 2 && isLastTrack()) {{
                        // Try to prevent Bandcamp's default behavior immediately
                        if (event) {{
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                        }}
                        
                        // If we already looped via timeupdate, ignore this event
                        if (isLoopingAlbum) {{
                            console.log('Bandcamp Player: Repeat Album mode - already looped, ignoring ended event');
                            return;
                        }}
                        
                        console.log('Bandcamp Player: Repeat Album mode - ended event fired, jumping to track 1 (fallback)');
                        var now = Date.now();
                        if ((now - lastLoopTime) < 1000) {{
                            console.log('Bandcamp Player: Repeat Album mode - loop too recent, ignoring');
                            return;
                        }}
                        
                        isLoopingAlbum = true;
                        lastLoopTime = now;
                        
                        // Find track 1 (first playable track) and click it
                        var tracklist = document.querySelector('#tracklist');
                        if (tracklist) {{
                            var playableTracks = getPlayableTracks();
                            if (playableTracks.length > 0) {{
                                var firstTrack = playableTracks[0];
                                var infoDiv = firstTrack.querySelector('.info');
                                if (infoDiv) {{
                                    try {{
                                        var clickEvent = new MouseEvent('click', {{
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        }});
                                        infoDiv.dispatchEvent(clickEvent);
                                        console.log('Bandcamp Player: Dispatched click event on track 1 .info div (fallback)');
                                    }} catch (e) {{
                                        try {{
                                            infoDiv.click();
                                        }} catch (e2) {{
                                            try {{
                                                firstTrack.click();
                                            }} catch (e3) {{
                                                console.log('Bandcamp Player: Error clicking track 1: ' + e3);
                                            }}
                                        }}
                                    }}
                                }} else {{
                                    try {{
                                        firstTrack.click();
                                    }} catch (e) {{
                                        console.log('Bandcamp Player: Error clicking track 1: ' + e);
                                    }}
                                }}
                            }}
                        }}
                        
                        setTimeout(function() {{
                            isLoopingAlbum = false;
                        }}, 1000);
                        // DO NOT set window.bandcampAlbumFinished - we're handling it in JavaScript
                        return; // Exit early, don't call handleTrackEnd()
                    }}
                    
                    // Normal behavior - handle track end
                    // Remove timeupdate listener since track ended
                    audioElement.removeEventListener('timeupdate', timeUpdateHandler);
                    handleTrackEnd();
                }}, true); // Use capture phase to intercept before Bandcamp's handlers
                
                // Also monitor for when audio stops (in case ended event doesn't fire)
                audioElement.addEventListener('pause', function(event) {{
                    // Only trigger if we're near the end of the track
                    if (audioElement.currentTime > 0 && 
                        audioElement.duration > 0 &&
                        audioElement.currentTime >= audioElement.duration - 0.5) {{
                        console.log('Bandcamp Player: Audio paused near end');
                        
                        // Check if Repeat 1 Track mode is active
                        if (window.bandcampRepeatMode === 3) {{
                            // Try to prevent Bandcamp's default behavior
                            if (event) {{
                                event.preventDefault();
                                event.stopPropagation();
                            }}
                            
                            var now = Date.now();
                            if (isRestartingTrack || (now - lastRestartTime) < 1000) {{
                                console.log('Bandcamp Player: Repeat 1 Track mode - restart too recent or already restarting, ignoring pause');
                                return;
                            }}
                            
                            console.log('Bandcamp Player: Repeat 1 Track mode - restarting track (paused near end, NOT setting trackFinished flag)');
                            isRestartingTrack = true;
                            lastRestartTime = now;
                            // Restart immediately
                            audioElement.currentTime = 0;
                            audioElement.play().catch(function(err) {{
                                console.log('Bandcamp Player: Error playing after restart:', err);
                            }});
                            setTimeout(function() {{
                                isRestartingTrack = false;
                            }}, 1000);
                            // DO NOT set window.bandcampTrackFinished - we're handling it in JavaScript
                            return; // Exit early, don't call handleTrackEnd()
                        }} else {{
                            audioElement.removeEventListener('timeupdate', timeUpdateHandler);
                            handleTrackEnd();
                        }}
                    }}
                }}, true); // Use capture phase
            }} else {{
                console.log('Bandcamp Player: Audio element not found, using fallback monitoring');
                """
                
    def _get_fallback_monitoring_js(self):
        """Generate JavaScript code for fallback MutationObserver monitoring"""
        return """
                // Fallback: monitor player for changes
                var observer = new MutationObserver(function(mutations) {
                    // Check if play button appeared (player stopped)
                    var playBtn = player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]');
                    var pauseBtn = player.querySelector('.pausebutton, .pause-button, button[title*="pause"], button[title*="Pause"]');
                    
                    if (playBtn && playBtn.offsetParent !== null && 
                        (!pauseBtn || pauseBtn.offsetParent === null)) {
                        // Player stopped - might be end of album
                        setTimeout(function() {
                            if (isLastTrack()) {
                                window.bandcampAlbumFinished = true;
                                console.log('Bandcamp Player: Album finished (fallback detection)');
                            }
                        }, 2000);
                    }
                });
                
                observer.observe(player, {
                    childList: true,
                    subtree: true,
                    characterData: true,
                    attributes: true
                });
                
                window.bandcampPlaybackObserver = observer;
            }
            """
    
    def setup_playback_monitoring(self):
        """Set up JavaScript monitoring to detect when album finishes playing"""
        if not self.web_view:
            return
        
        # Get current repeat mode and shuffle mode to pass to JavaScript
        repeat_mode = 0
        shuffle_mode = 0
        shuffled_track_list = None
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            repeat_mode = self.playlist_sidebar.repeat_mode
            shuffle_mode = self.playlist_sidebar.shuffle_mode
            # Get shuffled track list if Shuffle Tracks mode is active
            if shuffle_mode == 1 and hasattr(self, '_shuffled_track_list') and self._shuffled_track_list:
                shuffled_track_list = self._shuffled_track_list
        
        # Build JavaScript code from helper methods
        is_last_track_js = self._get_is_last_track_js()
        handle_track_end_js = self._get_handle_track_end_js()
        audio_monitoring_js = self._get_audio_monitoring_js(repeat_mode, shuffle_mode, shuffled_track_list)
        fallback_monitoring_js = self._get_fallback_monitoring_js()
        
        js_code = f"""
        (function() {{
            // Remove existing observer if any
            if (window.bandcampPlaybackObserver) {{
                window.bandcampPlaybackObserver.disconnect();
                window.bandcampPlaybackObserver = null;
            }}
            
            // Initialize flags
            window.bandcampAlbumFinished = false;
            window.bandcampTrackFinished = false;
            
            // Store repeat mode and shuffle mode for JavaScript
            window.bandcampRepeatMode = {repeat_mode};
            window.bandcampShuffleMode = {shuffle_mode};
            
            var player = document.querySelector('#player');
            if (!player) {{
                console.log('Bandcamp Player: Player element not found');
                return;
            }}
            
            var trackEndedTimeout = null;
            var lastTrackTitle = null;
            
            // Function to check if this is the last track
            {is_last_track_js}
            
            // Function to handle track end
            {handle_track_end_js}
            
            {audio_monitoring_js}
            {fallback_monitoring_js}
            
            console.log('Bandcamp Player: Playback monitoring setup complete (repeat_mode={repeat_mode})');
        }})();
        """
        
        self.run_javascript_safe(js_code)
        
        # Set up next/previous button interception for Shuffle Tracks mode
        self._setup_next_prev_button_interception()
        
        # Also update repeat mode in case it changed (for dynamic updates)
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            QTimer.singleShot(100, self.playlist_sidebar._update_javascript_repeat_mode)
            QTimer.singleShot(100, self.playlist_sidebar._update_javascript_shuffle_mode)
        
        # Set up periodic check to see if album/track finished
        if not hasattr(self, '_playback_check_timer'):
            self._playback_check_timer = QTimer(self)
            self._playback_check_timer.timeout.connect(self.check_playback_finished)
            self._playback_check_timer.start(PLAYBACK_CHECK_INTERVAL)
            logger.debug(f"Playback check timer started (checking every {PLAYBACK_CHECK_INTERVAL}ms)")
        
        # Set up periodic check to update current track number
        if not hasattr(self, '_track_number_check_timer'):
            self._track_number_check_timer = QTimer(self)
            self._track_number_check_timer.timeout.connect(self._update_current_track_number)
            self._track_number_check_timer.start(PLAYBACK_CHECK_INTERVAL)  # Check every second
            logger.debug(f"Track number check timer started (checking every {PLAYBACK_CHECK_INTERVAL}ms)")
        
        # Also re-inject after a delay to ensure it's set up (in case page wasn't ready)
        QTimer.singleShot(3000, lambda: self.web_view.page().runJavaScript(js_code) if self.web_view else None)
    
    def _setup_next_prev_button_interception(self):
        """Set up JavaScript to intercept next/previous button clicks for Shuffle Tracks mode"""
        if not self.web_view or not self.web_view.page():
            return
        
        # Get helper functions needed for last track detection
        playable_helper = self._get_playable_tracks_helper_js()
        is_last_track_js = self._get_is_last_track_js()
        
        js_code = playable_helper + is_last_track_js + """
        (function() {
            // Common function to click a track by number (reusable)
            function clickTrackByNumber(trackNum, logMessage) {
                var tracklist = getCachedElement('tracklist', '#tracklist');
                if (!tracklist) {
                    console.log('Bandcamp Player: Tracklist not found');
                    return false;
                }
                
                var targetTrack = tracklist.querySelector('li.track[data-num="' + trackNum + '"]');
                if (!targetTrack) {
                    var allTracks = tracklist.querySelectorAll('li.track');
                    if (allTracks.length >= trackNum) {
                        targetTrack = allTracks[trackNum - 1];
                    }
                }
                
                if (!targetTrack) {
                    console.log('Bandcamp Player: Track ' + trackNum + ' not found');
                    return false;
                }
                
                var infoDiv = targetTrack.querySelector('.info');
                if (infoDiv) {
                    try {
                        var clickEvent = new MouseEvent('click', {
                            bubbles: true,
                            cancelable: true,
                            view: window
                        });
                        infoDiv.dispatchEvent(clickEvent);
                        if (logMessage) {
                            console.log(logMessage);
                        }
                        return true;
                    } catch (e) {
                        try {
                            infoDiv.click();
                            if (logMessage) {
                                console.log(logMessage);
                            }
                            return true;
                        } catch (e2) {
                            try {
                                targetTrack.click();
                                if (logMessage) {
                                    console.log(logMessage);
                                }
                                return true;
                            } catch (e3) {
                                console.log('Bandcamp Player: Error clicking track ' + trackNum + ': ' + e3);
                                return false;
                            }
                        }
                    }
                } else {
                    try {
                        targetTrack.click();
                        if (logMessage) {
                            console.log(logMessage);
                        }
                        return true;
                    } catch (e) {
                        console.log('Bandcamp Player: Error clicking track ' + trackNum + ': ' + e);
                        return false;
                    }
                }
            }
            
            // Function to handle Super Shuffle mode (random album & track)
            function handleSuperShuffle(direction) {
                if (window.bandcampShuffleMode !== 3) {
                    return false; // Not in Super Shuffle mode
                }
                
                console.log('Bandcamp Player: Super Shuffle - ' + direction + ' button clicked, triggering random selection');
                // Set track finished flag to trigger Python handler for Super Shuffle
                window.bandcampTrackFinished = true;
                return true; // Handled
            }
            
            // Function to navigate to next/previous track in shuffled list
            function navigateShuffledTrack(direction) {
                if (window.bandcampShuffleMode !== 1 || 
                    !window.bandcampShuffledTrackList || 
                    window.bandcampShuffledTrackList.length === 0) {
                    return false; // Not in shuffle tracks mode or no shuffled list
                }
                
                if (window.bandcampShuffledTrackIndex === undefined) {
                    window.bandcampShuffledTrackIndex = 0;
                }
                
                var currentIndex = window.bandcampShuffledTrackIndex;
                var newIndex;
                
                if (direction === 'next') {
                    newIndex = (currentIndex + 1) % window.bandcampShuffledTrackList.length;
                    
                    // Check if we've reached the end
                    var reachedEnd = (newIndex === 0 && currentIndex === window.bandcampShuffledTrackList.length - 1);
                    if (reachedEnd) {
                        // If Repeat mode is Continuous (1) or Off (0), move to next album
                        if (window.bandcampRepeatMode === 0 || window.bandcampRepeatMode === 1) {
                            console.log('Bandcamp Player: Shuffle Tracks - reached end, moving to next album');
                            window.bandcampAlbumFinished = true;
                            return true; // Handled
                        }
                        // If Repeat Album mode (2), reshuffle and continue
                        else if (window.bandcampRepeatMode === 2) {
                            console.log('Bandcamp Player: Shuffle Tracks - reached end, reshuffling');
                            newIndex = 0;
                        }
                    }
                } else { // previous
                    newIndex = (currentIndex - 1 + window.bandcampShuffledTrackList.length) % window.bandcampShuffledTrackList.length;
                }
                
                window.bandcampShuffledTrackIndex = newIndex;
                var targetTrackNum = window.bandcampShuffledTrackList[newIndex];
                
                console.log('Bandcamp Player: Shuffle Tracks - navigating to track ' + targetTrackNum + ' (direction: ' + direction + ')');
                
                // Use common function to click the target track
                if (clickTrackByNumber(targetTrackNum, 'Bandcamp Player: Clicked shuffled track ' + targetTrackNum + ' via ' + direction + ' button')) {
                    return true; // Handled
                }
                
                return false; // Not handled
            }
            
            // Function to handle next button action (extracted for reuse)
            function handleNextButtonAction(event) {
                // Always check current mode at click time (in case mode changed)
                var currentMode = window.bandcampShuffleMode || 0;
                var repeatMode = window.bandcampRepeatMode || 0;
                
                // Check Super Shuffle mode first
                if (currentMode === 3 && handleSuperShuffle('next')) {
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    console.log('Bandcamp Player: Intercepted next button click for Super Shuffle mode (mode: ' + currentMode + ')');
                    return true; // Handled
                }
                // Check Shuffle Tracks mode
                if (currentMode === 1 && navigateShuffledTrack('next')) {
                    event.preventDefault();
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                    console.log('Bandcamp Player: Intercepted next button click for Shuffle Tracks mode (mode: ' + currentMode + ')');
                    return true; // Handled
                }
                
                // Check if we're on the last track - if so, handle based on repeat mode
                if (isLastTrack()) {
                    console.log('Bandcamp Player: Next button clicked on last track, repeat mode: ' + repeatMode);
                    
                    // Repeat 1 Track mode: restart current track
                    if (repeatMode === 3) {
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        console.log('Bandcamp Player: Repeat 1 Track - restarting current track');
                        var audioElement = document.querySelector('audio');
                        if (audioElement) {
                            audioElement.currentTime = 0;
                            if (audioElement.paused) {
                                audioElement.play();
                            }
                        }
                        return true; // Handled
                    }
                    
                    // Repeat Album mode: go to track 1
                    if (repeatMode === 2) {
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                                console.log('Bandcamp Player: Repeat Album - going to track 1');
                                var tracklist = getCachedElement('tracklist', '#tracklist');
                                if (tracklist) {
                                    var playableTracks = getPlayableTracks();
                                    if (playableTracks.length > 0) {
                                        // Get track number from first playable track
                                        var firstTrack = playableTracks[0];
                                        var trackNum = firstTrack.getAttribute('data-num');
                                        if (!trackNum) {
                                            // Fallback: try to find track number from text or index
                                            var allTracks = tracklist.querySelectorAll('li.track');
                                            for (var i = 0; i < allTracks.length; i++) {
                                                if (allTracks[i] === firstTrack) {
                                                    trackNum = i + 1;
                                                    break;
                                                }
                                            }
                                        }
                                        if (trackNum && clickTrackByNumber(parseInt(trackNum), 'Bandcamp Player: Clicked track 1 for Repeat Album')) {
                                            return true; // Handled
                                        }
                                    }
                                }
                                return true; // Handled
                    }
                    
                    // Continuous mode: move to next album
                    if (repeatMode === 1) {
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        console.log('Bandcamp Player: Continuous mode - moving to next album');
                        window.bandcampAlbumFinished = true;
                        return true; // Handled
                    }
                    
                    // Repeat Off: go to first track
                    if (repeatMode === 0) {
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                                console.log('Bandcamp Player: Repeat Off - going to first track');
                                var tracklist = getCachedElement('tracklist', '#tracklist');
                                if (tracklist) {
                                    var playableTracks = getPlayableTracks();
                                    if (playableTracks.length > 0) {
                                        // Get track number from first playable track
                                        var firstTrack = playableTracks[0];
                                        var trackNum = firstTrack.getAttribute('data-num');
                                        if (!trackNum) {
                                            // Fallback: try to find track number from text or index
                                            var allTracks = tracklist.querySelectorAll('li.track');
                                            for (var i = 0; i < allTracks.length; i++) {
                                                if (allTracks[i] === firstTrack) {
                                                    trackNum = i + 1;
                                                    break;
                                                }
                                            }
                                        }
                                        if (trackNum && clickTrackByNumber(parseInt(trackNum), 'Bandcamp Player: Clicked first track (Repeat Off)')) {
                                            return true; // Handled
                                        }
                                    }
                                }
                                return true; // Handled
                    }
                }
                
                // Otherwise, let normal behavior proceed (not on last track)
                return false; // Not handled
            }
            
            // Function to force-enable next button when needed
            function forceEnableNextButton() {
                var nextBtn = getCachedElement('nextBtn', 'button[aria-label="Skip to next song"], .next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
                if (nextBtn) {
                    var currentMode = window.bandcampShuffleMode || 0;
                    // If shuffle mode is active, force enable the button
                    if (currentMode === 1 || currentMode === 3) {
                        // Remove disabled attribute and class
                        nextBtn.removeAttribute('disabled');
                        nextBtn.removeAttribute('aria-disabled');
                        nextBtn.classList.remove('disabled');
                        // Also check if button has pointer-events: none and override it
                        var style = window.getComputedStyle(nextBtn);
                        if (style.pointerEvents === 'none') {
                            nextBtn.style.pointerEvents = 'auto';
                            nextBtn.style.cursor = 'pointer';
                            nextBtn.style.opacity = '1';
                        }
                    }
                }
            }
            
            // Cache DOM queries to avoid repeated lookups
            var cachedElements = {
                nextBtn: null,
                prevBtn: null,
                tracklist: null,
                player: null,
                audioElement: null,
                lastCacheTime: 0
            };
            
            // Cache refresh interval (5 seconds)
            var CACHE_REFRESH_INTERVAL = 5000;
            
            function getCachedElement(key, selector) {
                var now = Date.now();
                // Refresh cache if stale
                if (now - cachedElements.lastCacheTime > CACHE_REFRESH_INTERVAL) {
                    cachedElements.nextBtn = null;
                    cachedElements.prevBtn = null;
                    cachedElements.tracklist = null;
                    cachedElements.player = null;
                    cachedElements.audioElement = null;
                    cachedElements.lastCacheTime = now;
                }
                
                // Return cached or fetch new
                if (!cachedElements[key]) {
                    cachedElements[key] = document.querySelector(selector);
                }
                return cachedElements[key];
            }
            
            // Function to set up button interception
            function setupButtonInterception() {
                // Find next button (use cached lookup)
                var nextBtn = getCachedElement('nextBtn', 'button[aria-label="Skip to next song"], .next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
                if (nextBtn) {
                    // Force enable if shuffle is active
                    forceEnableNextButton();
                    
                    // Remove old listeners if exist
                    if (nextBtn._bandcampPlayerClickHandler) {
                        nextBtn.removeEventListener('click', nextBtn._bandcampPlayerClickHandler, true);
                    }
                    if (nextBtn._bandcampPlayerMouseDownHandler) {
                        nextBtn.removeEventListener('mousedown', nextBtn._bandcampPlayerMouseDownHandler, true);
                    }
                    
                    // Create click handler
                    nextBtn._bandcampPlayerClickHandler = function(event) {
                        if (handleNextButtonAction(event)) {
                            return false; // Handled
                        }
                    };
                    
                    // Create mousedown handler (for disabled buttons - mousedown still fires)
                    nextBtn._bandcampPlayerMouseDownHandler = function(event) {
                        // Check if button is disabled
                        if (nextBtn.disabled || nextBtn.hasAttribute('disabled') || 
                            nextBtn.getAttribute('aria-disabled') === 'true' ||
                            nextBtn.classList.contains('disabled')) {
                            // Force enable and handle the action
                            forceEnableNextButton();
                            // Use setTimeout to handle after mousedown completes
                            setTimeout(function() {
                                var fakeEvent = { preventDefault: function() {}, stopPropagation: function() {}, stopImmediatePropagation: function() {} };
                                if (handleNextButtonAction(fakeEvent)) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                    event.stopImmediatePropagation();
                                }
                            }, 0);
                        }
                    };
                    
                    // Add listeners
                    nextBtn.addEventListener('click', nextBtn._bandcampPlayerClickHandler, true);
                    nextBtn.addEventListener('mousedown', nextBtn._bandcampPlayerMouseDownHandler, true);
                    nextBtn.setAttribute('data-bandcamp-player-intercepted', 'true');
                    console.log('Bandcamp Player: Next button interception set up (mode: ' + (window.bandcampShuffleMode || 0) + ')');
                }
                
                // Find previous button (use cached lookup)
                var prevBtn = getCachedElement('prevBtn', 'button[aria-label="Skip to previous song"], .next-prev-controls button[aria-label*="previous"], .next-prev-controls button[aria-label*="Previous"], button[aria-label*="Skip to previous"]');
                if (prevBtn) {
                    // Remove old listener if exists
                    if (prevBtn._bandcampPlayerClickHandler) {
                        prevBtn.removeEventListener('click', prevBtn._bandcampPlayerClickHandler, true);
                    }
                    
                    // Create new handler
                    prevBtn._bandcampPlayerClickHandler = function(event) {
                        // Always check current mode at click time (in case mode changed)
                        var currentMode = window.bandcampShuffleMode || 0;
                        
                        // Check Super Shuffle mode first
                        if (currentMode === 3 && handleSuperShuffle('previous')) {
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                            console.log('Bandcamp Player: Intercepted previous button click for Super Shuffle mode (mode: ' + currentMode + ')');
                            return false;
                        }
                        // Check Shuffle Tracks mode
                        if (currentMode === 1 && navigateShuffledTrack('previous')) {
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                            console.log('Bandcamp Player: Intercepted previous button click for Shuffle Tracks mode (mode: ' + currentMode + ')');
                            return false;
                        }
                        // Otherwise, let normal behavior proceed (mode 0 or 2)
                        console.log('Bandcamp Player: Previous button - normal behavior (mode: ' + currentMode + ')');
                    };
                    
                    // Add new listener
                    prevBtn.addEventListener('click', prevBtn._bandcampPlayerClickHandler, true);
                    prevBtn.setAttribute('data-bandcamp-player-intercepted', 'true');
                    console.log('Bandcamp Player: Previous button interception set up (mode: ' + (window.bandcampShuffleMode || 0) + ')');
                }
            }
            
            // Set up immediately
            setupButtonInterception();
            
            // Also set up after delays in case buttons aren't ready yet
            // Use exponential backoff to reduce redundant calls
            var setupAttempts = 0;
            function setupWithRetry() {
                setupAttempts++;
                var nextBtn = document.querySelector('button[aria-label="Skip to next song"], .next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
                if (nextBtn && nextBtn.hasAttribute('data-bandcamp-player-intercepted')) {
                    // Already set up, skip
                    return;
                }
                setupButtonInterception();
                // Retry up to 3 times with increasing delays
                if (setupAttempts < 3) {
                    setTimeout(setupWithRetry, 500 * setupAttempts);
                }
            }
            setTimeout(setupWithRetry, 500);
            
            // Set up periodic check to keep button enabled when shuffle is active
            // (Bandcamp may re-disable it, so we need to keep re-enabling it)
            // Use a longer interval to reduce overhead (1000ms instead of 500ms)
            if (window.bandcampButtonEnablerInterval) {
                clearInterval(window.bandcampButtonEnablerInterval);
            }
            window.bandcampButtonEnablerInterval = setInterval(function() {
                var currentMode = window.bandcampShuffleMode || 0;
                // Only force enable if shuffle mode is active
                if (currentMode === 1 || currentMode === 3) {
                    forceEnableNextButton();
                }
            }, 1000); // Check every 1000ms (reduced from 500ms)
            
            // Watch for dynamically added buttons (if page updates)
            if (document.body) {
                var observer = new MutationObserver(function(mutations) {
                    setupButtonInterception();
                });
                observer.observe(document.body, { childList: true, subtree: true });
                
                // Store observer so we can disconnect it later if needed
                window.bandcampButtonObserver = observer;
            }
        })();
        """
        
        self.run_javascript_safe(js_code)
    
    def setup_first_playback_detection(self):
        """Set up JavaScript monitoring to detect first playback after URL load in micro mode"""
        if not self.web_view or self.mini_mode_state != 2:
            return
        
        # Stop any existing timer first
        if hasattr(self, '_first_playback_check_timer') and self._first_playback_check_timer:
            self._first_playback_check_timer.stop()
        
        # Reset the detection flag for this new URL load
        self._first_playback_detected = False
        
        js_code = """
        (function() {
            // Reset any previous setup
            window.bandcampFirstPlaybackSetup = false;
            window.bandcampFirstPlaybackDetected = false;
            
            // Set up fresh detection
            window.bandcampFirstPlaybackSetup = true;
            
            var audioElement = document.querySelector('audio');
            var hasTriggered = false;
            
            function detectFirstPlayback() {
                if (hasTriggered) {
                    return;
                }
                
                if (audioElement) {
                    var isPlaying = !audioElement.paused && audioElement.currentTime > 0;
                    if (isPlaying) {
                        hasTriggered = true;
                        console.log('Bandcamp Player: First playback detected - signaling layout refresh');
                        window.bandcampFirstPlaybackDetected = true;
                    }
                }
            }
            
            // Monitor audio element for first playback
            if (audioElement) {
                audioElement.addEventListener('play', function() {
                    if (!hasTriggered) {
                        hasTriggered = true;
                        console.log('Bandcamp Player: First play event - signaling layout refresh');
                        window.bandcampFirstPlaybackDetected = true;
                    }
                });
                
                audioElement.addEventListener('playing', function() {
                    if (!hasTriggered) {
                        hasTriggered = true;
                        console.log('Bandcamp Player: First playing event - signaling layout refresh');
                        window.bandcampFirstPlaybackDetected = true;
                    }
                });
            }
            
            // Also poll for audio state (fallback)
            var checkInterval = setInterval(function() {
                detectFirstPlayback();
                if (hasTriggered) {
                    clearInterval(checkInterval);
                }
            }, 200);
            
            // Stop checking after 5 seconds
            setTimeout(function() {
                clearInterval(checkInterval);
            }, 5000);
        })();
        """
        
        self.run_javascript_safe(js_code)
        
        # Set up periodic check to see if first playback was detected
        # Always create/restart the timer for each new URL load
        if hasattr(self, '_first_playback_check_timer') and self._first_playback_check_timer:
            self._first_playback_check_timer.stop()
        else:
            self._first_playback_check_timer = QTimer(self)
            self._first_playback_check_timer.timeout.connect(self._check_first_playback)
        
        self._first_playback_check_timer.start(200)  # Check every 200ms
        # Stop checking after 5 seconds
        QTimer.singleShot(5000, lambda: self._first_playback_check_timer.stop() if hasattr(self, '_first_playback_check_timer') and self._first_playback_check_timer else None)
    
    def _check_first_playback(self):
        """Check if first playback was detected and refresh layout in micro mode"""
        if not self.web_view or self.mini_mode_state != 2:
            # Not in micro mode anymore, stop checking
            if hasattr(self, '_first_playback_check_timer'):
                self._first_playback_check_timer.stop()
            return
        
        def on_check_result(result):
            if result is True or result == True or (isinstance(result, str) and result.lower() == 'true'):
                # First playback detected - refresh layout
                self._first_playback_detected = True
                # Stop the timer
                if hasattr(self, '_first_playback_check_timer'):
                    self._first_playback_check_timer.stop()
                # Reset JavaScript flag
                self.run_javascript_safe("window.bandcampFirstPlaybackDetected = false; window.bandcampFirstPlaybackSetup = false;")
                # Refresh layout by resizing to micro mode
                # Use a small delay to ensure player has fully expanded
                QTimer.singleShot(300, self._resize_to_micro_mode_with_retry)
                logger.debug("First playback detected in micro mode - refreshing layout")
        
        check_js = """
        (function() {
            if (typeof window.bandcampFirstPlaybackDetected === 'undefined') {
                return false;
            }
            return window.bandcampFirstPlaybackDetected === true;
        })();
        """
        
        self.web_view.page().runJavaScript(check_js, on_check_result)
    
    def check_playback_finished(self):
        """Check if track or album has finished playing and handle based on shuffle/repeat modes"""
        if not self.web_view:
            return
        
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # Check both track and album finish flags
        def on_check_result(result):
            try:
                track_finished = result.get('track_finished', False)
                album_finished = result.get('album_finished', False)
                
                # Handle track finish (for Repeat 1 Track, Super Shuffle, Shuffle Tracks)
                if track_finished:
                    self._handle_track_finished()
                
                # Handle album finish (for Repeat Album, Continuous, etc.)
                if album_finished:
                    self._handle_album_finished()
            except (AttributeError, TypeError, KeyError) as e:
                logger.debug(f"Error parsing playback check result: {e}")
        
        # Check JavaScript flags
        check_js = """
        (function() {
            return {
                track_finished: window.bandcampTrackFinished || false,
                album_finished: window.bandcampAlbumFinished || false
            };
        })();
        """
        self.web_view.page().runJavaScript(check_js, on_check_result)
    
    def check_album_finished(self):
        """Legacy method - redirects to check_playback_finished"""
        self.check_playback_finished()
    
    def _handle_track_finished(self):
        """Handle when a track finishes playing"""
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # Reset flag FIRST to prevent multiple triggers
        self.run_javascript_safe("window.bandcampTrackFinished = false;")
        
        shuffle_mode = self.playlist_sidebar.shuffle_mode
        repeat_mode = self.playlist_sidebar.repeat_mode
        
        # Repeat 1 Track mode: JavaScript handles restarting, but we can fallback to reload if needed
        if repeat_mode == 3:
            # Check if JavaScript actually restarted the track by checking if audio is playing
            def check_if_restarted():
                js_code = """
                (function() {
                    var audioElement = document.querySelector('audio');
                    if (audioElement) {
                        var isPlaying = !audioElement.paused && audioElement.currentTime > 0;
                        var currentTime = audioElement.currentTime || 0;
                        // If playing and near the beginning (< 5 seconds), JavaScript likely restarted it
                        return {
                            isPlaying: isPlaying,
                            currentTime: currentTime,
                            restarted: isPlaying && currentTime < 5
                        };
                    }
                    return {isPlaying: false, currentTime: 0, restarted: false};
                })();
                """
                
                def on_check_result(result):
                    try:
                        if result and result.get('restarted', False):
                            logger.debug("Repeat 1 Track: JavaScript successfully restarted track, skipping Python handler")
                            return  # JavaScript handled it, don't reload
                        else:
                            # JavaScript didn't restart, use fallback
                            logger.info("Repeat 1 Track: JavaScript restart failed, using fallback reload")
                            current_url = self.web_view.url().toString()
                            current_track = getattr(self, '_current_track_number', None)
                            if current_url and current_track:
                                # Load URL and then play the specific track
                                self.load_url(current_url)
                                # Set flag to auto-play the specific track after page loads
                                self._auto_play_track_number = current_track
                                # Also set _current_track_number so it's saved
                                self._current_track_number = current_track
                    except (AttributeError, TypeError, KeyError) as e:
                        logger.debug(f"Error checking restart status: {e}, using fallback")
                        # On error, use fallback
                        current_url = self.web_view.url().toString()
                        current_track = getattr(self, '_current_track_number', None)
                        if current_url and current_track:
                            self.load_url(current_url)
                            self._auto_play_track_number = current_track
                            self._current_track_number = current_track
                
                self.web_view.page().runJavaScript(js_code, on_check_result)
            
            # Wait a bit for JavaScript to restart, then check
            QTimer.singleShot(500, check_if_restarted)
            return
        
        # Super Shuffle mode: pick random album and random track
        if shuffle_mode == 3:
            # Check if this is a pending load from when Super Shuffle was toggled on
            pending_load = getattr(self, '_pending_super_shuffle_load', False)
            if pending_load:
                # Clear the flag
                self._pending_super_shuffle_load = False
                logger.info("Super Shuffle: Track finished, loading random album and random track (was pending)")
            else:
                logger.info("Super Shuffle: Track finished, loading random album and random track")
            self._load_super_shuffle_track()
            return
        
        # Shuffle Tracks mode: JavaScript should have already jumped to next track
        # Skip reload - JavaScript handles the seamless switch
        if shuffle_mode == 1:
            logger.info("Shuffle Tracks: JavaScript should have switched to next track, skipping reload")
            # Note: If JavaScript fails to switch, we could add a fallback here,
            # but for now we trust the JavaScript implementation
            return
    
    def _handle_album_finished(self):
        """Handle when an album finishes playing"""
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # CRITICAL: If Shuffle Tracks mode (mode 1) is active, verify we've played all shuffled tracks
        shuffle_mode = getattr(self.playlist_sidebar, 'shuffle_mode', 0)
        if shuffle_mode == 1:
            # Check if we have a shuffled list and if we've played all tracks
            if hasattr(self, '_shuffled_track_list') and self._shuffled_track_list:
                current_url = self.web_view.url().toString()
                # Only proceed if this is the same album and we've played all tracks
                if (self._shuffled_track_album_url == current_url and 
                    hasattr(self, '_shuffled_track_index') and 
                    self._shuffled_track_index < len(self._shuffled_track_list) - 1):
                    # We haven't played all shuffled tracks yet - don't move to next album
                    logger.info(f"Shuffle Tracks: Not all tracks played yet (index {self._shuffled_track_index}/{len(self._shuffled_track_list)-1}), ignoring album finished")
                    # Reset flag and let shuffle logic continue
                    self.run_javascript_safe("window.bandcampAlbumFinished = false;")
                    return
        
        # Reset flag FIRST to prevent multiple triggers
        self.web_view.page().runJavaScript("window.bandcampAlbumFinished = false;")
        
        repeat_mode = self.playlist_sidebar.repeat_mode
        
        # Repeat Album mode: JavaScript should have already jumped to track 1
        # Skip reload - JavaScript handles the seamless loop
        if repeat_mode == 2:
            logger.info("Repeat Album: JavaScript should have looped to track 1, skipping reload")
            # Note: If JavaScript fails to loop, we could add a fallback here,
            # but for now we trust the JavaScript implementation
            return
        
        # Continuous mode (or default): load next album
        if repeat_mode == 1 or repeat_mode == 0:
            logger.info("Continuous/Off: Loading next album")
            QTimer.singleShot(50, lambda: self._load_next_album_safe())
            return
    
    def _update_current_track_number(self):
        """Periodically update the current track number from the page"""
        if not self.web_view or not self.web_view.page():
            return
        
        js_code = """
            (function() {
            var currentTrack = document.querySelector('.current-track');
            if (currentTrack) {
                var trackNumEl = currentTrack.querySelector('.track-number, .track-num');
                if (trackNumEl) {
                    var trackNumber = trackNumEl.textContent.trim().replace(/[^\\d]/g, '');
                    if (trackNumber) {
                        return parseInt(trackNumber);
                    }
                }
                // Fallback: try to find number in spans
                var spans = currentTrack.querySelectorAll('span');
                for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    var text = span.textContent.trim();
                    if (/^\\d+$/.test(text)) {
                        return parseInt(text);
                }
                }
            }
            // Also try to get from data-num attribute of playing track
            var tracklist = document.querySelector('#tracklist');
            if (tracklist) {
                var playingTrack = tracklist.querySelector('li.track.playing, li.track.current');
                if (playingTrack) {
                    var dataNum = playingTrack.getAttribute('data-num');
                    if (dataNum) {
                        return parseInt(dataNum);
                    }
                }
            }
            return null;
            })();
        """
        
        def on_track_number_received(result):
            if result is not None:
                try:
                    track_num = int(result)
                    if track_num != self._current_track_number:
                        self._current_track_number = track_num
                        logger.debug(f"Updated current track number: {track_num}")
                        
                        # Update shuffled track index if Shuffle Tracks mode is active
                        if (hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and
                            self.playlist_sidebar.shuffle_mode == 1 and
                            hasattr(self, '_shuffled_track_list') and self._shuffled_track_list and
                            track_num in self._shuffled_track_list):
                            # Find the index of the current track in the shuffled list
                            new_index = self._shuffled_track_list.index(track_num)
                            if new_index != getattr(self, '_shuffled_track_index', -1):
                                self._shuffled_track_index = new_index
                                # Update JavaScript index
                                js_update = f"""
                                (function() {{
                                    window.bandcampShuffledTrackIndex = {new_index};
                                    console.log('Bandcamp Player: Updated shuffled track index to {new_index} (track {track_num})');
                                }})();
                                """
                                self.web_view.page().runJavaScript(js_update)
                                logger.debug(f"Updated shuffled track index to {new_index} for track {track_num}")
                        
                        # Track manual track selection in Super Shuffle mode (continue from there)
                        if (hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and
                            self.playlist_sidebar.shuffle_mode == 3):
                            current_url = self.web_view.url().toString()
                            if current_url and current_url.startswith('http'):
                                combo = (current_url, track_num)
                                self._add_to_super_shuffle_history(combo)
                                logger.debug(f"Super Shuffle: Tracked manual track selection: {combo}")
                        
                        # Save settings immediately when track number changes (regardless of autoplay settings)
                        self.save_settings()
                except (ValueError, TypeError):
                    pass
        
        self.web_view.page().runJavaScript(js_code, on_track_number_received)
    
    def _load_next_album_safe(self):
        """Safely load next album with error handling"""
        try:
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                # Mark that we're loading via repeat (so we can auto-play)
                self._auto_play_next_album = True
                success = self.playlist_sidebar.load_next_album()
                if success:
                    logger.info("Next album loaded successfully, will auto-play first track")
                else:
                    logger.info("Failed to load next album (no more albums?)")
                    self._auto_play_next_album = False
        except Exception as e:
            logger.error(f"Error loading next album: {e}", exc_info=True)
            self._auto_play_next_album = False
    
    def _create_shuffled_track_list(self, album_url):
        """Create a shuffled list of track numbers for the current album (for Shuffle Tracks mode)"""
        if not self.web_view or not self.web_view.page():
            return
        
        # Get all track numbers from the album
        js_code = """
        (function() {
            var tracks = [];
            var tracklist = document.querySelector('#tracklist');
            if (tracklist) {
                var trackElements = tracklist.querySelectorAll('li.track');
                trackElements.forEach(function(trackEl) {
                    var dataNum = trackEl.getAttribute('data-num');
                    if (dataNum) {
                        tracks.push(parseInt(dataNum));
                    } else {
                        // Fallback: use index + 1
                        var index = Array.from(tracklist.querySelectorAll('li.track')).indexOf(trackEl);
                        tracks.push(index + 1);
                    }
                });
            }
            return tracks;
        })();
        """
        
        def on_tracks_received(result):
            if result and isinstance(result, list) and len(result) > 0:
                # Remove duplicates to ensure each track plays only once
                # Convert to set to remove duplicates, then back to list to preserve order
                unique_tracks = list(dict.fromkeys(result))  # Preserves order while removing duplicates
                
                if len(unique_tracks) < len(result):
                    logger.debug(f"Removed {len(result) - len(unique_tracks)} duplicate track(s) from shuffled list")
                
                # Shuffle the track list
                shuffled = unique_tracks.copy()
                random.shuffle(shuffled)
                self._shuffled_track_list = shuffled
                self._shuffled_track_index = 0
                self._shuffled_track_album_url = album_url
                logger.debug(f"Created shuffled track list for album: {shuffled}")
            else:
                # No tracks found or single track - create list with just track 1
                self._shuffled_track_list = [1]
                self._shuffled_track_index = 0
                self._shuffled_track_album_url = album_url
                logger.debug("Single track album - shuffled list contains only track 1")
            
            # Inject shuffled list into JavaScript for seamless track switching
            if self._shuffled_track_list:
                # Find current track index in shuffled list
                current_track = getattr(self, '_current_track_number', None)
                if current_track and current_track in self._shuffled_track_list:
                    # Set index to current track's position in shuffled list
                    self._shuffled_track_index = self._shuffled_track_list.index(current_track)
                else:
                    # Start from beginning if current track not found
                    self._shuffled_track_index = 0
                
                shuffled_js = f"""
                (function() {{
                    window.bandcampShuffledTrackList = {self._shuffled_track_list};
                    window.bandcampShuffledTrackIndex = {self._shuffled_track_index};
                    console.log('Bandcamp Player: Injected shuffled track list:', window.bandcampShuffledTrackList, 'starting at index', window.bandcampShuffledTrackIndex);
                }})();
                """
                self.run_javascript_safe(shuffled_js)
                
                # Re-setup button interception after shuffled list is created to ensure it's active
                if hasattr(self, '_setup_next_prev_button_interception'):
                    self._debounced_setup_button_interception()
        
        self.web_view.page().runJavaScript(js_code, on_tracks_received)
    
    def _load_next_shuffled_track(self):
        """Load the next track in the shuffled list (for Shuffle Tracks mode)"""
        current_url = self.web_view.url().toString()
        
        # If album changed or no shuffled list exists, create one
        if (not self._shuffled_track_list or 
            self._shuffled_track_album_url != current_url):
            self._create_shuffled_track_list(current_url)
            # Wait a bit for the list to be created, then try again
            QTimer.singleShot(500, self._load_next_shuffled_track)
            return
        
        # Move to next track in shuffled list
        self._shuffled_track_index += 1
        
        # If we've played all tracks, check Repeat mode
        if self._shuffled_track_index >= len(self._shuffled_track_list):
            repeat_mode = 0
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                repeat_mode = self.playlist_sidebar.repeat_mode
            
            # If Repeat Album mode (2) is active, reshuffle and continue
            if repeat_mode == 2:
                random.shuffle(self._shuffled_track_list)
                self._shuffled_track_index = 0
                # Update JavaScript with reshuffled list
                if self._shuffled_track_list:
                    shuffled_js = f"""
                    (function() {{
                        window.bandcampShuffledTrackList = {self._shuffled_track_list};
                        window.bandcampShuffledTrackIndex = 0;
                        console.log('Bandcamp Player: Reshuffled track list:', window.bandcampShuffledTrackList);
                    }})();
                    """
                    self.run_javascript_safe(shuffled_js)
            # Otherwise (Continuous/Off), let album finished handler move to next album
            else:
                # Don't reshuffle - let the album finished handler take over
                logger.info("Shuffle Tracks: Reached end of shuffled list, moving to next album (Repeat mode: {})".format(repeat_mode))
                return
        
        # Get the track number to play
        track_number = self._shuffled_track_list[self._shuffled_track_index]
        logger.info(f"Shuffle Tracks: Loading track {track_number} from shuffled list")
        
        # Load URL and set track to play
        self.load_url(current_url)
        self._auto_play_track_number = track_number
        self._current_track_number = track_number
    
    def _load_super_shuffle_track(self):
        """Load a random album and random track (for Super Shuffle mode)
        
        Avoids the last 3 played (album_url, track_number) combinations.
        Works dynamically with playlist changes.
        """
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # Get all albums from playlist (dynamic - gets current playlist state)
        valid_items = []
        for i in range(self.playlist_sidebar.list_widget.count()):
            item = self.playlist_sidebar.list_widget.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole):  # Has URL
                valid_items.append((i, item))
        
        if len(valid_items) == 0:
            logger.warning("Super Shuffle: No albums in playlist")
            return
        
        # Get history of last played combinations (avoid last 3)
        history = getattr(self.playlist_sidebar, '_super_shuffle_history', [])
        max_history = getattr(self.playlist_sidebar, '_super_shuffle_max_history', 3)
        
        # Pick a random album, avoiding albums from recent history if possible
        available_albums = valid_items.copy()
        
        # If we have history, try to avoid albums that were recently played
        if history and len(valid_items) > 1:
            recent_albums = {combo[0] for combo in history[-max_history:]}
            # Only filter if we have enough albums to choose from
            if len(available_albums) > len(recent_albums):
                available_albums = [item for item in valid_items if item[1].data(Qt.ItemDataRole.UserRole) not in recent_albums]
                if len(available_albums) == 0:
                    available_albums = valid_items.copy()  # Fallback to all albums
        
        # Pick a random album
        random_album_index, random_item = random.choice(available_albums)
        random_album_url = random_item.data(Qt.ItemDataRole.UserRole)
        
        # Set Super Shuffle flag and store album URL before loading
        # This allows track selection to happen immediately when page is ready
        self._is_super_shuffle_load = True
        self._super_shuffle_album_url = random_album_url
        
        # Load the album - track selection will happen in on_page_loaded() when page is ready
        logger.info(f"Super Shuffle: Loading random album: {random_album_url}")
        self.load_url(random_album_url)
    
    def _pick_super_shuffle_track(self):
        """Pick a random track for Super Shuffle mode when page is ready
        
        This is called from on_page_loaded() when _is_super_shuffle_load is True.
        It selects a random track and sets _auto_play_track_number for immediate autoplay.
        """
        # Safety check: ensure Super Shuffle flag is set
        if not hasattr(self, '_is_super_shuffle_load') or not self._is_super_shuffle_load:
            return
        
        # Safety check: ensure Super Shuffle is still enabled (user might have toggled it off)
        if (not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar or 
            self.playlist_sidebar.shuffle_mode != 3):
            # Super Shuffle was disabled - clear flags and return
            logger.debug("Super Shuffle was disabled, clearing flags")
            self._is_super_shuffle_load = False
            self._super_shuffle_album_url = None
            return
        
        if not hasattr(self, '_super_shuffle_album_url') or not self._super_shuffle_album_url:
            # Clear flag and return if no album URL stored
            self._is_super_shuffle_load = False
            return
        
        if not self.web_view or not self.web_view.page():
            # Fallback to track 1 if page not ready
            combo = (self._super_shuffle_album_url, 1)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                self._add_to_super_shuffle_history(combo)
            self._auto_play_track_number = 1
            self._current_track_number = 1
            self._is_super_shuffle_load = False
            self._super_shuffle_album_url = None
            return
        
        random_album_url = self._super_shuffle_album_url
        history = []
        max_history = 3
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            history = getattr(self.playlist_sidebar, '_super_shuffle_history', [])
            max_history = getattr(self.playlist_sidebar, '_super_shuffle_max_history', 3)
        
        js_code = """
        (function() {
            var tracks = [];
            var tracklist = document.querySelector('#tracklist');
            if (tracklist) {
                var trackElements = tracklist.querySelectorAll('li.track');
                trackElements.forEach(function(trackEl) {
                    var dataNum = trackEl.getAttribute('data-num');
                    if (dataNum) {
                        tracks.push(parseInt(dataNum));
                    } else {
                        var index = Array.from(tracklist.querySelectorAll('li.track')).indexOf(trackEl);
                        tracks.push(index + 1);
                    }
                });
            }
            // Remove duplicates
            var uniqueTracks = [];
            var seen = {};
            tracks.forEach(function(track) {
                if (!seen[track]) {
                    seen[track] = true;
                    uniqueTracks.push(track);
                }
            });
            return uniqueTracks.length > 0 ? uniqueTracks : [1];
        })();
        """
        
        def on_tracks_received(result):
            if result and isinstance(result, list) and len(result) > 0:
                # Remove duplicates
                unique_tracks = list(dict.fromkeys(result))
                
                # Pick a random track, avoiding recent combinations
                available_tracks = unique_tracks.copy()
                
                # Filter out tracks that match recent history for this album
                if history and len(unique_tracks) > 1:
                    recent_combos_for_album = [
                        combo[1] for combo in history[-max_history:] 
                        if combo[0] == random_album_url
                    ]
                    if recent_combos_for_album:
                        available_tracks = [t for t in unique_tracks if t not in recent_combos_for_album]
                        if len(available_tracks) == 0:
                            available_tracks = unique_tracks.copy()  # Fallback to all tracks
                
                random_track = random.choice(available_tracks)
                combo = (random_album_url, random_track)
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    self._add_to_super_shuffle_history(combo)
                logger.info(f"Super Shuffle: Selected track {random_track} from random album")
                # Set track to play - autoplay will happen in hide_overlay()
                self._auto_play_track_number = random_track
                self._current_track_number = random_track
            else:
                # Fallback to track 1
                combo = (random_album_url, 1)
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    self._add_to_super_shuffle_history(combo)
                self._auto_play_track_number = 1
                self._current_track_number = 1
            
            # Clear flags after track selection
            self._is_super_shuffle_load = False
            self._super_shuffle_album_url = None
        
        self.web_view.page().runJavaScript(js_code, on_tracks_received)
    
    def _add_to_super_shuffle_history(self, combo):
        """Add a (album_url, track_number) combination to Super Shuffle history"""
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        history = getattr(self.playlist_sidebar, '_super_shuffle_history', [])
        max_history = getattr(self.playlist_sidebar, '_super_shuffle_max_history', 3)
        
        # Add to history
        history.append(combo)
        
        # Keep only last max_history items
        if len(history) > max_history:
            history = history[-max_history:]
        
        self.playlist_sidebar._super_shuffle_history = history
        logger.debug(f"Super Shuffle history updated: {history}")
    
    def _get_single_track_play_js(self):
        """Generate JavaScript code to play single track page"""
        return """
                // For singles, try to find and click the play button directly
                if (isSingleTrackPage) {{
                    console.log('Bandcamp Player: Detected single track page - trying direct play button');
                    var playBtn = player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"], button[aria-label*="play"], button[aria-label*="Play"]');
                    if (playBtn && playBtn.offsetParent !== null) {{
                        console.log('Bandcamp Player: Single track - clicking play button');
                        playBtn.click();
                        // Immediately restore scroll position after click
                        setTimeout(function() {{
                            window.scrollTo(savedScrollLeft, savedScrollTop);
                        }}, 0);
                        
                        // Also try direct audio.play() after a short delay
                        setTimeout(function() {{
                            var audioElement = document.querySelector('audio');
                            if (audioElement) {{
                                console.log('Bandcamp Player: Single track - attempting direct audio.play()');
                                var playPromise = audioElement.play();
                                if (playPromise !== undefined) {{
                                    playPromise.then(function() {{
                                        console.log('Bandcamp Player:  Single track audio.play() succeeded!');
                                    }}).catch(function(error) {{
                                        console.log('Bandcamp Player: Single track audio.play() failed: ' + error);
                                    }});
                                }}
                            }}
                        }}, 500);
                        return;
                    }}
                }}
                """
                
    def _get_album_track_play_js(self, track_number=None):
        """Generate JavaScript code to play specified track (or first playable track) from album tracklist
        
        Args:
            track_number: Optional track number to play (1-based). If None, plays first playable track.
        """
        # If track_number is None, we'll find the first playable track in JS
        # Otherwise, try to play the specified track (will fall back to first playable if not available)
        target_track_num = track_number if track_number is not None else 1
        use_first_playable = (track_number is None)
        logger.debug(f"_get_album_track_play_js: track_number={track_number}, target_track_num={target_track_num}, use_first_playable={use_first_playable}")
        playable_helper = self._get_playable_tracks_helper_js()
        # Convert boolean to JavaScript boolean string
        use_first_playable_js = 'true' if use_first_playable else 'false'
        return playable_helper + f"""
                
                // For albums, try clicking the specified track (or first track) in the tracklist to load it
                console.log('Bandcamp Player: Auto-play starting - looking for track number {target_track_num}, useFirstPlayable should be {use_first_playable_js}');
                var tracklist = document.querySelector('#tracklist');
                if (!tracklist) {{
                    console.log('Bandcamp Player: Tracklist not found yet, waiting...');
                    // Wait for tracklist to appear (retry up to 5 times with 200ms delay)
                    var retries = 0;
                    var maxRetries = 5;
                    var checkTracklist = setInterval(function() {{
                        retries++;
                        tracklist = document.querySelector('#tracklist');
                        if (tracklist || retries >= maxRetries) {{
                            clearInterval(checkTracklist);
                            if (tracklist) {{
                                console.log('Bandcamp Player: Tracklist found after ' + (retries * 200) + 'ms');
                                // Continue with track selection
                                selectAndPlayTrack();
                            }} else {{
                                console.log('Bandcamp Player: Tracklist not found after ' + (maxRetries * 200) + 'ms, using fallback');
                                // Fallback to play button
                                var player = document.querySelector('#player');
                                var playBtn = player ? player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]') : null;
                                if (playBtn && playBtn.offsetParent !== null) {{
                                    playBtn.click();
                                }}
                            }}
                        }}
                    }}, 200);
                }} else {{
                    selectAndPlayTrack();
                }}
                
                function selectAndPlayTrack() {{
                    var tracklist = document.querySelector('#tracklist');
                    if (!tracklist) {{
                        console.log('Bandcamp Player: Tracklist still not available in selectAndPlayTrack');
                        return;
                    }}
                    
                    // Get all playable tracks first
                    var playableTracks = getPlayableTracks();
                    console.log('Bandcamp Player: Found ' + playableTracks.length + ' playable tracks out of all tracks');
                    
                    if (playableTracks.length === 0) {{
                        console.log('Bandcamp Player: No playable tracks found, cannot autoplay');
                        // Log all tracks for debugging
                        var allTracks = tracklist.querySelectorAll('li.track');
                        console.log('Bandcamp Player: Total tracks in tracklist: ' + allTracks.length);
                        for (var i = 0; i < Math.min(allTracks.length, 5); i++) {{
                            var t = allTracks[i];
                            console.log('Bandcamp Player: Track ' + (i+1) + ' - classes: ' + t.className + ', has .info: ' + (t.querySelector('.info') ? 'YES' : 'NO'));
                        }}
                        return;
                    }}
                    
                    var targetTrack = null;
                    var actualTrackNum = null;
                    
                    // If track_number was None (target_track_num is 1 as default), always use first playable track
                    // Otherwise, try to find the requested track first
                    var useFirstPlayable = {use_first_playable_js};
                    console.log('Bandcamp Player: useFirstPlayable = ' + useFirstPlayable + ' (boolean), target_track_num = {target_track_num}');
                    
                    if (!useFirstPlayable) {{
                        // First, try to find the requested track by data-num attribute
                        var requestedTrack = tracklist.querySelector('li.track[data-num="{target_track_num}"]');
                        if (requestedTrack) {{
                            // Check if the requested track is actually playable
                            var isPlayable = false;
                            for (var i = 0; i < playableTracks.length; i++) {{
                                if (playableTracks[i] === requestedTrack) {{
                                    isPlayable = true;
                                    break;
                                }}
                            }}
                            
                            if (isPlayable) {{
                                targetTrack = requestedTrack;
                                actualTrackNum = {target_track_num};
                                console.log('Bandcamp Player: Found playable track with data-num="{target_track_num}"');
                            }} else {{
                                console.log('Bandcamp Player: Track {target_track_num} exists but is not playable, finding first playable track');
                                useFirstPlayable = true;
                            }}
                        }} else {{
                            console.log('Bandcamp Player: Track {target_track_num} not found, finding first playable track');
                            useFirstPlayable = true;
                        }}
                    }}
                    
                    // If requested track not found or not playable, or if track_number was None, find first playable track
                    if (useFirstPlayable || !targetTrack) {{
                        if (playableTracks.length === 0) {{
                            console.log('Bandcamp Player: ERROR - No playable tracks available!');
                            return;
                        }}
                        targetTrack = playableTracks[0];
                        // Get the actual track number from data-num attribute
                        actualTrackNum = targetTrack.getAttribute('data-num');
                        if (actualTrackNum) {{
                            actualTrackNum = parseInt(actualTrackNum);
                        }} else {{
                            // Fallback: find the track's position in the original tracklist
                            var allTracks = tracklist.querySelectorAll('li.track');
                            for (var i = 0; i < allTracks.length; i++) {{
                                if (allTracks[i] === targetTrack) {{
                                    actualTrackNum = i + 1; // 1-based
                                    break;
                                }}
                            }}
                            // If still not found, use index in playable tracks array (1-based)
                            if (!actualTrackNum) {{
                                for (var i = 0; i < playableTracks.length; i++) {{
                                    if (playableTracks[i] === targetTrack) {{
                                        actualTrackNum = i + 1;
                                        break;
                                    }}
                                }}
                            }}
                        }}
                        // Verify the track is actually in the playable tracks array
                        var isActuallyPlayable = false;
                        for (var i = 0; i < playableTracks.length; i++) {{
                            if (playableTracks[i] === targetTrack) {{
                                isActuallyPlayable = true;
                                break;
                            }}
                        }}
                        if (!isActuallyPlayable) {{
                            console.log('Bandcamp Player: ERROR - Selected track is not in playable tracks array!');
                            return;
                        }}
                        if (useFirstPlayable) {{
                            console.log('Bandcamp Player: Using first playable track (track number ' + actualTrackNum + ', index 0 in playable tracks)');
                        }} else {{
                            console.log('Bandcamp Player: Using first playable track (track number ' + actualTrackNum + ') instead of requested track {target_track_num}');
                        }}
                    }}
                    
                    if (targetTrack && playableTracks.length > 0) {{
                        // Double-check that targetTrack is actually playable
                        var isInPlayableArray = false;
                        for (var i = 0; i < playableTracks.length; i++) {{
                            if (playableTracks[i] === targetTrack) {{
                                isInPlayableArray = true;
                                break;
                            }}
                        }}
                        if (!isInPlayableArray) {{
                            console.log('Bandcamp Player: ERROR - Target track is not in playable tracks array, cannot play');
                            return;
                        }}
                        
                        var infoDiv = targetTrack.querySelector('.info');
                        if (!infoDiv) {{
                            console.log('Bandcamp Player: WARNING - Target track has no .info div, trying to click track element directly');
                        }}
                        
                        console.log('Bandcamp Player: Auto-playing track ' + actualTrackNum + ' (requested: {target_track_num}, autoplay restriction disabled)');
                        console.log('Bandcamp Player: Target track classes: ' + targetTrack.className);
                        console.log('Bandcamp Player: Target track has .info div: ' + (infoDiv ? 'YES' : 'NO'));
                        
                        // Step 1: Click target track to load it (scroll is locked, so it won't scroll)
                        // Try multiple methods to ensure the track loads
                        var clicked = false;
                        if (infoDiv) {{
                            console.log('Bandcamp Player: Step 1 - Clicking track ' + actualTrackNum + ' .info div to load track');
                            try {{
                                // Try mouse event first (more reliable)
                                var clickEvent = new MouseEvent('click', {{
                                    bubbles: true,
                                    cancelable: true,
                                    view: window
                                }});
                                infoDiv.dispatchEvent(clickEvent);
                                clicked = true;
                                console.log('Bandcamp Player: Dispatched click event on .info div');
                            }} catch (e) {{
                                console.log('Bandcamp Player: Error dispatching click on .info div: ' + e);
                                try {{
                            infoDiv.click();
                                    clicked = true;
                                    console.log('Bandcamp Player: Called .click() on .info div');
                                }} catch (e2) {{
                                    console.log('Bandcamp Player: Error calling .click() on .info div: ' + e2);
                                }}
                            }}
                        }}
                        
                        // Fallback: try clicking the track element directly
                        if (!clicked) {{
                            console.log('Bandcamp Player: Step 1 (fallback) - Clicking track ' + actualTrackNum + ' element to load track');
                            try {{
                                var clickEvent = new MouseEvent('click', {{
                                    bubbles: true,
                                    cancelable: true,
                                    view: window
                                }});
                                targetTrack.dispatchEvent(clickEvent);
                                clicked = true;
                                console.log('Bandcamp Player: Dispatched click event on track element');
                            }} catch (e) {{
                                console.log('Bandcamp Player: Error dispatching click on track element: ' + e);
                                try {{
                                    targetTrack.click();
                                    clicked = true;
                                    console.log('Bandcamp Player: Called .click() on track element');
                                }} catch (e2) {{
                                    console.log('Bandcamp Player: Error calling .click() on track element: ' + e2);
                                }}
                            }}
                        }}
                        
                        if (!clicked) {{
                            console.log('Bandcamp Player: ERROR - Failed to click track, cannot load');
                            return;
                        }}
                        
                        // Step 2: Wait for track to load, then try to play
                        // Use a longer delay and check multiple times to ensure track loads
                        var playAttempts = 0;
                        var maxPlayAttempts = 5;
                        var playInterval = setInterval(function() {{
                            playAttempts++;
                            var audioElement = document.querySelector('audio');
                            var player = document.querySelector('#player');
                            var playBtn = player ? player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]') : null;
                            
                            if (audioElement && audioElement.src) {{
                                console.log('Bandcamp Player: Step 2 (attempt ' + playAttempts + ') - Audio element found with src, attempting direct audio.play()');
                                clearInterval(playInterval);
                                var playPromise = audioElement.play();
                                if (playPromise !== undefined) {{
                                    playPromise.then(function() {{
                                        console.log('Bandcamp Player:  Direct audio.play() succeeded!');
                                    }}).catch(function(error) {{
                                        console.log('Bandcamp Player: Direct audio.play() failed: ' + error);
                                        // Fallback: try play button
                                        if (playBtn && playBtn.offsetParent !== null) {{
                                            console.log('Bandcamp Player: Fallback - Clicking play button');
                                            playBtn.click();
                                        }}
                                    }});
                                }}
                            }} else if (playBtn && playBtn.offsetParent !== null) {{
                                // Play button is visible, try clicking it
                                console.log('Bandcamp Player: Step 2 (attempt ' + playAttempts + ') - Play button found, clicking it');
                                clearInterval(playInterval);
                                playBtn.click();
                            }} else if (playAttempts >= maxPlayAttempts) {{
                                console.log('Bandcamp Player: Step 2 - Max attempts reached, audio/play button not found');
                                clearInterval(playInterval);
                            }} else {{
                                console.log('Bandcamp Player: Step 2 (attempt ' + playAttempts + ') - Waiting for audio/play button...');
                            }}
                        }}, 500); // Check every 500ms, up to 5 times (2.5 seconds total)
                        
                        return;
                    }} else {{
                        console.log('Bandcamp Player: ERROR - No target track found and no playable tracks available!');
                    }}
                }}
                """
                
    def _get_fallback_play_js(self):
        """Generate JavaScript code for fallback play button click"""
        return """
                // Fallback: if no tracklist found, try play button (for singles or edge cases)
                if (!tracklist || isSingleTrackPage) {{
                    console.log('Bandcamp Player: No tracklist found - trying play button fallback');
                    var playBtn = player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"], button[aria-label*="play"], button[aria-label*="Play"]');
                    if (playBtn && playBtn.offsetParent !== null) {{
                        console.log('Bandcamp Player: Fallback - Clicking play button');
                        playBtn.click();
                        // Scroll restoration will be handled by the interval, which stops when playback starts
                        
                        // Also try direct audio.play() after a short delay
                        setTimeout(function() {{
                            // Ensure scroll position is maintained
                            window.scrollTo(savedScrollLeft, savedScrollTop);
                            var audioElement = document.querySelector('audio');
                            if (audioElement) {{
                                console.log('Bandcamp Player: Fallback - attempting direct audio.play()');
                                var playPromise = audioElement.play();
                                if (playPromise !== undefined) {{
                                    playPromise.then(function() {{
                                        console.log('Bandcamp Player:  Fallback audio.play() succeeded!');
                                    }}).catch(function(error) {{
                                        console.log('Bandcamp Player: Fallback audio.play() failed: ' + error);
                                    }});
                                }}
                            }}
                        }}, 500);
                        return;
                    }}
                }}
                """
    
    def auto_play_first_track(self, track_number=None):
        """Automatically start playing the specified track (or first track) of the loaded album
        
        Args:
            track_number: Optional track number to play (1-based). If None, plays first track.
        """
        if not self.web_view:
            return
        
        # Ensure overlay is hidden before autoplay
        if self.loading_overlay and self.loading_overlay.isVisible():
            self.is_loading = False
            # Restore context menu policy on web view
            if self.web_view and self._original_context_menu_policy is not None:
                self.web_view.setContextMenuPolicy(self._original_context_menu_policy)
                self._original_context_menu_policy = None
            self.loading_overlay.hide()
            self.loading_overlay.setVisible(False)
            self.loading_overlay.setGraphicsEffect(None)
            self.loading_overlay.lower()
            self.loading_overlay.setGeometry(0, 0, 0, 0)
        
        # Build JavaScript code from helper methods
        logger.debug(f"auto_play_first_track: Building JS with track_number={track_number} (type: {type(track_number)})")
        # For regular autoplay (track_number=None), we want to find first playable track
        # For startup autoplay with saved track, we want to try that track first, then fall back
        single_track_js = self._get_single_track_play_js()
        album_track_js = self._get_album_track_play_js(track_number=track_number)
        fallback_js = self._get_fallback_play_js()
        
        js_code = f"""
        (function() {{
            // Save current scroll position to prevent scrolling during autoplay
            var savedScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
            var savedScrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
            
            // Set up scroll prevention IMMEDIATELY (before waiting for player) to catch fast-loading pages
            // Use multiple prevention methods to completely prevent scrolling without jitter
            var originalScrollIntoView = Element.prototype.scrollIntoView;
            var scrollPreventionActive = true;
            
            // Method 1: Override scrollIntoView to prevent browser's automatic scroll-to-view
            Element.prototype.scrollIntoView = function() {{
                if (scrollPreventionActive) {{
                    return; // Prevent scrolling
                }}
                return originalScrollIntoView.apply(this, arguments);
            }};
            
            // Method 2: Prevent scrolling via scroll event listeners (more direct, no jitter)
            var scrollPreventHandler = function(e) {{
                if (scrollPreventionActive) {{
                    window.scrollTo(savedScrollLeft, savedScrollTop);
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }}
            }};
            
            // Add scroll prevention listeners with capture to catch early
            window.addEventListener('scroll', scrollPreventHandler, {{ passive: false, capture: true }});
            document.addEventListener('scroll', scrollPreventHandler, {{ passive: false, capture: true }});
            
            // Method 3: Lock scroll position via CSS (prevents any scrolling)
            var originalOverflow = document.documentElement.style.overflow;
            var originalBodyOverflow = document.body.style.overflow;
            document.documentElement.style.overflow = 'hidden';
            document.body.style.overflow = 'hidden';
            
            // Stop scroll prevention after 1 second - restore everything
            setTimeout(function() {{
                scrollPreventionActive = false;
                // Restore original scrollIntoView
                Element.prototype.scrollIntoView = originalScrollIntoView;
                // Remove scroll event listeners
                window.removeEventListener('scroll', scrollPreventHandler, true);
                document.removeEventListener('scroll', scrollPreventHandler, true);
                // Restore overflow styles
                document.documentElement.style.overflow = originalOverflow;
                document.body.style.overflow = originalBodyOverflow;
                console.log('Bandcamp Player: Scroll prevention stopped after 1 second');
            }}, 1000); // 1 second
            
            // Wait a bit for player to be ready
            setTimeout(function() {{
                var player = document.querySelector('#player');
                if (!player) {{
                    console.log('Bandcamp Player: Player not found for auto-play');
                    return;
                }}
                
                // Cleanup: Ensure body classes are correct (remove mini/micro mode if not active)
                if (document.body) {{
                    var miniModeState = {self.mini_mode_state};
                    if (miniModeState === 0) {{
                        // Not in mini mode - ensure classes are removed
                        document.body.classList.remove('mini-mode', 'micro-mode', 'mini-mode-autohide');
                        // Force reset player positioning
                        var playerStyle = window.getComputedStyle(player);
                        if (playerStyle.position === 'absolute' && !document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {{
                            player.style.position = 'relative';
                            player.style.bottom = 'auto';
                            player.style.left = 'auto';
                            player.style.right = 'auto';
                        }}
                    }}
                }}
                
                // Check if this is a single track page
                var isSingleTrackPage = window.location.href.indexOf('/track/') !== -1;
                
                {single_track_js}
                {album_track_js}
                {fallback_js}
                
                console.log('Bandcamp Player: Could not find first track or play button');
            }}, 300); // Wait 300ms for player to be ready (reduced from 1500ms for faster autoplay)
        }})();
        """
        
        self.run_javascript_safe(js_code)
        
        # Add aggressive cleanup after autoplay - run multiple times to catch any timing issues
        # This ensures the player positioning is reset even if it gets set incorrectly
        def cleanup_player_positioning():
            """Force cleanup of player positioning to prevent dark block"""
            cleanup_js = f"""
            (function() {{
                if (document.body) {{
                    var miniModeState = {self.mini_mode_state};
                    if (miniModeState === 0) {{
                        // Not in mini mode - ensure classes are removed
                        document.body.classList.remove('mini-mode', 'micro-mode', 'mini-mode-autohide');
                        
                        // Force reset player positioning - check multiple times
                        var player = document.querySelector('#player');
                        if (player) {{
                            var playerStyle = window.getComputedStyle(player);
                            if (playerStyle.position === 'absolute' && !document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {{
                                player.style.position = 'relative';
                                player.style.bottom = 'auto';
                                player.style.left = 'auto';
                                player.style.right = 'auto';
                                player.style.zIndex = 'auto';
                                console.log('Bandcamp Player: Cleaned up player positioning');
                            }}
                        }}
                        
                        // CRITICAL: Prevent dark block at bottom by ensuring body/html don't have extra height
                        // This happens when player is temporarily positioned absolutely during autoplay
                        var html = document.documentElement;
                        var body = document.body;
                        
                        // Reset any absolute positioning on player container
                        var playerContainer = document.querySelector('.player-container');
                        if (playerContainer) {{
                            var containerStyle = window.getComputedStyle(playerContainer);
                            if (containerStyle.position === 'absolute' && !document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {{
                                playerContainer.style.position = 'relative';
                                playerContainer.style.bottom = 'auto';
                                console.log('Bandcamp Player: Cleaned up player container positioning');
                            }}
                        }}
                        
                        // Ensure body doesn't have extra padding/margin at bottom that could show dark background
                        // Check if body height is larger than content (which would show #212121 background)
                        var bodyHeight = body.scrollHeight;
                        var windowHeight = window.innerHeight;
                        
                        // If body is taller than window and there's no visible content at bottom, 
                        // it might be showing the dark background - force min-height to content height
                        if (bodyHeight > windowHeight) {{
                            // Check if last visible element is near bottom
                            var lastElement = body.lastElementChild;
                            if (lastElement) {{
                                var lastElementRect = lastElement.getBoundingClientRect();
                                var lastElementBottom = lastElementRect.bottom;
                                
                                // If last element is well above bottom of viewport, there might be extra space
                                if (lastElementBottom < windowHeight - 50) {{
                                    // Force body to fit content exactly - prevent extra dark space
                                    body.style.minHeight = 'auto';
                                    body.style.height = 'auto';
                                    html.style.height = 'auto';
                                    html.style.minHeight = 'auto';
                                    console.log('Bandcamp Player: Fixed body height to prevent dark block');
                                }}
                            }}
                        }}
                        
                        // Additional safeguard: ensure body/html height matches content to prevent dark block
                        // Check if there's a significant gap at bottom (more than 50px of dark space)
                        var scrollHeight = Math.max(body.scrollHeight, html.scrollHeight, document.documentElement.scrollHeight);
                        var clientHeight = Math.max(body.clientHeight, html.clientHeight, window.innerHeight);
                        
                        // If body is taller than viewport and there's extra space, it might show dark background
                        if (scrollHeight > clientHeight + 50) {{
                            // Check the last visible element to see if there's actually content or just empty space
                            var lastVisibleElement = null;
                            var allElements = body.querySelectorAll('*');
                            for (var i = allElements.length - 1; i >= 0; i--) {{
                                var el = allElements[i];
                                var rect = el.getBoundingClientRect();
                                if (rect.height > 0 && rect.width > 0 && rect.bottom > 0) {{
                                    lastVisibleElement = el;
                                    break;
                                }}
                            }}
                            
                            if (lastVisibleElement) {{
                                var lastElementBottom = lastVisibleElement.getBoundingClientRect().bottom;
                                // If last element is well above bottom, there's extra dark space
                                if (lastElementBottom < clientHeight - 50) {{
                                    // Force body to fit content exactly - prevent extra dark space
                                    body.style.minHeight = 'auto';
                                    body.style.height = 'auto';
                                    html.style.minHeight = 'auto';
                                    html.style.height = 'auto';
                                    console.log('Bandcamp Player: Fixed body height to prevent dark block (last element at ' + lastElementBottom + ', viewport ' + clientHeight + ')');
                                }}
                            }}
                        }}
                    }}
                }}
            }})();
            """
            self.web_view.page().runJavaScript(cleanup_js)
        
        # Run cleanup immediately, then after delays to catch any timing issues
        QTimer.singleShot(2000, cleanup_player_positioning)  # After autoplay delay
        QTimer.singleShot(3000, cleanup_player_positioning)  # Extra safety check
        QTimer.singleShot(4000, cleanup_player_positioning)  # Final check
        QTimer.singleShot(5000, cleanup_player_positioning)  # Additional check for slower page updates
    
    def update_mini_mode_button(self):
        """Update mini mode button icon and tooltip to show NEXT mode"""
        if not hasattr(self, 'mini_mode_btn'):
            return
        
        # Disable button if welcome message is visible and playlist is empty
        if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
            playlist = self.playlist_manager.get_playlist()
            if not playlist or len(playlist) == 0:
                self.mini_mode_btn.setEnabled(False)
                self.mini_mode_btn.setToolTip("Load a Bandcamp URL to Enable Mode Switching")
            return
        
        # Show/hide button based on bandcamp mode
        if self.bandcamp_mode:
            self.mini_mode_btn.setEnabled(True)
            self.mini_mode_btn.setVisible(True)
            # Icons for each mode: Regular = fa5s.square, Mini = ph.triangle-fill, Micro = msc.triangle-up
            if HAS_QT_AWESOME:
                state_icons = ['fa5s.square', 'ph.triangle-fill', 'msc.triangle-up']
            else:
                state_icons = ['', '', '']
            state_names = ['Regular', 'Mini', 'Micro']
            
            # Show NEXT mode (current + 1, wrapping around)
            next_state = (self.mini_mode_state + 1) % 3
            current_state_name = state_names[self.mini_mode_state]
            next_state_name = state_names[next_state]
            
            if HAS_QT_AWESOME:
                icon = get_icon(state_icons[next_state], color='#e0e0e0')
                if icon:
                    self.mini_mode_btn.setIcon(icon)
                else:
                    self.mini_mode_btn.setText(state_icons[next_state] if isinstance(state_icons[next_state], str) and len(state_icons[next_state]) == 1 else "")
            else:
                self.mini_mode_btn.setText(state_icons[next_state])
            self.mini_mode_btn.setToolTip(f"{current_state_name} Mode > {next_state_name} Mode")
        else:
            self.mini_mode_btn.setVisible(False)
    
    def update_mini_mode_menu_text(self):
        """Update mini mode menu item text to show NEXT mode"""
        if hasattr(self, 'mini_mode_action'):
            # Disable menu action if welcome message is visible and playlist is empty
            if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
                playlist = self.playlist_manager.get_playlist()
                if not playlist or len(playlist) == 0:
                    self.mini_mode_action.setEnabled(False)
                    return
            
            self.mini_mode_action.setEnabled(True)
            state_names = ['Regular Mode', 'Mini Mode', 'Micro Mode']
            # Show NEXT mode (current + 1, wrapping around)
            next_state = (self.mini_mode_state + 1) % 3
            self.mini_mode_action.setText(state_names[next_state])
        
    
    def toggle_always_on_top(self):
        """Toggle always on top"""
        self.always_on_top = not self.always_on_top
        # Update button state if it exists
        if hasattr(self, 'always_on_top_btn'):
            self.always_on_top_btn.setChecked(self.always_on_top)
            # Update icon color based on checked state (light when off, blue when on)
            if HAS_QT_AWESOME:
                icon_color = '#4a90e2' if self.always_on_top else '#a0a0a0'
                icon = get_icon('thumbtack', color=icon_color)
                if icon:
                    self.always_on_top_btn.setIcon(icon)
        self.apply_always_on_top()
        self.save_settings()
    
    def apply_always_on_top(self):
        """Apply always on top setting"""
        flags = self.windowFlags()
        
        # Preserve frameless mode if enabled
        if self.frameless_mode:
            flags |= Qt.WindowType.FramelessWindowHint
        
        # Apply always on top
        if self.always_on_top:
            flags |= Qt.WindowType.WindowStaysOnTopHint
        else:
            flags &= ~Qt.WindowType.WindowStaysOnTopHint
        
        self.setWindowFlags(flags)
        self.show()  # Required to apply flag changes
    
    def toggle_frameless_mode(self):
        """Toggle frameless window mode"""
        self.frameless_mode = not self.frameless_mode
        self.frameless_action.setChecked(self.frameless_mode)
        self.apply_frameless_mode()
        self.save_settings()
    
    def toggle_transparent_overlay(self):
        """Toggle transparent loading overlay"""
        self.transparent_overlay = not self.transparent_overlay
        self.transparent_overlay_action.setChecked(self.transparent_overlay)
        self.save_settings()
        # Apply transparency immediately if overlay is visible
        if self.loading_overlay and self.loading_overlay.isVisible():
            self.apply_overlay_transparency()
    
    def apply_overlay_transparency(self):
        """Apply transparency to loading overlay based on setting"""
        if not self.loading_overlay:
            return
        
        # Use QGraphicsOpacityEffect for proper transparency
        current_effect = self.loading_overlay.graphicsEffect()
        
        if self.transparent_overlay:
            # Make overlay semi-transparent (70% opacity)
            if not current_effect or not isinstance(current_effect, QGraphicsOpacityEffect):
                # Create new effect if one doesn't exist
                overlay_effect = QGraphicsOpacityEffect(self.loading_overlay)
                self.loading_overlay.setGraphicsEffect(overlay_effect)
                overlay_effect.setOpacity(0.7)
            else:
                # Update existing effect
                current_effect.setOpacity(0.7)
        else:
            # Make overlay fully opaque
            if not current_effect or not isinstance(current_effect, QGraphicsOpacityEffect):
                # Create new effect if one doesn't exist
                overlay_effect = QGraphicsOpacityEffect(self.loading_overlay)
                self.loading_overlay.setGraphicsEffect(overlay_effect)
                overlay_effect.setOpacity(1.0)
            else:
                # Update existing effect
                current_effect.setOpacity(1.0)
    
    def apply_frameless_mode(self):
        """Apply frameless window mode"""
        flags = self.windowFlags()
        
        if self.frameless_mode:
            # Remove native title bar
            flags |= Qt.WindowType.FramelessWindowHint
            # Keep always on top if enabled
            if self.always_on_top:
                flags |= Qt.WindowType.WindowStaysOnTopHint
            self.setWindowFlags(flags)
            # Enable rounded corners
            self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
            self.create_custom_title_bar()
            # Create bottom resize handle
            self.create_bottom_resize_handle()
            # Apply rounded corners after window is shown
            QTimer.singleShot(50, self.apply_rounded_corners)
        else:
            # Restore native title bar
            flags &= ~Qt.WindowType.FramelessWindowHint
            # Disable rounded corners (translucent background)
            self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, False)
            # Keep always on top if enabled
            if self.always_on_top:
                flags |= Qt.WindowType.WindowStaysOnTopHint
            self.setWindowFlags(flags)
            self.remove_custom_title_bar()
            # Remove bottom resize handle
            self.remove_bottom_resize_handle()
            # Clear mask
            self.clearMask()
        
        self.show()  # Required to apply flag changes
    
    def apply_rounded_corners(self):
        """Apply rounded corners to the window"""
        if not self.frameless_mode:
            return
        
        radius = 10  # Corner radius in pixels
        size = self.size()
        
        # Create a path with rounded corners
        path = QPainterPath()
        path.addRoundedRect(0, 0, size.width(), size.height(), radius, radius)
        
        # Convert path to polygon and create region
        polygon = path.toFillPolygon()
        rounded_region = QRegion(polygon.toPolygon())
        
        self.setMask(rounded_region)
    
    def update_loading_overlay_geometry(self):
        """Update loading overlay geometry to cover entire web view area (playlist will sit on top)"""
        if not self.loading_overlay:
            return
        
        # Only update geometry if overlay should be visible (is loading)
        # If not loading, ensure overlay is hidden and reset geometry
        if not self.is_loading:
            if self.loading_overlay.isVisible():
                self.loading_overlay.hide()
                self.loading_overlay.setVisible(False)
            # Always reset geometry when not loading to prevent taking up space
            self.loading_overlay.setGeometry(0, 0, 0, 0)
            return
        
        # Calculate top offset (title bar + controls bar)
        top_offset = 0
        
        # Add title bar height if it exists (frameless mode)
        if self.title_bar and self.title_bar.isVisible():
            top_offset += self.title_bar.height()
        
        # Add controls bar height only if it's in the layout (not in overlay mode)
        if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
            # Only add height if controls bar is in layout (not overlay mode)
            if hasattr(self, 'controls_bar_in_layout') and self.controls_bar_in_layout:
                top_offset += self.controls_bar_widget.height()
            # If autohide is enabled and controls bar is overlay, don't add to offset
            # (it will overlay the content, so overlay should cover everything)
        
        # Calculate overlay geometry - cover full height (playlist will be on top with higher z-order)
        overlay_x = 0
        overlay_y = top_offset
        overlay_width = self.width()
        overlay_height = self.height() - top_offset  # Full height, no bottom offset
        
        # Ensure minimum height
        if overlay_height < 0:
            overlay_height = 0
        
        self.loading_overlay.setGeometry(overlay_x, overlay_y, overlay_width, overlay_height)
    
    def resizeEvent(self, event):
        """Handle window resize to update rounded corners and overlay"""
        # In micro or mini mode, prevent user-initiated resizing but allow programmatic resizes
        if self.mini_mode_state == 2 or self.mini_mode_state == 1:
            # Check if this is a programmatic resize (from resize_to_mini_mode or resize_to_micro_mode)
            is_programmatic = (
                (hasattr(self, '_micro_mode_resizing') and self._micro_mode_resizing) or
                (hasattr(self, '_mini_mode_resizing') and self._mini_mode_resizing)
            )
            
            if not is_programmatic:
                # User tried to resize - restore fixed size
                current_size = self.size()
                if event.size() != current_size:
                    self.setGeometry(self.x(), self.y(), current_size.width(), current_size.height())
                    event.ignore()
                    return
        
        # Constrain width to 260px (fixed width) - only allow height changes
        new_size = event.size()
        if new_size.width() != 260:
            # Force width to 260, keep the requested height
            new_size.setWidth(260)
            # Use setGeometry to apply the constrained size
            self.setGeometry(self.x(), self.y(), 260, new_size.height())
        
        # In mini mode, enforce fixed height (cover art 260px + title bar + playlist if visible)
        if self.mini_mode_state == 1:
            # Check if this is a programmatic resize from _resize_mini_mode_for_playlist
            is_playlist_resize = (
                hasattr(self, '_mini_mode_playlist_resizing') and self._mini_mode_playlist_resizing
            )
            
            title_bar_height = 0
            if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                title_bar_height = self.title_bar.height()
            
            # Calculate expected height including playlist if visible
            base_height = 260 + title_bar_height
            
            # Add playlist height if visible
            playlist_height = 0
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible():
                if hasattr(self, 'playlist_container') and self.playlist_container:
                    playlist_height = self.playlist_container.height()
                    if playlist_height == 0:
                        playlist_height = self.playlist_container.sizeHint().height()
                    if playlist_height == 0 and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        playlist_height = self.playlist_sidebar.height()
                        if playlist_height == 0:
                            playlist_height = self.playlist_sidebar.sizeHint().height()
                        # Add title bar height if playlist is not minimized
                        is_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
                        if not is_minimized:
                            if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                                playlist_title_height = self.playlist_sidebar.title_bar_widget.height()
                                if playlist_title_height == 0:
                                    playlist_title_height = self.playlist_sidebar.title_bar_widget.sizeHint().height()
                                playlist_height += playlist_title_height
                        else:
                            # If minimized, just use title bar height
                            if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                                playlist_title_height = self.playlist_sidebar.title_bar_widget.height()
                                if playlist_title_height == 0:
                                    playlist_title_height = self.playlist_sidebar.title_bar_widget.sizeHint().height()
                                playlist_height = playlist_title_height
            
            expected_height = base_height + playlist_height
            
            # Only enforce height if this is NOT a programmatic playlist resize
            # (programmatic playlist resize already has the correct height)
            if not is_playlist_resize and new_size.height() != expected_height:
                # Force height to expected value
                self.setGeometry(self.x(), self.y(), 260, expected_height)
                return  # Don't process further if we corrected the height
        
        super().resizeEvent(event)
        
        # Update image viewer button visibility (immediate) and position (delayed) on resize
        if hasattr(self, 'image_viewer_btn') and self.image_viewer_btn:
            # Update visibility immediately for quick response
            self.update_image_viewer_btn_visibility()
            # Update position with slight delay to avoid layout interference
            QTimer.singleShot(50, self.update_image_viewer_btn_position)
        # Update autohide trigger button position on resize
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
            self.update_autohide_trigger_position()
        # Update playlist quick button position on resize
        if hasattr(self, 'playlist_quick_btn') and self.playlist_quick_btn and self.playlist_quick_btn.isVisible():
            self.update_playlist_quick_btn_position()
        
        if self.frameless_mode:
            # Update rounded corners after resize
            QTimer.singleShot(10, self.apply_rounded_corners)
        # Update overlay geometry only if it should be visible (is loading)
        if self.loading_overlay:
            if self.is_loading and self.loading_overlay.isVisible():
                self.update_loading_overlay_geometry()
                self.loading_overlay.raise_()
            elif not self.is_loading:
                # Ensure overlay is hidden when not loading and reset geometry
                if self.loading_overlay.isVisible():
                    self.loading_overlay.hide()
                    self.loading_overlay.setVisible(False)
                # Always reset geometry when not loading to prevent taking up space
                self.loading_overlay.setGeometry(0, 0, 0, 0)
        
        # Update bottom resize handle position if it exists
        if hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle:
            self.update_bottom_resize_handle_position()
        
        # Update address bar hover area position if it exists
        if hasattr(self, 'update_hover_area_position'):
            self.update_hover_area_position()
        
        # Update address bar overlay position if in overlay mode
        if self.autohide_address_bar and hasattr(self, 'update_address_bar_overlay_position'):
            self.update_address_bar_overlay_position()
        
        # Update regular player widget geometry to fill central widget (if it's absolutely positioned)
        if hasattr(self, 'regular_player_widget') and self.regular_player_widget and self.regular_player_widget.isVisible():
            central_widget = self.centralWidget()
            if central_widget:
                rect = central_widget.rect()
                # Account for title bar if it exists and is visible
                top_offset = 0
                if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                    top_offset = self.title_bar.height()
                # Position player widget below title bar
                self.regular_player_widget.setGeometry(0, top_offset, rect.width(), rect.height() - top_offset)
                # Update player section position (floats above playlist when needed)
                self._update_player_section_position()
                # Ensure z-order: title bar > player section > playlist > player widget
                if hasattr(self, 'title_bar') and self.title_bar:
                    self.title_bar.raise_()
                if hasattr(self, 'regular_player_widget') and hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                    self.regular_player_widget.player_section.raise_()
                if hasattr(self, 'playlist_container') and self.playlist_container:
                    self.playlist_container.raise_()
        
        # Update regular player widget geometry if in mini mode (mini mode reuses regular widget)
        if self.mini_mode_state == 1:
            if hasattr(self, 'regular_player_widget') and self.regular_player_widget and self.regular_player_widget.isVisible():
                central_widget = self.centralWidget()
                if central_widget:
                    rect = central_widget.rect()
                    top_offset = 0
                    if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                        top_offset = self.title_bar.height()
                    # In mini mode, widget height is 260px (cover art only)
                    widget_height = 260
                    self.regular_player_widget.setGeometry(0, top_offset, rect.width(), widget_height)
                    # Position cover art to fill widget in mini mode
                    if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                        cover_art = self.regular_player_widget.cover_art_label
                        cover_art.setGeometry(0, 0, rect.width(), widget_height)
                    # Position player section at bottom of cover art - ALWAYS at bottom, never center
                    if hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                        player_section = self.regular_player_widget.player_section
                        player_height = player_section.height()
                        # Calculate bottom position
                        bottom_y = widget_height - player_height
                        # Ensure it's at the bottom, not centered
                        player_section.setGeometry(0, bottom_y, rect.width(), player_height)
                        player_section.raise_()
                        # Store bottom position to prevent center snap
                        if hasattr(player_section, '_mini_mode_bottom_position'):
                            player_section._mini_mode_bottom_position = bottom_y
                    # Position playlist container at bottom in mini mode (opens upward)
                    if hasattr(self, 'playlist_container') and self.playlist_container:
                        playlist_container = self.playlist_container
                        if playlist_container.isVisible():
                            # Get playlist height
                            playlist_height = playlist_container.height()
                            if playlist_height == 0:
                                # Get preferred height if not set
                                playlist_height = playlist_container.sizeHint().height()
                            # Position at bottom of central widget
                            playlist_y = rect.height() - playlist_height
                            playlist_container.setGeometry(0, playlist_y, rect.width(), playlist_height)
                        playlist_container.raise_()
                    
                    # Ensure z-order: title bar > player section > playlist > player widget
                    if hasattr(self, 'title_bar') and self.title_bar:
                        self.title_bar.raise_()
                    if hasattr(self, 'regular_player_widget') and hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                        self.regular_player_widget.player_section.raise_()
        
        # Update micro player widget geometry if in micro mode
        if self.mini_mode_state == 2:
            if hasattr(self, 'micro_player_widget') and self.micro_player_widget and self.micro_player_widget.isVisible():
                central_widget = self.centralWidget()
                if central_widget:
                    rect = central_widget.rect()
                    top_offset = 0
                    if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                        top_offset = self.title_bar.height()
                    self.micro_player_widget.setGeometry(0, top_offset, rect.width(), rect.height() - top_offset)
                    # Ensure z-order: title bar > micro widget
                    if hasattr(self, 'title_bar') and self.title_bar:
                        self.title_bar.raise_()
    
    def _update_player_section_position(self):
        """Update player section z-order - raises it above playlist when playlist would cover it (Option 3)"""
        print(f"[DEBUG] _update_player_section_position called")
        
        # Skip in mini/micro mode - player section is positioned differently
        if self.mini_mode_state in (1, 2):
            print(f"[DEBUG] Skipping _update_player_section_position in mini/micro mode (state={self.mini_mode_state})")
            # CRITICAL: In micro mode, ensure regular player widget stays hidden
            if self.mini_mode_state == 2:
                if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                    if self.regular_player_widget.isVisible():
                        print(f"[MICRO MODE DEBUG] _update_player_section_position: WARNING - regular_player_widget is visible! Hiding it...")
                        self.regular_player_widget.hide()
            return
        
        if not hasattr(self, 'regular_player_widget') or not self.regular_player_widget:
            print(f"[DEBUG] No regular_player_widget")
            return
        
        if not hasattr(self.regular_player_widget, 'player_section') or not self.regular_player_widget.player_section:
            print(f"[DEBUG] No player_section")
            return
        
        player_section = self.regular_player_widget.player_section
        central_widget = self.centralWidget()
        if not central_widget:
            print(f"[DEBUG] No central_widget")
            return
        
        # Get title bar height
        top_offset = 0
        if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
            top_offset = self.title_bar.height()
        
        # Player section position in layout (below cover art at 260px)
        player_section_y_in_layout = top_offset + 260  # Cover art height
        player_section_height = 129  # Updated to account for 15px padding (was 105px with smaller padding)
        player_section_bottom_in_layout = player_section_y_in_layout + player_section_height
        
        # Initialize playlist_covering - will be set based on state checks
        playlist_covering = False
        playlist_top = None
        
        # Store whether player section is currently floating (moved to central widget)
        is_currently_floating = (player_section.parent() == central_widget)
        print(f"[DEBUG] is_currently_floating: {is_currently_floating}, parent: {player_section.parent()}")
        
        # Explicit checks for states that should reset the player - check these FIRST
        playlist_is_minimized = False
        playlist_is_hidden = False
        
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            # Check if minimized - use getattr with default False for safety
            playlist_is_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
            # Check if hidden
            playlist_is_hidden = not self.playlist_sidebar.isVisible()
            print(f"[DEBUG] playlist_is_minimized: {playlist_is_minimized}, playlist_is_hidden: {playlist_is_hidden}")
        else:
            print(f"[DEBUG] No playlist_sidebar or it's None")
        
        # If playlist is minimized or hidden, force reset - it can't cover the player
        # This must be checked BEFORE checking if it covers, and must force reset
        # ALWAYS reset when minimized/hidden, regardless of current floating state
        if playlist_is_minimized or playlist_is_hidden:
            print(f"[DEBUG] Playlist is minimized or hidden - FORCING RESET")
            regular_widget = self.regular_player_widget
            if regular_widget and regular_widget.layout():
                layout = regular_widget.layout()
                print(f"[DEBUG] Resetting player section - regular_widget: {regular_widget}, layout: {layout}")
                
                # If currently floating, remove from central widget first
                if is_currently_floating:
                    print(f"[DEBUG] Removing from central widget (was floating)")
                    player_section.setParent(None)  # Temporarily remove parent
                
                # Set parent to regular widget (in case it wasn't already)
                if player_section.parent() != regular_widget:
                    print(f"[DEBUG] Setting parent to regular_widget (was: {player_section.parent()})")
                    player_section.setParent(regular_widget)
                
                # Ensure it's in the layout at the correct position
                if layout:
                    # Remove it if it's somehow still in the layout
                    layout.removeWidget(player_section)
                    # Now add it back at index 1 (after cover art)
                    layout.insertWidget(1, player_section, 0)
                    print(f"[DEBUG] Added player_section back to layout at index 1")
                
                player_section.show()
                
                # Force layout update to ensure proper positioning
                layout.invalidate()
                regular_widget.updateGeometry()
                QApplication.processEvents()
                print(f"[DEBUG] Layout invalidated and geometry updated")
                
                # Multiple delayed updates to ensure layout settles
                QTimer.singleShot(10, lambda: layout.invalidate() if regular_widget and layout else None)
                QTimer.singleShot(50, lambda: regular_widget.updateGeometry() if regular_widget else None)
                QTimer.singleShot(100, lambda: layout.activate() if regular_widget and layout else None)
            else:
                print(f"[DEBUG] ERROR: No regular_widget or layout! regular_widget: {regular_widget}")
            
            # Ensure z-order is correct before returning
            if hasattr(self, 'title_bar') and self.title_bar:
                self.title_bar.raise_()
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.raise_()
            # Early return - don't check covering logic
            print(f"[DEBUG] Returning early after reset")
            return
        
        # Only check if playlist is visible, expanded (not minimized), and would cover the player
        playlist_is_visible_and_expanded = (not playlist_is_minimized and not playlist_is_hidden and
                                           hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and
                                           self.playlist_sidebar.isVisible())
        print(f"[DEBUG] playlist_is_visible_and_expanded: {playlist_is_visible_and_expanded}")
        
        if (playlist_is_visible_and_expanded and
              hasattr(self, 'playlist_container') and self.playlist_container and 
              self.playlist_container.isVisible()):
            
            # Get playlist container position (relative to central widget)
            playlist_y = self.playlist_container.y()
            playlist_top = playlist_y
            print(f"[DEBUG] Playlist container visible at y={playlist_y}, player_section_bottom={player_section_bottom_in_layout}")
            
            # Check if playlist would cover the player section (in its layout position)
            if playlist_top < player_section_bottom_in_layout:
                playlist_covering = True
                print(f"[DEBUG] Playlist WOULD cover player section - setting playlist_covering=True")
            else:
                print(f"[DEBUG] Playlist would NOT cover player section")
        else:
            print(f"[DEBUG] Playlist not visible/expanded or container not visible")
        
        print(f"[DEBUG] Final playlist_covering: {playlist_covering}")
        if playlist_covering:
            # Detach player section and attach it to the top of the playlist (moves with playlist)
            if not is_currently_floating:
                # Remove from layout
                regular_widget = self.regular_player_widget
                if regular_widget and regular_widget.layout():
                    regular_widget.layout().removeWidget(player_section)
                
                # Make it a child of central widget so it can float
                player_section.setParent(central_widget)
                player_section.show()
            
            # Position player section attached to the top of the playlist
            # It will move with the playlist as it's resized
            # playlist_top was already set above in the covering check
            if playlist_top is not None:
                player_section_y = playlist_top - player_section_height  # Just above playlist
            else:
                # Fallback: use original position (shouldn't happen, but safety check)
                player_section_y = player_section_y_in_layout
            
            # Ensure it doesn't go above the window (but can cover cover art)
            min_y = top_offset  # Can go to top of central widget (covers cover art)
            if player_section_y < min_y:
                player_section_y = min_y
            
            # Position it at the same x as the playlist (full width)
            rect = central_widget.rect()
            player_section.setGeometry(0, player_section_y, rect.width(), player_section_height)
            
            # Raise it above playlist so it stays visible
            player_section.raise_()
        else:
            # Put player section back in layout if it was floating
            # This happens when playlist is collapsed (minimized), hidden, or moved away
            if is_currently_floating:
                regular_widget = self.regular_player_widget
                if regular_widget and regular_widget.layout():
                    # Remove from central widget first
                    player_section.setParent(None)  # Temporarily remove parent
                    # Now set parent to regular widget
                    player_section.setParent(regular_widget)
                    # Add back to layout (at index 1, after cover art)
                    # First check if it's already in the layout
                    layout = regular_widget.layout()
                    if layout:
                        # Remove it if it's somehow still in the layout
                        layout.removeWidget(player_section)
                        # Now add it back
                        layout.insertWidget(1, player_section, 0)
                    player_section.show()
                    # Force layout update to ensure proper positioning
                    if layout:
                        layout.invalidate()
                    regular_widget.updateGeometry()
                    # Use multiple delayed updates to ensure layout settles properly
                    QApplication.processEvents()
                    QTimer.singleShot(10, lambda: layout.invalidate() if regular_widget and layout else None)
                    QTimer.singleShot(50, lambda: regular_widget.updateGeometry() if regular_widget else None)
                    QTimer.singleShot(100, lambda: layout.activate() if regular_widget and layout else None)
        
        # Ensure z-order: title bar > player section (when floating) > playlist > player widget
        if hasattr(self, 'title_bar') and self.title_bar:
            self.title_bar.raise_()
        if playlist_covering and is_currently_floating:
            player_section.raise_()
        if hasattr(self, 'playlist_container') and self.playlist_container:
            self.playlist_container.raise_()
    
    def _truncate_title_text(self, text, max_width=118):
        """Truncate title text to fit within max_width pixels with ellipsis."""
        if not text:
            return text
        
        # If window_title_label doesn't exist yet, use a default font
        if hasattr(self, 'window_title_label') and self.window_title_label:
            font = self.window_title_label.font()
        else:
            # Use default font if label doesn't exist yet
            font = QFont()
            font.setPointSize(11)
        
        font_metrics = QFontMetrics(font)
        
        # Truncate text if it exceeds max_width
        elided_text = font_metrics.elidedText(str(text), Qt.TextElideMode.ElideRight, max_width)
        return elided_text
    
    def create_custom_title_bar(self):
        """Create custom title bar for frameless mode"""
        if self.title_bar:
            return  # Already exists
        
        # Create title bar widget
        self.title_bar = QWidget(self)
        self.title_bar.setFixedHeight(30)
        self.title_bar.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border-bottom: 1px solid #1a1a1a;
            }
        """)
        
        title_layout = QHBoxLayout(self.title_bar)
        title_layout.setContentsMargins(8, 0, 0, 0)
        title_layout.setSpacing(0)
        
        # Icon
        if self.app_icon:
            icon_label = QLabel()
            icon_label.setPixmap(self.app_icon.pixmap(16, 16))
            title_layout.addWidget(icon_label)
            title_layout.addSpacing(8)
        
        # Title
        current_title = self.windowTitle() or "Bandcamp Player"
        self.window_title_label = QLabel(self._truncate_title_text(current_title))
        self.window_title_label.setStyleSheet("""
            QLabel {
                color: #e0e0e0;
                font-size: 11px;
            }
        """)
        # Set maximum width and enable text truncation
        self.window_title_label.setMaximumWidth(118)
        self.window_title_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Preferred)
        # Enable word wrap and elide text that exceeds width
        self.window_title_label.setWordWrap(False)
        title_layout.addWidget(self.window_title_label)
        
        title_layout.addStretch()
        
        # Window controls
        controls_layout = QHBoxLayout()
        controls_layout.setContentsMargins(0, 0, 0, 0)
        controls_layout.setSpacing(0)
        
        # Always on Top button (Pin) - first button
        # Check if button already exists and reuse it, otherwise create new
        if not hasattr(self, 'always_on_top_btn') or not self.always_on_top_btn:
            self.always_on_top_btn = QPushButton()
        else:
            # Button already exists - remove from any previous parent/layout before adding to title bar
            if self.always_on_top_btn.parent():
                old_parent = self.always_on_top_btn.parent()
                if hasattr(old_parent, 'layout'):
                    layout = old_parent.layout()
                    if layout:
                        layout.removeWidget(self.always_on_top_btn)
        icon_color = '#4a90e2' if self.always_on_top else '#a0a0a0'
        if HAS_QT_AWESOME:
            icon = get_icon('thumbtack', color=icon_color)
            if icon:
                self.always_on_top_btn.setIcon(icon)
            else:
                self.always_on_top_btn.setText("")
        else:
            self.always_on_top_btn.setText("")
        self.always_on_top_btn.setFixedSize(22, 22)  # Match other titlebar buttons
        self.always_on_top_btn.setToolTip("Always on Top")
        self.always_on_top_btn.setCheckable(True)
        self.always_on_top_btn.setChecked(self.always_on_top)
        self.always_on_top_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #a0a0a0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """)
        self.always_on_top_btn.clicked.connect(self.toggle_always_on_top)
        controls_layout.addWidget(self.always_on_top_btn)
        
        # Minimize button (actual minimize, not nano mode)
        minimize_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('minus', color='#e0e0e0')
            if icon:
                minimize_btn.setIcon(icon)
            else:
                minimize_btn.setText("")
        else:
            minimize_btn.setText("")
        minimize_btn.setFixedSize(22, 22)  # Match playlist buttons
        minimize_btn.setToolTip("Minimize")
        minimize_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        def on_minimize_clicked():
            self._minimize_button_clicked = True
            self.showMinimized()
        minimize_btn.clicked.connect(on_minimize_clicked)
        controls_layout.addWidget(minimize_btn)
        
        # Nano mode button (hide main window and show nano player)
        nano_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.chevron-down', color='#e0e0e0')
            if icon:
                nano_btn.setIcon(icon)
            else:
                nano_btn.setText("")
        else:
            nano_btn.setText("")
        nano_btn.setFixedSize(22, 22)  # Match playlist buttons
        nano_btn.setToolTip("Nano Mode")
        nano_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        nano_btn.clicked.connect(self._enter_nano_mode)
        controls_layout.addWidget(nano_btn)
        
        # Mini Mode button (between minimize and close)
        if hasattr(self, 'mini_mode_btn') and self.mini_mode_btn:
            # Remove from any previous parent/layout before adding to title bar
            if self.mini_mode_btn.parent():
                old_parent = self.mini_mode_btn.parent()
                if hasattr(old_parent, 'layout'):
                    layout = old_parent.layout()
                    if layout:
                        layout.removeWidget(self.mini_mode_btn)
            # Ensure correct size and style for title bar
            self.mini_mode_btn.setFixedSize(22, 22)  # Match playlist buttons
            # Update style to match
            self.mini_mode_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            controls_layout.addWidget(self.mini_mode_btn)
        else:
            # Create mini mode button if it doesn't exist yet
            self.mini_mode_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('square', color='#e0e0e0')
                if icon:
                    self.mini_mode_btn.setIcon(icon)
                else:
                    self.mini_mode_btn.setText("")  # Default icon (will be updated by update_mini_mode_button)
            else:
                self.mini_mode_btn.setText("")  # Default icon (will be updated by update_mini_mode_button)
            self.mini_mode_btn.setFixedSize(22, 22)  # Match playlist buttons
            self.mini_mode_btn.setToolTip("Mini Mode")
            self.mini_mode_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            self.mini_mode_btn.clicked.connect(self.toggle_mini_mode)
            controls_layout.addWidget(self.mini_mode_btn)
        
        # Update button state after adding to title bar
        if hasattr(self, 'update_mini_mode_button'):
            self.update_mini_mode_button()
        
        # Close button
        close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_btn.setIcon(icon)
            else:
                close_btn.setText("")
        else:
            close_btn.setText("")
        close_btn.setFixedSize(22, 22)  # Match playlist buttons
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #e81123;
                color: white;
            }
        """)
        close_btn.clicked.connect(self.close)
        controls_layout.addWidget(close_btn)
        
        title_layout.addLayout(controls_layout)
        
        # Add title bar to layout (at the top)
        layout = self.centralWidget().layout()
        layout.insertWidget(0, self.title_bar)
        
        # Enable window dragging on title bar
        self.title_bar.mousePressEvent = self.title_bar_mouse_press
        self.title_bar.mouseMoveEvent = self.title_bar_mouse_move
        self.title_bar.mouseReleaseEvent = self.title_bar_mouse_release
        
        # Update bottom resize handle if it exists
        if hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle:
            QTimer.singleShot(50, self.update_bottom_resize_handle_position)
    
    def remove_custom_title_bar(self):
        """Remove custom title bar"""
        if self.title_bar:
            layout = self.centralWidget().layout()
            layout.removeWidget(self.title_bar)
            self.title_bar.deleteLater()
            self.title_bar = None
    
    def mousePressEvent(self, event):
        """Handle mouse press events - hide address bar if clicking outside it when autohide is enabled"""
        super().mousePressEvent(event)
        
        # Debug: Right-click to inspect widget at position (Ctrl+Right-click for more details)
        # Only if debug methods exist (they may not be implemented)
        if event.button() == Qt.MouseButton.RightButton:
            modifiers = event.modifiers()
            if modifiers & Qt.KeyboardModifier.ShiftModifier:
                # Inspect HTML element at position (since dark block shows HTML context menu)
                if hasattr(self, 'inspect_html_element_at_position'):
                    self.inspect_html_element_at_position(event.position().toPoint())
                    return  # Don't process further if inspecting
            elif modifiers & Qt.KeyboardModifier.ControlModifier:
                if hasattr(self, 'inspect_widget_at_position'):
                    self.inspect_widget_at_position(event.globalPosition().toPoint())
                    return  # Don't process further if inspecting
            else:
                # Simple right-click: just show basic info
                if hasattr(self, 'quick_inspect_widget'):
                    self.quick_inspect_widget(event.position().toPoint())
                    return  # Don't process further if inspecting
                # If debug methods don't exist, allow normal right-click behavior to proceed
        
        # Don't handle address bar hiding if we're dragging the playlist resize handle
        if hasattr(self, 'playlist_start_resize_y') and self.playlist_start_resize_y is not None:
            return
        
        if self.autohide_address_bar and hasattr(self, 'controls_bar_widget'):
            # Check if click is outside the address bar
            click_pos = event.pos()
            
            # In mini/micro mode, only show address bar when clicking on the trigger button
            # Don't show it when clicking anywhere else at the top
            is_mini_or_micro = hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2)
            
            # Check if click is on the trigger icon (which should show the address bar)
            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
                if self.autohide_trigger_btn.geometry().contains(click_pos):
                    # Click is on trigger icon, show address bar
                    self.show_address_bar_immediate()
                    return
            
            # Check if click is within address bar geometry
            if self.controls_bar_widget.geometry().contains(click_pos):
                # Click is on address bar
                # In all modes (including regular), don't show on click - only show on trigger button hover/click
                # Schedule hide instead
                self.schedule_address_bar_hide()
            else:
                # Click is outside address bar
                # Schedule hide
                self.schedule_address_bar_hide()
    
    def moveEvent(self, event):
        """Handle window move event - update linked detached playlist window if link mode is enabled, and handle snapping."""
        super().moveEvent(event)
        if self.playlist_detached and self.playlist_window_linked:
            self._handle_main_window_movement_for_linking(event)
        
        # Check for automatic docking at screen edges (similar to nano player)
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            self._check_windows_dock_to_screen_edge()
        
        # Handle snapping main window to detached playlist window (only while dragging)
        # Only snap if link mode is NOT enabled and we're dragging
        if (
            self.playlist_detached
            and hasattr(self, 'detached_playlist_window')
            and self.detached_playlist_window
            and not self.playlist_window_linked
            and not self._moving_main_window_programmatically
            and self._is_dragging_main_window
        ):
            # Snap immediately while dragging (more forceful, like nano player)
            if self._handle_main_window_snapping():
                self._snapped_during_drag = True
    
    def showEvent(self, event):
        """Handle window show event"""
        super().showEvent(event)
        # Update bottom resize handle position when window is shown
        if self.frameless_mode and hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle:
            QTimer.singleShot(50, self.update_bottom_resize_handle_position)
    
    def title_bar_mouse_press(self, event):
        """Handle mouse press on title bar for window dragging"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
            self._is_dragging_main_window = True
            self._snapped_during_drag = False
            event.accept()
    
    def title_bar_mouse_move(self, event):
        """Handle mouse move on title bar for window dragging"""
        if event.buttons() == Qt.MouseButton.LeftButton and hasattr(self, 'drag_position'):
            self.move(event.globalPosition().toPoint() - self.drag_position)
            # Only enable snapping while dragging main window (and not linked)
            if self.playlist_detached and not self.playlist_window_linked:
                # Check if snapping occurred
                if self._handle_main_window_snapping():
                    self._snapped_during_drag = True
            event.accept()
    
    def title_bar_mouse_release(self, event):
        """Handle mouse release on title bar"""
        if event.button() == Qt.MouseButton.LeftButton:
            self._is_dragging_main_window = False
            # If windows snapped during drag, link them now (on release) - but only if still close
            if self._snapped_during_drag and self.playlist_detached:
                # Check if windows are still close (within snap threshold)
                main_rect = self.geometry()
                detached_rect = self.detached_playlist_window.geometry()
                
                main_left = main_rect.x()
                main_right = main_rect.x() + main_rect.width()
                main_top = main_rect.y()
                main_bottom = main_rect.y() + main_rect.height()
                
                detached_left = detached_rect.x()
                detached_right = detached_rect.x() + detached_rect.width()
                detached_top = detached_rect.y()
                detached_bottom = detached_rect.y() + detached_rect.height()
                
                # Check if windows are within snap threshold
                h_dist = 0
                v_dist = 0
                if detached_right < main_left:
                    h_dist = main_left - detached_right
                elif detached_left > main_right:
                    h_dist = detached_left - main_right
                
                if detached_bottom < main_top:
                    v_dist = main_top - detached_bottom
                elif detached_top > main_bottom:
                    v_dist = detached_top - main_bottom
                
                total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5
                if total_dist <= self._snap_threshold:
                    # Windows are still close - link them
                    self._toggle_playlist_window_linking(True)
                    self._windows_docked = True
                    # Update link offset
                    main_x = self.x()
                    main_y = self.y()
                    detached_x = self.detached_playlist_window.x()
                    detached_y = self.detached_playlist_window.y()
                    self._playlist_window_link_offset = (detached_x - main_x, detached_y - main_y)
            self._snapped_during_drag = False
            if hasattr(self, 'drag_position'):
                self.drag_position = None
    
    def create_bottom_resize_handle(self):
        """Create bottom resize handle for frameless mode"""
        if self.bottom_resize_handle:
            return  # Already exists
        
        # Create resize handle widget
        self.bottom_resize_handle = QWidget(self)
        self.bottom_resize_handle.setFixedHeight(6)  # 6px tall resize area
        self.bottom_resize_handle.setStyleSheet("""
            QWidget {
                background-color: transparent;
            }
            QWidget:hover {
                background-color: rgba(100, 100, 100, 0.3);
            }
        """)
        self.bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)  # Vertical resize cursor
        self.bottom_resize_handle.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        
        # Mouse event handlers for resizing
        def handle_mouse_press(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.resize_start_y = event.globalPosition().y()
                self.resize_start_height = self.height()
                event.accept()
        
        def handle_mouse_move(event):
            if self.resize_start_y is not None and event.buttons() & Qt.MouseButton.LeftButton:
                delta_y = event.globalPosition().y() - self.resize_start_y
                new_height = max(150, self.resize_start_height + int(delta_y))  # Min 150px
                # Keep width fixed at 260px
                self.resize(WINDOW_DEFAULT_WIDTH, new_height)
                event.accept()
        
        def handle_mouse_release(event):
            self.resize_start_y = None
            self.resize_start_height = None
            event.accept()
        
        self.bottom_resize_handle.mousePressEvent = handle_mouse_press
        self.bottom_resize_handle.mouseMoveEvent = handle_mouse_move
        self.bottom_resize_handle.mouseReleaseEvent = handle_mouse_release
        
        # Position at bottom of window
        self.update_bottom_resize_handle_position()
        self.bottom_resize_handle.show()
        self.bottom_resize_handle.raise_()  # Keep on top
    
    def update_bottom_resize_handle_position(self):
        """Update bottom resize handle position"""
        if not self.bottom_resize_handle:
            return
        
        # Position at bottom of window, full width
        handle_height = 6
        self.bottom_resize_handle.setGeometry(0, self.height() - handle_height, self.width(), handle_height)
        self.bottom_resize_handle.raise_()  # Keep on top
    
    def remove_bottom_resize_handle(self):
        """Remove bottom resize handle"""
        if self.bottom_resize_handle:
            self.bottom_resize_handle.deleteLater()
            self.bottom_resize_handle = None
        self.resize_start_y = None
        self.resize_start_height = None
    
    def toggle_playlist_expand(self):
        """Toggle playlist expand/collapse (minimize/restore)"""
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible():
            self.playlist_sidebar._toggle_minimize_state()
    
    def _update_playlist_button_icon(self, is_visible):
        """Update playlist button icon color based on visibility state"""
        # Ensure is_visible is a boolean (handle None case)
        if is_visible is None:
            is_visible = False
        else:
            is_visible = bool(is_visible)
        
        icon_color = '#4a90e2' if is_visible else '#a0a0a0'
        
        # Update top nav playlist button
        if hasattr(self, 'playlist_btn') and HAS_QT_AWESOME:
            icon = get_icon('mdi6.list-box', color=icon_color)
            if icon:
                self.playlist_btn.setIcon(icon)
        
        # Update player playlist button (in regular player widget)
        if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
            if hasattr(self.regular_player_widget, 'player_playlist_btn') and self.regular_player_widget.player_playlist_btn:
                self.regular_player_widget.player_playlist_btn.setChecked(is_visible)
                if HAS_QT_AWESOME:
                    icon = get_icon('mdi6.list-box', color=icon_color)
                    if icon:
                        self.regular_player_widget.player_playlist_btn.setIcon(icon)
        
        # Update player playlist button (in micro player widget)
        if hasattr(self, 'micro_player_widget') and self.micro_player_widget:
            if hasattr(self.micro_player_widget, 'player_playlist_btn') and self.micro_player_widget.player_playlist_btn:
                self.micro_player_widget.player_playlist_btn.setChecked(is_visible)
                if HAS_QT_AWESOME:
                    icon = get_icon('mdi6.list-box', color=icon_color)
                    if icon:
                        self.micro_player_widget.player_playlist_btn.setIcon(icon)
    
    def toggle_playlist(self):
        """Toggle playlist sidebar visibility"""
        # If playlist is detached, toggle detached window visibility instead
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            is_visible = self.detached_playlist_window.isVisible()
            if is_visible:
                self.detached_playlist_window.hide()
                new_visible = False
            else:
                self.detached_playlist_window.show()
                self.detached_playlist_window.raise_()
                self.detached_playlist_window.activateWindow()
                new_visible = True
            
            # CRITICAL: Force main window repaint when detached playlist visibility changes
            # When paused, playback updates don't trigger repaints, so we need to force it
            def force_main_window_repaint():
                # Repaint main window and all its widgets
                self.update()
                self.repaint()
                # Repaint central widget
                central_widget = self.centralWidget()
                if central_widget:
                    central_widget.update()
                    central_widget.repaint()
                # Repaint player widget and cover art
                if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                    self.regular_player_widget.update()
                    self.regular_player_widget.repaint()
                    if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                        self.regular_player_widget.cover_art_label.update()
                        self.regular_player_widget.cover_art_label.repaint()
                QApplication.processEvents()
            
            # Force immediate repaint
            force_main_window_repaint()
            # Schedule additional repaints to catch timing issues (especially when paused)
            QTimer.singleShot(10, force_main_window_repaint)
            QTimer.singleShot(50, force_main_window_repaint)
            QTimer.singleShot(100, force_main_window_repaint)
            
            # Update button states and icon color (both top nav and player buttons)
            if hasattr(self, 'playlist_btn'):
                self.playlist_btn.setChecked(new_visible)
            self._update_playlist_button_icon(new_visible)
            if hasattr(self, 'show_playlist_action'):
                self.show_playlist_action.setChecked(new_visible)
            # Save state
            self.settings['playlist_visible'] = new_visible
            self.save_settings()
            # Keep quick button in sync (should be hidden while detached)
            try:
                self.update_playlist_quick_btn_visibility()
            except Exception:
                pass
            return
        
        # Lazy-load playlist sidebar on first use
        if self.playlist_sidebar is None:
            layout = self.centralWidget().layout()
            
            # Create container widget for playlist and resize handle
            playlist_container = QWidget()
            # Set size policy to prevent container from expanding vertically
            # Expanding horizontally (fills window width), Preferred vertically (only takes space it needs)
            playlist_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            # Set minimum height to 0 so container can collapse completely when playlist is hidden
            playlist_container.setMinimumHeight(0)
            playlist_container_layout = QVBoxLayout(playlist_container)
            playlist_container_layout.setContentsMargins(0, 0, 0, 0)
            playlist_container_layout.setSpacing(0)
            
            # Resize handle (horizontal bar at top of playlist)
            resize_handle = QWidget()
            resize_handle.setFixedHeight(0)  # Start with 0 height since it's hidden
            resize_handle.setStyleSheet("""
                QWidget {
                    background-color: transparent;
                }
                QWidget:hover {
                    background-color: transparent;
                }
            """)
            resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)  # Vertical resize cursor
            resize_handle.hide()  # Hidden by default, shown when playlist is visible
            # Set size policy to prevent taking space when hidden
            resize_handle.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
            playlist_container_layout.addWidget(resize_handle)
            
            self.playlist_sidebar = PlaylistSidebar(
                self,
                self.playlist_manager,
                self.resolve_url_redirects,
                self.load_url
            )
            # Sync playlist_sidebar's state with centralized state
            if hasattr(self, 'shuffle_mode') and hasattr(self, 'repeat_mode'):
                self.playlist_sidebar.shuffle_mode = self.shuffle_mode
                self.playlist_sidebar.repeat_mode = self.repeat_mode
                # Update UI to reflect centralized state
                QTimer.singleShot(0, self.playlist_sidebar._update_shuffle_button_ui)
                QTimer.singleShot(0, self.playlist_sidebar._update_repeat_button_ui)
            
            # Set size policy - expand horizontally to fill container, preferred height
            self.playlist_sidebar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            # Set initial height and allow resizing between min and max
            self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
            self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
            # Restore height from settings or use default
            saved_height = self.settings.get("playlist_height", 250)
            saved_height = int(max(100, min(600, saved_height)))  # Clamp between min and max
            self.playlist_sidebar.setFixedHeight(saved_height)
            if hasattr(self.playlist_sidebar, '_restore_height'):
                self.playlist_sidebar._restore_height = saved_height
            # Always hide by default - the restore function will set the correct visibility
            self.playlist_sidebar.hide()
            playlist_container_layout.addWidget(self.playlist_sidebar, 1)
            
            # Store references for resize functionality
            self.playlist_container = playlist_container
            self.playlist_resize_handle = resize_handle
            self.playlist_start_resize_y = None
            self.playlist_start_height = None
            
            # Setup resize handle mouse events
            def resize_handle_mouse_press(event):
                # Don't allow resizing when playlist is minimized
                if self.playlist_sidebar.is_minimized:
                    return
                # Don't allow resizing in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    return
                # Don't allow resizing if playlist is detached (detached playlist has its own resize handle)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    return
                if event.button() == Qt.MouseButton.LeftButton:
                    self.playlist_start_resize_y = event.globalPosition().y()
                    self.playlist_start_height = self.playlist_sidebar.height()
            
            def resize_handle_mouse_move(event):
                # Don't allow resizing when playlist is minimized
                if self.playlist_sidebar.is_minimized:
                    return
                # Don't allow resizing in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    return
                # Don't allow resizing if playlist is detached (detached playlist has its own resize handle)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    return
                if self.playlist_start_resize_y is not None and event.buttons() & Qt.MouseButton.LeftButton:
                    delta_y = self.playlist_start_resize_y - event.globalPosition().y()  # Inverted: drag up = increase height
                    new_height = self.playlist_start_height + delta_y
                    # Clamp between minimum and maximum and convert to int
                    new_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, new_height)))
                    self.playlist_sidebar.setFixedHeight(new_height)
                    # Ensure playlist stays above loading overlay during resize
                    if hasattr(self, 'playlist_container') and self.playlist_container:
                        self.playlist_container.raise_()
                    # Update player section position (attaches to playlist top and moves with it)
                    if hasattr(self, '_update_player_section_position'):
                        QTimer.singleShot(10, self._update_player_section_position)
            
            def resize_handle_mouse_release(event):
                # Don't save height if in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    self.playlist_start_resize_y = None
                    self.playlist_start_height = None
                    return
                # Don't save height if playlist is detached (detached playlist handles its own saving)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    self.playlist_start_resize_y = None
                    self.playlist_start_height = None
                    return
                
                # Store the new height for restore after minimize (only in regular mode)
                if self.playlist_sidebar:
                    new_height = self.playlist_sidebar.height()
                    self.playlist_sidebar._restore_height = new_height
                    # Save playlist height to settings (only in regular mode)
                    self.settings['playlist_height'] = new_height
                    # Also save to playlist_height_regular for regular mode
                    self.settings['playlist_height_regular'] = new_height
                    # CRITICAL: keep attached height in sync so detach/reattach + mode cycling restores correctly
                    self.settings['playlist_attached_height'] = new_height
                    self.save_settings()
                
                self.playlist_start_resize_y = None
                self.playlist_start_height = None
                
                # After drag ends, check if mouse is outside address bar and hide if autohide is enabled
                if self.autohide_address_bar and hasattr(self, 'controls_bar_widget'):
                    # Use a small delay to allow mouse position to settle
                    QTimer.singleShot(50, self.check_and_hide_address_bar_after_drag)
            
            resize_handle.mousePressEvent = resize_handle_mouse_press
            resize_handle.mouseMoveEvent = resize_handle_mouse_move
            resize_handle.mouseReleaseEvent = resize_handle_mouse_release
            
            # Add container to layout, aligned to bottom
            layout.addWidget(playlist_container, 0, Qt.AlignmentFlag.AlignBottom)  # Align to bottom
            # Ensure playlist is above loading overlay (higher z-order)
            playlist_container.raise_()
            
            # Force layout update after adding new widget to ensure it's properly positioned
            layout.update()
            layout.activate()
            QApplication.processEvents()
            
            # If playlist was just created and we need to restore state, do it now
            if hasattr(self, '_restore_playlist_state_pending') and self._restore_playlist_state_pending:
                # Check if this is a user-initiated toggle (button is checked = user wants it visible)
                # If button is checked, user just clicked to show it, so don't restore hidden state
                user_wants_visible = hasattr(self, 'playlist_btn') and self.playlist_btn.isChecked()
                
                if not user_wants_visible:
                    # Not a user click, or user wants it hidden - restore saved state
                    self._restore_playlist_state()
                else:
                    # User clicked to show it - show it and update button state
                    self.playlist_sidebar.setVisible(True)
                    # Ensure playlist container is visible
                    if hasattr(self, 'playlist_container') and self.playlist_container:
                        self.playlist_container.show()
                    if hasattr(self, 'playlist_resize_handle'):
                        handle = self.playlist_resize_handle
                        handle.setVisible(True)
                        handle.setFixedHeight(4)  # Restore height when shown
                    # Restore other state (height, minimized) but keep visible
                    playlist_minimized = self.settings.get("playlist_minimized", True)  # Default to minimized
                    playlist_height = self.settings.get("playlist_height", 250)
                    playlist_height = int(max(100, min(600, playlist_height)))
                    self.playlist_sidebar.setFixedHeight(playlist_height)
                    if hasattr(self.playlist_sidebar, '_restore_height'):
                        self.playlist_sidebar._restore_height = playlist_height
                    if playlist_minimized != self.playlist_sidebar.is_minimized:
                        self.playlist_sidebar._toggle_minimize_state()
                    # Update button state and icon color
                    if hasattr(self, 'playlist_btn'):
                        self.playlist_btn.setChecked(True)
                        self._update_playlist_button_icon(True)
                    if hasattr(self, 'show_playlist_action'):
                        self.show_playlist_action.setChecked(True)
                    # Update settings
                    self.settings['playlist_visible'] = True
                    self.save_settings()
                    
                    # If in mini mode, resize to accommodate playlist
                    if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 1:
                        self._debounced_resize_mini_mode(True, delay=200)
                
                self._restore_playlist_state_pending = False
                return  # Don't continue with normal toggle logic
        
        visible = self.playlist_sidebar.isVisible()
        new_visible = not visible
        
        # CRITICAL: Preserve minimized state before hiding/showing
        was_minimized = getattr(self.playlist_sidebar, 'is_minimized', False) if self.playlist_sidebar else False
        
        self.playlist_sidebar.setVisible(new_visible)
        
        # Show/hide playlist container when playlist is shown/hidden
        if hasattr(self, 'playlist_container') and self.playlist_container:
            if new_visible:
                # Ensure both container and sidebar are visible
                self.playlist_container.show()
                # Clear any constraints that might have been set when closing
                self.playlist_container.setMinimumHeight(0)
                self.playlist_container.setMaximumHeight(16777215)  # Qt max
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    self.playlist_sidebar.show()
                
                # CRITICAL: In mini/micro mode, restore minimized state and set correct height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    # CRITICAL: Restore minimized state BEFORE showing widgets
                    # This ensures internal widgets are in the correct state when shown
                    if was_minimized:
                        # If it was minimized, ensure it stays minimized
                        if not self.playlist_sidebar.is_minimized:
                            # Need to minimize it
                            self.playlist_sidebar.is_minimized = True
                            # Manually set internal widget visibility to match minimized state
                            if hasattr(self.playlist_sidebar, 'list_widget'):
                                self.playlist_sidebar.list_widget.setVisible(False)
                            if hasattr(self.playlist_sidebar, 'content_container'):
                                self.playlist_sidebar.content_container.setVisible(False)
                            if hasattr(self.playlist_sidebar, 'tracklist_widget'):
                                self.playlist_sidebar.tracklist_widget.setVisible(False)
                            # Update minimize button icon
                            if hasattr(self.playlist_sidebar, '_update_minimize_button_icon'):
                                self.playlist_sidebar._update_minimize_button_icon()
                    else:
                        # If it was expanded, ensure it's expanded
                        if self.playlist_sidebar.is_minimized:
                            # Need to expand it
                            self.playlist_sidebar.is_minimized = False
                            # Manually set internal widget visibility to match expanded state
                            if hasattr(self.playlist_sidebar, 'content_container'):
                                self.playlist_sidebar.content_container.setVisible(True)
                            # Show list_widget or tracklist_widget based on active tab
                            if hasattr(self.playlist_sidebar, 'active_tab'):
                                if self.playlist_sidebar.active_tab == 'albums':
                                    if hasattr(self.playlist_sidebar, 'list_widget'):
                                        self.playlist_sidebar.list_widget.setVisible(True)
                                    if hasattr(self.playlist_sidebar, 'tracklist_widget'):
                                        self.playlist_sidebar.tracklist_widget.setVisible(False)
                                else:  # tracks tab
                                    if hasattr(self.playlist_sidebar, 'list_widget'):
                                        self.playlist_sidebar.list_widget.setVisible(False)
                                    if hasattr(self.playlist_sidebar, 'tracklist_widget'):
                                        self.playlist_sidebar.tracklist_widget.setVisible(True)
                            # Update minimize button icon
                            if hasattr(self.playlist_sidebar, '_update_minimize_button_icon'):
                                self.playlist_sidebar._update_minimize_button_icon()
                    
                    # Set correct height based on minimized state
                    if self.playlist_sidebar.is_minimized:
                        # Minimized: use actual minimized height (title bar + margins)
                        title_bar_height = self.playlist_sidebar.title_bar_widget.sizeHint().height() if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget else 30
                        layout = self.playlist_sidebar.layout()
                        if layout:
                            margins = layout.getContentsMargins()
                            minimized_height = title_bar_height + margins[1] + margins[3]  # top + bottom margins
                        else:
                            minimized_height = title_bar_height + 10  # Add some padding
                        self.playlist_sidebar.setFixedHeight(minimized_height)
                    else:
                        # Expanded: always 230px in mini mode
                        self.playlist_sidebar.setFixedHeight(230)
                
                # Force geometry update to ensure proper sizing
                self.playlist_container.updateGeometry()
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    self.playlist_sidebar.updateGeometry()
                # Force layout update
                layout = self.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                QApplication.processEvents()
            else:
                # In mini/micro mode, hide the container when playlist is toggled off
                # This prevents black space from appearing (same behavior as close button)
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    # CRITICAL: Ensure playlist sidebar is hidden first
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        self.playlist_sidebar.hide()
                        # CRITICAL: Ensure internal widgets maintain their minimized state
                        # Don't let hiding the sidebar affect the internal widget visibility
                        # The minimized state should be preserved
                        if was_minimized:
                            # Ensure list_widget and content_container stay hidden (minimized state)
                            if hasattr(self.playlist_sidebar, 'list_widget'):
                                self.playlist_sidebar.list_widget.setVisible(False)
                            if hasattr(self.playlist_sidebar, 'content_container'):
                                self.playlist_sidebar.content_container.setVisible(False)
                    
                    # Hide container to prevent black space
                    self.playlist_container.hide()
                    # CRITICAL: Clear ALL height restrictions and reset geometry
                    # This prevents the container from contributing to window height calculations
                    self.playlist_container.setFixedHeight(0)  # Force to 0
                    self.playlist_container.setMinimumHeight(0)
                    self.playlist_container.setMaximumHeight(0)  # Set to 0, not max
                    self.playlist_container.updateGeometry()
                    # Force layout update to ensure visibility changes are reflected
                    layout = self.centralWidget().layout()
                    if layout:
                        layout.update()
                        layout.activate()
                    QApplication.processEvents()
                    # Verify container height is actually 0
                    actual_height = self.playlist_container.height()
                    if actual_height > 0:
                        print(f"[DEBUG] toggle_playlist: WARNING - Container height is {actual_height}px after hiding! Forcing to 0...")
                        self.playlist_container.setFixedHeight(0)
                        self.playlist_container.resize(self.playlist_container.width(), 0)
                        self.playlist_container.updateGeometry()
                        QApplication.processEvents()
                else:
                    # In regular mode, don't hide container - just hide sidebar
                    # Container will be positioned but empty
                    pass
        
        # Show/hide resize handle when playlist is shown/hidden
        if hasattr(self, 'playlist_resize_handle'):
            handle = self.playlist_resize_handle
            handle.setVisible(new_visible)
            # Set height to 0 when hidden to prevent taking up space
            if new_visible:
                handle.setFixedHeight(4)
            else:
                handle.setFixedHeight(0)
        
        # Ensure playlist container is raised above other widgets when shown
        if new_visible and hasattr(self, 'playlist_container') and self.playlist_container:
            self.playlist_container.raise_()
        
        # Update player section position when playlist visibility changes (treat as resize event)
        # Fake a resize event by calling immediately (like resize handler does) and with delays
        if hasattr(self, '_update_player_section_position'):
            # Call immediately first (like resize handler does)
            self._update_player_section_position()
            # Then call with delays to catch any layout changes
            QTimer.singleShot(10, self._update_player_section_position)
            QTimer.singleShot(50, self._update_player_section_position)
            QTimer.singleShot(100, self._update_player_section_position)
            QTimer.singleShot(200, self._update_player_section_position)
        
        # If playlist was just shown, force layout update before resizing
        # This ensures the playlist is properly positioned in the layout before we measure/resize
        # This is especially important on first open when playlist is lazy-loaded
        if new_visible:
            # Force layout update to ensure playlist is properly positioned
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.show()  # Ensure it's visible
                self.playlist_container.updateGeometry()
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                self.playlist_sidebar.updateGeometry()
            layout = self.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            QApplication.processEvents()
        
        # Update loading overlay geometry only if it should be visible (is loading)
        if self.loading_overlay:
            if self.is_loading and self.loading_overlay.isVisible():
                self.update_loading_overlay_geometry()
            elif not self.is_loading:
                # Ensure overlay is hidden when not loading and reset geometry
                if self.loading_overlay.isVisible():
                    self.loading_overlay.hide()
                    self.loading_overlay.setVisible(False)
                # Always reset geometry when not loading to prevent taking up space
                self.loading_overlay.setGeometry(0, 0, 0, 0)
        # Update button state and icon color (both top nav and player buttons)
        if hasattr(self, 'playlist_btn'):
            self.playlist_btn.setChecked(new_visible)
        self._update_playlist_button_icon(new_visible)  # Updates both top nav and player buttons
        if hasattr(self, 'show_playlist_action'):
            self.show_playlist_action.setChecked(new_visible)
        
        # Save playlist state to settings
        self.settings['playlist_visible'] = new_visible
        if hasattr(self.playlist_sidebar, 'is_minimized'):
            self.settings['playlist_minimized'] = self.playlist_sidebar.is_minimized
            # Keep attached-specific minimized state in sync (only when attached)
            try:
                if not self.playlist_detached:
                    self.settings['playlist_attached_minimized'] = self.playlist_sidebar.is_minimized
            except Exception:
                pass
        # Don't save playlist height in mini or micro mode - it has fixed heights
        if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
            # In mini/micro mode, don't save height changes - use fixed heights
            self.save_settings()
            
            # CRITICAL: Resize window to account for playlist visibility change in mini/micro mode
            # This ensures the window size is correct when playlist is toggled on/off
            def resize_with_actual_visibility():
                # CRITICAL: Check both sidebar AND container visibility
                # Container must be visible for playlist to be considered visible
                sidebar_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible()
                container_visible = hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible()
                actual_visible = sidebar_visible and container_visible
                
                # If playlist is hidden, ensure container height is cleared to prevent wrong calculations
                if not actual_visible and hasattr(self, 'playlist_container') and self.playlist_container:
                    # Clear any height constraints on hidden container
                    self.playlist_container.setMinimumHeight(0)
                    self.playlist_container.setMaximumHeight(16777215)  # Qt max
                    self.playlist_container.updateGeometry()
                
                if hasattr(self, '_resize_mini_mode_for_playlist'):
                    self._resize_mini_mode_for_playlist(actual_visible)
                # Also trigger mode-specific resize
                if self.mini_mode_state == 1:
                    if hasattr(self, 'resize_to_mini_mode'):
                        self.resize_to_mini_mode()
                elif self.mini_mode_state == 2:
                    if hasattr(self, 'resize_to_micro_mode'):
                        self.resize_to_micro_mode()
            
            # Schedule resize calls with multiple delays to ensure geometry is updated
            QTimer.singleShot(10, resize_with_actual_visibility)
            QTimer.singleShot(50, resize_with_actual_visibility)
            QTimer.singleShot(100, resize_with_actual_visibility)
            QTimer.singleShot(200, resize_with_actual_visibility)
            QTimer.singleShot(300, resize_with_actual_visibility)  # Extra delay for safety

        # Keep quick button in sync with playlist visibility
        try:
            self.update_playlist_quick_btn_visibility()
        except Exception:
            pass
        else:
            # Only save height in regular mode or detached mode
            if hasattr(self.playlist_sidebar, '_restore_height'):
                self.settings['playlist_height'] = self.playlist_sidebar._restore_height
            elif self.playlist_sidebar:
                self.settings['playlist_height'] = self.playlist_sidebar.height()
            self.save_settings()
        
        # Update player section position when playlist visibility changes (treat as resize event)
        # Fake a resize event by calling immediately (like resize handler does) and with delays
        if hasattr(self, '_update_player_section_position'):
            # Call immediately first (like resize handler does)
            self._update_player_section_position()
            # Then call with delays to catch any layout changes
            QTimer.singleShot(10, self._update_player_section_position)
            QTimer.singleShot(50, self._update_player_section_position)
            QTimer.singleShot(100, self._update_player_section_position)
            QTimer.singleShot(200, self._update_player_section_position)
        
        # If in mini/micro mode, resize window to account for playlist visibility change
        if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
            mode_name = "mini" if self.mini_mode_state == 1 else "micro"
            print(f"[DEBUG] toggle_playlist: In {mode_name} mode, new_visible={new_visible}")
            # Ensure playlist container is visible if playlist is being shown
            if new_visible:
                print(f"[DEBUG] toggle_playlist: Showing playlist in {mode_name} mode")
                if hasattr(self, 'playlist_container') and self.playlist_container:
                    print(f"[DEBUG] toggle_playlist: playlist_container exists, showing it")
                    self.playlist_container.show()
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    print(f"[DEBUG] toggle_playlist: playlist_sidebar exists, showing it")
                    self.playlist_sidebar.show()
                    # Force geometry update
                    self.playlist_sidebar.updateGeometry()
                # Force layout update
                layout = self.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                QApplication.processEvents()
                print(f"[DEBUG] toggle_playlist: After show, container visible={self.playlist_container.isVisible() if hasattr(self, 'playlist_container') and self.playlist_container else 'N/A'}, sidebar visible={self.playlist_sidebar.isVisible() if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else 'N/A'}")
            # Use multiple delays to ensure playlist geometry is updated first
            # Check actual visibility instead of relying on parameter
            def resize_with_actual_visibility():
                actual_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible()
                print(f"[DEBUG] toggle_playlist: Resize callback, actual_visible={actual_visible}")
                self._resize_mini_mode_for_playlist(actual_visible)
                # Also trigger mode-specific resize
                if self.mini_mode_state == 1:
                    self.resize_to_mini_mode()
                else:  # micro mode
                    self.resize_to_micro_mode()
            print(f"[DEBUG] toggle_playlist: Scheduling resize calls")
            QTimer.singleShot(10, resize_with_actual_visibility)
            QTimer.singleShot(50, resize_with_actual_visibility)
            QTimer.singleShot(100, resize_with_actual_visibility)
            QTimer.singleShot(200, resize_with_actual_visibility)
            QTimer.singleShot(300, resize_with_actual_visibility)  # Extra delay for safety
    
    def _toggle_detach_playlist(self):
        """Toggle between attached and detached playlist window."""
        if self.playlist_detached:
            self._reattach_playlist()
        else:
            self._detach_playlist()
    
    def _detach_playlist(self):
        """Detach playlist to separate window."""
        print("[DETACH DEBUG] _detach_playlist called")
        logger.debug("[DETACH DEBUG] _detach_playlist called")
        if not self.playlist_sidebar:
            print("[DETACH DEBUG] No playlist_sidebar, returning")
            return
        # If already detached and window exists, don't recreate (unless window doesn't exist)
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            # Window already exists, just ensure it's shown
            self.detached_playlist_window.show()
            self.detached_playlist_window.raise_()
            # Update overlay when window is shown (in case mode changed while hidden)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                repeat_mode = getattr(self.playlist_sidebar, 'repeat_mode', 0)
                if hasattr(self, '_update_detached_repeat_overlay'):
                    QTimer.singleShot(100, lambda: self._update_detached_repeat_overlay(repeat_mode))
            return
        
        # CRITICAL: Save playlist visibility state before detaching
        # This ensures we can restore it correctly when reattaching
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            playlist_was_visible = self.playlist_sidebar.isVisible()
            playlist_was_minimized = getattr(self.playlist_sidebar, 'is_minimized', False)
            print(f"[REATTACH DEBUG] Detaching: playlist_visible={playlist_was_visible}, is_minimized={playlist_was_minimized}")
            self.settings['playlist_visible'] = playlist_was_visible
            self.save_settings()
        
        # Ensure playlist is visible before detaching
        if not self.playlist_sidebar.isVisible():
            self.playlist_sidebar.setVisible(True)
            if hasattr(self, 'playlist_resize_handle'):
                self.playlist_resize_handle.setVisible(True)

        # Snapshot the ATTACHED regular-mode expanded playlist height BEFORE reparenting.
        # Once we move the widget into the detached window, Qt will re-layout it and the height can change
        # (often to a smaller default like ~230), which would clobber the user's custom attached height.
        try:
            if getattr(self, 'mini_mode_state', 0) == 0 and not getattr(self, 'playlist_detached', False):
                if hasattr(self.playlist_sidebar, 'is_minimized') and self.playlist_sidebar.is_minimized:
                    # If minimized, don't overwrite attached height  keep the last expanded value.
                    pass
                else:
                    candidate = int(self.playlist_sidebar.height())
                    if candidate and candidate != 135:
                        candidate = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, candidate)))
                        self.settings['playlist_attached_height'] = candidate
                        # Keep regular-mode keys in sync so all restoration paths agree
                        self.settings['playlist_height_regular'] = candidate
                        self.settings['playlist_height'] = candidate
                        self.save_settings()
        except Exception:
            pass

        # Remember attached minimized state before detaching (detached will always show expanded content)
        try:
            if hasattr(self.playlist_sidebar, 'is_minimized'):
                attached_minimized = bool(self.playlist_sidebar.is_minimized)
                self.settings['playlist_attached_minimized'] = attached_minimized
                # Keep legacy key in sync while attached so attached startup restores correctly
                self.settings['playlist_minimized'] = attached_minimized
                self.save_settings()
        except Exception:
            pass
        
        # Expand playlist if minimized (auto-expand when detaching)
        if hasattr(self.playlist_sidebar, 'is_minimized') and self.playlist_sidebar.is_minimized:
            self.playlist_sidebar._toggle_minimize_state()
        
        # Hide playlist title bar when detached (buttons moved to window title bar)
        if hasattr(self.playlist_sidebar, 'title_bar_widget'):
            self.playlist_sidebar.title_bar_widget.hide()
        
        # Hide minimize button when detached
        if hasattr(self.playlist_sidebar, 'minimize_btn'):
            self.playlist_sidebar.minimize_btn.hide()
        
        # Hide close button when detached (detached window has its own close button)
        if hasattr(self.playlist_sidebar, 'close_btn'):
            self.playlist_sidebar.close_btn.hide()
        
        # Remove size constraints from playlist sidebar to allow window resizing
        if self.playlist_sidebar:
            # Remove fixed width constraint
            self.playlist_sidebar.setMaximumWidth(16777215)  # Qt's maximum
            # Ensure playlist can expand horizontally
            self.playlist_sidebar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        # Create detached window
        self._create_detached_playlist_window()
        
        # Initialize window linking if enabled (with a small delay to ensure window is positioned)
        if self.playlist_window_linked:
            # Use a small delay to ensure the detached window is fully created and positioned
            def init_linking_after_window_ready():
                if hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
                    self._initialize_playlist_window_linking()
            QTimer.singleShot(50, init_linking_after_window_ready)
        
        # Hide loading overlay if visible to prevent black overlay on main window
        print(f"[DETACH DEBUG] Checking loading overlay: exists={hasattr(self, 'loading_overlay')}, "
              f"overlay={getattr(self, 'loading_overlay', None)}, "
              f"visible={getattr(self.loading_overlay, 'isVisible', lambda: False)() if hasattr(self, 'loading_overlay') and self.loading_overlay else False}, "
              f"is_loading={getattr(self, 'is_loading', False)}")
        logger.debug(f"[DETACH DEBUG] Checking loading overlay: exists={hasattr(self, 'loading_overlay')}, "
              f"overlay={getattr(self, 'loading_overlay', None)}, "
              f"visible={getattr(self.loading_overlay, 'isVisible', lambda: False)() if hasattr(self, 'loading_overlay') and self.loading_overlay else False}, "
              f"is_loading={getattr(self, 'is_loading', False)}")
        if hasattr(self, 'loading_overlay') and self.loading_overlay and self.loading_overlay.isVisible():
            print("[DETACH DEBUG] Hiding loading overlay")
            logger.debug("[DETACH DEBUG] Hiding loading overlay")
            self.loading_overlay.hide()
            self.loading_overlay.setVisible(False)
            self.loading_overlay.setGraphicsEffect(None)
            self.loading_overlay.lower()  # Move behind other widgets
            # Ensure it's not taking up space
            self.loading_overlay.setGeometry(0, 0, 0, 0)
            # Also clear loading state
            self.is_loading = False
            QApplication.processEvents()
        else:
            print("[DETACH DEBUG] Loading overlay not visible or doesn't exist")
            logger.debug("[DETACH DEBUG] Loading overlay not visible or doesn't exist")
        
        # SIMPLIFIED: Just hide the container like regular mode does
        # With layout-based approach, hiding the container automatically adjusts the layout
        if hasattr(self, 'playlist_container') and self.playlist_container:
            print(f"[DETACH DEBUG] Hiding playlist_container (layout-based, like regular mode)")
            logger.debug(f"[DETACH DEBUG] Hiding playlist_container (layout-based, like regular mode)")
            # Just hide it - layout handles the rest automatically
            self.playlist_container.hide()
            
            # Update layout to reflect the change
            layout = self.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
                QApplication.processEvents()
            
            # In mini mode, resize window to remove playlist space (like toggle_playlist does)
            # The _resize_mini_mode_for_playlist function will handle window resizing
            if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 1:
                print(f"[DETACH DEBUG] Resizing window to remove playlist space in mini mode")
                logger.debug(f"[DETACH DEBUG] Resizing window to remove playlist space in mini mode")
                # Call the resize function - layout handles widget positioning automatically
                self._resize_mini_mode_for_playlist(False)
            elif hasattr(self, 'mini_mode_state') and self.mini_mode_state == 2:
                # Micro mode: Aggressively clear container to prevent black space
                print(f"[DETACH DEBUG] Resizing window to remove playlist space in micro mode")
                logger.debug(f"[DETACH DEBUG] Resizing window to remove playlist space in micro mode")
                # Clear height restrictions
                self.playlist_container.setMinimumHeight(0)
                self.playlist_container.setMaximumHeight(16777215)  # Qt max
                # Aggressively hide and clear geometry to prevent black space
                self.playlist_container.setVisible(False)
                self.playlist_container.setGeometry(0, 0, 0, 0)
                self.playlist_container.updateGeometry()
                # Also hide resize handle if it exists
                if hasattr(self, 'playlist_resize_handle') and self.playlist_resize_handle:
                    self.playlist_resize_handle.hide()
                    self.playlist_resize_handle.setVisible(False)
                    self.playlist_resize_handle.setFixedHeight(0)
                # Call the resize function - layout handles widget positioning automatically
                def resize_after_detach():
                    # Double-check container is hidden and cleared
                    if hasattr(self, 'playlist_container') and self.playlist_container:
                        if self.playlist_container.isVisible():
                            print(f"[DETACH DEBUG] Container still visible in resize_after_detach, forcing hide")
                            self.playlist_container.hide()
                            self.playlist_container.setVisible(False)
                            self.playlist_container.setGeometry(0, 0, 0, 0)
                    actual_visible = False  # Playlist is detached, so not visible in main window
                    self._resize_mini_mode_for_playlist(actual_visible)
                    # Also trigger micro mode resize
                    self.resize_to_micro_mode()
                    # Force layout update after resize
                    layout = self.centralWidget().layout()
                    if layout:
                        layout.update()
                        layout.activate()
                        QApplication.processEvents()
                # Use multiple delays to ensure layout has settled
                QTimer.singleShot(10, resize_after_detach)
                QTimer.singleShot(50, resize_after_detach)
                QTimer.singleShot(100, resize_after_detach)
                QTimer.singleShot(200, resize_after_detach)
                # Extra delayed check to ensure container stays cleared
                def final_clear_check():
                    if hasattr(self, 'playlist_container') and self.playlist_container:
                        if self.playlist_container.isVisible():
                            print(f"[DETACH DEBUG] Final clear check: Container still visible, forcing hide")
                            self.playlist_container.hide()
                            self.playlist_container.setVisible(False)
                            self.playlist_container.setGeometry(0, 0, 0, 0)
                            # Force layout update
                            layout = self.centralWidget().layout()
                            if layout:
                                layout.update()
                                layout.activate()
                QTimer.singleShot(300, final_clear_check)
        else:
            print("[DETACH DEBUG] No playlist_container found")
            logger.debug("[DETACH DEBUG] No playlist_container found")
        
        # Hide playlist sidebar immediately before moving to prevent black flash
        print(f"[DETACH DEBUG] Hiding playlist_sidebar, current visible={self.playlist_sidebar.isVisible()}")
        logger.debug(f"[DETACH DEBUG] Hiding playlist_sidebar, current visible={self.playlist_sidebar.isVisible()}")
        self.playlist_sidebar.hide()
        QApplication.processEvents()
        print(f"[DETACH DEBUG] playlist_sidebar hidden, visible={self.playlist_sidebar.isVisible()}")
        logger.debug(f"[DETACH DEBUG] playlist_sidebar hidden, visible={self.playlist_sidebar.isVisible()}")
        
        # Move playlist sidebar to detached window
        layout = self.detached_playlist_window.layout()
        print(f"[DETACH DEBUG] Detached window layout has {layout.count() if layout else 0} items before adding playlist_sidebar")
        if layout:
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.widget():
                    widget = item.widget()
                    print(f"[DETACH DEBUG]   Existing item {i}: {type(widget).__name__}, visible={widget.isVisible()}")
        
        # Remove from any previous layout first (prevents duplicates when switching modes)
        if self.playlist_sidebar.parent():
            parent_layout = self.playlist_sidebar.parent().layout()
            if parent_layout:
                try:
                    print(f"[DETACH DEBUG] Removing playlist_sidebar from previous parent layout")
                    parent_layout.removeWidget(self.playlist_sidebar)
                except Exception as e:
                    print(f"[DETACH DEBUG] Error removing from previous layout: {e}")
                    pass
        self.playlist_sidebar.setParent(self.detached_playlist_window)
        # Check if already in layout before adding (prevents duplicates)
        already_in_layout = False
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.widget() == self.playlist_sidebar:
                already_in_layout = True
                print(f"[DETACH DEBUG] playlist_sidebar already in layout at index {i}, skipping add")
                break
        if not already_in_layout:
            print(f"[DETACH DEBUG] Adding playlist_sidebar to detached window layout")
            layout.addWidget(self.playlist_sidebar)
        
        # CRITICAL: Ensure playlist sidebar's title bar widget stays hidden in detached window
        # The detached window has its own title bar, so the sidebar's title bar should never be visible
        if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
            was_visible = self.playlist_sidebar.title_bar_widget.isVisible()
            self.playlist_sidebar.title_bar_widget.hide()
            self.playlist_sidebar.title_bar_widget.setVisible(False)
            print(f"[DETACH DEBUG] playlist_sidebar.title_bar_widget was_visible={was_visible}, now hidden")
        
        # Show it in the detached window after it's been moved
        print("[DETACH DEBUG] Showing playlist_sidebar in detached window")
        logger.debug("[DETACH DEBUG] Showing playlist_sidebar in detached window")
        self.playlist_sidebar.show()
        
        # Final check of layout after adding
        print(f"[DETACH DEBUG] Detached window layout has {layout.count() if layout else 0} items after adding playlist_sidebar")
        if layout:
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.widget():
                    widget = item.widget()
                    print(f"[DETACH DEBUG]   Final item {i}: {type(widget).__name__}, visible={widget.isVisible()}")
                    if widget == self.playlist_sidebar and hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                        print(f"[DETACH DEBUG]     playlist_sidebar.title_bar_widget visible={self.playlist_sidebar.title_bar_widget.isVisible()}")
        
        # Debug: Check what widgets are visible on main window that might cause black overlay
        print(f"[DETACH DEBUG] Main window widgets state after detach:")
        logger.debug(f"[DETACH DEBUG] Main window widgets state after detach:")
        if hasattr(self, 'playlist_container'):
            print(f"  playlist_container: visible={self.playlist_container.isVisible()}, geometry={self.playlist_container.geometry()}")
            logger.debug(f"  playlist_container: visible={self.playlist_container.isVisible()}, geometry={self.playlist_container.geometry()}")
        if hasattr(self, 'loading_overlay'):
            print(f"  loading_overlay: visible={self.loading_overlay.isVisible()}, geometry={self.loading_overlay.geometry()}")
            logger.debug(f"  loading_overlay: visible={self.loading_overlay.isVisible()}, geometry={self.loading_overlay.geometry()}")
        if hasattr(self, 'web_view'):
            print(f"  web_view: visible={self.web_view.isVisible() if self.web_view else False}")
            logger.debug(f"  web_view: visible={self.web_view.isVisible() if self.web_view else False}")
        if hasattr(self, 'regular_player_widget'):
            print(f"  regular_player_widget: visible={self.regular_player_widget.isVisible() if self.regular_player_widget else False}")
            logger.debug(f"  regular_player_widget: visible={self.regular_player_widget.isVisible() if self.regular_player_widget else False}")
        
        # Make playlist expand to fill detached window
        self.playlist_sidebar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        # NOTE: We intentionally do not save attached height here anymore (after reparenting),
        # because the detach layout can change the widget's height and would overwrite the user's
        # custom attached regular-mode height.
        
        # Remove fixed height constraints - clear any fixed height that might have been set
        # On Windows 10, we need to be careful with size constraints to avoid negative size errors
        # Don't use setFixedHeight(-1) as it can cause Qt to interpret sizes incorrectly
        # Instead, just set min/max and let size policy handle expansion
        # First ensure we have a valid size before changing constraints
        if self.playlist_sidebar.height() <= 0:
            self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
        
        self.playlist_sidebar.setMaximumHeight(16777215)  # Qt's maximum value
        # Use a small positive minimum instead of 0 to avoid Qt's negative size detection on Windows 10
        self.playlist_sidebar.setMinimumHeight(1)  # Minimum of 1px instead of 0 to avoid negative size errors
        
        # Force layout update to ensure playlist fills the window immediately
        layout.update()
        layout.activate()
        self.playlist_sidebar.updateGeometry()
        QApplication.processEvents()
        
        # Trigger a resize to force layout recalculation (fixes initial sizing issue on Windows 10)
        def force_layout_update():
            if hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
                current_size = self.detached_playlist_window.size()
                # Trigger resize by setting size to itself (forces layout recalculation)
                self.detached_playlist_window.resize(current_size.width(), current_size.height() + 1)
                QApplication.processEvents()
                self.detached_playlist_window.resize(current_size.width(), current_size.height())
        QTimer.singleShot(10, force_layout_update)
        
        # Create resize handle if it doesn't exist yet (it will be created after window is shown)
        # But if it exists, ensure it's on top after playlist is added
        if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
            QTimer.singleShot(50, lambda: (
                self._update_detached_bottom_resize_handle_position() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None,
                self.detached_bottom_resize_handle.raise_() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None
            ))
        
        # If in mini mode, update layout BEFORE hiding container to prevent black flash
        if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 1:
            # Ensure regular player widget is properly positioned and visible before hiding playlist
            if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                # Ensure widget is visible and raised
                if not self.regular_player_widget.isVisible():
                    self.regular_player_widget.show()
                self.regular_player_widget.raise_()
                
                central_widget = self.centralWidget()
                if central_widget:
                    rect = central_widget.rect()
                    top_offset = 0
                    if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                        top_offset = self.title_bar.height()
                    # Position player widget to fill the space (will be resized after container is hidden)
                    widget_height = 260
                    self.regular_player_widget.setGeometry(0, top_offset, rect.width(), widget_height)
                    # Ensure cover art and player section are positioned and visible
                    if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                        if not self.regular_player_widget.cover_art_label.isVisible():
                            self.regular_player_widget.cover_art_label.show()
                        self.regular_player_widget.cover_art_label.setGeometry(0, 0, rect.width(), widget_height)
                        self.regular_player_widget.cover_art_label.lower()
                    if hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                        player_section = self.regular_player_widget.player_section
                        if not player_section.isVisible():
                            player_section.show()
                        player_height = player_section.height()
                        bottom_y = widget_height - player_height
                        player_section.setGeometry(0, bottom_y, rect.width(), player_height)
                        player_section.raise_()
                    # Force repaint to ensure everything is visible before hiding container
                    self.regular_player_widget.repaint()
                    QApplication.processEvents()
        
        # Hide playlist container in main window
        if hasattr(self, 'playlist_container'):
            self.playlist_container.hide()
            # Don't set geometry to 0,0,0,0 as it breaks restoration
            # Just hide it and let the resize handle the space
        if hasattr(self, 'playlist_resize_handle'):
            self.playlist_resize_handle.hide()
        
        # NO RESIZE NEEDED! The detached playlist is a separate window.
        # Just hide the container like toggle_playlist does - that's it!
        # The window stays the same size, container is just hidden.
        
        # OLD RESIZE LOGIC DISABLED - not needed since detached playlist is separate window
        if False and hasattr(self, 'mini_mode_state') and self.mini_mode_state == 1:
            print(f"[DEBUG] _detach_playlist: In mini mode, resizing for playlist detached")
            # Ensure playlist container and sidebar are hidden (should already be done above, but double-check)
            if hasattr(self, 'playlist_container') and self.playlist_container:
                if self.playlist_container.isVisible():
                    print("[DETACH DEBUG] Container still visible before resize, hiding it")
                    self.playlist_container.hide()
                    self.playlist_container.setVisible(False)
                    self.playlist_container.setGeometry(0, 0, 0, 0)
            # Force repaint of background (cover art) before resize to prevent black flash
            if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                    print("[DETACH DEBUG] Forcing cover art repaint before resize")
                    self.regular_player_widget.cover_art_label.update()
                    self.regular_player_widget.cover_art_label.repaint()
                self.regular_player_widget.update()
                self.regular_player_widget.repaint()
            # Force layout update to ensure visibility changes are reflected
            layout = self.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            # CRITICAL: Update player widget geometry to fill window after detach
            # In mini mode, player widget is positioned absolutely and needs to be resized
            def update_player_widget_geometry_after_detach():
                print("[DETACH DEBUG] Updating player widget geometry after detach")
                logger.debug("[DETACH DEBUG] Updating player widget geometry after detach")
                if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                    central_widget = self.centralWidget()
                    if central_widget:
                        rect = central_widget.rect()
                        top_offset = 0
                        if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                            top_offset = self.title_bar.height()
                        # In mini mode, widget should fill the window (260px + title bar)
                        widget_height = rect.height() - top_offset
                        print(f"[DETACH DEBUG] Setting player widget geometry: x=0, y={top_offset}, w={rect.width()}, h={widget_height}")
                        logger.debug(f"[DETACH DEBUG] Setting player widget geometry: x=0, y={top_offset}, w={rect.width()}, h={widget_height}")
                        self.regular_player_widget.setGeometry(0, top_offset, rect.width(), widget_height)
                        # Update cover art to fill widget
                        if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                            self.regular_player_widget.cover_art_label.setGeometry(0, 0, rect.width(), widget_height)
                            self.regular_player_widget.cover_art_label.lower()
                        # Update player section position
                        if hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                            player_section = self.regular_player_widget.player_section
                            player_height = player_section.height()
                            bottom_y = widget_height - player_height
                            player_section.setGeometry(0, bottom_y, rect.width(), player_height)
                            player_section.raise_()
            # Force full window repaint after detach (especially important when paused)
            # When paused, playback updates don't trigger repaints, so we need to force it
            def force_window_repaint(update_geometry=True):
                print("[DETACH DEBUG] Forcing full window repaint after detach")
                logger.debug("[DETACH DEBUG] Forcing full window repaint after detach")
                # Only update geometry if requested (not on every repaint)
                if update_geometry:
                    update_player_widget_geometry_after_detach()
                # Repaint the entire window to clear any black overlay
                self.update()
                self.repaint()
                # Also repaint central widget and all child widgets
                central_widget = self.centralWidget()
                if central_widget:
                    central_widget.update()
                    central_widget.repaint()
                # Force repaint of player widget and cover art
                if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                    self.regular_player_widget.update()
                    self.regular_player_widget.repaint()
                    if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                        self.regular_player_widget.cover_art_label.update()
                        self.regular_player_widget.cover_art_label.repaint()
                QApplication.processEvents()
            # Force repaint immediately (with geometry update)
            force_window_repaint(update_geometry=True)
            QApplication.processEvents()
            # Schedule a few strategic delayed repaints (repaints only, no geometry updates to avoid resizes)
            QTimer.singleShot(10, lambda: force_window_repaint(update_geometry=False))
            QTimer.singleShot(50, lambda: force_window_repaint(update_geometry=False))
            QTimer.singleShot(100, lambda: force_window_repaint(update_geometry=False))
            # SIMPLIFIED: Since container is removed from layout, just update player widget and resize if needed
            # The container removal should prevent layout recalculation issues
            def update_after_detach():
                print(f"[DEBUG] _detach_playlist: Updating layout after detach (container removed from layout)")
                logger.debug(f"[DEBUG] _detach_playlist: Updating layout after detach (container removed from layout)")
                
                # Calculate target window size (base height without playlist)
                title_bar_height = 0
                if hasattr(self, 'title_bar') and self.title_bar and self.title_bar.isVisible():
                    title_bar_height = self.title_bar.height()
                base_height = 260 + title_bar_height  # Cover art (260px) + title bar
                current_height = self.height()
                
                # Update player widget geometry to match current window size
                if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                    central_widget = self.centralWidget()
                    if central_widget:
                        top_offset = title_bar_height
                        widget_height = current_height - top_offset  # Fill remaining space
                        current_width = self.width()
                        
                        print(f"[DETACH DEBUG] Updating player widget to current window size: w={current_width}, h={widget_height}")
                        # Update player widget to fill the current window
                        self.regular_player_widget.setGeometry(0, top_offset, current_width, widget_height)
                        # Update cover art (but keep it at 260px height, not filling entire widget)
                        if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                            # Cover art should be 260px, positioned at top of widget
                            self.regular_player_widget.cover_art_label.setGeometry(0, 0, current_width, 260)
                            self.regular_player_widget.cover_art_label.lower()
                        # Update player section
                        if hasattr(self.regular_player_widget, 'player_section') and self.regular_player_widget.player_section:
                            player_section = self.regular_player_widget.player_section
                            player_height = player_section.height()
                            # Position at bottom of cover art (260px)
                            bottom_y = 260 - player_height
                            player_section.setGeometry(0, bottom_y, current_width, player_height)
                            player_section.raise_()
                        # Force immediate repaint
                        self.regular_player_widget.update()
                        self.regular_player_widget.repaint()
                        if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                            self.regular_player_widget.cover_art_label.update()
                            self.regular_player_widget.cover_art_label.repaint()
                        # Repaint central widget to fill any remaining space
                        central_widget.update()
                        central_widget.repaint()
                        # Repaint main window
                        self.update()
                        self.repaint()
                        QApplication.processEvents()
                        
                        # Schedule a few strategic delayed repaints (only repaints, no geometry updates)
                        def delayed_repaint():
                            self.regular_player_widget.update()
                            self.regular_player_widget.repaint()
                            if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                                self.regular_player_widget.cover_art_label.update()
                                self.regular_player_widget.cover_art_label.repaint()
                            central_widget.update()
                            central_widget.repaint()
                            self.update()
                            self.repaint()
                            QApplication.processEvents()
                        QTimer.singleShot(10, delayed_repaint)
                        QTimer.singleShot(50, delayed_repaint)
                        QTimer.singleShot(150, delayed_repaint)
                
                # Only resize if window is larger than base height (playlist was taking space)
                if current_height > base_height:
                    print(f"[DETACH DEBUG] Window height ({current_height}) > base height ({base_height}), resizing to base height")
                    # Resize to base height
                    actual_visible = False  # Playlist is detached
                    self._resize_mini_mode_for_playlist(actual_visible)
                    # After resize, update player widget and repaint (just once, not many times)
                    QTimer.singleShot(10, lambda: (
                        update_player_widget_geometry_after_detach(),
                        force_window_repaint(update_geometry=False)
                    ))
                    # One more repaint after a short delay
                    QTimer.singleShot(50, lambda: force_window_repaint(update_geometry=False))
                else:
                    print(f"[DETACH DEBUG] Window already at base height ({current_height}), no resize needed")
                    # No resize needed - just ensure everything is repainted (repaints only, no geometry updates)
                    force_window_repaint(update_geometry=False)
                    QTimer.singleShot(50, lambda: force_window_repaint(update_geometry=False))
            # Update after a short delay to let container removal complete
            print(f"[DEBUG] _detach_playlist: Scheduling layout update (container removed from layout)")
            QTimer.singleShot(50, update_after_detach)
        
        # Update player section position when playlist is detached (treat as resize event)
        # The playlist is now hidden in the main window, so player should reset
        # Use a delay to ensure the playlist container is fully hidden first
        print(f"[DEBUG] _detach_playlist: Playlist detached, scheduling _update_player_section_position")
        QTimer.singleShot(50, lambda: (
            print(f"[DEBUG] _detach_playlist: Calling _update_player_section_position (delayed)"),
            self._update_player_section_position() if hasattr(self, '_update_player_section_position') else None,
            QTimer.singleShot(10, self._update_player_section_position) if hasattr(self, '_update_player_section_position') else None,
            QTimer.singleShot(50, self._update_player_section_position) if hasattr(self, '_update_player_section_position') else None,
            QTimer.singleShot(100, self._update_player_section_position) if hasattr(self, '_update_player_section_position') else None,
            QTimer.singleShot(200, self._update_player_section_position) if hasattr(self, '_update_player_section_position') else None
        ))
        
        # Update detach button icon to "attach" icon
        if hasattr(self.playlist_sidebar, 'detach_btn') and self.playlist_sidebar.detach_btn:
            if HAS_QT_AWESOME:
                # Try multiple icon options for attach
                icon = None
                for icon_name in ['fa5s.window-maximize', 'fa5.window-maximize', 'ei.arrow-down', 'fa5s.compress']:
                    try:
                        icon = get_icon(icon_name, color='#e0e0e0')
                        if icon:
                            break
                    except:
                        continue
                if icon:
                    self.playlist_sidebar.detach_btn.setIcon(icon)
                else:
                    self.playlist_sidebar.detach_btn.setText("")
            else:
                self.playlist_sidebar.detach_btn.setText("")
            self.playlist_sidebar.detach_btn.setToolTip("Attach Playlist to Main Window")
        
        # Update state
        self.playlist_detached = True

        # Hide playlist quick button when detached
        try:
            self.update_playlist_quick_btn_visibility()
        except Exception:
            pass
        
        # NO RESIZE NEEDED! The detached playlist is a separate window.
        # The main window stays the same size - just the container is hidden.
        # Removed resize calls - not needed since detached playlist is separate window
        # if self.mini_mode_state == 1:
        #     QTimer.singleShot(100, self.resize_to_mini_mode)
        # elif self.mini_mode_state == 2:
        #     QTimer.singleShot(50, self._resize_to_micro_mode_with_retry)
        
        # Save settings
        self._save_playlist_detach_state()
    
    def _update_detached_repeat_overlay(self, repeat_mode):
        """Update overlay on detached playlist repeat button based on mode:
        - Mode 3 (Track): "1" overlay (white)
        - Other modes: no overlay
        """
        if not hasattr(self, '_detached_repeat_btn') or not self._detached_repeat_btn:
            return
        
        # Remove existing overlay if it exists
        if hasattr(self, '_detached_repeat_overlay_label') and self._detached_repeat_overlay_label is not None:
            try:
                self._detached_repeat_overlay_label.deleteLater()
            except (AttributeError, RuntimeError):
                pass  # Label might already be deleted
            self._detached_repeat_overlay_label = None
        
        # Show overlay only for mode 3 ("1")
        if repeat_mode == 3:
            # Create overlay label
            from PyQt6.QtWidgets import QLabel
            from PyQt6.QtCore import Qt
            
            # Set overlay text to "1" for mode 3
            overlay_text = "1"
            
            # Set overlay color: white for mode 3 (track)
            overlay_color = 'white'
            
            # Create overlay as child of button's parent widget to ensure it's on top
            # Get the button's parent widget (the container)
            button_parent = self._detached_repeat_btn.parent()
            if button_parent:
                self._detached_repeat_overlay_label = QLabel(overlay_text, button_parent)
            else:
                # Fallback to button itself if no parent
                self._detached_repeat_overlay_label = QLabel(overlay_text, self._detached_repeat_btn)
            
            self._detached_repeat_overlay_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            # Make overlay transparent to mouse events so clicks pass through to button
            self._detached_repeat_overlay_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._detached_repeat_overlay_label.setStyleSheet(f"""
                QLabel {{
                    background-color: transparent;
                    color: {overlay_color};
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                }}
            """)
            # Position will be updated when button is shown/resized
            # Use a method to update position
            def update_overlay_position():
                if hasattr(self, '_detached_repeat_overlay_label') and self._detached_repeat_overlay_label and self._detached_repeat_btn:
                    try:
                        # Get button position relative to its parent widget
                        btn_pos = self._detached_repeat_btn.pos()
                        btn_size = self._detached_repeat_btn.size()
                        overlay_size = 12  # Smaller overlay to ensure it stays within button bounds
                        # Calculate position relative to button's parent, centered on button
                        x = btn_pos.x() + (btn_size.width() - overlay_size) // 2
                        y = btn_pos.y() + (btn_size.height() - overlay_size) // 2
                        # Ensure overlay stays within button bounds
                        x = max(btn_pos.x(), min(x, btn_pos.x() + btn_size.width() - overlay_size))
                        y = max(btn_pos.y(), min(y, btn_pos.y() + btn_size.height() - overlay_size))
                        self._detached_repeat_overlay_label.setGeometry(x, y, overlay_size, overlay_size)
                        self._detached_repeat_overlay_label.show()
                        self._detached_repeat_overlay_label.raise_()
                    except (RuntimeError, AttributeError):
                        pass  # Button or overlay might have been deleted
            
            # Update position immediately and on button resize
            QTimer.singleShot(0, update_overlay_position)
            # Use multiple delays to ensure button is fully rendered and positioned
            QTimer.singleShot(50, update_overlay_position)
            QTimer.singleShot(100, update_overlay_position)
            QTimer.singleShot(200, update_overlay_position)
        else:
            # Ensure overlay is removed for other modes
            if hasattr(self, '_detached_repeat_overlay_label') and self._detached_repeat_overlay_label:
                self._detached_repeat_overlay_label.hide()
    
    def _update_detached_shuffle_button_icon(self):
        """Update the detached shuffle button icon based on current mode."""
        if not hasattr(self, '_detached_shuffle_btn') or not self._detached_shuffle_btn:
            return
        
        try:
            # Check if button is still valid
            _ = self._detached_shuffle_btn.isVisible()
        except (RuntimeError, AttributeError):
            return
        
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        try:
            shuffle_mode = getattr(self.playlist_sidebar, 'shuffle_mode', 0)
            self._detached_shuffle_btn.blockSignals(True)
            
            # Update checked state
            is_active = shuffle_mode > 0
            self._detached_shuffle_btn.setChecked(is_active)
            
            # Update icon based on mode
            if HAS_QT_AWESOME:
                if shuffle_mode == 0:
                    icon_color = '#a0a0a0'
                    icon = get_icon('random', color=icon_color)
                    tooltip = "Shuffle: Off"
                elif shuffle_mode == 1:
                    icon_color = '#4a90e2'
                    icon = get_icon('random', color=icon_color)
                    tooltip = "Shuffle: Tracks (shuffle tracks in album)"
                elif shuffle_mode == 2:
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.question', color=icon_color)
                    tooltip = "Shuffle: Albums (randomize album order)"
                else:  # mode 3
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.asl', color=icon_color)
                    tooltip = "Super Shuffle (random album & track)"
                
                if icon:
                    # Clear and set icon to force refresh
                    self._detached_shuffle_btn.setIcon(QIcon())
                    QApplication.processEvents()
                    self._detached_shuffle_btn.setIcon(icon)
                    self._detached_shuffle_btn.setToolTip(tooltip)
                    # Force update
                    self._detached_shuffle_btn.update()
                    self._detached_shuffle_btn.repaint()
                    if self._detached_shuffle_btn.parent():
                        self._detached_shuffle_btn.parent().update()
                    # Process events to ensure visual update
                    QApplication.processEvents()
            
            self._detached_shuffle_btn.blockSignals(False)
        except (RuntimeError, AttributeError):
            pass
    
    def _update_detached_repeat_button_icon(self):
        """Update the detached repeat button icon based on current mode."""
        if not hasattr(self, '_detached_repeat_btn') or not self._detached_repeat_btn:
            return
        
        try:
            # Check if button is still valid
            _ = self._detached_repeat_btn.isVisible()
        except (RuntimeError, AttributeError):
            return
        
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        try:
            repeat_mode = getattr(self.playlist_sidebar, 'repeat_mode', 0)
            self._detached_repeat_btn.blockSignals(True)
            
            # Update checked state
            is_active = repeat_mode > 0
            self._detached_repeat_btn.setChecked(is_active)
            
            # Update icon based on mode
            if HAS_QT_AWESOME:
                if repeat_mode == 0:
                    icon_color = '#a0a0a0'
                    icon = get_icon('ei.repeat', color=icon_color)
                    tooltip = "Repeat: Off"
                elif repeat_mode == 1:
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.repeat', color=icon_color)
                    tooltip = "Repeat: Continuous (play next album)"
                elif repeat_mode == 2:
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.heart', color=icon_color)
                    tooltip = "Repeat: Album (loop current album)"
                else:  # mode 3
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.heart', color=icon_color)
                    tooltip = "Repeat: Track (loop current track)"
                
                if icon:
                    # Clear and set icon to force refresh
                    self._detached_repeat_btn.setIcon(QIcon())
                    QApplication.processEvents()
                    self._detached_repeat_btn.setIcon(icon)
                    self._detached_repeat_btn.setToolTip(tooltip)
                    # Force update
                    self._detached_repeat_btn.update()
                    self._detached_repeat_btn.repaint()
                    if self._detached_repeat_btn.parent():
                        self._detached_repeat_btn.parent().update()
                    # Process events to ensure visual update
                    QApplication.processEvents()
            
            self._detached_repeat_btn.blockSignals(False)
            
            # Update overlay
            if hasattr(self, '_update_detached_repeat_overlay'):
                QTimer.singleShot(0, lambda: self._update_detached_repeat_overlay(repeat_mode))
        except (RuntimeError, AttributeError):
            pass
    
    def _reattach_playlist(self):
        """Reattach playlist to main window."""
        print(f"[REATTACH DEBUG] _reattach_playlist called")
        if not self.playlist_detached or not self.detached_playlist_window:
            print(f"[REATTACH DEBUG] Early return: playlist_detached={getattr(self, 'playlist_detached', False)}, window_exists={hasattr(self, 'detached_playlist_window') and self.detached_playlist_window is not None}")
            return
        
        # Check saved visibility state
        saved_visible = self.settings.get('playlist_visible', True)
        saved_minimized = self.settings.get('playlist_attached_minimized', False)
        print(f"[REATTACH DEBUG] Saved state: playlist_visible={saved_visible}, playlist_attached_minimized={saved_minimized}")
        
        # Save detached window position and size before closing
        try:
            pos = self.detached_playlist_window.pos()
            size = self.detached_playlist_window.size()
            main_pos = self.pos()
            
            # Save docking state if windows were docked OR if linking is enabled (snapped together)
            # If linking is enabled, windows are positioned relative to each other, so we should save relative positioning
            was_docked = hasattr(self, '_windows_docked') and self._windows_docked
            is_linked = hasattr(self, 'playlist_window_linked') and self.playlist_window_linked
            docked_edge = getattr(self, '_windows_docked_edge', None) if was_docked else None
            
            # If docked OR linked, save relative positioning
            if (was_docked and docked_edge) or is_linked:
                # Calculate and save relative offset (detached position relative to main position)
                # This ensures the playlist reopens in the correct relative position
                # Use the current offset (which is already calculated correctly for linked windows)
                if is_linked and hasattr(self, '_playlist_window_link_offset') and self._playlist_window_link_offset:
                    # If linked, use the link offset (most accurate for snapped windows)
                    offset_x, offset_y = self._playlist_window_link_offset
                else:
                    # Calculate offset from current positions
                    main_rect = self.geometry()
                    detached_rect = self.detached_playlist_window.geometry()
                    offset_x = detached_rect.x() - main_rect.x()
                    offset_y = detached_rect.y() - main_rect.y()
                
                self.playlist_detached_offset = (offset_x, offset_y)
                # Don't save absolute position when docked/linked - use relative positioning instead
                self.playlist_detached_position = None
            else:
                # Not docked - save both absolute position and relative offset
                self.playlist_detached_position = (pos.x(), pos.y())
                self.playlist_detached_offset = (pos.x() - main_pos.x(), pos.y() - main_pos.y())
            
            self.playlist_detached_size = f"{size.width()}x{size.height()}"
            
            # Save docking/linking state and offset to settings (so linking uses correct offset when reopening)
            self.settings['playlist_was_docked'] = was_docked or is_linked  # Treat linked as "docked" for reopening
            self.settings['playlist_docked_edge'] = docked_edge
            self.settings['playlist_was_linked'] = is_linked  # Also save linking state separately
            self.settings['playlist_detached_offset'] = self.playlist_detached_offset
            self.save_settings()
        except Exception as e:
            logger.debug(f"Error saving detached playlist position: {e}")
        
        # Ensure playlist container and resize handle exist (they might not if playlist started detached)
        if not hasattr(self, 'playlist_container') or not self.playlist_container:
            # Create container and resize handle if they don't exist
            layout = self.centralWidget().layout()
            
            # Create container widget for playlist and resize handle
            playlist_container = QWidget()
            playlist_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            playlist_container.setMinimumHeight(0)
            playlist_container_layout = QVBoxLayout(playlist_container)
            playlist_container_layout.setContentsMargins(0, 0, 0, 0)
            playlist_container_layout.setSpacing(0)
            
            # Resize handle (horizontal bar at top of playlist)
            resize_handle = QWidget()
            resize_handle.setFixedHeight(0)  # Start with 0 height since it's hidden
            resize_handle.setStyleSheet("""
                QWidget {
                    background-color: transparent;
                }
                QWidget:hover {
                    background-color: transparent;
                }
            """)
            resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)  # Vertical resize cursor
            resize_handle.hide()  # Hidden by default, shown when playlist is visible
            resize_handle.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
            playlist_container_layout.addWidget(resize_handle)
            
            # Store references
            self.playlist_container = playlist_container
            self.playlist_resize_handle = resize_handle
            self.playlist_start_resize_y = None
            self.playlist_start_height = None
            
            # Setup resize handle mouse events
            def resize_handle_mouse_press(event):
                # Don't allow resizing when playlist is minimized
                if self.playlist_sidebar.is_minimized:
                    return
                # Don't allow resizing in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    return
                # Don't allow resizing if playlist is detached (detached playlist has its own resize handle)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    return
                if event.button() == Qt.MouseButton.LeftButton:
                    self.playlist_start_resize_y = event.globalPosition().y()
                    self.playlist_start_height = self.playlist_sidebar.height()
            
            def resize_handle_mouse_move(event):
                # Don't allow resizing when playlist is minimized
                if self.playlist_sidebar.is_minimized:
                    return
                # Don't allow resizing in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    return
                # Don't allow resizing if playlist is detached (detached playlist has its own resize handle)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    return
                if self.playlist_start_resize_y is not None and event.buttons() & Qt.MouseButton.LeftButton:
                    delta_y = self.playlist_start_resize_y - event.globalPosition().y()  # Inverted: drag up = increase height
                    new_height = self.playlist_start_height + delta_y
                    # Clamp between minimum and maximum and convert to int
                    new_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, new_height)))
                    self.playlist_sidebar.setFixedHeight(new_height)
                    # Ensure playlist stays above loading overlay during resize
                    if hasattr(self, 'playlist_container') and self.playlist_container:
                        self.playlist_container.raise_()
                    # Update player section position (attaches to playlist top and moves with it)
                    if hasattr(self, '_update_player_section_position'):
                        QTimer.singleShot(10, self._update_player_section_position)
            
            def resize_handle_mouse_release(event):
                # Don't save height if in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    self.playlist_start_resize_y = None
                    self.playlist_start_height = None
                    return
                # Don't save height if playlist is detached (detached playlist handles its own saving)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    self.playlist_start_resize_y = None
                    self.playlist_start_height = None
                    return
                
                # Store the new height for restore after minimize (only in regular mode)
                if self.playlist_sidebar:
                    new_height = self.playlist_sidebar.height()
                    self.playlist_sidebar._restore_height = new_height
                    # Save playlist height to settings (only in regular mode)
                    self.settings['playlist_height'] = new_height
                    # Also save to playlist_height_regular for regular mode
                    self.settings['playlist_height_regular'] = new_height
                    # CRITICAL: keep attached height in sync so detach/reattach + mode cycling restores correctly
                    self.settings['playlist_attached_height'] = new_height
                    self.save_settings()
                
                self.playlist_start_resize_y = None
                self.playlist_start_height = None
                
                # After drag ends, check if mouse is outside address bar and hide if autohide is enabled
                if self.autohide_address_bar and hasattr(self, 'controls_bar_widget'):
                    # Use a small delay to allow mouse position to settle
                    QTimer.singleShot(50, self.check_and_hide_address_bar_after_drag)
            
            resize_handle.mousePressEvent = resize_handle_mouse_press
            resize_handle.mouseMoveEvent = resize_handle_mouse_move
            resize_handle.mouseReleaseEvent = resize_handle_mouse_release
            
            # Add container to layout, aligned to bottom
            layout.addWidget(playlist_container, 0, Qt.AlignmentFlag.AlignBottom)
            playlist_container.raise_()
            layout.update()
            layout.activate()
        else:
            # Container already exists - make sure it's in the layout
            layout = self.centralWidget().layout()
            if layout:
                # Check if container is already in layout
                container_in_layout = False
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if item and item.widget() == self.playlist_container:
                        container_in_layout = True
                        break
                # If not in layout, add it back
                if not container_in_layout:
                    print("[DEBUG] _reattach_playlist: Adding existing container back to layout")
                    logger.debug("[DEBUG] _reattach_playlist: Adding existing container back to layout")
                    layout.addWidget(self.playlist_container, 0, Qt.AlignmentFlag.AlignBottom)
                    self.playlist_container.raise_()
                    layout.update()
                    layout.activate()
        
        # Move playlist sidebar back to main window
        print(f"[REATTACH DEBUG] Moving playlist_sidebar back to main window")
        if self.playlist_sidebar:
            print(f"[REATTACH DEBUG] playlist_sidebar exists, current visible: {self.playlist_sidebar.isVisible()}, parent: {self.playlist_sidebar.parent()}")
            layout = self.detached_playlist_window.layout()
            layout.removeWidget(self.playlist_sidebar)
            print(f"[REATTACH DEBUG] Removed from detached window layout, visible: {self.playlist_sidebar.isVisible()}")
            
            # Add back to main window container
            if hasattr(self, 'playlist_container'):
                print(f"[REATTACH DEBUG] playlist_container exists: {self.playlist_container is not None}")
                playlist_container_layout = self.playlist_container.layout()
                if playlist_container_layout:
                    # Remove any existing widget from the container (shouldn't be any, but just in case)
                    for i in range(playlist_container_layout.count()):
                        item = playlist_container_layout.itemAt(i)
                        if item and item.widget() == self.playlist_sidebar:
                            print(f"[REATTACH DEBUG] Removing existing playlist_sidebar from container layout")
                            playlist_container_layout.removeWidget(self.playlist_sidebar)
                    
                    # Add playlist back to container
                    print(f"[REATTACH DEBUG] Setting parent to playlist_container and adding to layout")
                    self.playlist_sidebar.setParent(self.playlist_container)
                    print(f"[REATTACH DEBUG] After setParent, visible: {self.playlist_sidebar.isVisible()}")
                    playlist_container_layout.addWidget(self.playlist_sidebar, 1)
                    print(f"[REATTACH DEBUG] After addWidget, visible: {self.playlist_sidebar.isVisible()}")
                    
                    # With layout-based approach, we don't need to position off-screen
                    # The layout handles positioning automatically
                    
                    # Show container and resize handle
                    print(f"[REATTACH DEBUG] Showing playlist_container")
                    self.playlist_container.show()
                    print(f"[REATTACH DEBUG] playlist_container visible after show: {self.playlist_container.isVisible()}")
                    # CRITICAL: Ensure playlist sidebar is visible if it was visible before detaching
                    # The playlist should be visible if it was expanded before detaching
                    playlist_should_be_visible = self.settings.get('playlist_visible', True)
                    print(f"[REATTACH DEBUG] playlist_should_be_visible from settings: {playlist_should_be_visible}")
                    if playlist_should_be_visible and self.playlist_sidebar:
                        print(f"[REATTACH DEBUG] Showing playlist_sidebar (was visible before detaching)")
                        self.playlist_sidebar.show()
                        self.playlist_sidebar.setVisible(True)
                        print(f"[REATTACH DEBUG] playlist_sidebar visible after show: {self.playlist_sidebar.isVisible()}")
                    else:
                        print(f"[REATTACH DEBUG] NOT showing playlist_sidebar: should_be_visible={playlist_should_be_visible}, sidebar_exists={self.playlist_sidebar is not None}")
                    # Restore resize handle visibility based on playlist visibility state
                    if hasattr(self, 'playlist_resize_handle'):
                        # Check if playlist should be visible (from settings or current state)
                        # Also check if sidebar is actually visible (might be set later)
                        playlist_is_visible = self.playlist_sidebar.isVisible() if self.playlist_sidebar else False
                        if playlist_should_be_visible or playlist_is_visible:
                            self.playlist_resize_handle.show()
                            self.playlist_resize_handle.setFixedHeight(4)  # Restore height when shown
                        else:
                            self.playlist_resize_handle.hide()
                            self.playlist_resize_handle.setFixedHeight(0)
                else:
                    print(f"[REATTACH DEBUG] ERROR: playlist_container has no layout!")
            else:
                print(f"[REATTACH DEBUG] ERROR: playlist_container doesn't exist!")
        else:
            print(f"[REATTACH DEBUG] ERROR: playlist_sidebar is None!")
        
        # Restore playlist title bar visibility
        if hasattr(self.playlist_sidebar, 'title_bar_widget'):
            self.playlist_sidebar.title_bar_widget.show()
        
        # Restore minimize button visibility
        if hasattr(self.playlist_sidebar, 'minimize_btn'):
            self.playlist_sidebar.minimize_btn.show()
        
        # Restore close button visibility
        if hasattr(self.playlist_sidebar, 'close_btn'):
            self.playlist_sidebar.close_btn.show()
        
        # Restore playlist sidebar width constraint
        if self.playlist_sidebar:
            self.playlist_sidebar.setMaximumWidth(260)  # Restore original constraint
        
        # Restore size policy and height constraints
        self.playlist_sidebar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)

        # CRITICAL: Ensure playlist sidebar is visible after reattaching
        # The sidebar might be hidden during the reparenting process
        print(f"[REATTACH DEBUG] Ensuring playlist_sidebar is visible after reparenting")
        if self.playlist_sidebar:
            print(f"[REATTACH DEBUG] playlist_sidebar exists, current visible: {self.playlist_sidebar.isVisible()}")
            self.playlist_sidebar.show()
            self.playlist_sidebar.setVisible(True)
            print(f"[REATTACH DEBUG] playlist_sidebar visible after show: {self.playlist_sidebar.isVisible()}")
        else:
            print(f"[REATTACH DEBUG] ERROR: playlist_sidebar is None!")
        
        # Restore attached minimized state exactly as it was before detaching
        try:
            desired_minimized = bool(self.settings.get('playlist_attached_minimized', self.settings.get('playlist_minimized', False)))
            print(f"[REATTACH DEBUG] Restoring minimized state: desired_minimized={desired_minimized}")
            if hasattr(self.playlist_sidebar, 'is_minimized'):
                current_minimized = bool(self.playlist_sidebar.is_minimized)
                print(f"[REATTACH DEBUG] Current minimized state: {current_minimized}")
                if desired_minimized != current_minimized:
                    print(f"[REATTACH DEBUG] Toggling minimized state to match desired state")
                    self.playlist_sidebar._toggle_minimize_state()
                    print(f"[REATTACH DEBUG] After toggle, is_minimized: {self.playlist_sidebar.is_minimized}")
                
                # CRITICAL: Recompute minimized geometry after restoring state (for all modes)
                # This ensures the minimized height is correctly calculated after reattach
                if self.playlist_sidebar.is_minimized:
                    if hasattr(self.playlist_sidebar, '_recompute_minimized_geometry_if_needed'):
                        # Use multiple delays to ensure layout has settled
                        QTimer.singleShot(0, self.playlist_sidebar._recompute_minimized_geometry_if_needed)
                        QTimer.singleShot(50, self.playlist_sidebar._recompute_minimized_geometry_if_needed)
                        QTimer.singleShot(100, self.playlist_sidebar._recompute_minimized_geometry_if_needed)
                        QTimer.singleShot(200, self.playlist_sidebar._recompute_minimized_geometry_if_needed)
                
                # CRITICAL: In mini/micro mode, immediately set the correct fixed height after restoring minimized state
                # This ensures _resize_mini_mode_for_playlist() gets the correct height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    if self.playlist_sidebar.is_minimized:
                        # Minimized: calculate and set minimized height
                        # Get title bar height + margins
                        title_bar_height = 0
                        if hasattr(self.playlist_sidebar, 'title_bar_widget') and self.playlist_sidebar.title_bar_widget:
                            title_bar_height = self.playlist_sidebar.title_bar_widget.height()
                            if title_bar_height == 0:
                                title_bar_height = self.playlist_sidebar.title_bar_widget.sizeHint().height()
                        if title_bar_height == 0:
                            title_bar_height = 30  # Fallback
                        # Add margins/padding (layout margins + outline)
                        minimized_height = title_bar_height + 4
                        print(f"[REATTACH DEBUG] Setting minimized height to {minimized_height}px (title_bar: {title_bar_height} + margins: 4)")
                        self.playlist_sidebar.setFixedHeight(minimized_height)
                        self.playlist_sidebar.updateGeometry()
                        # Also set container height if it exists
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            self.playlist_container.setMinimumHeight(minimized_height)
                            self.playlist_container.setMaximumHeight(minimized_height)
                            self.playlist_container.updateGeometry()
                    else:
                        # Expanded: set to 230px for mini/micro mode
                        print(f"[REATTACH DEBUG] Setting expanded height to 230px for mini/micro mode")
                        self.playlist_sidebar.setFixedHeight(230)
                        self.playlist_sidebar.updateGeometry()
                        # Clear container restrictions in mini mode (micro mode will set them later)
                        if self.mini_mode_state == 1 and hasattr(self, 'playlist_container') and self.playlist_container:
                            self.playlist_container.setMinimumHeight(0)
                            self.playlist_container.setMaximumHeight(16777215)
                            self.playlist_container.updateGeometry()
                    QApplication.processEvents()
        except Exception as e:
            print(f"[REATTACH DEBUG] Exception restoring minimized state: {e}")
            pass
        
        # CRITICAL: Ensure playlist container is visible and properly shown in layout
        # This is especially important when the playlist was expanded before detaching
        print(f"[REATTACH DEBUG] Ensuring playlist_container is visible and in layout")
        if hasattr(self, 'playlist_container') and self.playlist_container:
            print(f"[REATTACH DEBUG] playlist_container exists, current visible: {self.playlist_container.isVisible()}, geometry: {self.playlist_container.geometry()}")
            # Ensure container is in layout and layout is updated
            layout = self.centralWidget().layout()
            if layout:
                # Check if container is in layout
                container_in_layout = False
                for i in range(layout.count()):
                    item = layout.itemAt(i)
                    if item and item.widget() == self.playlist_container:
                        container_in_layout = True
                        break
                print(f"[REATTACH DEBUG] Container in layout: {container_in_layout}")
                if not container_in_layout:
                    # Add to layout if not already there
                    print(f"[REATTACH DEBUG] Adding container to layout")
                    layout.addWidget(self.playlist_container, 0, Qt.AlignmentFlag.AlignBottom)
                
                # CRITICAL: Show container and ensure it's visible with proper size policy
                self.playlist_container.show()
                self.playlist_container.setVisible(True)
                # Ensure container has proper size policy for layout
                self.playlist_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
                # In mini mode, always clear restrictions (like working version)
                # In micro mode, container height will be set by _resize_mini_mode_for_playlist
                if not (hasattr(self, 'mini_mode_state') and self.mini_mode_state == 2):
                    # Clear restrictions in regular and mini mode
                    self.playlist_container.setMinimumHeight(0)
                    self.playlist_container.setMaximumHeight(16777215)
                
                # Force layout update
                layout.update()
                layout.activate()
                self.playlist_container.updateGeometry()
                QApplication.processEvents()
                print(f"[REATTACH DEBUG] Layout updated, container visible: {self.playlist_container.isVisible()}, geometry: {self.playlist_container.geometry()}, height: {self.playlist_container.height()}")
        else:
            print(f"[REATTACH DEBUG] ERROR: playlist_container doesn't exist!")
        
        # Restore attached playlist height from settings (independent from detached window size)
        attached_height = self.settings.get('playlist_attached_height')
        if attached_height:
            # Restore the saved attached playlist height
            restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, attached_height))
            self.playlist_sidebar._restore_height = restore_height
            # Apply height deterministically after reparenting.
            # IMPORTANT: right after reparenting, Qt may report isVisible()==False briefly, so don't gate on it.
            try:
                if not self.playlist_sidebar.is_minimized:
                    self.playlist_sidebar.setFixedHeight(restore_height)
            except Exception:
                pass
            # Re-apply on the next event loop tick so the layout has settled (prevents snapping to ~230px)
            def _enforce_attached_height():
                try:
                    if not self.playlist_detached and self.playlist_sidebar and not self.playlist_sidebar.is_minimized:
                        self.playlist_sidebar.setFixedHeight(restore_height)
                        self.playlist_sidebar._restore_height = restore_height
                        # Ensure container isn't artificially constraining height
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            # In mini mode, always clear restrictions (like working version)
                            # In micro mode, container height will be set by _resize_mini_mode_for_playlist
                            if not (hasattr(self, 'mini_mode_state') and self.mini_mode_state == 2):
                                # Clear restrictions in regular and mini mode
                                self.playlist_container.setMaximumHeight(16777215)
                                self.playlist_container.setMinimumHeight(0)
                            self.playlist_container.updateGeometry()
                        layout = self.centralWidget().layout() if self.centralWidget() else None
                        if layout:
                            layout.update()
                            layout.activate()
                except Exception:
                    pass
            QTimer.singleShot(0, _enforce_attached_height)
        else:
            # No saved attached height, use default or current settings
            playlist_height = self.settings.get('playlist_height', PLAYLIST_DEFAULT_HEIGHT)
            if playlist_height == 135:  # Don't use micro mode height
                playlist_height = self.settings.get('playlist_height_regular', PLAYLIST_DEFAULT_HEIGHT)
            restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, playlist_height))
            self.playlist_sidebar._restore_height = restore_height
            try:
                if not self.playlist_sidebar.is_minimized:
                    self.playlist_sidebar.setFixedHeight(restore_height)
            except Exception:
                pass
            QTimer.singleShot(0, lambda: (
                self.playlist_sidebar.setFixedHeight(restore_height)
                if (not self.playlist_detached and self.playlist_sidebar and not self.playlist_sidebar.is_minimized)
                else None
            ))
        
        # Restore reasonable max height
        self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
        self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
        
        # Restore layout margins (remove bottom margin for resize handle)
        if hasattr(self, 'playlist_container') and self.playlist_container:
            playlist_container_layout = self.playlist_container.layout()
            if playlist_container_layout:
                playlist_container_layout.setContentsMargins(0, 0, 0, 0)
        
        # Update detach button icon back to "detach" icon
        if hasattr(self.playlist_sidebar, 'detach_btn') and self.playlist_sidebar.detach_btn:
            if HAS_QT_AWESOME:
                # Try multiple icon options for detach
                icon = None
                for icon_name in ['fa5s.external-link-alt', 'fa5.external-link', 'ei.external-link', 'fa5s.window-restore']:
                    try:
                        icon = get_icon(icon_name, color='#e0e0e0')
                        if icon:
                            break
                    except:
                        continue
                if icon:
                    self.playlist_sidebar.detach_btn.setIcon(icon)
                else:
                    self.playlist_sidebar.detach_btn.setText("")
            else:
                self.playlist_sidebar.detach_btn.setText("")
            self.playlist_sidebar.detach_btn.setToolTip("Detach Playlist to Separate Window")
        
        # Close detached window
        if hasattr(self, 'detached_playlist_title_bar'):
            self.detached_playlist_title_bar = None
        if hasattr(self, 'detached_bottom_resize_handle'):
            if self.detached_bottom_resize_handle:
                self.detached_bottom_resize_handle.deleteLater()
            self.detached_bottom_resize_handle = None
        if hasattr(self, 'detached_resize_start_y'):
            self.detached_resize_start_y = None
        if hasattr(self, 'detached_resize_start_height'):
            self.detached_resize_start_height = None
        if hasattr(self, 'detached_resize_start_x'):
            self.detached_resize_start_x = None
        if hasattr(self, 'detached_resize_start_width'):
            self.detached_resize_start_width = None
        if hasattr(self, 'detached_resize_start_pos'):
            self.detached_resize_start_pos = None
        self.detached_playlist_window.close()
        self.detached_playlist_window = None
        
        # Update state
        self.playlist_detached = False
        
        # Ensure resize handle is properly restored after reattach
        # Use a delay to ensure playlist sidebar visibility is set correctly
        def restore_resize_handle():
            if hasattr(self, 'playlist_resize_handle') and self.playlist_resize_handle:
                playlist_visible = self.settings.get('playlist_visible', True)
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    playlist_visible = playlist_visible or self.playlist_sidebar.isVisible()
                if playlist_visible:
                    self.playlist_resize_handle.show()
                    self.playlist_resize_handle.setFixedHeight(4)
                else:
                    self.playlist_resize_handle.hide()
                    self.playlist_resize_handle.setFixedHeight(0)
        QTimer.singleShot(50, restore_resize_handle)
        QTimer.singleShot(100, restore_resize_handle)

        # Update player section position when playlist is reattached (treat as resize event)
        # The playlist is now visible in the main window again, so player should update
        print(f"[DEBUG] _reattach_playlist: Playlist reattached, calling _update_player_section_position")
        if hasattr(self, '_update_player_section_position'):
            # Use a delay to ensure the playlist container is fully shown and positioned first
            QTimer.singleShot(50, lambda: (
                print(f"[DEBUG] _reattach_playlist: Calling _update_player_section_position (delayed)"),
                self._update_player_section_position(),
                QTimer.singleShot(10, self._update_player_section_position),
                QTimer.singleShot(50, self._update_player_section_position),
                QTimer.singleShot(100, self._update_player_section_position),
                QTimer.singleShot(200, self._update_player_section_position)
            ))

        # Re-evaluate playlist quick button after reattach
        try:
            self.update_playlist_quick_btn_visibility()
        except Exception:
            pass
        
        # CRITICAL: Ensure playlist button state matches the restored playlist visibility
        # If playlist was expanded before detaching, it should be visible and button should be checked
        print(f"[REATTACH DEBUG] Syncing playlist button state")
        if hasattr(self, 'playlist_btn') and self.playlist_btn:
            playlist_should_be_visible = (
                hasattr(self, 'playlist_sidebar') and 
                self.playlist_sidebar and 
                self.playlist_sidebar.isVisible()
            )
            print(f"[REATTACH DEBUG] playlist_should_be_visible: {playlist_should_be_visible}, button checked: {self.playlist_btn.isChecked()}")
            if self.playlist_btn.isChecked() != playlist_should_be_visible:
                print(f"[REATTACH DEBUG] Updating button checked state to: {playlist_should_be_visible}")
                self.playlist_btn.setChecked(playlist_should_be_visible)
        
        # CRITICAL: In regular mode, ensure window resizes correctly when playlist is reattached
        if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 0:
            print(f"[REATTACH DEBUG] In regular mode, resizing window for reattached playlist")
            # Determine if playlist should be visible
            playlist_visible = (
                hasattr(self, 'playlist_sidebar') and 
                self.playlist_sidebar and 
                self.playlist_sidebar.isVisible()
            )
            print(f"[REATTACH DEBUG] Resizing for playlist_visible: {playlist_visible}")
            # Use multiple delays to ensure layout has settled
            def resize_regular_mode_for_reattach():
                # Check actual visibility instead of relying on parameter
                actual_visible = (
                    hasattr(self, 'playlist_sidebar') and 
                    self.playlist_sidebar and 
                    self.playlist_sidebar.isVisible()
                )
                # If playlist is minimized, ensure minimized height is correctly calculated
                if (hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and 
                    hasattr(self.playlist_sidebar, 'is_minimized') and self.playlist_sidebar.is_minimized):
                    if hasattr(self.playlist_sidebar, '_recompute_minimized_geometry_if_needed'):
                        self.playlist_sidebar._recompute_minimized_geometry_if_needed()
                # Update player section position when playlist is reattached
                if hasattr(self, '_update_player_section_position'):
                    self._update_player_section_position()
                # Force layout update
                layout = self.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                    QApplication.processEvents()
            QTimer.singleShot(50, resize_regular_mode_for_reattach)
            QTimer.singleShot(100, resize_regular_mode_for_reattach)
            QTimer.singleShot(150, resize_regular_mode_for_reattach)
            QTimer.singleShot(200, resize_regular_mode_for_reattach)
        # CRITICAL: In mini mode, resize window to accommodate the reattached playlist
        elif hasattr(self, 'mini_mode_state') and self.mini_mode_state == 1:
            print(f"[REATTACH DEBUG] In mini mode, resizing window for reattached playlist")
            # Determine if playlist should be visible
            playlist_visible = (
                hasattr(self, 'playlist_sidebar') and 
                self.playlist_sidebar and 
                self.playlist_sidebar.isVisible()
            )
            print(f"[REATTACH DEBUG] Resizing for playlist_visible: {playlist_visible}")
            if hasattr(self, '_resize_mini_mode_for_playlist'):
                self._debounced_resize_mini_mode(playlist_visible, delay=150)
        elif hasattr(self, 'mini_mode_state') and self.mini_mode_state == 2:
            # Micro mode: Use complex resize logic with multiple delays
            print(f"[REATTACH DEBUG] In micro mode, resizing window for reattached playlist")
            # Determine if playlist should be visible
            playlist_visible = (
                hasattr(self, 'playlist_sidebar') and 
                self.playlist_sidebar and 
                self.playlist_sidebar.isVisible()
            )
            print(f"[REATTACH DEBUG] Resizing for playlist_visible: {playlist_visible}")
            if hasattr(self, '_resize_mini_mode_for_playlist'):
                def resize_for_reattach():
                    # Check actual visibility instead of relying on parameter
                    actual_visible = (
                        hasattr(self, 'playlist_sidebar') and 
                        self.playlist_sidebar and 
                        self.playlist_sidebar.isVisible()
                    )
                    # If playlist is minimized, ensure minimized height is correctly calculated
                    if (hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and 
                        hasattr(self.playlist_sidebar, 'is_minimized') and self.playlist_sidebar.is_minimized):
                        if hasattr(self.playlist_sidebar, '_recompute_minimized_geometry_if_needed'):
                            self.playlist_sidebar._recompute_minimized_geometry_if_needed()
                    self._resize_mini_mode_for_playlist(actual_visible)
                    # Also trigger micro mode resize
                    self.resize_to_micro_mode()
                # Use multiple delays to ensure layout has settled
                QTimer.singleShot(50, resize_for_reattach)
                QTimer.singleShot(100, resize_for_reattach)
                QTimer.singleShot(150, resize_for_reattach)
                QTimer.singleShot(200, resize_for_reattach)
                QTimer.singleShot(300, resize_for_reattach)  # Extra delay for safety
        
        # Force a layout update and repaint to ensure everything is visible
        def finalize_reattach():
            try:
                print(f"[REATTACH DEBUG] finalize_reattach called")
                if hasattr(self, 'playlist_container') and self.playlist_container:
                    print(f"[REATTACH DEBUG] Finalizing: container visible before: {self.playlist_container.isVisible()}, geometry: {self.playlist_container.geometry()}, height: {self.playlist_container.height()}")
                    self.playlist_container.show()
                    self.playlist_container.setVisible(True)
                    self.playlist_container.update()
                    self.playlist_container.repaint()
                    print(f"[REATTACH DEBUG] Finalizing: container visible after: {self.playlist_container.isVisible()}, geometry: {self.playlist_container.geometry()}, height: {self.playlist_container.height()}")
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    print(f"[REATTACH DEBUG] Finalizing: sidebar visible before: {self.playlist_sidebar.isVisible()}")
                    self.playlist_sidebar.show()
                    self.playlist_sidebar.setVisible(True)
                    self.playlist_sidebar.update()
                    self.playlist_sidebar.repaint()
                    print(f"[REATTACH DEBUG] Finalizing: sidebar visible after: {self.playlist_sidebar.isVisible()}, is_minimized: {getattr(self.playlist_sidebar, 'is_minimized', 'N/A')}, height: {self.playlist_sidebar.height()}")
                layout = self.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                    QApplication.processEvents()
            except Exception as e:
                print(f"[REATTACH DEBUG] Exception in finalize_reattach: {e}")
                pass
        QTimer.singleShot(100, finalize_reattach)
        QTimer.singleShot(200, finalize_reattach)
    
    def _enter_nano_mode(self):
        """Enter nano mode: hide main window and detached playlist, show nano player."""
        if self._main_window_hidden_for_nano:
            return  # Already in nano mode
        
        # Ensure playlist is created before entering nano mode (needed for shuffle/repeat button sync)
        playlist_was_closed = False
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            # Playlist doesn't exist - create it to initialize shuffle/repeat states
            # This is needed so nano player can sync buttons correctly
            playlist_was_closed = True  # Assume it was closed since it doesn't exist
            self.toggle_playlist()  # Create playlist
            # Small delay to ensure playlist is fully initialized
            QApplication.processEvents()
            # Hide it again if it was supposed to be closed
            if playlist_was_closed:
                self.toggle_playlist()  # Hide playlist
                QApplication.processEvents()
        
        # Save playlist visibility state before hiding main window
        # This ensures we can restore it correctly when closing in nano mode
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
            self.settings['playlist_visible'] = self.playlist_sidebar.isVisible()
            if hasattr(self.playlist_sidebar, 'is_minimized'):
                self.settings['playlist_minimized'] = self.playlist_sidebar.is_minimized
                self.settings['playlist_attached_minimized'] = self.playlist_sidebar.is_minimized
            self.save_settings()
        
        self._main_window_hidden_for_nano = True
        
        # Hide main window (not minimize - actually hide it)
        self.hide()
        
        # Hide detached playlist window if it exists
        if (self.playlist_detached and 
            hasattr(self, 'detached_playlist_window') and 
            self.detached_playlist_window):
            self.detached_playlist_window.hide()
        
        # Create and show nano player window
        if not self.nano_player_window:
            self._create_nano_player_window()
        
        if self.nano_player_window:
            self.nano_player_window.show()
            self.nano_player_window.raise_()
            self.nano_player_window.activateWindow()
            # Sync shuffle/repeat buttons after nano player is shown
            # Small delay to ensure playlist_sidebar is fully initialized
            QTimer.singleShot(100, self.nano_player_window._sync_shuffle_repeat_buttons)
            # Note: One-time resize trick is now handled in showEvent() with longer delay
    
    def _exit_nano_mode(self):
        """Exit nano mode: show main window and detached playlist, hide nano player."""
        logger.debug(f"_exit_nano_mode called: _main_window_hidden_for_nano={self._main_window_hidden_for_nano}, _first_restore_from_nano={getattr(self, '_first_restore_from_nano', 'NOT SET')}")
        
        if not self._main_window_hidden_for_nano:
            logger.debug("_exit_nano_mode: Not in nano mode, returning early")
            return  # Not in nano mode
        
        self._main_window_hidden_for_nano = False
        
        # Force hide nano player window immediately and aggressively
        if self.nano_player_window:
            try:
                # Save position before hiding (hideEvent will also save, but save here too for safety)
                if hasattr(self.nano_player_window, '_save_nano_position'):
                    self.nano_player_window._save_nano_position()
                self.nano_player_window.hide()
                self.nano_player_window.setVisible(False)
                # Process events to ensure hide takes effect
                QApplication.processEvents()
            except Exception as e:
                logger.debug(f"Error hiding nano player: {e}")
        
        # Check if this is the first restore from nano after startup
        # If so, do a quick minimize/restore cycle to force proper initialization
        if hasattr(self, '_first_restore_from_nano') and self._first_restore_from_nano:
            logger.debug("First restore from nano - performing quick sync cycle")
            self._first_restore_from_nano = False  # Clear flag so it only happens once
            
            # Show main window first
            self.show()
            self.raise_()
            self.activateWindow()
            QApplication.processEvents()
            
            # Set flag to prevent nano mode from activating during quick sync
            self._doing_quick_sync = True
            
            # Do a quick minimize/restore cycle to force proper sync
            def quick_sync_cycle():
                logger.debug("Quick sync: minimizing")
                # Minimize
                self.showMinimized()
                QApplication.processEvents()
                # Immediately restore
                def restore_after_minimize():
                    logger.debug("Quick sync: restoring")
                    self._doing_quick_sync = False  # Clear flag before restore
                    self._restore_after_quick_sync()
                QTimer.singleShot(100, restore_after_minimize)
            
            QTimer.singleShot(200, quick_sync_cycle)
            return  # Exit early - _restore_after_quick_sync will handle the rest
        
        # Normal restore (not first time)
        # Show main window (restore from hidden/minimized state)
        # Always use showNormal() to ensure it's properly restored regardless of state
        self.showNormal()
        self.raise_()
        self.activateWindow()
        
        # Process events to ensure window is shown
        QApplication.processEvents()
        
        # Double-check window is actually visible (not minimized)
        if self.isMinimized():
            logger.debug("Window still minimized after showNormal(), forcing restore")
            self.showNormal()
            QApplication.processEvents()
        
        # Show detached playlist window immediately if it was detached
        # This must happen before reinitialize to ensure it's visible
        if self.playlist_detached:
            # Check if detached window exists, if not, create it
            if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
                # Detached window doesn't exist - create it now
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    try:
                        self._detach_playlist()
                    except Exception as e:
                        logger.debug(f"Error creating detached playlist on nano exit: {e}")
            
            # Now show it if it exists
            if (hasattr(self, 'detached_playlist_window') and 
                self.detached_playlist_window):
                try:
                    # Ensure it's not minimized (unless main window is minimized)
                    if not self.isMinimized():
                        if self.detached_playlist_window.isMinimized():
                            self.detached_playlist_window.showNormal()
                        self.detached_playlist_window.show()
                        self.detached_playlist_window.raise_()
                        # Process events to ensure show takes effect
                        QApplication.processEvents()
                except Exception as e:
                    logger.debug(f"Error showing detached playlist: {e}")
        
        # Reinitialize things that might not have completed if window was hidden too early
        # This is especially important when starting in nano mode
        def reinitialize_after_nano():
            # Double-check nano player is hidden
            if self.nano_player_window and self.nano_player_window.isVisible():
                self.nano_player_window.hide()
                self.nano_player_window.setVisible(False)
            
            # Ensure window is visible and processed
            if not self.isVisible():
                self.show()
            QApplication.processEvents()
            
            # Re-apply mini/micro mode CSS and resizing if needed
            if self.mini_mode_state != 0 and self.web_view and self.web_view.page():
                # Re-inject CSS to ensure it's applied (critical for mini mode player visibility)
                self.inject_css()
                # Force re-injection of JavaScript for image viewer and mini mode
                if self.web_view.page():
                    # Re-inject all JavaScript that might have been missed
                    js_code = self._get_mini_mode_class_js()
                    self.run_javascript_safe(js_code)
                # Re-apply mini mode settings
                if self.mini_mode_state == 1:
                    QTimer.singleShot(200, self.resize_to_mini_mode)
                elif self.mini_mode_state == 2:
                    QTimer.singleShot(200, self.resize_to_micro_mode)
            
            # Ensure playlist state is properly restored
            if hasattr(self, '_restore_playlist_state_pending') and self._restore_playlist_state_pending:
                if self.playlist_sidebar:
                    self._restore_playlist_state()
                self._restore_playlist_state_pending = False
            
            # Ensure detached playlist is properly synced and visible
            if (self.playlist_detached and 
                hasattr(self, 'detached_playlist_window') and 
                self.detached_playlist_window):
                # Re-sync window state
                if self.isMinimized() and not self.detached_playlist_window.isMinimized():
                    self.detached_playlist_window.showMinimized()
                elif not self.isMinimized() and self.detached_playlist_window.isMinimized():
                    self.detached_playlist_window.showNormal()
                # Ensure it's visible
                if not self.detached_playlist_window.isVisible():
                    self.detached_playlist_window.show()
                self.detached_playlist_window.raise_()
                # Re-sync minimize state flag
                if self.isMinimized():
                    self._detached_playlist_minimized_by_main = True
                else:
                    self._detached_playlist_minimized_by_main = False
        
        # Reinitialize after a short delay to ensure window is fully shown
        QTimer.singleShot(200, reinitialize_after_nano)
    
    def _restore_after_quick_sync(self):
        """Restore main window after quick minimize/restore cycle (first restore from nano workaround)."""
        # Ensure we're not in nano mode anymore
        self._main_window_hidden_for_nano = False
        
        # Restore main window
        self.showNormal()
        self.raise_()
        self.activateWindow()
        QApplication.processEvents()
        
        # Now do the normal restore logic
        # Show detached playlist window immediately if it was detached
        if self.playlist_detached:
            # Check if detached window exists, if not, create it
            if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
                # Detached window doesn't exist - create it now
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    try:
                        self._detach_playlist()
                    except Exception as e:
                        logger.debug(f"Error creating detached playlist on nano exit: {e}")
            
            # Now show it if it exists
            if (hasattr(self, 'detached_playlist_window') and 
                self.detached_playlist_window):
                try:
                    # Ensure it's not minimized (unless main window is minimized)
                    if not self.isMinimized():
                        if self.detached_playlist_window.isMinimized():
                            self.detached_playlist_window.showNormal()
                        self.detached_playlist_window.show()
                        self.detached_playlist_window.raise_()
                        # Process events to ensure show takes effect
                        QApplication.processEvents()
                except Exception as e:
                    logger.debug(f"Error showing detached playlist: {e}")
        
        # Reinitialize things that might not have completed if window was hidden too early
        def reinitialize_after_nano():
            # Double-check nano player is hidden
            if self.nano_player_window and self.nano_player_window.isVisible():
                self.nano_player_window.hide()
                self.nano_player_window.setVisible(False)
            
            # Ensure window is visible and processed
            if not self.isVisible():
                self.showNormal()  # Use showNormal to ensure proper restore
            QApplication.processEvents()
            
            # Re-apply mini/micro mode CSS and resizing if needed
            # This is critical - the quick sync cycle might have broken JavaScript injection
            # Always re-inject CSS and JavaScript after quick sync cycle (regardless of mode)
            if self.web_view and self.web_view.page():
                # Re-inject CSS to ensure it's applied (critical for mini mode player visibility)
                self.inject_css()
                # Force re-injection of JavaScript for image viewer and mini mode
                js_code = self._get_cover_art_modal_js() + self._get_mini_mode_class_js()
                self.run_javascript_safe(js_code)
                logger.debug("Re-injected CSS and JavaScript after quick sync cycle")
                
                # Re-apply mini mode settings if in mini/micro mode
                if self.mini_mode_state == 1:
                    QTimer.singleShot(200, self.resize_to_mini_mode)
                elif self.mini_mode_state == 2:
                    QTimer.singleShot(200, self.resize_to_micro_mode)
            
            # Ensure playlist state is properly restored
            if hasattr(self, '_restore_playlist_state_pending') and self._restore_playlist_state_pending:
                if self.playlist_sidebar:
                    self._restore_playlist_state()
                self._restore_playlist_state_pending = False
            
            # Ensure detached playlist is properly synced and visible
            if (self.playlist_detached and 
                hasattr(self, 'detached_playlist_window') and 
                self.detached_playlist_window):
                # Re-sync window state
                if self.isMinimized() and not self.detached_playlist_window.isMinimized():
                    self.detached_playlist_window.showMinimized()
                elif not self.isMinimized() and self.detached_playlist_window.isMinimized():
                    self.detached_playlist_window.showNormal()
                # Ensure it's visible
                if not self.detached_playlist_window.isVisible():
                    self.detached_playlist_window.show()
                self.detached_playlist_window.raise_()
                # Re-sync minimize state flag
                if self.isMinimized():
                    self._detached_playlist_minimized_by_main = True
                else:
                    self._detached_playlist_minimized_by_main = False
        
        # Reinitialize after a short delay to ensure window is fully shown
        QTimer.singleShot(200, reinitialize_after_nano)
    
    def _create_nano_player_window(self):
        """Create the nano player window."""
        if self.nano_player_window:
            return  # Already created
        
        self.nano_player_window = NanoPlayerWindow(self)
        # NOTE: We intentionally do not force-minimize on reattach in mini/micro mode anymore.
        # We restore the user's attached minimized state instead (see above).
        
        # Resize modes to account for reattached playlist
        if self.mini_mode_state == 1:
            print(f"[DEBUG] _reattach_playlist: In mini mode, resizing for playlist reattached")
            # Ensure playlist container is visible and positioned correctly
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.show()
                # Clear any constraints that might have been set
                self.playlist_container.setMinimumHeight(0)
                self.playlist_container.setMaximumHeight(16777215)  # Qt max
            # Force layout update to ensure visibility changes are reflected
            layout = self.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            QApplication.processEvents()
            # Use multiple delays to ensure playlist geometry is updated first
            # Check actual visibility instead of relying on parameter
            def resize_with_actual_visibility():
                actual_visible = hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached
                print(f"[DEBUG] _reattach_playlist: Resize callback, actual_visible={actual_visible}")
                self._resize_mini_mode_for_playlist(actual_visible)
                # Also update playlist position in mini mode
                QTimer.singleShot(10, self._update_playlist_position_in_mini_mode)
                QTimer.singleShot(50, self._update_playlist_position_in_mini_mode)
            print(f"[DEBUG] _reattach_playlist: Scheduling resize calls")
            QTimer.singleShot(10, resize_with_actual_visibility)
            QTimer.singleShot(50, resize_with_actual_visibility)
            QTimer.singleShot(100, resize_with_actual_visibility)
            QTimer.singleShot(200, resize_with_actual_visibility)
            QTimer.singleShot(300, resize_with_actual_visibility)  # Extra delay for safety
        elif self.mini_mode_state == 2:
            QTimer.singleShot(50, self._resize_to_micro_mode_with_retry)
        
        # Save settings
        self._save_playlist_detach_state()
    
    def _toggle_playlist_window_linking(self, enabled):
        """Toggle linking between main window and detached playlist window."""
        self.playlist_window_linked = enabled
        # If disabling linking, also clear docked state
        if not enabled:
            self._windows_docked = False
            self._windows_docked_edge = None
        
        if enabled:
            self._initialize_playlist_window_linking()
        else:
            self._deinitialize_playlist_window_linking()
        
        # Update button state if it exists (button is read-only for visual feedback)
        if hasattr(self, '_detached_link_btn') and self._detached_link_btn:
            # Update the checked state
            self._detached_link_btn.blockSignals(True)
            self._detached_link_btn.setChecked(enabled)
            self._detached_link_btn.blockSignals(False)
            
            # Manually call update_link_icon function since signals are blocked
            # Button is now kept enabled (but clicks are blocked via event filter) so icon colors work
            if hasattr(self, '_update_link_icon_func'):
                self._update_link_icon_func(enabled)
            else:
                # Fallback: update icon directly
                if HAS_QT_AWESOME:
                    icon_color = '#4a90e2' if enabled else '#e0e0e0'
                    icon = get_icon('link', color=icon_color)
                    if icon:
                        self._detached_link_btn.setIcon(icon)
            
            # Force repaint to ensure icon change is visible
            self._detached_link_btn.repaint()
            # Update tooltip to reflect current state
            if enabled:
                self._detached_link_btn.setToolTip("Windows are linked (automatic when snapped together)")
            else:
                self._detached_link_btn.setToolTip("Windows are not linked (link automatically when snapped together)")
        
        # Save linking state to settings
        self.settings['playlist_window_linked'] = enabled
        self.save_settings()
    
    def _initialize_playlist_window_linking(self):
        """Initialize window linking - set up event handlers and calculate initial offset."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return
        
        try:
            # Calculate initial offset between windows
            main_x = self.x()
            main_y = self.y()
            detached_x = self.detached_playlist_window.x()
            detached_y = self.detached_playlist_window.y()
            
            self._playlist_window_link_offset = (detached_x - main_x, detached_y - main_y)
            
            # Store initial positions for movement detection
            self._last_main_window_pos = (main_x, main_y)
            self._last_detached_playlist_pos = (detached_x, detached_y)
        except Exception:
            pass
    
    def _deinitialize_playlist_window_linking(self):
        """Deinitialize window linking - remove event handlers."""
        # Stop any in-flight throttle timer and clear state
        try:
            if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                self._linked_move_timer.stop()
        except Exception:
            pass
        self._pending_linked_detached_pos = None
        self._link_move_idle_ticks = 0
        self._moving_detached_playlist_programmatically = False
        self._last_programmatic_detached_pos = None
    
    def _handle_main_window_movement_for_linking(self, event):
        """Handle main window movement - move detached playlist window if linked."""
        # Keep windows linked while main window is moving - only unlink if playlist window is manually moved away
        if not self.playlist_detached or not self.detached_playlist_window or not self.detached_playlist_window.isVisible():
            return
        
        try:
            # Get current main window position
            current_main_x = self.x()
            current_main_y = self.y()
            
            # Check if position actually changed (not just a resize)
            if self._last_main_window_pos:
                old_main_x, old_main_y = self._last_main_window_pos
                if current_main_x == old_main_x and current_main_y == old_main_y:
                    return  # No position change, just a resize
            
            # Calculate new detached window position (always keep it linked while main window moves)
            if self._playlist_window_link_offset:
                offset_x, offset_y = self._playlist_window_link_offset
                new_detached_x = current_main_x + offset_x
                new_detached_y = current_main_y + offset_y

                # Throttle moves (reduces jitter vs moving on every moveEvent, without deferring indefinitely)
                self._pending_linked_detached_pos = (new_detached_x, new_detached_y, current_main_x, current_main_y)
                self._link_move_idle_ticks = 0
                if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                    if not self._linked_move_timer.isActive():
                        # While throttling, keep this guard enabled so detached Move events don't rewrite offsets
                        self._moving_detached_playlist_programmatically = True
                        self._linked_move_timer.start()
        except Exception:
            self._moving_detached_playlist_programmatically = False

    def _apply_pending_linked_detached_move(self):
        """Apply a throttled detached-window move while in link mode."""
        if not self.playlist_detached or not self.playlist_window_linked:
            self._pending_linked_detached_pos = None
            self._link_move_idle_ticks = 0
            if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                self._linked_move_timer.stop()
            self._moving_detached_playlist_programmatically = False
            return
        if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
            self._pending_linked_detached_pos = None
            self._link_move_idle_ticks = 0
            if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                self._linked_move_timer.stop()
            self._moving_detached_playlist_programmatically = False
            return
        if not self._pending_linked_detached_pos:
            # No new target  stop quickly once movement has settled
            self._link_move_idle_ticks += 1
            if self._link_move_idle_ticks >= 2:
                self._link_move_idle_ticks = 0
                if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                    self._linked_move_timer.stop()
                self._moving_detached_playlist_programmatically = False
                self._last_programmatic_detached_pos = None
            return

        try:
            new_detached_x, new_detached_y, current_main_x, current_main_y = self._pending_linked_detached_pos
            self._pending_linked_detached_pos = None
            self._link_move_idle_ticks = 0

            # Mark this as programmatic so the detached window Move event doesn't update offsets
            self._last_programmatic_detached_pos = (new_detached_x, new_detached_y)
            self.detached_playlist_window.move(new_detached_x, new_detached_y)

            # Update stored positions (main position is known here)
            self._last_main_window_pos = (current_main_x, current_main_y)
            self._last_detached_playlist_pos = (new_detached_x, new_detached_y)
        except Exception:
            # If something goes wrong, stop throttling to avoid getting stuck
            self._pending_linked_detached_pos = None
            self._link_move_idle_ticks = 0
            if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                self._linked_move_timer.stop()
            self._moving_detached_playlist_programmatically = False
            self._last_programmatic_detached_pos = None
    
    def _handle_detached_playlist_window_movement(self, event):
        """Handle detached playlist window movement - recalculate offset if moved manually, or unlink if moved away."""
        if not self.playlist_window_linked or not self.detached_playlist_window:
            return
        
        if self._moving_detached_playlist_programmatically:
            return  # This is a programmatic move, don't recalculate offset
        
        try:
            # Get current positions
            current_main_x = self.x()
            current_main_y = self.y()
            current_detached_x = self.detached_playlist_window.x()
            current_detached_y = self.detached_playlist_window.y()
            
            # Check if position actually changed (not just a resize)
            if self._last_detached_playlist_pos:
                old_detached_x, old_detached_y = self._last_detached_playlist_pos
                if current_detached_x == old_detached_x and current_detached_y == old_detached_y:
                    return  # No position change, just a resize
            
            # Check if windows have moved apart (beyond snap threshold) - if so, unlink
            main_rect = self.geometry()
            detached_rect = self.detached_playlist_window.geometry()
            
            main_left = main_rect.x()
            main_right = main_rect.x() + main_rect.width()
            main_top = main_rect.y()
            main_bottom = main_rect.y() + main_rect.height()
            
            detached_left = detached_rect.x()
            detached_right = detached_rect.x() + detached_rect.width()
            detached_top = detached_rect.y()
            detached_bottom = detached_rect.y() + detached_rect.height()
            
            # Calculate minimum distance between windows
            # Check horizontal distance
            if detached_right < main_left:
                h_dist = main_left - detached_right
            elif detached_left > main_right:
                h_dist = detached_left - main_right
            else:
                h_dist = 0  # Overlapping horizontally
            
            # Check vertical distance
            if detached_bottom < main_top:
                v_dist = main_top - detached_bottom
            elif detached_top > main_bottom:
                v_dist = detached_top - main_bottom
            else:
                v_dist = 0  # Overlapping vertically
            
            # If windows are far apart (beyond snap threshold), unlink
            # Use a more lenient threshold - unlink if either direction is beyond threshold
            total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5  # Euclidean distance
            # Lower threshold to make unlinking easier - unlink if total distance > 1.5x threshold or either direction > threshold
            if total_dist > self._snap_threshold * 1.5 or h_dist > self._snap_threshold or v_dist > self._snap_threshold:
                # Windows have moved apart - unlink them
                self._toggle_playlist_window_linking(False)
                return
            
            # Windows are still close - recalculate offset (user moved detached window manually but kept it close)
            self._playlist_window_link_offset = (current_detached_x - current_main_x, current_detached_y - current_main_y)
            
            # Update stored positions
            self._last_main_window_pos = (current_main_x, current_main_y)
            self._last_detached_playlist_pos = (current_detached_x, current_detached_y)
        except Exception:
            pass
    
    def _calculate_distance_to_main_window(self, playlist_pos):
        """Calculate distance from playlist position to main window."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return float('inf')
        
        main_rect = self.geometry()
        playlist_rect = QRect(playlist_pos, self.detached_playlist_window.size())
        
        main_left = main_rect.x()
        main_right = main_rect.x() + main_rect.width()
        main_top = main_rect.y()
        main_bottom = main_rect.y() + main_rect.height()
        
        playlist_left = playlist_rect.x()
        playlist_right = playlist_rect.x() + playlist_rect.width()
        playlist_top = playlist_rect.y()
        playlist_bottom = playlist_rect.y() + playlist_rect.height()
        
        # Calculate minimum distance
        h_dist = 0
        v_dist = 0
        if playlist_right < main_left:
            h_dist = main_left - playlist_right
        elif playlist_left > main_right:
            h_dist = playlist_left - main_right
        
        if playlist_bottom < main_top:
            v_dist = main_top - playlist_bottom
        elif playlist_top > main_bottom:
            v_dist = playlist_top - main_bottom
        
        return (h_dist ** 2 + v_dist ** 2) ** 0.5
    
    def _handle_playlist_window_snapping(self):
        """Handle window snapping - snap detached playlist window to main window edges when close."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return False
        
        try:
            main_rect = self.geometry()
            detached_rect = self.detached_playlist_window.geometry()
            
            main_left = main_rect.x()
            main_right = main_rect.x() + main_rect.width()
            main_top = main_rect.y()
            main_bottom = main_rect.y() + main_rect.height()
            
            detached_left = detached_rect.x()
            detached_right = detached_rect.x() + detached_rect.width()
            detached_top = detached_rect.y()
            detached_bottom = detached_rect.y() + detached_rect.height()
            
            # First check if windows are reasonably close (within 2x snap threshold) before attempting to snap
            # This prevents snapping when windows are far apart
            h_dist = 0
            v_dist = 0
            if detached_right < main_left:
                h_dist = main_left - detached_right
            elif detached_left > main_right:
                h_dist = detached_left - main_right
            
            if detached_bottom < main_top:
                v_dist = main_top - detached_bottom
            elif detached_top > main_bottom:
                v_dist = detached_top - main_bottom
            
            total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5
            # Only attempt snapping if windows are within reasonable distance (2x snap threshold)
            if total_dist > self._snap_threshold * 2:
                return False  # Windows too far apart, don't snap
            
            new_x = detached_left
            new_y = detached_top
            snapped = False
            
            # Check snapping to right edge of main window
            if abs(detached_left - main_right) <= self._snap_threshold:
                new_x = main_right
                snapped = True
            # Check snapping to left edge of main window
            elif abs(detached_right - main_left) <= self._snap_threshold:
                new_x = main_left - detached_rect.width()
                snapped = True
            # Check snapping to left edge of detached window to right edge of main window
            elif abs(detached_right - main_right) <= self._snap_threshold:
                new_x = main_right - detached_rect.width()
                snapped = True
            
            # Check snapping to bottom edge of main window
            if abs(detached_top - main_bottom) <= self._snap_threshold:
                new_y = main_bottom
                snapped = True
            # Check snapping to top edge of main window
            elif abs(detached_bottom - main_top) <= self._snap_threshold:
                new_y = main_top - detached_rect.height()
                snapped = True
            # Check snapping to top edge of detached window to bottom edge of main window
            elif abs(detached_bottom - main_bottom) <= self._snap_threshold:
                new_y = main_bottom - detached_rect.height()
                snapped = True
            
            # Also check vertical alignment (same top or bottom)
            if abs(detached_top - main_top) <= self._snap_threshold:
                new_y = main_top
                snapped = True
            elif abs(detached_bottom - main_bottom) <= self._snap_threshold:
                new_y = main_bottom - detached_rect.height()
                snapped = True
            
            # Apply snapping if within threshold
            if snapped:
                self._moving_detached_playlist_programmatically = True
                self.detached_playlist_window.move(new_x, new_y)
                # Don't link immediately - wait for mouse release
                # Just mark that snapping occurred
                QTimer.singleShot(50, lambda: setattr(self, '_moving_detached_playlist_programmatically', False))
                return True  # Return True to indicate snapping occurred
        except Exception:
            pass
        return False  # No snapping occurred
    
    def _check_windows_dock_to_screen_edge(self):
        """Check if both main window and playlist window are at a screen edge and should dock together."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        screen_geometry = screen.geometry()
        main_rect = self.frameGeometry()
        detached_rect = self.detached_playlist_window.frameGeometry()
        
        # Calculate distances to screen edges for both windows
        main_dist_to_top = abs(main_rect.top() - screen_geometry.top())
        main_dist_to_bottom = abs(main_rect.bottom() - screen_geometry.bottom())
        main_dist_to_left = abs(main_rect.left() - screen_geometry.left())
        main_dist_to_right = abs(main_rect.right() - screen_geometry.right())
        
        detached_dist_to_top = abs(detached_rect.top() - screen_geometry.top())
        detached_dist_to_bottom = abs(detached_rect.bottom() - screen_geometry.bottom())
        detached_dist_to_left = abs(detached_rect.left() - screen_geometry.left())
        detached_dist_to_right = abs(detached_rect.right() - screen_geometry.right())
        
        # Check if both windows are at the same screen edge (within threshold)
        docked_edge = None
        if main_dist_to_top < self._snap_threshold and detached_dist_to_top < self._snap_threshold:
            docked_edge = 'top'
        elif main_dist_to_bottom < self._snap_threshold and detached_dist_to_bottom < self._snap_threshold:
            docked_edge = 'bottom'
        elif main_dist_to_left < self._snap_threshold and detached_dist_to_left < self._snap_threshold:
            docked_edge = 'left'
        elif main_dist_to_right < self._snap_threshold and detached_dist_to_right < self._snap_threshold:
            docked_edge = 'right'
        
        # If both windows are at an edge and not already docked, dock them
        if docked_edge and not self._windows_docked:
            self._dock_windows_to_edge(docked_edge)
        # If windows are no longer at an edge, undock them
        elif not docked_edge and self._windows_docked:
            self._undock_windows()
    
    def _dock_windows_to_edge(self, edge):
        """Dock both windows to the specified screen edge and enable linking."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        screen_geometry = screen.geometry()
        main_rect = self.frameGeometry()
        detached_rect = self.detached_playlist_window.frameGeometry()
        
        self._windows_docked_edge = edge
        self._windows_docked = True
        
        # Snap both windows to the edge
        if edge == 'top':
            self.move(main_rect.left(), screen_geometry.top())
            self.detached_playlist_window.move(detached_rect.left(), screen_geometry.top())
        elif edge == 'bottom':
            self.move(main_rect.left(), screen_geometry.bottom() - main_rect.height())
            self.detached_playlist_window.move(detached_rect.left(), screen_geometry.bottom() - detached_rect.height())
        elif edge == 'left':
            self.move(screen_geometry.left(), main_rect.top())
            self.detached_playlist_window.move(screen_geometry.left(), detached_rect.top())
        elif edge == 'right':
            self.move(screen_geometry.right() - main_rect.width(), main_rect.top())
            self.detached_playlist_window.move(screen_geometry.right() - detached_rect.width(), detached_rect.top())
        
        # Auto-enable linking when docked
        if not self.playlist_window_linked:
            self._toggle_playlist_window_linking(True)
    
    def _undock_windows(self):
        """Undock windows from screen edge."""
        self._windows_docked_edge = None
        self._windows_docked = False
        # Note: We don't disable linking automatically - user can do that manually if desired
    
    def _handle_main_window_snapping(self):
        """Handle main window snapping - snap main window to detached playlist window edges when close."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return False
        
        try:
            main_rect = self.geometry()
            detached_rect = self.detached_playlist_window.geometry()
            
            main_left = main_rect.x()
            main_right = main_rect.x() + main_rect.width()
            main_top = main_rect.y()
            main_bottom = main_rect.y() + main_rect.height()
            
            detached_left = detached_rect.x()
            detached_right = detached_rect.x() + detached_rect.width()
            detached_top = detached_rect.y()
            detached_bottom = detached_rect.y() + detached_rect.height()
            
            # First check if windows are reasonably close (within 2x snap threshold) before attempting to snap
            # This prevents snapping when windows are far apart
            h_dist = 0
            v_dist = 0
            if detached_right < main_left:
                h_dist = main_left - detached_right
            elif detached_left > main_right:
                h_dist = detached_left - main_right
            
            if detached_bottom < main_top:
                v_dist = main_top - detached_bottom
            elif detached_top > main_bottom:
                v_dist = detached_top - main_bottom
            
            total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5
            # Only attempt snapping if windows are within reasonable distance (2x snap threshold)
            if total_dist > self._snap_threshold * 2:
                return False  # Windows too far apart, don't snap
            
            new_x = main_left
            new_y = main_top
            snapped = False
            
            # Check snapping main window right edge to detached window left edge
            if abs(main_right - detached_left) <= self._snap_threshold:
                new_x = detached_left - main_rect.width()
                snapped = True
            # Check snapping main window left edge to detached window right edge
            elif abs(main_left - detached_right) <= self._snap_threshold:
                new_x = detached_right
                snapped = True
            # Check snapping main window right edge to detached window right edge
            elif abs(main_right - detached_right) <= self._snap_threshold:
                new_x = detached_right - main_rect.width()
                snapped = True
            
            # Check snapping main window bottom edge to detached window top edge
            if abs(main_bottom - detached_top) <= self._snap_threshold:
                new_y = detached_top - main_rect.height()
                snapped = True
            # Check snapping main window top edge to detached window bottom edge
            elif abs(main_top - detached_bottom) <= self._snap_threshold:
                new_y = detached_bottom
                snapped = True
            # Check snapping main window bottom edge to detached window bottom edge
            elif abs(main_bottom - detached_bottom) <= self._snap_threshold:
                new_y = detached_bottom - main_rect.height()
                snapped = True
            
            # Also check vertical alignment (same top or bottom)
            if abs(main_top - detached_top) <= self._snap_threshold:
                new_y = detached_top
                snapped = True
            elif abs(main_bottom - detached_bottom) <= self._snap_threshold:
                new_y = detached_bottom - main_rect.height()
                snapped = True
            
            # Apply snapping if within threshold
            if snapped:
                # Guard against recursive snap scheduling caused by this programmatic move
                self._moving_main_window_programmatically = True
                self.move(new_x, new_y)
                # Don't link immediately - wait for mouse release
                # Just mark that snapping occurred
                QTimer.singleShot(0, lambda: setattr(self, '_moving_main_window_programmatically', False))
                return True  # Return True to indicate snapping occurred
        except Exception:
            pass
        return False  # No snapping occurred
    
    def _create_detached_playlist_window(self):
        """Create a new window for the detached playlist."""
        if self.detached_playlist_window:
            return
        
        # Create dialog window (non-modal) as a separate top-level window for taskbar
        # Use None as parent to make it a top-level window that appears in taskbar
        self.detached_playlist_window = QDialog(None)
        self.detached_playlist_window.setWindowTitle("Playlist")
        self.detached_playlist_window.setModal(False)
        self.detached_playlist_window.setMinimumSize(260, 200)
        # Ensure window is resizable (no maximum size constraint)
        self.detached_playlist_window.setMaximumSize(16777215, 16777215)  # Qt's default maximum (effectively unlimited)
        # Set size policy to allow resizing
        self.detached_playlist_window.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        # Make it frameless like the main window, but ensure it appears in taskbar
        # Window flag makes it a separate taskbar item
        flags = Qt.WindowType.FramelessWindowHint | Qt.WindowType.Window
        if self.always_on_top:
            flags |= Qt.WindowType.WindowStaysOnTopHint
        self.detached_playlist_window.setWindowFlags(flags)
        
        # Set window icon if available
        if hasattr(self, 'app_icon') and self.app_icon:
            self.detached_playlist_window.setWindowIcon(self.app_icon)
        
        # Set background color to prevent white border on Windows 10
        # This ensures the window background matches the dark theme
        self.detached_playlist_window.setStyleSheet("""
            QDialog {
                background-color: rgb(21, 21, 21);
            }
        """)
        self.detached_playlist_window.setAutoFillBackground(True)
        # On Windows 10, frameless windows can show white borders without this attribute
        self.detached_playlist_window.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, True)
        
        # Create layout first (bottom margin will be set when playlist is added)
        layout = QVBoxLayout(self.detached_playlist_window)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create custom title bar for detached window (only if it doesn't exist)
        self._create_detached_window_title_bar()
        # Check if title bar is already in layout before adding (prevents duplicates when switching modes)
        title_bar_in_layout = False
        for i in range(layout.count()):
            item = layout.itemAt(i)
            if item and item.widget() == self.detached_playlist_title_bar:
                title_bar_in_layout = True
                break
        if not title_bar_in_layout and self.detached_playlist_title_bar:
            layout.addWidget(self.detached_playlist_title_bar)
        
        # Load saved size from settings
        saved_size = self.settings.get("playlist_detached_size", "260x400")
        try:
            if 'x' in saved_size:
                size_parts = saved_size.split('x')
                if len(size_parts) == 2:
                    width = int(size_parts[0])
                    height = int(size_parts[1])
                    # Validate size - width should always be 260 to match main window
                    if width >= 260 and height >= 200:
                        # Force width to 260 to match main window width
                        self.detached_playlist_window.resize(260, height)
                    else:
                        self.detached_playlist_window.resize(260, 400)
                else:
                    self.detached_playlist_window.resize(260, 400)
            else:
                self.detached_playlist_window.resize(260, 400)
        except Exception:
            self.detached_playlist_window.resize(260, 400)
        
        # Set fixed width to match main window width (260px)
        # This ensures the detached playlist always matches the main window width
        self.detached_playlist_window.setFixedWidth(260)
        
        # Position window - check if it was previously docked or linked first
        was_docked = self.settings.get('playlist_was_docked', False)
        was_linked = self.settings.get('playlist_was_linked', False)
        docked_edge = self.settings.get('playlist_docked_edge', None)
        
        # If it was docked OR linked, use relative positioning
        if was_docked or was_linked:
            # Was previously docked - use saved offset relative to main window's CURRENT position
            # This ensures the playlist appears in the same relative position even if main window moved
            main_pos = self.pos()
            offset_x, offset_y = self.playlist_detached_offset
            
            # FIRST: Find the screen containing the main window (for multi-monitor support)
            # This is critical - we want the playlist on the SAME screen as the main window
            # Try multiple methods to reliably get the main window's screen
            main_screen = None
            # Method 1: Get screen directly from window object (most reliable)
            if hasattr(self, 'screen'):
                try:
                    main_screen = self.screen()
                except Exception:
                    pass
            # Method 2: Use QApplication.screenAt with main window position
            if not main_screen:
                main_screen = QApplication.screenAt(main_pos)
            # Method 3: Fallback to primary screen
            if not main_screen:
                main_screen = QApplication.primaryScreen()
            
            # Calculate position using saved offset relative to current main window position
            detached_x = main_pos.x() + offset_x
            detached_y = main_pos.y() + offset_y
            
            # Ensure window stays on the same screen as main window
            if main_screen:
                screen_geometry = main_screen.availableGeometry()
                detached_width = self.detached_playlist_window.width()
                detached_height = self.detached_playlist_window.height()
                
                # Clamp position to the main window's screen bounds
                # This ensures the window will be placed on the correct screen
                detached_x = max(screen_geometry.left(), 
                               min(detached_x, screen_geometry.right() - detached_width))
                detached_y = max(screen_geometry.top(), 
                               min(detached_y, screen_geometry.bottom() - detached_height))
            
            # Store positioning info for after window is shown
            # We need to position AFTER showing the window for multi-monitor support to work correctly
            def position_window_on_correct_screen():
                nonlocal detached_x, detached_y  # Allow modification of outer scope variables
                # Explicitly set the screen to ensure it's on the correct monitor (multi-monitor support)
                # This is critical for secondary monitors
                if main_screen and main_screen != self.detached_playlist_window.screen():
                    self.detached_playlist_window.setScreen(main_screen)
                
                # Recalculate position from scratch using main window's CURRENT position
                # This ensures correct positioning on the correct screen
                current_main_pos = self.pos()
                detached_x = current_main_pos.x() + offset_x
                detached_y = current_main_pos.y() + offset_y
                
                # Clamp position to the main window's screen bounds
                if main_screen:
                    screen_geometry = main_screen.availableGeometry()
                    detached_width = self.detached_playlist_window.width()
                    detached_height = self.detached_playlist_window.height()
                    detached_x = max(screen_geometry.left(), 
                                   min(detached_x, screen_geometry.right() - detached_width))
                    detached_y = max(screen_geometry.top(), 
                                   min(detached_y, screen_geometry.bottom() - detached_height))
                
                # Move the window to the calculated position (clamped to main window's screen)
                self.detached_playlist_window.move(int(detached_x), int(detached_y))
                
                # Update offset to match actual position (in case it was clamped to screen)
                # Use current_main_pos since we recalculated from the current position
                actual_offset_x = int(detached_x - current_main_pos.x())
                actual_offset_y = int(detached_y - current_main_pos.y())
                self.playlist_detached_offset = (actual_offset_x, actual_offset_y)
                # Save offset to settings so linking uses correct offset
                self.settings['playlist_detached_offset'] = self.playlist_detached_offset
                self.save_settings()
            
            # Store the positioning function to call after window is shown
            self._position_docked_playlist = position_window_on_correct_screen
            
            # Don't save absolute position when docked - we'll use relative positioning
            self.playlist_detached_position = None
        
        # If not docked and not linked, use saved position or offset-based positioning
        if not was_docked and not was_linked:
            saved_pos_tuple = self.playlist_detached_position
            if saved_pos_tuple and isinstance(saved_pos_tuple, (list, tuple)) and len(saved_pos_tuple) == 2:
                # Use saved absolute position
                saved_pos = QPoint(saved_pos_tuple[0], saved_pos_tuple[1])
                
                # Validate position is on a valid screen (multi-monitor support)
                screen = QApplication.screenAt(saved_pos)
                if screen:
                    # Position is on a valid screen, use it
                    self.detached_playlist_window.move(saved_pos)
                else:
                    # Position is off-screen, find the closest screen
                    screens = QApplication.screens()
                    target_screen = None
                    min_distance = float('inf')
                    
                    for s in screens:
                        screen_geom = s.geometry()
                        # Calculate distance from saved position to screen center
                        screen_center = screen_geom.center()
                        distance = ((saved_pos.x() - screen_center.x()) ** 2 + 
                                   (saved_pos.y() - screen_center.y()) ** 2) ** 0.5
                        if distance < min_distance:
                            min_distance = distance
                            target_screen = s
                    
                    if not target_screen:
                        target_screen = QApplication.primaryScreen()
                    
                    # Adjust position to be on the target screen
                    screen_geometry = target_screen.availableGeometry()
                    window_size = self.detached_playlist_window.size()
                    
                    # Try to keep relative position within screen if possible
                    new_x = max(screen_geometry.left(), 
                               min(saved_pos.x(), screen_geometry.right() - window_size.width()))
                    new_y = max(screen_geometry.top(), 
                               min(saved_pos.y(), screen_geometry.bottom() - window_size.height()))
                    
                    # If saved position is way off, center on screen instead
                    if (abs(new_x - saved_pos.x()) > screen_geometry.width() or 
                        abs(new_y - saved_pos.y()) > screen_geometry.height()):
                        new_x = screen_geometry.center().x() - window_size.width() // 2
                        new_y = screen_geometry.center().y() - window_size.height() // 2
                    
                    validated_pos = QPoint(new_x, new_y)
                    self.detached_playlist_window.move(validated_pos)
                    
                    # Set screen if different from current
                    if target_screen and target_screen != self.detached_playlist_window.screen():
                        self.detached_playlist_window.setScreen(target_screen)
        else:
            # No saved absolute position, use offset-based positioning (fallback)
            screen = QApplication.primaryScreen()
            screen_geometry = screen.availableGeometry() if screen else None
            
            main_pos = self.pos()
            offset_x, offset_y = self.playlist_detached_offset
            
            # Calculate position relative to main window's current position
            detached_x = main_pos.x() + offset_x
            detached_y = main_pos.y() + offset_y
            
            # Ensure window stays on screen
            if screen_geometry:
                if detached_x + self.detached_playlist_window.width() > screen_geometry.right():
                    detached_x = screen_geometry.right() - self.detached_playlist_window.width() - 20
                if detached_y + self.detached_playlist_window.height() > screen_geometry.bottom():
                    detached_y = screen_geometry.bottom() - self.detached_playlist_window.height() - 20
                if detached_x < screen_geometry.left():
                    detached_x = screen_geometry.left() + 20
                if detached_y < screen_geometry.top():
                    detached_y = screen_geometry.top() + 20
            
            self.detached_playlist_window.move(detached_x, detached_y)
        
        # Handle window close - reattach instead of destroying
        self.detached_playlist_window.finished.connect(self._reattach_playlist)
        
        # CRITICAL: Force main window repaint when detached playlist window visibility changes
        # This prevents the main window from going black when the detached playlist is shown/hidden
        def force_main_window_repaint():
            # Force main window repaint
            self.update()
            self.repaint()
            # Repaint central widget
            central_widget = self.centralWidget()
            if central_widget:
                central_widget.update()
                central_widget.repaint()
            # Repaint player widget and cover art
            if hasattr(self, 'regular_player_widget') and self.regular_player_widget:
                self.regular_player_widget.update()
                self.regular_player_widget.repaint()
                if hasattr(self.regular_player_widget, 'cover_art_label') and self.regular_player_widget.cover_art_label:
                    self.regular_player_widget.cover_art_label.update()
                    self.regular_player_widget.cover_art_label.repaint()
            QApplication.processEvents()
        
        # Connect to show and hide events
        original_show_event = self.detached_playlist_window.showEvent
        original_hide_event = self.detached_playlist_window.hideEvent
        
        def on_show_event(event):
            if original_show_event:
                original_show_event(event)
            # Force immediate repaint
            force_main_window_repaint()
            # Schedule additional repaints (non-recursive)
            QTimer.singleShot(10, force_main_window_repaint)
            QTimer.singleShot(50, force_main_window_repaint)
            QTimer.singleShot(100, force_main_window_repaint)
        
        def on_hide_event(event):
            if original_hide_event:
                original_hide_event(event)
            # Force immediate repaint
            force_main_window_repaint()
            # Schedule additional repaints (non-recursive)
            QTimer.singleShot(10, force_main_window_repaint)
            QTimer.singleShot(50, force_main_window_repaint)
            QTimer.singleShot(100, force_main_window_repaint)
        
        self.detached_playlist_window.showEvent = on_show_event
        self.detached_playlist_window.hideEvent = on_hide_event
        
        # Install event filter to catch move/resize events
        # The eventFilter method in PlayerWindow will handle Move and Resize events
        self.detached_playlist_window.installEventFilter(self)
        
        # Apply rounded corners after window is shown
        def apply_rounded_corners():
            radius = 10  # Corner radius in pixels (same as main window)
            size = self.detached_playlist_window.size()
            
            # Create a path with rounded corners
            path = QPainterPath()
            path.addRoundedRect(0, 0, size.width(), size.height(), radius, radius)
            
            # Convert path to polygon and create region
            polygon = path.toFillPolygon()
            rounded_region = QRegion(polygon.toPolygon())
            
            self.detached_playlist_window.setMask(rounded_region)
            
            # After setting mask, ensure resize handle is still on top and visible
            if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                QTimer.singleShot(10, lambda: (
                    self._update_detached_bottom_resize_handle_position() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None,
                    self.detached_bottom_resize_handle.raise_() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None
                ))
        
        # Make window resizable (remove fixed size constraints)
        self.detached_playlist_window.setMinimumSize(260, 200)
        # No maximum size - allow resizing
        
        # Store apply_rounded_corners function for event filter
        self._apply_detached_rounded_corners = apply_rounded_corners
        
        # Handle resize events to update bottom resize handle position and rounded corners
        original_resize_event = self.detached_playlist_window.resizeEvent
        
        def on_resize(event):
            # Ensure width is always 260px to match main window
            if self.detached_playlist_window.width() != 260:
                self.detached_playlist_window.setFixedWidth(260)
            # Call original resize event handler
            if original_resize_event:
                original_resize_event(event)
            # Update bottom resize handle position
            if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                self._update_detached_bottom_resize_handle_position()
            # Update rounded corners on resize
            QTimer.singleShot(10, apply_rounded_corners)
        
        self.detached_playlist_window.resizeEvent = on_resize
        
        # Show window (always show on creation, visibility state will be restored from settings)
        # The window should always be shown when created, even if it was minimized before
        self.detached_playlist_window.show()
        
        # Position window on correct screen AFTER showing (for multi-monitor support)
        # This is critical for docked/linked playlists on secondary monitors
        if hasattr(self, '_position_docked_playlist') and self._position_docked_playlist:
            # Use a small delay to ensure window is fully shown before positioning
            QTimer.singleShot(10, self._position_docked_playlist)
            # Clear the function after use
            self._position_docked_playlist = None
        
        # Update overlay when window is first shown
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            repeat_mode = getattr(self.playlist_sidebar, 'repeat_mode', 0)
            if hasattr(self, '_update_detached_repeat_overlay'):
                QTimer.singleShot(100, lambda: self._update_detached_repeat_overlay(repeat_mode))
        self.detached_playlist_window.raise_()
        # Don't activate window on startup restoration to avoid stealing focus
        # Only activate if this is a user-initiated detach (not startup restoration)
        if not self.playlist_detached:
            self.detached_playlist_window.activateWindow()
        
        # Create bottom resize handle AFTER window is shown and playlist is added
        # This ensures it's created on top of all content
        QTimer.singleShot(150, lambda: (
            self._create_detached_bottom_resize_handle(),
            self._update_detached_bottom_resize_handle_position() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None,
            self.detached_bottom_resize_handle.raise_() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None
        ))
        
        # Apply rounded corners after showing
        QTimer.singleShot(50, apply_rounded_corners)
    
    def _create_detached_window_title_bar(self):
        """Create custom title bar for detached playlist window with all playlist buttons."""
        # Don't create if it already exists (prevents duplicates when switching modes)
        if hasattr(self, 'detached_playlist_title_bar') and self.detached_playlist_title_bar:
            return
        # Create title bar widget
        self.detached_playlist_title_bar = QWidget(self.detached_playlist_window)
        self.detached_playlist_title_bar.setFixedHeight(30)
        self.detached_playlist_title_bar.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border-bottom: 1px solid #1a1a1a;
            }
        """)
        
        title_layout = QHBoxLayout(self.detached_playlist_title_bar)
        title_layout.setContentsMargins(10, 2, 10, 2)  # Add padding on left and right sides
        title_layout.setSpacing(2)  # Match playlist title bar spacing
        
        # Add Albums and Tracks tab buttons (same as attached playlist)
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            # Albums button
            detached_albums_tab_btn = QPushButton("Albums")
            detached_albums_tab_btn.setCheckable(True)
            # Get current active tab from playlist sidebar
            current_tab = getattr(self.playlist_sidebar, 'active_tab', 'albums')
            detached_albums_tab_btn.setChecked(current_tab == 'albums')
            detached_albums_tab_btn.setToolTip("Show Albums Playlist")
            detached_albums_tab_btn.setFixedSize(50, 22)  # Compact size to fit in title bar
            detached_albums_tab_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: 1px solid transparent;
                    font-size: 11px;
                    padding: 2px 4px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
                QPushButton:checked {
                    background-color: transparent;
                    color: #4a90e2;
                    border: 1px solid #4a90e2;
                }
                QPushButton:focus {
                    outline: none;
                }
            """)
            detached_albums_tab_btn.clicked.connect(lambda: self.playlist_sidebar._switch_tab('albums'))
            title_layout.addWidget(detached_albums_tab_btn)
            
            # Tracks button
            detached_tracks_tab_btn = QPushButton("Tracks")
            detached_tracks_tab_btn.setCheckable(True)
            detached_tracks_tab_btn.setChecked(current_tab == 'tracks')
            detached_tracks_tab_btn.setToolTip("Show Current Album Tracks")
            detached_tracks_tab_btn.setFixedSize(50, 22)  # Compact size to fit in title bar
            detached_tracks_tab_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: 1px solid transparent;
                    font-size: 11px;
                    padding: 2px 4px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
                QPushButton:checked {
                    background-color: transparent;
                    color: #4a90e2;
                    border: 1px solid #4a90e2;
                }
                QPushButton:focus {
                    outline: none;
                }
            """)
            detached_tracks_tab_btn.clicked.connect(lambda: self.playlist_sidebar._switch_tab('tracks'))
            title_layout.addWidget(detached_tracks_tab_btn)
            
            # Store references to update tab states when switching
            self._detached_albums_tab_btn = detached_albums_tab_btn
            self._detached_tracks_tab_btn = detached_tracks_tab_btn
        
        # Copy all buttons from playlist sidebar
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            # Playlist menu button
            playlist_menu_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('ph.dots-three-outline-vertical-fill', color='#e0e0e0')
                if icon:
                    playlist_menu_btn.setIcon(icon)
                else:
                    playlist_menu_btn.setText("")
            else:
                playlist_menu_btn.setText("")
            playlist_menu_btn.setToolTip("Playlist Menu")
            playlist_menu_btn.setFixedSize(22, 22)
            playlist_menu_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            playlist_menu_btn.clicked.connect(self.playlist_sidebar.show_playlist_menu)
            title_layout.addWidget(playlist_menu_btn)
            
            title_layout.addStretch()
            
            # Detach/Attach button
            detach_btn = QPushButton()
            if HAS_QT_AWESOME:
                # Use attach icon since we're detached
                icon = None
                for icon_name in ['fa5s.window-maximize', 'fa5.window-maximize', 'ei.arrow-down', 'fa5s.compress']:
                    try:
                        icon = get_icon(icon_name, color='#e0e0e0')
                        if icon:
                            break
                    except:
                        continue
                if icon:
                    detach_btn.setIcon(icon)
                else:
                    detach_btn.setText("")
            else:
                detach_btn.setText("")
            detach_btn.setToolTip("Attach Playlist to Main Window")
            detach_btn.setFixedSize(22, 22)
            detach_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            detach_btn.clicked.connect(self._reattach_playlist)
            # Store detach button reference but don't add it yet - we'll add it in the correct order
            self._detached_detach_btn = detach_btn
        
        title_layout.addStretch()
        
        # Add URL button (on the right with other buttons)
        add_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('plus', color='#e0e0e0')
            if icon:
                add_btn.setIcon(icon)
            else:
                add_btn.setText("")
        else:
            add_btn.setText("")
        add_btn.setToolTip("Add URL(s) From Clipboard (Supports Multiple URLs, One Per Line)")
        add_btn.setFixedSize(22, 22)
        add_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
                outline: none;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:focus {
                outline: none;
                border: none;
            }
            QPushButton:pressed {
                outline: none;
                border: none;
            }
        """)
        add_btn.clicked.connect(self.playlist_sidebar.add_url)
        title_layout.addWidget(add_btn)
        
        # Link mode toggle button (before window controls)
        link_btn = QPushButton()
        link_btn.setCheckable(True)
        # Block signals when setting initial state to prevent triggering toggle during creation
        link_btn.blockSignals(True)
        link_btn.setChecked(self.playlist_window_linked)
        link_btn.blockSignals(False)
        # Set initial icon color based on linked state (blue if linked, gray if not)
        initial_icon_color = '#4a90e2' if self.playlist_window_linked else '#e0e0e0'
        if HAS_QT_AWESOME:
            icon = get_icon('link', color=initial_icon_color)
            if icon:
                link_btn.setIcon(icon)
            else:
                link_btn.setText("")
        else:
            link_btn.setText("")
        link_btn.setFixedSize(22, 22)  # Match other buttons
        link_btn.setToolTip("Windows are linked (automatic when snapped together)" if self.playlist_window_linked else "Windows are not linked (link automatically when snapped together)")
        # Store initial checked state for stylesheet
        initial_checked = "checked" if self.playlist_window_linked else ""
        link_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }}
            QPushButton:hover {{
                background-color: #3a3a3a;
            }}
            QPushButton:checked {{
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }}
            QPushButton:checked:disabled {{
                color: #4a90e2;
            }}
        """)
        # Update icon color when checked state changes (to match shuffle/repeat buttons)
        def update_link_icon(checked):
            if HAS_QT_AWESOME:
                icon_color = '#4a90e2' if checked else '#e0e0e0'
                icon = get_icon('link', color=icon_color)
                if icon:
                    link_btn.setIcon(icon)
        link_btn.toggled.connect(update_link_icon)
        # Don't connect to toggle function - button is read-only for visual feedback only
        # Linking is now automatic when windows snap together
        # Keep button enabled so icon colors work properly, but use event filter to block clicks
        class ReadOnlyButtonFilter(QObject):
            def __init__(self, parent=None):
                super().__init__(parent)
            
            def eventFilter(self, obj, event):
                # Block all mouse button events to prevent clicking
                if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.MouseButtonRelease, 
                                   QEvent.Type.MouseButtonDblClick):
                    # Accept the event to prevent it from being processed by the button
                    event.accept()
                    return True  # Event was handled, don't propagate
                return False  # Let other events through normally
        read_only_filter = ReadOnlyButtonFilter(self)
        link_btn.installEventFilter(read_only_filter)
        # Force initial icon color update
        update_link_icon(self.playlist_window_linked)
        title_layout.addWidget(link_btn)
        self._detached_link_btn = link_btn
        # Store reference to update function so we can call it directly when linking changes programmatically
        self._update_link_icon_func = update_link_icon
        
        # Window controls (minimize and close buttons at the end)
        # Note: Close button reattaches, so attach button is redundant and hidden
        controls_layout = QHBoxLayout()
        controls_layout.setContentsMargins(0, 0, 0, 0)
        controls_layout.setSpacing(2)  # Match title_layout spacing for consistency
        
        # Minimize button (first)
        minimize_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('minus', color='#e0e0e0')
            if icon:
                minimize_btn.setIcon(icon)
            else:
                minimize_btn.setText("")
        else:
            minimize_btn.setText("")
        minimize_btn.setFixedSize(22, 22)  # Match other buttons
        minimize_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        minimize_btn.clicked.connect(self.detached_playlist_window.showMinimized)
        controls_layout.addWidget(minimize_btn)
        
        # Attach button is hidden - close button already reattaches, so it's redundant
        
        # Close button (reattaches instead of closing)
        close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_btn.setIcon(icon)
            else:
                close_btn.setText("")
        else:
            close_btn.setText("")
        close_btn.setFixedSize(22, 22)  # Match other buttons
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #e81123;
                color: white;
            }
        """)
        close_btn.clicked.connect(self._reattach_playlist)
        controls_layout.addWidget(close_btn)
        
        title_layout.addLayout(controls_layout)
        
        # Enable window dragging on title bar
        def title_bar_mouse_press(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self._detached_window_drag_position = event.globalPosition().toPoint()
                # When dragging playlist starts, instantly unlink
                was_linked = self.playlist_window_linked
                if was_linked:
                    self._toggle_playlist_window_linking(False)
                    # Activate release window: brief period where snapping is disabled to allow easy breakaway
                    self._playlist_release_window_active = True
                    self._playlist_release_window_timer.start(150)  # 150ms grace period
                self._is_dragging_playlist_window = True
                self._snapped_during_drag = False
                # Store initial position for breakaway detection
                self._playlist_drag_start_pos = self.detached_playlist_window.pos()
                self._playlist_breakaway_activated = False
                event.accept()
        
        def title_bar_mouse_move(event):
            if event.buttons() == Qt.MouseButton.LeftButton and hasattr(self, '_detached_window_drag_position') and self._detached_window_drag_position is not None:
                delta = event.globalPosition().toPoint() - self._detached_window_drag_position
                new_pos = self.detached_playlist_window.pos() + delta
                self.detached_playlist_window.move(new_pos)
                self._detached_window_drag_position = event.globalPosition().toPoint()
                
                # Check if playlist is being dragged away from main window (breakaway detection)
                current_dist_to_main = self._calculate_distance_to_main_window(new_pos)
                breakaway_threshold = 10  # Fixed 10px threshold for breakaway
                
                if self._playlist_drag_start_pos:
                    start_dist_to_main = self._calculate_distance_to_main_window(self._playlist_drag_start_pos)
                    
                    # If distance increased by breakaway threshold, activate breakaway
                    if current_dist_to_main > start_dist_to_main + breakaway_threshold:
                        self._playlist_breakaway_activated = True
                    # If distance decreased (dragging back toward main window), reset breakaway
                    elif current_dist_to_main < start_dist_to_main:
                        self._playlist_breakaway_activated = False
                        # Update start position to current position for new reference
                        self._playlist_drag_start_pos = new_pos
                
                # Enable snapping if not linked, not in release window, and (not broken away OR windows are close enough to snap)
                # Release window gives a brief grace period after unlinking to allow easy breakaway
                # This allows snapping to re-engage if user drags back toward main window
                can_snap = (not self.playlist_window_linked and 
                           not self._playlist_release_window_active and
                           (not self._playlist_breakaway_activated or current_dist_to_main <= self._snap_threshold))
                if can_snap:
                    # Check if snapping occurred
                    if self._handle_playlist_window_snapping():
                        self._snapped_during_drag = True
                        # Reset breakaway if we snap (user is dragging toward main window)
                        self._playlist_breakaway_activated = False
                        # Reset drag start position since we snapped (new reference point)
                        self._playlist_drag_start_pos = new_pos
                event.accept()
        
        def title_bar_mouse_release(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self._is_dragging_playlist_window = False
                self._playlist_drag_start_pos = None
                self._playlist_breakaway_activated = False
                # Cancel release window timer if still active
                if self._playlist_release_window_timer.isActive():
                    self._playlist_release_window_timer.stop()
                self._playlist_release_window_active = False
                # If windows snapped during drag, link them now (on release) - but only if still close
                if self._snapped_during_drag:
                    # Check if windows are still close (within snap threshold)
                    main_rect = self.geometry()
                    detached_rect = self.detached_playlist_window.geometry()
                    
                    main_left = main_rect.x()
                    main_right = main_rect.x() + main_rect.width()
                    main_top = main_rect.y()
                    main_bottom = main_rect.y() + main_rect.height()
                    
                    detached_left = detached_rect.x()
                    detached_right = detached_rect.x() + detached_rect.width()
                    detached_top = detached_rect.y()
                    detached_bottom = detached_rect.y() + detached_rect.height()
                    
                    # Check if windows are within snap threshold
                    h_dist = 0
                    v_dist = 0
                    if detached_right < main_left:
                        h_dist = main_left - detached_right
                    elif detached_left > main_right:
                        h_dist = detached_left - main_right
                    
                    if detached_bottom < main_top:
                        v_dist = main_top - detached_bottom
                    elif detached_top > main_bottom:
                        v_dist = detached_top - main_bottom
                    
                    total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5
                    if total_dist <= self._snap_threshold:
                        # Windows are still close - link them
                        self._toggle_playlist_window_linking(True)
                        self._windows_docked = True
                        # Update link offset
                        main_x = self.x()
                        main_y = self.y()
                        detached_x = self.detached_playlist_window.x()
                        detached_y = self.detached_playlist_window.y()
                        self._playlist_window_link_offset = (detached_x - main_x, detached_y - main_y)
                self._snapped_during_drag = False
                if hasattr(self, '_detached_window_drag_position'):
                    self._detached_window_drag_position = None
        
        self.detached_playlist_title_bar.mousePressEvent = title_bar_mouse_press
        self.detached_playlist_title_bar.mouseMoveEvent = title_bar_mouse_move
        self.detached_playlist_title_bar.mouseReleaseEvent = title_bar_mouse_release
    
    def _create_detached_bottom_resize_handle(self):
        """Create bottom resize handle for detached playlist window (like main window)"""
        if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
            return  # Already exists
        
        if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
            return  # Window doesn't exist yet
        
        # Create resize handle widget as a direct child of the window (not in layout)
        # This ensures it can be positioned absolutely and stay on top
        self.detached_bottom_resize_handle = QWidget(self.detached_playlist_window)
        self.detached_bottom_resize_handle.setFixedHeight(6)  # 6px tall resize area
        self.detached_bottom_resize_handle.setStyleSheet("""
            QWidget {
                background-color: transparent;
            }
            QWidget:hover {
                background-color: rgba(100, 100, 100, 0.3);
            }
        """)
        # Use SizeVerCursor for vertical resizing from bottom edge (like main window)
        # The bottom edge allows resizing height, and width from the right side
        self.detached_bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)
        self.detached_bottom_resize_handle.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        
        # Initialize resize state variables
        self.detached_resize_start_y = None
        self.detached_resize_start_height = None
        self.detached_resize_start_x = None
        self.detached_resize_start_width = None
        self.detached_resize_start_pos = None  # Store initial mouse position relative to window
        
        # Mouse event handlers for resizing
        def handle_mouse_press(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.detached_resize_start_y = event.globalPosition().y()
                self.detached_resize_start_height = self.detached_playlist_window.height()
                self.detached_resize_start_x = event.globalPosition().x()
                self.detached_resize_start_width = self.detached_playlist_window.width()
                # Store mouse position relative to window for determining resize direction
                window_pos = self.detached_playlist_window.pos()
                self.detached_resize_start_pos = event.globalPosition().toPoint() - window_pos
                event.accept()
        
        def handle_mouse_move(event):
            if (self.detached_resize_start_y is not None and 
                self.detached_resize_start_x is not None and 
                event.buttons() & Qt.MouseButton.LeftButton):
                delta_y = event.globalPosition().y() - self.detached_resize_start_y
                delta_x = event.globalPosition().x() - self.detached_resize_start_x
                
                # Always resize height from bottom
                new_height = max(200, self.detached_resize_start_height + int(delta_y))  # Min 200px
                
                # Only resize height - width is always fixed to 260px to match main window
                # Dragging from any position only resizes height
                self.detached_playlist_window.resize(260, new_height)  # Always keep width at 260px
                # Update cursor to vertical (only height resizing)
                if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                    self.detached_bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)
                event.accept()
            else:
                # Update cursor on hover - always vertical since we only resize height
                if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                    self.detached_bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)
        
        def handle_mouse_release(event):
            self.detached_resize_start_y = None
            self.detached_resize_start_height = None
            self.detached_resize_start_x = None
            self.detached_resize_start_width = None
            self.detached_resize_start_pos = None
            # Reset cursor to vertical
            self.detached_bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)
            event.accept()
        
        self.detached_bottom_resize_handle.mousePressEvent = handle_mouse_press
        self.detached_bottom_resize_handle.mouseMoveEvent = handle_mouse_move
        self.detached_bottom_resize_handle.mouseReleaseEvent = handle_mouse_release
        
        # Position at bottom of window
        self._update_detached_bottom_resize_handle_position()
        self.detached_bottom_resize_handle.show()
        self.detached_bottom_resize_handle.raise_()  # Keep on top
    
    def _update_detached_bottom_resize_handle_position(self):
        """Update bottom resize handle position for detached window"""
        if not hasattr(self, 'detached_bottom_resize_handle') or not self.detached_bottom_resize_handle:
            return
        if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
            return
        
        # Position at bottom of window, full width (like main window)
        handle_height = 6
        window_width = self.detached_playlist_window.width()
        window_height = self.detached_playlist_window.height()
        self.detached_bottom_resize_handle.setGeometry(0, window_height - handle_height, window_width, handle_height)
        # Ensure it's always on top and visible
        self.detached_bottom_resize_handle.show()
        self.detached_bottom_resize_handle.raise_()
        # Make sure it can receive mouse events (not transparent)
        self.detached_bottom_resize_handle.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        # Set stacking order to ensure it's above all other widgets
        self.detached_bottom_resize_handle.setAttribute(Qt.WidgetAttribute.WA_NoSystemBackground, True)
        # Force raise again to ensure it's on top
        self.detached_bottom_resize_handle.raise_()
    
    def _save_playlist_detach_state(self):
        """Save playlist detach state to settings."""
        try:
            self.settings['playlist_detached'] = self.playlist_detached
            if self.detached_playlist_window:
                try:
                    pos = self.detached_playlist_window.pos()
                    size = self.detached_playlist_window.size()
                    # Save absolute position
                    self.playlist_detached_position = (pos.x(), pos.y())
                    # Also save relative offset for backward compatibility
                    main_pos = self.pos()
                    self.playlist_detached_offset = (pos.x() - main_pos.x(), pos.y() - main_pos.y())
                    self.playlist_detached_size = f"{size.width()}x{size.height()}"
                except Exception:
                    pass
            self.settings['playlist_detached_offset'] = self.playlist_detached_offset
            self.settings['playlist_detached_position'] = self.playlist_detached_position
            self.settings['playlist_detached_size'] = self.playlist_detached_size
            # Save link mode state
            self.settings['playlist_window_linked'] = self.playlist_window_linked
            self.save_settings()
        except Exception as e:
            logger.debug(f"Error saving playlist detach state: {e}")
    
    def reload_page(self):
        """Reload the current page"""
        self.web_view.reload()
    
    def toggle_dev_tools(self):
        """Toggle developer tools/inspector"""
        dev_tools_opening = self.dev_tools_window is None or not self.dev_tools_window.isVisible()
        
        if dev_tools_opening:
            try:
                # Create developer tools window
                self.dev_tools_window = QWidget()
                self.dev_tools_window.setWindowTitle("Developer Tools - Bandcamp Player")
                self.dev_tools_window.setMinimumSize(800, 600)
                
                # Restore window geometry from settings
                dev_tools_geometry = self.settings.get("dev_tools_geometry")
                if dev_tools_geometry:
                    try:
                        x = dev_tools_geometry.get("x", 100)
                        y = dev_tools_geometry.get("y", 100)
                        width = dev_tools_geometry.get("width", 1000)
                        height = dev_tools_geometry.get("height", 700)
                        self.dev_tools_window.setGeometry(x, y, width, height)
                    except:
                        self.dev_tools_window.resize(1000, 700)
                else:
                    self.dev_tools_window.resize(1000, 700)
                
                # Create a web view for dev tools using the same profile
                # This ensures dev tools settings are persisted
                # Initialize profile if not already done (lazy initialization)
                if not self._webengine_storage_setup:
                    self.setup_webengine_storage()
                    self._webengine_storage_setup = True
                dev_tools_page = QWebEnginePage(self.webengine_profile, self.dev_tools_window)
                dev_tools_view = QWebEngineView()
                dev_tools_view.setPage(dev_tools_page)
                
                dev_tools_layout = QVBoxLayout(self.dev_tools_window)
                dev_tools_layout.setContentsMargins(0, 0, 0, 0)
                dev_tools_layout.addWidget(dev_tools_view)
                
                # Set the dev tools page - this connects the inspector to the main page
                # Using the same profile ensures settings persistence
                self.web_view.page().setDevToolsPage(dev_tools_page)
                
                # Store dev tools page reference for element inspection
                self.dev_tools_page = dev_tools_page
                
                # Set dev tools theme - use our saved preference or default to dark
                # DevTools may store theme in IndexedDB, so we'll try multiple storage mechanisms
                dev_tools_theme = self.settings.get("dev_tools_theme", "dark")  # Default to dark
                
                def apply_dev_tools_theme(theme):
                    """Apply theme to developer tools using multiple methods including IndexedDB"""
                    theme_js = f"""
                    (function() {{
                        try {{
                            const theme = '{theme}';
                            console.log('DevTools: Applying theme:', theme);
                            
                            // Method 1: Set in localStorage (multiple keys)
                            if (window.localStorage) {{
                                window.localStorage.setItem('theme', theme);
                                window.localStorage.setItem('uiTheme', theme);
                                window.localStorage.setItem('devtools-theme', theme);
                                window.localStorage.setItem('theme-source', 'user');
                            }}
                            
                            // Method 2: Set in IndexedDB (DevTools may use this for persistence)
                            if (window.indexedDB) {{
                                try {{
                                    const request = window.indexedDB.open('DevToolsSettings', 1);
                                    request.onsuccess = function(event) {{
                                        const db = event.target.result;
                                        if (db.objectStoreNames.contains('settings')) {{
                                            const transaction = db.transaction(['settings'], 'readwrite');
                                            const store = transaction.objectStore('settings');
                                            store.put({{ key: 'theme', value: theme }});
                                            store.put({{ key: 'uiTheme', value: theme }});
                                        }}
                                    }};
                                }} catch (e) {{
                                    console.log('IndexedDB access failed:', e);
                                }}
                            }}
                            
                            // Method 3: Try DevTools API
                            if (window.DevToolsAPI) {{
                                if (window.DevToolsAPI.setTheme) {{
                                    window.DevToolsAPI.setTheme(theme);
                                }}
                                if (window.DevToolsAPI.setSetting) {{
                                    window.DevToolsAPI.setSetting('theme', theme);
                                }}
                            }}
                            
                            // Method 4: Try InspectorFrontendHost (most reliable for DevTools)
                            if (window.InspectorFrontendHost) {{
                                if (window.InspectorFrontendHost.setTheme) {{
                                    window.InspectorFrontendHost.setTheme(theme);
                                }}
                                if (window.InspectorFrontendHost.setPreference) {{
                                    window.InspectorFrontendHost.setPreference('theme', theme);
                                }}
                                // Try the actual method that Chrome DevTools uses
                                if (window.InspectorFrontendHost.setPreference) {{
                                    window.InspectorFrontendHost.setPreference('uiTheme', theme);
                                }}
                            }}
                            
                            // Method 5: Try Settings object
                            if (window.Settings && window.Settings.setSetting) {{
                                window.Settings.setSetting('theme', theme);
                                window.Settings.setSetting('uiTheme', theme);
                            }}
                            
                            // Method 6: Try to find and interact with the theme selector UI
                            setTimeout(() => {{
                                try {{
                                    // Look for the actual theme selector in DevTools UI
                                    const selectors = [
                                        'select[aria-label*="theme" i]',
                                        'select[title*="theme" i]',
                                        '.toolbar-select[aria-label*="theme" i]',
                                        '[data-key="ui-theme"]',
                                        'select.toolbar-select'
                                    ];
                                    
                                    for (const selector of selectors) {{
                                        const select = document.querySelector(selector);
                                        if (select && select.options) {{
                                            for (let i = 0; i < select.options.length; i++) {{
                                                const option = select.options[i];
                                                if (option.value === theme || 
                                                    option.text.toLowerCase().includes(theme)) {{
                                                    select.value = option.value;
                                                    select.dispatchEvent(new Event('change', {{ bubbles: true }}));
                                                    console.log('DevTools: Set theme via UI selector');
                                                    break;
                                                }}
                                            }}
                                        }}
                                    }}
                                }} catch (e) {{
                                    // Ignore errors in UI selector search
                                }}
                            }}, 2500);
                            
                            return true;
                        }} catch (e) {{
                            console.error('Error applying dev tools theme:', e);
                            return false;
                        }}
                    }})();
                    """
                    dev_tools_page.runJavaScript(theme_js)
                
                # Also monitor for theme changes to save user's manual preference
                def monitor_theme_changes():
                    """Monitor for theme changes and save to our settings"""
                    monitor_js = """
                    (function() {
                        try {
                            // Monitor localStorage changes
                            const originalSetItem = window.localStorage.setItem;
                            window.localStorage.setItem = function(key, value) {
                                originalSetItem.apply(this, arguments);
                                if (key === 'theme' || key === 'uiTheme' || key === 'devtools-theme') {
                                    // Notify Python about theme change
                                    if (window.qt && window.qt.webChannelTransport) {
                                        // Try to send message back to Python
                                        console.log('DevTools theme changed to:', value);
                                    }
                                }
                            };
                            
                            // Also listen for theme change events
                            window.addEventListener('theme-changed', function(e) {
                                console.log('DevTools theme change event:', e.detail);
                            });
                            
                            return true;
                        } catch (e) {
                            return false;
                        }
                    })();
                    """
                    dev_tools_page.runJavaScript(monitor_js)
                
                # Connect to page load to apply theme when dev tools loads
                def on_dev_tools_load_finished(success):
                    if success:
                        # Apply theme with multiple attempts at different times
                        QTimer.singleShot(500, lambda: apply_dev_tools_theme(dev_tools_theme))
                        QTimer.singleShot(1000, lambda: apply_dev_tools_theme(dev_tools_theme))
                        QTimer.singleShot(2000, lambda: apply_dev_tools_theme(dev_tools_theme))
                        QTimer.singleShot(3000, lambda: apply_dev_tools_theme(dev_tools_theme))
                        # Monitor for changes
                        QTimer.singleShot(2000, monitor_theme_changes)
                
                dev_tools_page.loadFinished.connect(on_dev_tools_load_finished)
                
                # Also try immediately with delays
                QTimer.singleShot(500, lambda: apply_dev_tools_theme(dev_tools_theme))
                QTimer.singleShot(1500, lambda: apply_dev_tools_theme(dev_tools_theme))
                
                # Save geometry when window closes
                def save_geometry_on_close(event):
                    if self.dev_tools_window:
                        geom = self.dev_tools_window.geometry()
                        self.settings["dev_tools_geometry"] = {
                            "x": geom.x(),
                            "y": geom.y(),
                            "width": geom.width(),
                            "height": geom.height()
                        }
                        
                        # Try to read current theme from DevTools before closing
                        def read_theme():
                            read_theme_js = """
                            (function() {
                                try {
                                    const theme = window.localStorage.getItem('theme') || 
                                                 window.localStorage.getItem('uiTheme') || 
                                                 window.localStorage.getItem('devtools-theme') || 
                                                 'dark';
                                    return theme;
                                } catch (e) {
                                    return 'dark';
                                }
                            })();
                            """
                            def on_theme_read(theme):
                                if theme and isinstance(theme, str):
                                    self.settings["dev_tools_theme"] = theme
                                    logger.debug(f"DevTools: Saved theme preference: {theme}")
                                self.save_settings()
                            
                            if self.dev_tools_page:
                                self.dev_tools_page.runJavaScript(read_theme_js, on_theme_read)
                            else:
                                self.save_settings()
                        
                        # Try to read theme, but don't wait too long
                        QTimer.singleShot(100, read_theme)
                        
                        self.save_settings()
                    # Hide developer menu options when dev tools closes
                    self.bandcamp_action.setVisible(False)
                    self.compact_action.setVisible(False)
                    self.frameless_action.setVisible(False)
                    self.transparent_overlay_action.setVisible(False)
                    event.accept()
                
                # Override close event to save geometry
                self.dev_tools_window.closeEvent = save_geometry_on_close
                
                # Show the window
                self.dev_tools_window.show()
                self.dev_tools_window.raise_()
                self.dev_tools_window.activateWindow()
                
                # Show developer menu options when dev tools opens
                self.bandcamp_action.setVisible(True)
                self.compact_action.setVisible(True)
                self.frameless_action.setVisible(True)
                self.transparent_overlay_action.setVisible(True)
            except Exception as e:
                QMessageBox.warning(self, "Developer Tools Error", 
                                  f"Failed to open developer tools:\n\n{str(e)}")
                self.dev_tools_window = None
        else:
            # Save geometry before hiding
            try:
                if self.dev_tools_window:
                    geom = self.dev_tools_window.geometry()
                    self.settings["dev_tools_geometry"] = {
                        "x": geom.x(),
                        "y": geom.y(),
                        "width": geom.width(),
                        "height": geom.height()
                    }
                    self.save_settings()
                # Hide the window
                self.dev_tools_window.hide()
                
                # Hide developer menu options when dev tools closes
                self.bandcamp_action.setVisible(False)
                self.compact_action.setVisible(False)
                self.frameless_action.setVisible(False)
                self.transparent_overlay_action.setVisible(False)
                # Clear dev tools page reference
                self.dev_tools_page = None
            except Exception as e:
                QMessageBox.warning(self, "Developer Tools Error", 
                                  f"Error closing developer tools:\n\n{str(e)}")
                self.dev_tools_window = None
                self.dev_tools_page = None
    
    def _trigger_inspect_at_position(self, position):
        """Trigger inspect at position - ensures dev tools is open first"""
        # Check if dev tools is open, if not wait a bit more
        if not self.dev_tools_window or not self.dev_tools_window.isVisible():
            # Wait a bit more and try again
            QTimer.singleShot(500, lambda: self._trigger_inspect_at_position(position))
            return
        # Dev tools is open, trigger inspect
        self.inspect_element_at_position(position)
    
    def inspect_element_at_position(self, position):
        """Inspect element at the given position in the web view - only works when dev tools are open"""
        # Only proceed if dev tools are open
        if not self.dev_tools_window or not self.dev_tools_window.isVisible():
            return
        
        # Convert widget position to content coordinates (accounting for zoom)
        zoom_factor = self.web_view.zoomFactor()
        content_x = position.x() / zoom_factor
        content_y = position.y() / zoom_factor
        
        # Use Chrome DevTools Protocol to select the element
        # First, get the element and its node ID, then select it in dev tools
        js_code = f"""
        (function() {{
            try {{
                // Get element at the click position
                const element = document.elementFromPoint({content_x}, {content_y});
                if (!element) {{
                    console.log('Bandcamp Player: No element found at position');
                    return null;
                }}
                
                // Store element reference
                window.__elementToInspect = element;
                
                // Try to get a unique identifier for the element
                // We'll use a combination of tag name, class, and position
                const tagName = element.tagName || 'UNKNOWN';
                const className = element.className || '';
                const id = element.id || '';
                
                return {{
                    tagName: tagName,
                    className: className,
                    id: id,
                    x: {content_x},
                    y: {content_y}
                }};
            }} catch (e) {{
                console.error('Bandcamp Player: Error getting element:', e);
                return null;
            }}
        }})();
        """
        
        def on_js_result(result):
            if not result:
                return
            
            # Now select the element in dev tools using Chrome DevTools Protocol
            # We need to inject into the dev tools page to use the protocol
            self._select_element_in_dev_tools(content_x, content_y)
        
        # Run JavaScript to get element info
        self.web_view.page().runJavaScript(js_code, on_js_result)
    
    def _select_element_in_dev_tools(self, x, y):
        """Select element in dev tools Elements panel using Chrome DevTools Protocol"""
        # First, highlight the element in the main page
        js_code = f"""
        (function() {{
            try {{
                // Get element at position (prefer stored reference, fallback to elementFromPoint)
                let element = window.__elementToInspect;
                if (!element) {{
                    element = document.elementFromPoint({x}, {y});
                }}
                
                if (!element) {{
                    console.log('Bandcamp Player: No element found at position for dev tools');
                    return false;
                }}
                
                // Scroll element into view
                element.scrollIntoView({{ behavior: 'smooth', block: 'center' }});
                
                // Highlight the element with a blue outline
                const originalOutline = element.style.outline;
                const originalOutlineOffset = element.style.outlineOffset;
                element.style.outline = '2px solid #4285f4';
                element.style.outlineOffset = '2px';
                
                // Remove highlight after 3 seconds
                setTimeout(() => {{
                    element.style.outline = originalOutline;
                    element.style.outlineOffset = originalOutlineOffset;
                }}, 3000);
                
                return true;
            }} catch (e) {{
                console.error('Bandcamp Player: Error highlighting element:', e);
                return false;
            }}
        }})();
        """
        
        self.run_javascript_safe(js_code)
        
        # Now try to select the element in dev tools Elements panel
        # We need to use Chrome DevTools Protocol via the dev tools page
        if self.dev_tools_page:
            # Wait a bit for dev tools to be ready, then inject selection command
            QTimer.singleShot(200, lambda: self._inject_element_selection(x, y))
    
    def _inject_element_selection(self, x, y):
        """Inject JavaScript into dev tools page to select element in Elements panel"""
        if not self.dev_tools_page:
            return
        
        # JavaScript to inject into the dev tools page
        # This uses Chrome DevTools Protocol commands
        dev_tools_js = f"""
        (function() {{
            try {{
                // Access the Chrome DevTools Protocol
                if (window.DevToolsAPI && window.DevToolsAPI.inspectElement) {{
                    // Use the inspectElement method if available
                    window.DevToolsAPI.inspectElement({x}, {y});
                    return true;
                }}
                
                // Alternative: Try to use the inspector's selectNodeForLocation method
                if (window.InspectorFrontendHost && window.InspectorFrontendHost.inspect) {{
                    window.InspectorFrontendHost.inspect({x}, {y});
                    return true;
                }}
                
                // Fallback: Try to dispatch a message to the inspector
                if (window.postMessage) {{
                    window.postMessage({{
                        method: 'DOM.getNodeForLocation',
                        params: {{ x: {x}, y: {y} }}
                    }}, '*');
                    return true;
                }}
                
                return false;
            }} catch (e) {{
                console.error('Bandcamp Player: Error selecting element in dev tools:', e);
                return false;
            }}
        }})();
        """
        
        # Inject into the dev tools page
        self.dev_tools_page.runJavaScript(dev_tools_js)
    
    def update_playlist_display(self):
        """Update the playlist display"""
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            self.playlist_sidebar.load_playlist()
    
    def on_playlist_item_clicked(self, item):
        """Handle playlist item double-click (backward compatibility)"""
        # This is now handled by the sidebar
        pass
    
    def apply_settings(self):
        """Apply saved settings"""
        self.apply_always_on_top()
        self.apply_frameless_mode()
        # Apply rounded corners if frameless mode is enabled
        if self.frameless_mode:
            QTimer.singleShot(100, self.apply_rounded_corners)
            # Ensure bottom resize handle is created and positioned
            QTimer.singleShot(150, lambda: self.update_bottom_resize_handle_position() if hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle else None)
        # Update mini mode button visibility
        if hasattr(self, 'mini_mode_btn'):
            self.update_mini_mode_button()
        # Update always on top button icon color if it exists
        if hasattr(self, 'always_on_top_btn'):
            if HAS_QT_AWESOME:
                icon_color = '#4a9eff' if self.always_on_top else '#e0e0e0'
                icon = get_icon('thumbtack', color=icon_color)
                if icon:
                    self.always_on_top_btn.setIcon(icon)
        if self.web_view:
            # Always inject CSS (for regular mode or as base for mini/micro mode)
            self.inject_css()
            # Note: Mini mode is applied separately in __init__ with minimal delay
            # to prevent flash of regular mode before switching
    
    def load_settings(self):
        """Load settings from file"""
        if self.settings_file.exists():
            try:
                with open(self.settings_file, 'r') as f:
                    settings = json.load(f)
                    # Ensure bandcamp_mode exists (default to True for new installs)
                    if 'bandcamp_mode' not in settings:
                        settings['bandcamp_mode'] = True
                    # Ensure compact_mode exists (default to True for new installs)
                    if 'compact_mode' not in settings:
                        settings['compact_mode'] = True
                    # Ensure autoplay exists (default to True for new installs)
                    if 'autoplay' not in settings:
                        settings['autoplay'] = True
                    # Ensure mini_mode_state exists (default to 0 for new installs)
                    if 'mini_mode_state' not in settings:
                        settings['mini_mode_state'] = 0
                    # Ensure autohide_address_bar exists (default to True for new installs)
                    if 'autohide_address_bar' not in settings:
                        settings['autohide_address_bar'] = True
                    # Ensure mini_mode_player_autohide exists (default to False for new installs)
                    if 'mini_mode_player_autohide' not in settings:
                        settings['mini_mode_player_autohide'] = False
                    # Ensure autoplay_on_startup exists (default to True for new installs)
                    if 'autoplay_on_startup' not in settings:
                        settings['autoplay_on_startup'] = True
                    # Ensure playlist_visible exists (default to True for new installs)
                    if 'playlist_visible' not in settings:
                        settings['playlist_visible'] = True
                    # Ensure playlist_minimized exists (default to True for new installs)
                    if 'playlist_minimized' not in settings:
                        settings['playlist_minimized'] = True
                    # Ensure repeat_mode exists (default to 1 for new installs - continuous)
                    if 'repeat_mode' not in settings:
                        settings['repeat_mode'] = 1
                    # Ensure nano_always_on_top exists (default to True for new installs)
                    if 'nano_always_on_top' not in settings:
                        settings['nano_always_on_top'] = True
                    return settings
            except:
                pass
        return {}
    
    def save_settings(self):
        """Save settings to file"""
        # No longer storing mini_mode_original_size - each mode uses fixed defaults
        
        # Save current playlist file path (relative to Playlists directory)
        current_playlist_file = None
        if hasattr(self, 'playlist_manager') and self.playlist_manager:
            playlist_file = self.playlist_manager.playlist_file
            if playlist_file:
                # Store relative path to Playlists directory for portability
                try:
                    rel_path = playlist_file.relative_to(self.playlist_manager.playlists_dir)
                    current_playlist_file = str(rel_path)
                except ValueError:
                    # If not relative, store the filename only
                    current_playlist_file = playlist_file.name
        
        # Get current track number for saving (from main window - updated continuously)
        current_track_to_save = None
        if hasattr(self, '_current_track_number') and self._current_track_number is not None:
            current_track_to_save = self._current_track_number
        # Fallback: try nano player if main window doesn't have it
        elif hasattr(self, 'nano_player_window') and self.nano_player_window and hasattr(self.nano_player_window, '_current_track_number'):
            current_track_to_save = self.nano_player_window._current_track_number
        # If still None, preserve the existing saved value (don't overwrite with None during startup)
        elif current_track_to_save is None:
            current_track_to_save = self.settings.get("last_played_track_number")
        
        # Update existing settings with current state, preserving other keys
        self.settings.update({
            "compact_mode": self.compact_mode,
            "bandcamp_mode": self.bandcamp_mode,
            "always_on_top": self.always_on_top,
            "frameless_mode": self.frameless_mode,
            "mini_mode_state": self.mini_mode_state,
            "autohide_address_bar": self.autohide_address_bar,
            "mini_mode_player_autohide": self.mini_mode_player_autohide,
            "mini_mode_player_hidden": self.mini_mode_player_hidden,
            "current_playlist_file": current_playlist_file,  # Save current playlist file
            "autoplay": self.autoplay,
            "autoplay_on_startup": self.autoplay_on_startup,
            "last_played_url": self.settings.get("last_played_url"),  # Preserve last played URL
            "last_played_track_number": current_track_to_save,  # Save current track number
            "playlist_visible": self.settings.get("playlist_visible", False),  # Preserve playlist visibility
            "playlist_minimized": self.settings.get("playlist_minimized", False),  # Preserve playlist minimized state
            "playlist_height": self.settings.get("playlist_height", 250),  # Preserve playlist height
            "playlist_detached": self.settings.get("playlist_detached", False),  # Preserve playlist detached state
            "playlist_detached_offset": self.settings.get("playlist_detached_offset", (20, 0)),  # Preserve detached window offset
            "playlist_detached_size": self.settings.get("playlist_detached_size", "260x400"),  # Preserve detached window size
            # These are now explicitly updated from the sidebar in closeEvent
            "shuffle_on": self.settings.get("shuffle_on", False),  # Preserve shuffle state
            "repeat_on": self.settings.get("repeat_on", False),  # Preserve repeat state (default to False)
            "keyboard_shortcuts": self.settings.get("keyboard_shortcuts", {}),  # Preserve keyboard shortcuts
            "auto_check_updates": self.settings.get("auto_check_updates", True),  # Preserve auto-check updates setting
        })
        try:
            with open(self.settings_file, 'w') as f:
                json.dump(self.settings, f, indent=2)
        except:
            pass
    
    def _get_version_string(self):
        """Get formatted version string for display.
        
        Returns:
            "vX.X.X" or "vX.X.X (Launcher vX.X.X)" if launcher mode
        """
        gui_version = __version__
        launcher_version = self._get_launcher_version()
        
        edition = globals().get("__edition__")
        edition_suffix = f" ({edition})" if edition else ""

        if launcher_version:
            return f"v{gui_version}{edition_suffix} (Launcher v{launcher_version})"
        else:
            return f"v{gui_version}{edition_suffix}"
    
    def _get_launcher_version(self):
        """Get launcher version if running in launcher mode."""
        launcher_version = os.environ.get('BANDCAMP_PLAYER_LAUNCHER_VERSION')
        return launcher_version if launcher_version else None
    
    def _show_about_dialog(self):
        """Show About dialog"""
        version_string = self._get_version_string()
        about_text = f"""Bandcamp Player
{version_string}

A standalone mini player for streaming music from Bandcamp built with PyQt6 and QWebEngineView.

Features:
 Regular, Mini, Micro, and Nano player modes
 Image viewer with fullscreen player and visualizations
 Playlist management with shuffle and repeat modes
 Keyboard shortcuts and global hotkeys
 Auto-update system
 Customizable UI and settings

GitHub: https://github.com/kameryn1811/Bandcamp-Player"""
        
        QMessageBox.about(self, "About Bandcamp Player", about_text)
    
    def on_auto_check_updates_change(self):
        """Handle auto-check for updates checkbox change."""
        auto_check = self.auto_check_updates_action.isChecked()
        self.settings["auto_check_updates"] = auto_check
        self.save_settings()

    def _on_ui_invoke(self, fn):
        """Internal slot: executes a callable on the UI thread."""
        try:
            fn()
        except Exception:
            pass

    def _message_box(self, icon, title, text, buttons=QMessageBox.StandardButton.Ok):
        """Show a QMessageBox that stays above the main window (UI-thread safe via caller)."""
        msg_box = QMessageBox(self)
        try:
            msg_box.setIcon(icon)
        except Exception:
            pass
        msg_box.setWindowTitle(title)
        msg_box.setText(text)
        msg_box.setStandardButtons(buttons)

        # Ensure it appears above the main window, even if main window is always-on-top.
        try:
            if bool(self.windowFlags() & Qt.WindowType.WindowStaysOnTopHint):
                msg_box.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, True)
        except Exception:
            pass
        try:
            msg_box.setWindowModality(Qt.WindowModality.ApplicationModal)
        except Exception:
            pass

        return msg_box.exec()

    def _show_info(self, title, text):
        return self._message_box(QMessageBox.Icon.Information, title, text, QMessageBox.StandardButton.Ok)

    def _show_warning(self, title, text):
        return self._message_box(QMessageBox.Icon.Warning, title, text, QMessageBox.StandardButton.Ok)

    def _run_on_ui_thread(self, fn):
        """Run a callable on the Qt UI thread (safe from worker threads)."""
        try:
            # If we're already on the UI thread, run immediately.
            if QThread.currentThread() == self.thread():
                fn()
                return

            # Otherwise, queue onto the UI thread via signal/slot.
            self._ui_invoke.emit(fn)
        except Exception:
            # Fallback: try direct call (may fail if called off-thread, but better than silent no-op)
            try:
                fn()
            except Exception:
                pass
    
    def check_for_updates(self, checked=False, show_if_no_update=True):
        """Check for updates by reading version directly from main branch.
        
        Args:
            checked: QAction.triggered(bool) passes this automatically; unused.
            show_if_no_update: If True, show message even if no update is available (for manual check)
        """
        def check():
            try:
                try:
                    import requests
                    import re
                except ImportError:
                    error_msg = "The 'requests' library is required for update checking.\n\nPlease install it:\npython -m pip install requests"
                    logger.error(error_msg)
                    if show_if_no_update:
                        self._run_on_ui_thread(lambda: self._show_warning("Update Check Failed", error_msg))
                    return
                
                # GitHub repository info
                repo_owner = "kameryn1811"
                repo_name = "Bandcamp-Player"
                
                # Get version directly from main branch file (not from releases)
                download_url = f"https://raw.githubusercontent.com/{repo_owner}/{repo_name}/main/bandcamp_pl_gui.py"
                logger.debug(f"Checking for updates from: {download_url}")
                
                response = requests.get(download_url, timeout=10)
                response.raise_for_status()
                file_content = response.text
                
                logger.debug(f"Fetched file content, length: {len(file_content)} characters")
                
                # Extract version from the file
                version_match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', file_content)
                if not version_match:
                    error_msg = "Could not find version number in main branch file."
                    logger.error(error_msg)
                    if show_if_no_update:
                        self._run_on_ui_thread(lambda: self._show_warning("Update Check Failed", error_msg))
                    return
                
                latest_version = version_match.group(1)
                current_version = __version__
                
                logger.info(f"Version check: Current={current_version}, Latest={latest_version}")
                
                # Compare versions
                comparison_result = self._compare_versions(latest_version, current_version)
                logger.debug(f"Version comparison result: {comparison_result} (1=newer, 0=same, -1=older)")
                
                if comparison_result > 0:
                    # Update available - show popup
                    logger.info(f"Update available: v{current_version}  v{latest_version}")
                    
                    # Try to fetch commit message from GitHub API
                    release_notes = self._fetch_commit_message(repo_owner, repo_name, latest_version)
                    
                    # Show update dialog - use QTimer to ensure it runs on main thread
                    # Store values as instance variables to avoid closure issues
                    self._pending_update_info = {
                        'current_version': current_version,
                        'latest_version': latest_version,
                        'download_url': download_url,
                        'release_notes': release_notes
                    }
                    self._run_on_ui_thread(self._show_pending_update_popup)
                elif comparison_result == 0:
                    # Versions are the same - already up to date
                    logger.info(f"Already up to date (current: v{current_version}, latest: v{latest_version})")
                    if show_if_no_update:
                        # User manually checked, show "up to date" message
                        # Store values to avoid closure issues
                        msg_current_version = current_version
                        self._run_on_ui_thread(lambda v=msg_current_version: self._show_info(
                            "Update Check",
                            f"You're running the latest version (v{v})\n\nNo updates available."
                        ))
                else:
                    # Current version is newer than latest (shouldn't happen, but handle gracefully)
                    logger.warning(f"Current version ({current_version}) is newer than latest ({latest_version})")
                    if show_if_no_update:
                        msg_current_version = current_version
                        self._run_on_ui_thread(lambda v=msg_current_version: self._show_info(
                            "Update Check",
                            f"You're running version v{v}\n\nThis appears to be a development or pre-release version."
                        ))
            except requests.exceptions.RequestException as e:
                error_msg = f"Could not check for updates.\n\nError: {str(e)}\n\nPlease check your internet connection."
                logger.error(f"Update check failed (network error): {e}", exc_info=True)
                if show_if_no_update:
                    self._run_on_ui_thread(lambda: self._show_warning("Update Check Failed", error_msg))
            except Exception as e:
                error_msg = f"An error occurred while checking for updates.\n\nError: {str(e)}"
                logger.error(f"Update check failed (unexpected error): {e}", exc_info=True)
                if show_if_no_update:
                    self._run_on_ui_thread(lambda: self._show_warning("Update Check Failed", error_msg))
        
        # Run in background thread to avoid blocking UI
        import threading
        threading.Thread(target=check, daemon=True).start()
    
    def _check_for_updates_background(self):
        """Check for updates in background (non-blocking, no popup if up to date)."""
        self.check_for_updates(show_if_no_update=False)
    
    def _compare_versions(self, version1, version2):
        """Compare two version strings.
        
        Returns:
            -1 if version1 < version2
             0 if version1 == version2
             1 if version1 > version2
        """
        def version_tuple(v):
            parts = []
            for part in v.split('.'):
                try:
                    parts.append(int(part))
                except ValueError:
                    parts.append(0)
            return tuple(parts)
        
        v1_tuple = version_tuple(version1)
        v2_tuple = version_tuple(version2)
        
        max_len = max(len(v1_tuple), len(v2_tuple))
        v1_tuple = v1_tuple + (0,) * (max_len - len(v1_tuple))
        v2_tuple = v2_tuple + (0,) * (max_len - len(v2_tuple))
        
        if v1_tuple < v2_tuple:
            return -1
        elif v1_tuple > v2_tuple:
            return 1
        else:
            return 0
    
    def _fetch_commit_message(self, repo_owner, repo_name, version):
        """Fetch the commit message for the latest commit that modified bandcamp_pl_gui.py."""
        try:
            import requests
            
            # Get the latest commit that modified bandcamp_pl_gui.py on main branch
            api_url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/commits"
            params = {
                'path': 'bandcamp_pl_gui.py',
                'sha': 'main',
                'per_page': 1
            }
            
            response = requests.get(api_url, params=params, timeout=10)
            response.raise_for_status()
            commits = response.json()
            
            if commits and len(commits) > 0:
                commit_message = commits[0].get('commit', {}).get('message', '')
                # Clean up the commit message
                lines = commit_message.strip().split('\n')
                if len(lines) > 1 and (lines[0].startswith('v') or lines[0] == version):
                    commit_message = '\n'.join(lines[1:]).strip()
                return commit_message
            
            return ""
        except Exception as e:
            logger.debug(f"Could not fetch commit message: {str(e)}")
            return ""
    
    def _show_pending_update_popup(self):
        """Show pending update popup (called from main thread via QTimer)."""
        if hasattr(self, '_pending_update_info') and self._pending_update_info:
            info = self._pending_update_info
            self._show_update_popup(
                info.get('current_version'),
                info.get('latest_version'),
                info.get('download_url'),
                info.get('release_notes', '')
            )
            # Clear pending info
            self._pending_update_info = None
    
    def _show_update_popup(self, current_version, latest_version, download_url, release_notes=""):
        """Show update available popup."""
        if not current_version or not latest_version:
            QMessageBox.warning(
                self,
                "Update Error",
                f"Invalid version information detected.\n\n"
                f"Current: {current_version}\n"
                f"Latest: {latest_version}\n\n"
                f"Please check for updates manually."
            )
            return
        
        if not download_url:
            QMessageBox.warning(
                self,
                "Update Error",
                "No download URL available. Please download manually from GitHub."
            )
            return
        
        # Format release notes (first few lines)
        notes_preview = ""
        if release_notes and release_notes.strip():
            cleaned_notes = release_notes.strip()
            lines = [line for line in cleaned_notes.split('\n') if line.strip()]
            if lines:
                preview_lines = lines[:8]
                notes_preview = "\n\n" + "\n".join(preview_lines)
                if len(lines) > 8:
                    notes_preview += "\n..."
        
        # Build message
        message = (
            f"A new version is available!\n\n"
            f"Current version: v{current_version}\n"
            f"Latest version: v{latest_version}"
        )
        
        if notes_preview:
            message += notes_preview
        
        message += (
            f"\n\nWould you like to update now?\n\n"
            f"Note: In launcher mode, the launcher will handle the update automatically."
        )
        
        # Build an explicit QMessageBox so we can ensure it stays above an always-on-top main window.
        msg_box = QMessageBox(self)
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setWindowTitle("Update Available")
        msg_box.setText(message)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)

        # Ensure it appears above the main window, even if main window is always-on-top.
        try:
            if bool(self.windowFlags() & Qt.WindowType.WindowStaysOnTopHint):
                msg_box.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, True)
        except Exception:
            pass
        try:
            msg_box.setWindowModality(Qt.WindowModality.ApplicationModal)
        except Exception:
            pass

        response = msg_box.exec()
        
        if response == QMessageBox.StandardButton.Yes:
            # User approved update - trigger download
            if os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1':
                # In launcher mode, create flag file to trigger launcher download
                try:
                    launcher_dir = Path(__file__).parent
                    flag_file = launcher_dir / "update_download_flag.json"
                    flag_data = {
                        "download": True,
                        "version": latest_version,
                        "download_url": download_url,
                        "timestamp": time.time()
                    }
                    with open(flag_file, 'w', encoding='utf-8') as f:
                        json.dump(flag_data, f)
                    
                    QMessageBox.information(
                        self,
                        "Update",
                        f"Update to v{latest_version} will be downloaded and applied on next restart.\n\n"
                        "Please restart the application to complete the update."
                    )
                except Exception as e:
                    logger.error(f"Failed to trigger update download: {e}")
                    QMessageBox.warning(
                        self,
                        "Update Error",
                        f"Failed to trigger update download:\n{str(e)}\n\n"
                        "Please download manually from GitHub."
                    )
            else:
                QMessageBox.information(
                    self,
                    "Update",
                    "Please download the latest version from GitHub:\n\n"
                    f"https://github.com/kameryn1811/Bandcamp-Player"
                )
        else:
            # User declined update - do nothing
            logger.info(f"User declined update to v{latest_version}")
    
    def extract_artist_album_from_url(self, url):
        """Extract Artist - Album format from Bandcamp URL
        
        Returns:
            String like "Artist - Album" or "Artist" or None
        """
        if not url or 'bandcamp.com' not in url.lower():
            return None
        
        try:
            from urllib.parse import urlparse
            import re
            
            # Clean URL
            url = url.rstrip(' \t,;')
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            parsed = urlparse(url)
            hostname = parsed.hostname or ""
            
            # Extract artist from subdomain
            artist = None
            if ".bandcamp.com" in hostname.lower():
                subdomain = hostname.lower().replace(".bandcamp.com", "")
                if "-" in subdomain:
                    artist = " ".join(word.capitalize() for word in subdomain.split("-"))
                else:
                    words = re.findall(r'[a-z]+|[A-Z][a-z]*', subdomain)
                    if len(words) > 1:
                        artist = " ".join(word.capitalize() for word in words)
                    else:
                        # Single word (all lowercase or no camelCase) - try to split on common word endings
                        # Common word endings that might indicate a word boundary
                        common_endings = ['pony', 'ponies', 'music', 'records', 'label', 'band', 'group', 'crew', 'team', 'sound', 'audio', 'tunes', 'tracks']
                        subdomain_lower = subdomain.lower()
                        for ending in common_endings:
                            if subdomain_lower.endswith(ending) and len(subdomain_lower) > len(ending):
                                # Split before the ending
                                prefix = subdomain_lower[:-len(ending)]
                                if len(prefix) > 0:
                                    # Capitalize both parts
                                    artist = f"{prefix.capitalize()} {ending.capitalize()}"
                                    break
                        
                        # Final fallback: just capitalize the first letter
                        if not artist:
                            artist = subdomain.capitalize()
            
            if not artist:
                return None
            
            # Extract path components
            path = parsed.path.strip('/')
            path_parts = [p for p in path.split('/') if p]
            
            # Determine type and extract name
            if not path_parts:
                return artist  # Artist page
            elif len(path_parts) >= 2:
                # URL format: artist.bandcamp.com/album/album-name
                # or: artist.bandcamp.com/track/track-name
                if path_parts[0] in ['album', 'track']:
                    name = path_parts[1]
                    name = " ".join(word.capitalize() for word in name.split("-"))
                    return f"{artist} - {name}"
                else:
                    # Direct format: artist.bandcamp.com/album-name
                    name = path_parts[0]
                    name = " ".join(word.capitalize() for word in name.split("-"))
                    return f"{artist} - {name}"
            elif len(path_parts) == 1:
                # Single path part - could be album or track name
                name = path_parts[0]
                name = " ".join(word.capitalize() for word in name.split("-"))
                return f"{artist} - {name}"
            else:
                return artist  # Unknown format, return artist
            
        except Exception as e:
            logger.debug(f"Error extracting artist/album from URL: {e}")
            return None
    
    def extract_metadata_from_page(self):
        """Extract artist and album metadata from the page DOM and update playlist item"""
        if not self.web_view or not self.web_view.page():
            return
        
        def on_metadata_extracted(result):
            """Callback when metadata is extracted from page DOM"""
            if not result or not isinstance(result, dict):
                return
            
            current_url = self.web_view.url().toString() if self.web_view else None
            if not current_url:
                return
            
            # Extract artist and album from the result
            artist = result.get('artist', '').strip()
            album = result.get('album', '').strip()
            
            # Build display text in "Album by Artist" format (matches album menu button format)
            display_text = None
            if artist and album:
                # Album page: "Album by Artist"
                display_text = f"{album} by {artist}"
            elif album:
                # Just album (fallback)
                display_text = album
            elif artist:
                # Just artist (fallback)
                display_text = artist
            
            if display_text:
                # Ensure playlist manager is initialized
                self._ensure_playlist_manager()
                if hasattr(self, 'playlist_manager') and self.playlist_manager:
                    # Save the metadata to the playlist file so it persists
                    # Save for current URL (normalization will match it to playlist item, ignoring query params)
                    logger.debug(f"Attempting to save metadata: {current_url} -> {display_text}")
                    self.playlist_manager.update_url_metadata(current_url, display_text)
                    logger.debug(f"Updated playlist metadata from page: {current_url} -> {display_text}")
                    # Also try to save for all URLs in playlist that might match (same base URL, different query params)
                    playlist_urls = self.playlist_manager.get_playlist()
                    for playlist_url in playlist_urls:
                        # Normalize both URLs for comparison (same logic as update_url_metadata)
                        def normalize_for_match(u):
                            if not u:
                                return ""
                            u = u.strip().rstrip('/')
                            if '?' in u:
                                u = u.split('?')[0]
                            if u.startswith('http://'):
                                u = 'https://' + u[7:]
                            return u.lower()
                        
                        if normalize_for_match(playlist_url) == normalize_for_match(current_url):
                            # URLs match (ignoring query params) - also save for playlist URL
                            self.playlist_manager.update_url_metadata(playlist_url, display_text)
                            logger.debug(f"Also saved metadata for playlist URL: {playlist_url} -> {display_text}")
                    # Update the playlist item for this URL (refresh display)
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        self.playlist_sidebar.refresh_all_items()
        
        # Extract metadata from page using JavaScript
        # Get album name from .tralbum-name and artist from .tralbum-artist (removing "by " prefix)
        js_code = """
        (function() {
            try {
                var albumElement = document.querySelector('.tralbum-name');
                var artistElement = document.querySelector('.tralbum-artist');
                
                var album = '';
                var artist = '';
                
                if (albumElement) {
                    album = albumElement.textContent.trim();
                }
                
                if (artistElement) {
                    var artistText = artistElement.textContent.trim();
                    // Remove "by " prefix if present
                    if (artistText.toLowerCase().startsWith('by ')) {
                        artist = artistText.substring(3).trim();
                    } else {
                        artist = artistText;
                    }
                }
                
                return {
                    'album': album,
                    'artist': artist
                };
            } catch (e) {
                return {'album': '', 'artist': ''};
            }
        })();
        """
        
        self.web_view.page().runJavaScript(js_code, on_metadata_extracted)
    
    def update_title_from_page(self):
        """Update window title from page title (extract Artist - Album format)"""
        def extract_title(title_text):
            """Extract Artist - Album from page title"""
            if not title_text:
                return None
            
            # Common Bandcamp title formats:
            # "Album Name, by Artist Name | Bandcamp"
            # "Track Name, by Artist Name | Bandcamp"
            # "Artist Name | Bandcamp"
            
            # Remove " | Bandcamp" suffix
            title_text = title_text.replace(" | Bandcamp", "").strip()
            
            # Try to extract "Album/Track, by Artist" format
            if ", by " in title_text:
                parts = title_text.split(", by ")
                if len(parts) == 2:
                    album_or_track = parts[0].strip()
                    artist = parts[1].strip()
                    return f"{artist} - {album_or_track}"
            
            # If no "by" format, try to parse other formats
            # Sometimes it's just "Artist Name" or "Album Name"
            return title_text
        
        def on_title_received(result):
            """Callback when page title is received"""
            if result:
                title_text = result if isinstance(result, str) else str(result)
                extracted_title = extract_title(title_text)
                if extracted_title:
                    # Always append "- Bandcamp Player" to the title for reliable window detection
                    full_title = f"{extracted_title} - Bandcamp Player"
                    QMainWindow.setWindowTitle(self, full_title)
                    if self.window_title_label:
                        # Only show the extracted title (without suffix) in the UI
                        self.window_title_label.setText(self._truncate_title_text(extracted_title))
                else:
                    # No valid title extracted - check if welcome widget is visible (empty state)
                    if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
                        edition = globals().get("__edition__")
                        edition_suffix = f" ({edition})" if edition else ""
                        QMainWindow.setWindowTitle(self, f"Empty - Bandcamp Player{edition_suffix}")
                        if self.window_title_label:
                            self.window_title_label.setText(self._truncate_title_text("Empty"))
            else:
                # No result - check if welcome widget is visible (empty state)
                if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
                    edition = globals().get("__edition__")
                    edition_suffix = f" ({edition})" if edition else ""
                    QMainWindow.setWindowTitle(self, f"Empty - Bandcamp Player{edition_suffix}")
                    if self.window_title_label:
                        self.window_title_label.setText(self._truncate_title_text("Empty"))
        
        # Get page title from web view
        if self.web_view and self.web_view.page():
            # Connect to title changed signal
            try:
                self.web_view.page().titleChanged.disconnect()
            except:
                pass
            self.web_view.page().titleChanged.connect(lambda title: on_title_received(title))
            # Also try to get current title immediately
            self.web_view.page().runJavaScript("document.title", on_title_received)
    
    def closeEvent(self, event):
        """Handle window close event"""
        # Keyboard shortcuts are automatically cleaned up by Qt
        # No need to manually remove them
        
        # Close developer tools window if open
        if hasattr(self, 'dev_tools_window') and self.dev_tools_window:
            try:
                # Save geometry before closing
                if self.dev_tools_window.isVisible():
                    geom = self.dev_tools_window.geometry()
                    self.settings["dev_tools_geometry"] = {
                        "x": geom.x(),
                        "y": geom.y(),
                        "width": geom.width(),
                        "height": geom.height()
                    }
                # Close the developer tools window
                self.dev_tools_window.close()
                self.dev_tools_window = None
                self.dev_tools_page = None
            except Exception as e:
                logger.warning(f"Error closing developer tools: {e}")
        
        # Get current track number before closing (if available)
        # Main window should already have it from periodic updates, but sync from nano player as fallback
        if (not hasattr(self, '_current_track_number') or self._current_track_number is None) and \
           hasattr(self, 'nano_player_window') and self.nano_player_window and \
           hasattr(self.nano_player_window, '_current_track_number'):
            self._current_track_number = self.nano_player_window._current_track_number
            logger.debug(f"closeEvent: Got track number from nano player (fallback): {self._current_track_number}")
        else:
            logger.debug(f"closeEvent: Using main window track number: {getattr(self, '_current_track_number', None)}")
        
        # Save window geometry before closing
        try:
            geometry = self.saveGeometry()
            self.settings["window_geometry"] = geometry.toHex().data().decode()
        except Exception as e:
            print(f"Could not save window geometry: {e}")
        
        # Save playlist state before closing
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            # Only save visibility if not detached (detached playlist is always "visible" in its own window)
            if not self.playlist_detached:
                # If in nano mode, the main window is hidden so isVisible() will return False
                # even if the playlist was visible. We saved the state when entering nano mode,
                # so use that saved state (it's already in settings from _enter_nano_mode)
                if hasattr(self, '_main_window_hidden_for_nano') and self._main_window_hidden_for_nano:
                    # In nano mode - state was already saved when entering nano mode
                    # Just ensure it's still in settings (it should be)
                    if 'playlist_visible' not in self.settings:
                        # Fallback: if somehow not saved, assume visible if container exists
                        self.settings['playlist_visible'] = hasattr(self, 'playlist_container') and self.playlist_container is not None
                else:
                    # Not in nano mode - use actual visibility
                    self.settings['playlist_visible'] = self.playlist_sidebar.isVisible()
            else:
                # If detached, save as visible (since it's visible in detached window)
                self.settings['playlist_visible'] = True
            if hasattr(self.playlist_sidebar, 'is_minimized'):
                # Only update attached minimized state when playlist is attached.
                # When detached we force-expand, so updating this would lose the user's attached preference.
                if not self.playlist_detached:
                    self.settings['playlist_minimized'] = self.playlist_sidebar.is_minimized
                    self.settings['playlist_attached_minimized'] = self.playlist_sidebar.is_minimized
            if hasattr(self.playlist_sidebar, '_restore_height'):
                playlist_height_to_save = self.playlist_sidebar._restore_height
            else:
                playlist_height_to_save = self.playlist_sidebar.height() if self.playlist_sidebar else self.settings.get('playlist_height', 250)
            
            # Save playlist height
            self.settings['playlist_height'] = playlist_height_to_save
            
            # If not in micro mode, also save to playlist_height_regular
            # This ensures we preserve the regular/mini mode height even if app is closed in micro mode
            if self.mini_mode_state != 2 and playlist_height_to_save != 135:
                self.settings['playlist_height_regular'] = playlist_height_to_save
                logger.debug(f"Saved playlist_height_regular on close: {playlist_height_to_save}")
            
            # Explicitly save shuffle and repeat modes from the sidebar
            self.settings['shuffle_mode'] = self.playlist_sidebar.shuffle_mode
            self.settings['repeat_mode'] = self.playlist_sidebar.repeat_mode
            # Keep old settings for backward compatibility
            self.settings['shuffle_on'] = self.playlist_sidebar.shuffle_mode > 0
            self.settings['repeat_on'] = self.playlist_sidebar.repeat_mode > 0
        else:
            # Playlist doesn't exist yet, save as closed
            self.settings['playlist_visible'] = False
            # Also ensure shuffle/repeat modes are saved even if playlist not created
            # (e.g., if app closed immediately after launch)
            self.settings['shuffle_mode'] = self.settings.get('shuffle_mode', 0)
            self.settings['repeat_mode'] = self.settings.get('repeat_mode', 0)
            # Keep old settings for backward compatibility
            self.settings['shuffle_on'] = self.settings.get('shuffle_mode', 0) > 0
            self.settings['repeat_on'] = self.settings.get('repeat_mode', 0) > 0
        
        # Save nano mode state if active
        if hasattr(self, '_main_window_hidden_for_nano') and self._main_window_hidden_for_nano:
            self.settings['start_in_nano_mode'] = True
        else:
            self.settings['start_in_nano_mode'] = False
        
        # Save detached playlist state before closing
        # Disconnect the finished signal temporarily to prevent reattachment during app close
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            try:
                # Disconnect finished signal to prevent reattachment during app close
                self.detached_playlist_window.finished.disconnect()
            except:
                pass  # Signal might not be connected or already disconnected
            try:
                pos = self.detached_playlist_window.pos()
                size = self.detached_playlist_window.size()
                # Save absolute position
                self.playlist_detached_position = (pos.x(), pos.y())
                # Also save relative offset for backward compatibility
                main_pos = self.pos()
                self.playlist_detached_offset = (pos.x() - main_pos.x(), pos.y() - main_pos.y())
                self.playlist_detached_size = f"{size.width()}x{size.height()}"
            except Exception as e:
                logger.debug(f"Error saving detached playlist position on close: {e}")
        self._save_playlist_detach_state()
        
        # Close detached playlist window if it exists
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            try:
                self.detached_playlist_window.close()
            except Exception as e:
                logger.debug(f"Error closing detached playlist window: {e}")
        
        self.save_settings()
        self.playlist_manager.save_playlist()
        event.accept()


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def check_python_version():
    """Check if Python version matches requirements."""
    version = sys.version_info[:3]
    if version != REQUIRED_PYTHON_VERSION:
        print(f"\n{'='*60}")
        print(f"ERROR: Python version mismatch!")
        print(f"{'='*60}")
        print(f"Required: {'.'.join(map(str, REQUIRED_PYTHON_VERSION))}")
        print(f"Current: {'.'.join(map(str, version))}")
        print(f"\nPlease install Python {'.'.join(map(str, REQUIRED_PYTHON_VERSION))}")
        print(f"{'='*60}\n")
        input("Press Enter to exit...")
        sys.exit(1)

def check_and_install_dependencies():
    """Check if dependencies are installed, install if missing."""
    missing = []
    
    try:
        import PyQt6
    except ImportError:
        missing.append("PyQt6")
    
    try:
        from PyQt6.QtWebEngineWidgets import QWebEngineView
    except ImportError:
        missing.append("PyQt6-WebEngine")
    
    if missing:
        print(f"\nMissing dependencies: {', '.join(missing)}")
        print("Attempting to install automatically...\n")
        
        requirements_file = Path(__file__).parent / "requirements.txt"
        if requirements_file.exists():
            try:
                result = subprocess.run(
                    [sys.executable, "-m", "pip", "install", "-r", str(requirements_file)],
                    check=False
                )
                if result.returncode == 0:
                    print("Dependencies installed successfully!\n")
                    # Re-import to verify
                    import importlib
                    importlib.invalidate_caches()
                else:
                    print("Failed to install dependencies automatically.")
                    print("Please run: pip install -r requirements.txt")
                    input("Press Enter to exit...")
                    sys.exit(1)
            except Exception as e:
                print(f"Error installing dependencies: {e}")
                print("Please run: pip install -r requirements.txt")
                input("Press Enter to exit...")
                sys.exit(1)
        else:
            print("requirements.txt not found!")
            print("Please install dependencies manually.")
            input("Press Enter to exit...")
            sys.exit(1)


# ============================================================================
# MAIN FUNCTION
# ============================================================================

def main():
    """Main entry point - simplified like downloader for Windows 10 compatibility."""
    # Set up global exception handler for runtime crashes
    def global_exception_handler(exc_type, exc_value, exc_traceback):
        """Handle unhandled exceptions that occur during runtime."""
        if issubclass(exc_type, KeyboardInterrupt):
            # Allow keyboard interrupt to work normally
            sys.__excepthook__(exc_type, exc_value, exc_traceback)
            return
        
        import traceback
        error_msg = ''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
        
        # Log to file
        try:
            script_dir = Path(__file__).parent if __file__ else Path.cwd()
            logs_dir = script_dir / "Logs"
            logs_dir.mkdir(exist_ok=True)
            crash_log_file = logs_dir / "crash_log.txt"
            import time
            with open(crash_log_file, 'a', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write(f"RUNTIME CRASH - {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("=" * 80 + "\n")
                f.write(error_msg)
                f.write("=" * 80 + "\n\n")
            
            # Also log via logger if available
            logger.error(f"Unhandled exception: {exc_type.__name__}: {exc_value}", exc_info=(exc_type, exc_value, exc_traceback))
        except Exception as log_error:
            print(f"Warning: Could not write to crash log: {log_error}", file=sys.stderr)
        
        # Print to console
        print("=" * 60, file=sys.stderr)
        print("RUNTIME CRASH - Bandcamp Player", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        print(error_msg, file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        try:
            print(f"\nError has been saved to: {crash_log_file}", file=sys.stderr)
        except:
            print("\nError has been saved to: Logs/crash_log.txt", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        
        # Try to show error dialog if Qt is available
        try:
            from PyQt6.QtWidgets import QApplication, QMessageBox
            app = QApplication.instance()
            if app:
                msg_box = QMessageBox()
                msg_box.setIcon(QMessageBox.Icon.Critical)
                msg_box.setWindowTitle("Runtime Crash")
                msg_box.setText(f"Bandcamp Player crashed:\n\n{exc_type.__name__}: {exc_value}")
                msg_box.setDetailedText(error_msg)
                msg_box.exec()
        except Exception:
            pass  # Qt not available or error showing dialog
        
        # Keep console open on Windows so user can read error
        if sys.platform == "win32":
            try:
                input("\nPress Enter to exit...")
            except:
                import time
                time.sleep(5)  # Wait so user can read error
        
        # Call default exception handler
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
    
    # Install global exception handler
    sys.excepthook = global_exception_handler
    
    # Ensure we're running from the script's directory (fixes Windows 10 issue)
    try:
        if hasattr(sys, 'frozen'):
            script_dir = Path(sys.executable).resolve().parent
        elif __file__:
            script_dir = Path(__file__).resolve().parent
        else:
            script_dir = Path(os.getcwd())
        
        if os.getcwd() != str(script_dir):
            try:
                os.chdir(str(script_dir))
            except OSError:
                pass  # Continue even if directory change fails
    except Exception:
        pass  # Continue even if directory setup fails
    
    # Check Python version
    try:
        check_python_version()
    except (SystemExit, Exception):
        if sys.platform == "win32":
            input("Press Enter to exit...")
        sys.exit(1)
    
    # Check and install dependencies if not running from launcher
    launcher_mode = os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1'
    if not launcher_mode:
        try:
            check_and_install_dependencies()
        except (SystemExit, Exception):
            if sys.platform == "win32":
                input("Press Enter to exit...")
            sys.exit(1)
    
    launcher_version = os.environ.get('BANDCAMP_PLAYER_LAUNCHER_VERSION', 'Unknown')
    
    # Create QApplication - do this FIRST like downloader does with Tk
    try:
        app = QApplication(sys.argv)
        app.setApplicationName("Bandcamp Player")
        app.setOrganizationName("Bandcamp Tools")
    except Exception as e:
        print(f"Failed to initialize Qt: {e}")
        if sys.platform == "win32":
            input("Press Enter to exit...")
        sys.exit(1)
    
    # Create window - console handling will be done INSIDE PlayerWindow.__init__
    # This matches the downloader pattern where console is handled after GUI creation
    try:
        window = PlayerWindow()
        
        if launcher_mode:
            window.setWindowTitle(f"Bandcamp Player (Launcher v{launcher_version})")
        
        # Install media key event filter for WM_APPCOMMAND and custom AutoHotkey messages
        if sys.platform == 'win32' and _HAS_CTYPES:
            media_key_filter = MediaKeyEventFilter()
            media_key_filter.setCallbacks(
                next_callback=window._trigger_next_track,
                prev_callback=window._trigger_previous_track
            )
            app.installNativeEventFilter(media_key_filter)
            window.media_key_filter = media_key_filter  # Keep reference to prevent garbage collection
            window.media_next_callback = window._trigger_next_track  # Store for IPC
            window.media_prev_callback = window._trigger_previous_track  # Store for IPC
        
        # Defer non-critical initialization until after window is ready
        QTimer.singleShot(0, window.deferred_init)
        
        sys.exit(app.exec())
    except Exception as e:
        # Show error dialog if possible
        try:
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Icon.Critical)
            msg_box.setWindowTitle("Error")
            msg_box.setText(f"Failed to start Bandcamp Player:\n\n{str(e)}")
            import traceback
            msg_box.setDetailedText(traceback.format_exc())
            msg_box.exec()
        except:
            print(f"Failed to start Bandcamp Player:\n\n{str(e)}")
            import traceback
            traceback.print_exc()
            if sys.platform == "win32":
                input("Press Enter to exit...")
        if not launcher_mode:
            sys.exit(1)
        else:
            raise


# ============================================================================
# NANO PLAYER WINDOW CLASS
# ============================================================================

class NanoPlayerWindow(QDialog):
    """Super compact nano player window that appears when main window is minimized."""
    
    def __init__(self, parent_window):
        super().__init__(None)  # No parent - separate top-level window
        self.parent_window = parent_window
        
        # Flag to track if one-time resize trick has been done
        self._one_time_resize_done = False
        
        # Window setup
        self.setWindowTitle("Nano Player")
        self.setModal(False)
        self.setMinimumSize(510, 50)  # Minimum width 510px, height will be determined by content
        self.setMaximumSize(16777215, 100)  # Maximum height ~100px (controls + progress bar)
        
        # Frameless window (no rounded corners as requested)
        flags = Qt.WindowType.FramelessWindowHint | Qt.WindowType.Window
        # Always-on-top will be controlled by pin button (independent of main window)
        self.nano_always_on_top = parent_window.settings.get("nano_always_on_top", True)  # Default to enabled
        if self.nano_always_on_top:
            flags |= Qt.WindowType.WindowStaysOnTopHint
        self.setWindowFlags(flags)
        
        # Set window icon if available
        if hasattr(parent_window, 'app_icon') and parent_window.app_icon:
            self.setWindowIcon(parent_window.app_icon)
        
        # Load saved position and size
        saved_pos = parent_window.settings.get("nano_player_position", None)
        saved_size = parent_window.settings.get("nano_player_size", "510x50")
        
        if saved_pos and isinstance(saved_pos, (list, tuple)) and len(saved_pos) == 2:
            # Validate position is on a valid screen (multi-monitor support)
            saved_pos_point = QPoint(saved_pos[0], saved_pos[1])
            screen = QApplication.screenAt(saved_pos_point)
            if screen:
                # Position is on a valid screen, use it
                self.move(saved_pos_point)
            else:
                # Position is off-screen, find the closest screen or use primary
                screens = QApplication.screens()
                target_screen = None
                min_distance = float('inf')
                
                for s in screens:
                    screen_geom = s.geometry()
                    # Calculate distance from saved position to screen center
                    screen_center = screen_geom.center()
                    distance = ((saved_pos_point.x() - screen_center.x()) ** 2 + 
                               (saved_pos_point.y() - screen_center.y()) ** 2) ** 0.5
                    if distance < min_distance:
                        min_distance = distance
                        target_screen = s
                
                if not target_screen:
                    target_screen = QApplication.primaryScreen()
                
                # Move to primary screen (or closest screen) - center it
                target_geometry = target_screen.availableGeometry()
                self.move(
                    target_geometry.center().x() - 510 // 2,
                    target_geometry.center().y() - 50 // 2
                )
        else:
            # Center on screen if no saved position
            screen = QApplication.primaryScreen()
            if screen:
                screen_geometry = screen.availableGeometry()
                self.move(
                    (screen_geometry.width() - 510) // 2,
                    (screen_geometry.height() - 50) // 2
                )
        
        # Parse saved size
        try:
            if 'x' in saved_size:
                size_parts = saved_size.split('x')
                if len(size_parts) == 2:
                    width = int(size_parts[0])
                    height = int(size_parts[1])
                    if width >= 510 and height >= 50:
                        self.resize(width, height)
                    else:
                        self.resize(510, 50)
                else:
                    self.resize(510, 50)
            else:
                self.resize(510, 50)
        except Exception:
            self.resize(510, 50)
        
        # Initialize resize-related attributes BEFORE setup_ui to ensure they exist
        # Track drag state
        self._drag_position = None
        
        # Track resize state ('left', 'right', or None)
        self._resize_edge = None
        self._resize_start_pos = None
        self._resize_start_geometry = None
        
        # Resize edge detection threshold (pixels from edge) - initialize early
        self._resize_threshold = 5
        
        # Window snapping and docking
        self._snap_threshold = 20  # Same as main window
        self._docked_edge = None  # 'top', 'bottom', or None
        self._docked_y_position = None  # Y position when docked
        
        # Autohide when docked
        self.nano_autohide_when_docked = parent_window.settings.get("nano_autohide_when_docked", False)
        # Autohide sensitivity (pixels from edge) - default to 5px, will be clamped to valid range when needed
        self.nano_autohide_sensitivity = parent_window.settings.get("nano_autohide_sensitivity", 5)
        # Ensure sensitivity is within valid range (5px minimum)
        self.nano_autohide_sensitivity = max(5, self.nano_autohide_sensitivity)
        self._autohide_timer = QTimer(self)
        self._autohide_timer.timeout.connect(self._check_autohide)
        self._autohide_timer.setInterval(100)  # Check every 100ms
        self._is_autohidden = False
        self._context_menu = None  # Track context menu to prevent autohide when open
        self._autohide_cooldown = False  # Prevent autohide from triggering immediately after window is shown
        
        # Create transparent hover area widget for hotspot (similar to archived address bar implementation)
        # Create as a top-level window that stays on top and is frameless
        # Use Tool window type so it doesn't appear in taskbar but can receive mouse events
        self._autohide_hover_area = QWidget()
        self._autohide_hover_area.setWindowFlags(
            Qt.WindowType.FramelessWindowHint | 
            Qt.WindowType.WindowStaysOnTopHint |
            Qt.WindowType.Tool  # Tool windows don't appear in taskbar but can receive events
        )
        self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        self._autohide_hover_area.setStyleSheet("background-color: transparent;")
        self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating, True)  # Don't steal focus
        self._autohide_hover_area.hide()  # Hidden by default
        
        # Mouse enter/leave events for hover area
        def hover_area_enter(event):
            if self.nano_autohide_when_docked and self._docked_edge and self._is_autohidden:
                self.show()
                self._is_autohidden = False
                # Hide hover area when window is shown
                self._autohide_hover_area.hide()
        
        def hover_area_leave(event):
            if self.nano_autohide_when_docked and self._docked_edge and not self._is_autohidden:
                # Small delay before hiding to prevent flicker
                QTimer.singleShot(150, lambda: self._check_autohide_after_leave())
        
        self._autohide_hover_area.enterEvent = hover_area_enter
        self._autohide_hover_area.leaveEvent = hover_area_leave
        
        # Initialize resize edge widgets to None (will be created after UI setup)
        self._left_resize_edge = None
        self._right_resize_edge = None
        
        # Setup UI
        self.setup_ui()
        
        # Install event filter for window snapping and drag handling
        self.installEventFilter(self)
        
        # Create invisible resize edge widgets (left and right) - must be after UI setup and _resize_threshold is set
        self._create_resize_edges()
        
        # Enable drag-and-drop on the window
        self.setAcceptDrops(True)
        
        # Track if dragging over album button for visual feedback
        self._dragging_over_album_btn = False
        
        # Enable drag-and-drop on album button and install event filter
        if hasattr(self, 'album_menu_btn'):
            self.album_menu_btn.setAcceptDrops(True)
            self.album_menu_btn.installEventFilter(self)
        
        # TODO: Add all controls, menus, progress bar, etc.
    
    def setup_ui(self):
        """Setup the nano player UI."""
        # Main horizontal layout: cover art on left, controls/progress on right
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Cover art display (left side, spans both rows)
        self.cover_art_label = QLabel()
        self.cover_art_label.setFixedWidth(50)  # Fixed width, height will match window height
        self.cover_art_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.cover_art_label.setStyleSheet("""
            QLabel {
                background-color: #1a1a1a;
                border: none;
            }
        """)
        self.cover_art_label.setScaledContents(True)  # Scale image to fit
        # Install event filter to allow dragging from cover art
        self.cover_art_label.installEventFilter(self)
        main_layout.addWidget(self.cover_art_label)
        
        # Create loading animation widget for cover art area
        self.cover_art_loading_widget = CoverArtLoadingWidget(self.cover_art_label)
        self.cover_art_loading_widget.hide()  # Hidden by default
        
        # Right side: controls and progress bar
        right_layout = QVBoxLayout()
        # Reduced margins: left margin matches where controls start, right margin minimal
        # Top and bottom margins kept for visual spacing
        right_layout.setContentsMargins(5, 2, 3, 2)  # Left margin aligns with cover art spacing
        right_layout.setSpacing(0)  # No spacing between controls and progress bar
        
        # Controls row
        controls_row = QHBoxLayout()
        controls_row.setSpacing(1)  # Compact spacing for consistent button layout
        controls_row.setContentsMargins(0, 0, 0, 0)  # No margins since parent layout has them
        
        # Button style (matches playlist title bar buttons exactly)
        button_style = """
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 11px;
                padding: 2px;
                outline: none;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:focus {
                outline: none;
                border: none;
            }
            QPushButton:pressed {
                outline: none;
                border: none;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """
        
        # Previous album button
        self.prev_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-backward', color='#e0e0e0')
            if icon:
                self.prev_album_btn.setIcon(icon)
            else:
                self.prev_album_btn.setText("")
        else:
            self.prev_album_btn.setText("")
        self.prev_album_btn.setToolTip("Previous album")
        self.prev_album_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.prev_album_btn.setStyleSheet(button_style)
        self.prev_album_btn.clicked.connect(self._on_prev_album)
        controls_row.addWidget(self.prev_album_btn)
        
        # Previous track button
        self.prev_track_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('backward', color='#e0e0e0')
            if icon:
                self.prev_track_btn.setIcon(icon)
            else:
                self.prev_track_btn.setText("")
        else:
            self.prev_track_btn.setText("")
        self.prev_track_btn.setToolTip("Previous Track")
        self.prev_track_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.prev_track_btn.setStyleSheet(button_style)
        self.prev_track_btn.clicked.connect(self._on_prev_track)
        controls_row.addWidget(self.prev_track_btn)
        
        # Play/Pause button (with animated border for buffering)
        self.play_pause_btn = AnimatedPlayButton()
        if HAS_QT_AWESOME:
            icon = get_icon('play', color='#e0e0e0')
            if icon:
                self.play_pause_btn.setIcon(icon)
            else:
                self.play_pause_btn.setText("")
        else:
            self.play_pause_btn.setText("")
        self.play_pause_btn.setToolTip("Play/Pause")
        self.play_pause_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.play_pause_btn.setStyleSheet(button_style)
        self.play_pause_btn.clicked.connect(self._on_play_pause)
        controls_row.addWidget(self.play_pause_btn)
        
        self._is_buffering = False  # Track buffering state
        
        # Next track button
        self.next_track_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('forward', color='#e0e0e0')
            if icon:
                self.next_track_btn.setIcon(icon)
            else:
                self.next_track_btn.setText("")
        else:
            self.next_track_btn.setText("")
        self.next_track_btn.setToolTip("Next Track")
        self.next_track_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.next_track_btn.setStyleSheet(button_style)
        self.next_track_btn.clicked.connect(self._on_next_track)
        controls_row.addWidget(self.next_track_btn)
        
        # Next album button
        self.next_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-forward', color='#e0e0e0')
            if icon:
                self.next_album_btn.setIcon(icon)
            else:
                self.next_album_btn.setText("")
        else:
            self.next_album_btn.setText("")
        self.next_album_btn.setToolTip("Next album")
        self.next_album_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.next_album_btn.setStyleSheet(button_style)
        self.next_album_btn.clicked.connect(self._on_next_album)
        controls_row.addWidget(self.next_album_btn)
        
        controls_row.addSpacing(1)  # Consistent spacing between button groups
        
        # Shuffle button
        self.shuffle_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('random', color='#a0a0a0')
            if icon:
                self.shuffle_btn.setIcon(icon)
            else:
                self.shuffle_btn.setText("")
        else:
            self.shuffle_btn.setText("")
        self.shuffle_btn.setToolTip("Shuffle: Off")
        self.shuffle_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.shuffle_btn.setCheckable(True)
        self.shuffle_btn.setStyleSheet(button_style)
        self.shuffle_btn.clicked.connect(self._on_shuffle)
        controls_row.addWidget(self.shuffle_btn)
        
        # Repeat button (match playlist title bar exactly)
        self.repeat_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.repeat', color='#a0a0a0')  # Use same icon as playlist
            if icon:
                self.repeat_btn.setIcon(icon)
            else:
                self.repeat_btn.setText("")
        else:
            self.repeat_btn.setText("")
        self.repeat_btn.setToolTip("Repeat: Off")
        self.repeat_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.repeat_btn.setCheckable(True)
        self.repeat_btn.setStyleSheet(button_style)
        self.repeat_btn.clicked.connect(self._on_repeat)
        controls_row.addWidget(self.repeat_btn)
        
        controls_row.addSpacing(1)  # Consistent spacing between button groups
        
        # Volume button (will show popup like main interface)
        self.volume_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('volume-up', color='#e0e0e0')
            if icon:
                self.volume_btn.setIcon(icon)
            else:
                self.volume_btn.setText("")
        else:
            self.volume_btn.setText("")
        self.volume_btn.setToolTip("Volume")
        self.volume_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.volume_btn.setStyleSheet(button_style)
        self.volume_btn.clicked.connect(self._on_volume_click)
        controls_row.addWidget(self.volume_btn)
        
        controls_row.addSpacing(1)  # Reduced spacing between volume and track list
        
        # Artist - Track menu button (expandable)
        self.track_menu_btn = QPushButton()
        self.track_menu_btn.setText("Artist - Track")
        self.track_menu_btn.setToolTip("Select Track")
        # Set minimum width explicitly (not in stylesheet to avoid conflicts)
        self.track_menu_btn.setMinimumWidth(80)
        # Width will be set to fixed value based on text in _update_button_widths()
        # Set size policy to fixed - width will be set based on text content
        self.track_menu_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.track_menu_btn.setStyleSheet(button_style + """
            QPushButton {
                text-align: left;
                padding: 2px 0 2px 6px;
                font-size: 11px;
            }
        """)
        # Create a custom button that clips text cleanly without elision
        # We'll override the paint event to draw text and clip it to button bounds
        def paint_with_clipping(event):
            painter = QPainter(self.track_menu_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            option = QStyleOptionButton()
            self.track_menu_btn.initStyleOption(option)
            # Draw button background and bevel
            self.track_menu_btn.style().drawControl(QStyle.ControlElement.CE_PushButtonBevel, option, painter, self.track_menu_btn)
            # Clip to button rectangle to hide overflow cleanly (no "..." elision)
            painter.setClipRect(self.track_menu_btn.rect())
            # Draw text without elision - use the button's font with correct size
            text_rect = self.track_menu_btn.rect().adjusted(6, 2, -1, -2)  # Left padding 6px, right padding 1px (minimal)
            text = self.track_menu_btn.text()
            font = self.track_menu_btn.font()
            font.setPixelSize(11)  # Match time label font size
            painter.setFont(font)
            painter.setPen(QColor("#e0e0e0"))
            # Draw full text - it will be cleanly clipped by setClipRect if it overflows (no "...")
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, text)
        self.track_menu_btn.paintEvent = paint_with_clipping
        self.track_menu_btn.clicked.connect(self._show_track_menu)
        # Track button will be added to bottom_row instead (between progress bar and time label)
        # Don't add to controls_row here
        
        # Album menu button (expandable) - moved to top row where track button originally was
        self.album_menu_btn = QPushButton()
        self.album_menu_btn.setText("Album")
        self.album_menu_btn.setToolTip("Select Album")
        # Set minimum width explicitly (not in stylesheet to avoid conflicts)
        self.album_menu_btn.setMinimumWidth(60)
        # Width will be set to fixed value based on text in _update_button_widths()
        # Set size policy to fixed - width will be set based on text content
        self.album_menu_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        album_btn_style = button_style + """
            QPushButton {
                text-align: left;
                padding: 2px 0 2px 6px;
                font-size: 11px;
            }
        """
        self.album_menu_btn.setStyleSheet(album_btn_style)
        # Store original style for drag feedback
        self._original_album_btn_style = album_btn_style
        # Create a custom button that clips text cleanly without elision
        # We'll override the paint event to draw text and clip it to button bounds
        def paint_with_clipping(event):
            painter = QPainter(self.album_menu_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            option = QStyleOptionButton()
            self.album_menu_btn.initStyleOption(option)
            # Draw button background and bevel
            self.album_menu_btn.style().drawControl(QStyle.ControlElement.CE_PushButtonBevel, option, painter, self.album_menu_btn)
            # Clip to button rectangle to hide overflow cleanly (no "..." elision)
            painter.setClipRect(self.album_menu_btn.rect())
            # Draw text without elision - use the button's font with correct size
            text_rect = self.album_menu_btn.rect().adjusted(6, 2, -1, -2)  # Left padding 6px, right padding 1px (minimal)
            text = self.album_menu_btn.text()
            font = self.album_menu_btn.font()
            font.setPixelSize(11)  # Match time label font size
            painter.setFont(font)
            painter.setPen(QColor("#e0e0e0"))
            # Draw full text - it will be cleanly clipped by setClipRect if it overflows (no "...")
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, text)
        self.album_menu_btn.paintEvent = paint_with_clipping
        self.album_menu_btn.clicked.connect(self._show_album_menu)
        # Enable context menu on right-click
        self.album_menu_btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.album_menu_btn.customContextMenuRequested.connect(self._show_album_context_menu)
        # Album button should be added to controls_row (top row) where track button originally was
        # Add it BEFORE stretch and window controls
        controls_row.addWidget(self.album_menu_btn, 0)  # No stretch - fixed width based on text
        
        # Add flexible space between album list and window controls
        controls_row.addStretch(1)
        
        # Create a container widget for the three right buttons with shared background
        # This will cover album list text if it extends past them (same as elapsed time)
        self.right_buttons_container = QWidget()
        # Use Expanding horizontal policy so it extends to the right edge
        self.right_buttons_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        # Set background color to cover text underneath and to the right
        self.right_buttons_container.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border-radius: 2px;
            }
        """)
        # Use a timer to extend container width after layout updates to cover right margin area
        # This ensures the background covers any text that might peek out past the buttons
        def extend_container_width():
            container = self.right_buttons_container
            if not container:
                return
            parent_widget = container.parent()
            if parent_widget:
                # Get the main widget (right_layout's parent - the nano window itself)
                main_widget = parent_widget.parent()
                if main_widget:
                    # Calculate desired width: extend all the way to the right edge
                    container_geo = container.geometry()
                    # Map container's position to main widget coordinates
                    container_left_in_main = container.mapTo(main_widget, container_geo.topLeft())
                    main_right = main_widget.width()
                    # Extend all the way to the right edge (accounting for right_layout's 3px right margin)
                    # Add extra safety margin to ensure we cover any text sliver
                    desired_width = main_right - container_left_in_main.x() - 3 + 10  # -3 for margin, +10 for safety
                    if desired_width > container_geo.width():
                        # Set minimum width to ensure container extends to cover the area
                        container.setMinimumWidth(desired_width)
        # Store the function for later use
        self._extend_container_width = extend_container_width
        # Call after a short delay to ensure layout is done
        QTimer.singleShot(10, extend_container_width)
        # Also call on resize events
        original_resize_event = self.right_buttons_container.resizeEvent
        def extended_resize_event(event):
            if original_resize_event:
                original_resize_event(event)
            QTimer.singleShot(10, extend_container_width)
        self.right_buttons_container.resizeEvent = extended_resize_event
        right_buttons_layout = QHBoxLayout(self.right_buttons_container)
        # Left padding increased to add space between tracklist and pin button
        # Right margin 0 to extend all the way to the right edge
        # This ensures the background covers any text that might peek out
        right_buttons_layout.setContentsMargins(8, 0, 0, 0)  # Left padding 8px (increased from 4px), extend to right edge
        right_buttons_layout.setSpacing(1)  # Spacing between buttons
        right_buttons_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)  # Align buttons to the left
        
        # Pin button (always on top) - match main interface icon
        self.pin_btn = QPushButton()
        self.pin_btn.setToolTip("Pin to Top")
        self.pin_btn.setCheckable(True)
        self.pin_btn.setChecked(self.nano_always_on_top)
        self.pin_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.pin_btn.setStyleSheet(button_style)
        # Set icon color based on initial state
        if HAS_QT_AWESOME:
            icon_color = '#4a90e2' if self.nano_always_on_top else '#a0a0a0'
            icon = get_icon('thumbtack', color=icon_color)  # Match main interface
            if icon:
                self.pin_btn.setIcon(icon)
            else:
                self.pin_btn.setText("")
        else:
            self.pin_btn.setText("")
        self.pin_btn.clicked.connect(self._on_pin_toggle)
        right_buttons_layout.addWidget(self.pin_btn)
        
        # Minimize button
        self.minimize_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('minus', color='#e0e0e0')
            if icon:
                self.minimize_btn.setIcon(icon)
            else:
                self.minimize_btn.setText("")
        else:
            self.minimize_btn.setText("")
        self.minimize_btn.setToolTip("Minimize")
        self.minimize_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.minimize_btn.setStyleSheet(button_style)
        self.minimize_btn.clicked.connect(self.showMinimized)
        right_buttons_layout.addWidget(self.minimize_btn)
        
        # Restore button
        self.restore_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.chevron-up', color='#e0e0e0')
            if icon:
                self.restore_btn.setIcon(icon)
            else:
                self.restore_btn.setText("")
        else:
            self.restore_btn.setText("")
        self.restore_btn.setToolTip("Restore Main Window")
        self.restore_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.restore_btn.setStyleSheet(button_style)
        self.restore_btn.clicked.connect(self._on_restore)
        right_buttons_layout.addWidget(self.restore_btn)
        
        # Close button
        self.close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                self.close_btn.setIcon(icon)
            else:
                self.close_btn.setText("")
        else:
            self.close_btn.setText("")
        self.close_btn.setToolTip("Close")
        self.close_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.close_btn.setStyleSheet(button_style)
        self.close_btn.clicked.connect(self.close)
        right_buttons_layout.addWidget(self.close_btn)
        
        # Add the container to the controls row (will render on top of tracklist text)
        # Use stretch factor 0 but allow it to expand to fill remaining space to right edge
        controls_row.addWidget(self.right_buttons_container, 0)  # Will extend to right edge
        
        right_layout.addLayout(controls_row)
        
        # Bottom row: progress bar (only under control buttons) and album button
        bottom_row = QHBoxLayout()
        bottom_row.setSpacing(4)  # Spacing between progress bar and album button
        # Match controls_row margins (0, 0, 0, 0) - no margins since parent right_layout has them
        bottom_row.setContentsMargins(0, 0, 0, 0)
        # Align to left - no stretch before first widget
        bottom_row.setAlignment(Qt.AlignmentFlag.AlignLeft)
        
        # Progress bar (below controls only, 5px height, clickable and draggable)
        # Width will be constrained to match control buttons width
        self.progress_bar = QSlider(Qt.Orientation.Horizontal)
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(1000)  # Use 1000 for smoother seeking
        self.progress_bar.setValue(0)
        self.progress_bar.setFixedHeight(5)
        # Make progress bar taller for easier interaction (but visually 5px)
        self.progress_bar.setMinimumHeight(12)  # Larger hit area for easier clicking/dragging
        self.progress_bar.setStyleSheet("""
            QSlider::groove:horizontal {
                background: #3a3a3a;
                height: 5px;
                border-radius: 2px;
            }
            QSlider::handle:horizontal {
                background: #4a90e2;
                width: 8px;
                height: 5px;
                border-radius: 2px;
                margin: 0;
            }
            QSlider::sub-page:horizontal {
                background: #4a90e2;
                border-radius: 2px;
            }
        """)
        self.progress_bar.sliderPressed.connect(self._on_progress_pressed)
        self.progress_bar.sliderReleased.connect(self._on_progress_released)
        self.progress_bar.valueChanged.connect(self._on_progress_changed)
        self._progress_dragging = False
        
        # Override mousePressEvent to handle clicks anywhere on the slider (Windows 10 compatibility)
        # On Windows 10, QSlider doesn't automatically snap to click position like Windows 11
        original_mouse_press = self.progress_bar.mousePressEvent
        def custom_mouse_press_event(event):
            if event.button() == Qt.MouseButton.LeftButton:
                # Calculate position based on click X coordinate
                pos = event.position().x() if hasattr(event, 'position') else event.x()
                slider_width = self.progress_bar.width()
                if slider_width > 0:
                    # Calculate value based on click position (0 to maximum)
                    ratio = pos / slider_width
                    # Clamp ratio to 0-1 range
                    ratio = max(0.0, min(1.0, ratio))
                    # Calculate slider value
                    min_val = self.progress_bar.minimum()
                    max_val = self.progress_bar.maximum()
                    new_value = int(min_val + ratio * (max_val - min_val))
                    # Set the value directly - this will trigger sliderPressed and valueChanged
                    self.progress_bar.setValue(new_value)
                    # Mark as dragging
                    self._progress_dragging = True
                    # Call the original handler to ensure proper event processing
                    if original_mouse_press:
                        original_mouse_press(event)
                else:
                    # Fallback to original behavior if width is 0
                    if original_mouse_press:
                        original_mouse_press(event)
            else:
                # For non-left clicks, use original behavior
                if original_mouse_press:
                    original_mouse_press(event)
        
        self.progress_bar.mousePressEvent = custom_mouse_press_event
        
        # Override mouseMoveEvent to handle dragging (Windows 10 compatibility)
        # This ensures smooth dragging works the same on both Windows 10 and 11
        original_mouse_move = self.progress_bar.mouseMoveEvent
        def custom_mouse_move_event(event):
            if self._progress_dragging and event.buttons() & Qt.MouseButton.LeftButton:
                # Calculate position based on mouse X coordinate
                pos = event.position().x() if hasattr(event, 'position') else event.x()
                slider_width = self.progress_bar.width()
                if slider_width > 0:
                    # Calculate value based on mouse position (0 to maximum)
                    ratio = pos / slider_width
                    # Clamp ratio to 0-1 range
                    ratio = max(0.0, min(1.0, ratio))
                    # Calculate slider value
                    min_val = self.progress_bar.minimum()
                    max_val = self.progress_bar.maximum()
                    new_value = int(min_val + ratio * (max_val - min_val))
                    # Update the value during drag
                    self.progress_bar.setValue(new_value)
                # Call original handler for proper event processing
                if original_mouse_move:
                    original_mouse_move(event)
            else:
                # Not dragging, use original behavior
                if original_mouse_move:
                    original_mouse_move(event)
        
        self.progress_bar.mouseMoveEvent = custom_mouse_move_event
        
        # Install event filter on progress bar to prevent window dragging when interacting with it
        self.progress_bar.installEventFilter(self)
        # Progress bar should only span the width of control buttons (8 buttons * 22px + spacing)
        # Approximate: 8 buttons * 22px = 176px, plus spacing between them
        # We'll let it size naturally but constrain it - use fixed width based on button count
        # Calculate: 8 buttons (prev album, prev track, play, next track, next album, shuffle, repeat, volume)
        # = 8 * 22 = 176px, plus 7 * 1px spacing = 7px, total ~183px
        # But we need to account for margins too - let's use a more flexible approach
        # Set size policy to Fixed width, but we'll update it dynamically
        self.progress_bar.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        # Store reference to calculate width later
        self._control_buttons_width = None
        bottom_row.addWidget(self.progress_bar, 0)  # No stretch - fixed width
        
        # Track menu button (expandable) - in bottom row after progress bar, before time label
        # Add track button here (swapped from top row)
        bottom_row.addWidget(self.track_menu_btn, 0)  # No stretch - fixed width based on text
        
        # Add flexible space between track list and time label
        bottom_row.addStretch(1)
        
        # Create a container widget for the time label with shared background
        # This will cover track list text if it extends past the time label
        self.time_label_container = QWidget()
        # Use Expanding horizontal policy so it extends to the right edge
        self.time_label_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        # Set background color to cover text underneath and to the right
        self.time_label_container.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border-radius: 2px;
            }
        """)
        # Use a timer to extend container width after layout updates to cover right margin area
        # This ensures the background covers any text that might peek out past the time label
        def extend_time_container_width():
            container = self.time_label_container
            if not container:
                return
            parent_widget = container.parent()
            if parent_widget:
                # Get the main widget (right_layout's parent - the nano window itself)
                main_widget = parent_widget.parent()
                if main_widget:
                    # Calculate desired width: extend all the way to the right edge
                    container_geo = container.geometry()
                    # Map container's position to main widget coordinates
                    container_left_in_main = container.mapTo(main_widget, container_geo.topLeft())
                    main_right = main_widget.width()
                    # Extend all the way to the right edge (accounting for right_layout's 3px right margin)
                    # Add extra safety margin to ensure we cover any text sliver (increased from 10 to 15 for better coverage)
                    desired_width = main_right - container_left_in_main.x() - 3 + 15  # -3 for margin, +15 for safety
                    # Always set minimum width to ensure container extends to cover the area (even if current width is larger)
                    container.setMinimumWidth(desired_width)
        # Store the function for later use
        self._extend_time_container_width = extend_time_container_width
        # Call after a short delay to ensure layout is done
        QTimer.singleShot(10, extend_time_container_width)
        # Also call on resize events
        original_time_resize_event = self.time_label_container.resizeEvent
        def extended_time_resize_event(event):
            if original_time_resize_event:
                original_time_resize_event(event)
            QTimer.singleShot(10, extend_time_container_width)
        self.time_label_container.resizeEvent = extended_time_resize_event
        time_label_layout = QHBoxLayout(self.time_label_container)
        # Right margin 0 to extend all the way to the right edge
        # This ensures the background covers any text that might peek out
        time_label_layout.setContentsMargins(0, 0, 0, 0)  # No margins - extend to right edge
        time_label_layout.setSpacing(0)
        time_label_layout.setAlignment(Qt.AlignmentFlag.AlignRight)  # Align time label to the right
        
        # Time display (clickable to cycle modes) - fixed width, positioned on right side of container
        self.time_label = QLabel("00:00/00:00")
        self.time_label.setStyleSheet("""
            QLabel {
                color: #e0e0e0;
                font-size: 11px;
                padding: 2px 2px 2px 4px;
                background-color: transparent;
                border-radius: 2px;
            }
            QLabel:hover {
                background-color: #3a3a3a;
                border-radius: 2px;
            }
        """)
        # Calculate minimum width based on text content - measure longest possible format
        font_metrics = QFontMetrics(self.time_label.font())
        # Measure both formats to ensure enough width: "00:00/00:00" and "-00:00/00:00" (for remaining time)
        text_width1 = font_metrics.horizontalAdvance("00:00/00:00")
        text_width2 = font_metrics.horizontalAdvance("-00:00/00:00")
        max_text_width = max(text_width1, text_width2)
        # Add padding: left 4px + right 2px = 6px total
        time_label_width = max_text_width + 6
        self.time_label.setMinimumWidth(time_label_width)  # Text + padding
        self.time_label.setMaximumWidth(time_label_width)  # Fixed width based on content
        self.time_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.time_label.setCursor(Qt.CursorShape.PointingHandCursor)
        self.time_label.mousePressEvent = self._on_time_label_clicked
        # Time display mode: 0 = elapsed/total, 1 = elapsed/remaining
        self.time_display_mode = self.parent_window.settings.get('nano_time_display_mode', 0)
        time_label_layout.addWidget(self.time_label)  # Add time label to container layout
        bottom_row.addWidget(self.time_label_container, 0)  # Add container to bottom row - expands to right edge
        
        right_layout.addLayout(bottom_row)
        
        # Add right layout to main layout
        main_layout.addLayout(right_layout)
        
        # Network manager for loading cover art images
        self.network_manager = QNetworkAccessManager(self)
        self.network_manager.finished.connect(self._on_cover_art_loaded)
        
        # Track current cover art URL to avoid reloading same image
        self._current_cover_art_url = None
        
        # Store current track and album info for highlighting
        self._current_track_number = None
        self._current_album_name = None
        
        # Set initial cover art height
        if hasattr(self, 'cover_art_label'):
            self.cover_art_label.setFixedHeight(self.height())
        
        # Set background color to match main window/playlist title bar
        self.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
                border: 1px solid #1a1a1a;
            }
        """)
        
        # Setup update timer for track info and time
        self.update_timer = QTimer(self)
        self.update_timer.timeout.connect(self._update_track_info)
        self.update_timer.start(500)  # Update every 500ms
        
        # Initial cover art update
        QTimer.singleShot(1000, self._update_cover_art)  # Update after a short delay
        
        # Initial update
        QTimer.singleShot(100, self._update_track_info)
        
        # Sync shuffle and repeat buttons after a delay to ensure playlist_sidebar is initialized
        # This is especially important when starting in nano mode
        QTimer.singleShot(200, self._sync_shuffle_repeat_buttons)
        QTimer.singleShot(500, self._sync_shuffle_repeat_buttons)  # Retry after a bit more time
    
    def _perform_one_time_resize_trick(self):
        """
        Force layout activation to ensure button geometries are correctly calculated.
        The issue is that when the window first shows, the layout hasn't finished
        calculating sizes for expanding widgets, so button.rect() in paintEvent is wrong.
        Activating the layout forces Qt to calculate all widget sizes immediately.
        """
        # Safety check: only do this once
        if self._one_time_resize_done:
            return
        
        # Check if user is currently resizing - if so, abort immediately
        if self._resize_edge is not None:
            # User is resizing, don't interfere - mark as done so we don't try again
            self._one_time_resize_done = True
            return
        
        # Mark as done immediately to prevent any retries
        self._one_time_resize_done = True
        
        # Only proceed if window is visible and has valid size
        if not self.isVisible() or self.width() <= 0:
            return
        
        try:
            # Force layout to activate - this calculates all widget sizes immediately
            layout = self.layout()
            if layout:
                # activate() forces Qt to calculate and assign sizes to all widgets
                layout.activate()
            
            # Now that layout is activated, update button widths based on calculated sizes
            self._update_button_widths()
            
            # Force buttons to repaint with their now-correct geometries
            if hasattr(self, 'track_menu_btn'):
                self.track_menu_btn.update()
            if hasattr(self, 'album_menu_btn'):
                self.album_menu_btn.update()
            
        except Exception as e:
            logger.debug(f"Error in one-time layout activation: {e}")
    
    def _create_resize_edges(self):
        """Create invisible edge widgets for resize detection."""
        # Ensure _resize_threshold exists before using it
        if not hasattr(self, '_resize_threshold') or self._resize_threshold is None:
            self._resize_threshold = 5  # Default value
        
        try:
            # Left edge widget
            self._left_resize_edge = QWidget(self)
            self._left_resize_edge.setFixedWidth(self._resize_threshold)
            self._left_resize_edge.setCursor(Qt.CursorShape.SizeHorCursor)
            self._left_resize_edge.setStyleSheet("background-color: transparent;")
            self._left_resize_edge.installEventFilter(self)
            self._left_resize_edge.raise_()  # Raise to top so it's always accessible
            
            # Right edge widget
            self._right_resize_edge = QWidget(self)
            self._right_resize_edge.setFixedWidth(self._resize_threshold)
            self._right_resize_edge.setCursor(Qt.CursorShape.SizeHorCursor)
            self._right_resize_edge.setStyleSheet("background-color: transparent;")
            self._right_resize_edge.installEventFilter(self)
            self._right_resize_edge.raise_()  # Raise to top so it's always accessible
            
            # Position edge widgets (will be updated on resize)
            self._update_resize_edge_positions()
        except Exception as e:
            logger.error(f"Error creating resize edges: {e}")
            # Ensure attributes exist even if creation fails
            if not hasattr(self, '_left_resize_edge'):
                self._left_resize_edge = None
            if not hasattr(self, '_right_resize_edge'):
                self._right_resize_edge = None
    
    def _update_resize_edge_positions(self):
        """Update positions of resize edge widgets."""
        if hasattr(self, '_left_resize_edge') and self._left_resize_edge and hasattr(self, '_resize_threshold'):
            self._left_resize_edge.setGeometry(0, 0, self._resize_threshold, self.height())
        if hasattr(self, '_right_resize_edge') and self._right_resize_edge and hasattr(self, '_resize_threshold'):
            self._right_resize_edge.setGeometry(self.width() - self._resize_threshold, 0, self._resize_threshold, self.height())
    
    def _update_button_widths(self):
        """Update track and album button widths based on text content and available space."""
        if not hasattr(self, 'track_menu_btn'):
            return
        
        # Calculate available space (window width minus fixed elements and margins)
        window_width = self.width()
        # If window width is not valid yet, skip (will be called again when window is shown)
        if window_width <= 0:
            return
        # Account for layout margins (left: 5, right: 3) and contents margins (left: 5, right: 3)
        available_width = window_width - 5 - 3 - 5 - 3  # = window_width - 16
        
        # Calculate fixed widths for top row (controls_row)
        # Navigation buttons: 5 buttons * 22px = 110px
        # Spacing between nav buttons: 4 * 1px = 4px (reduced spacing)
        # Shuffle, repeat, volume: 3 * 22px = 66px
        # Spacing: 2 * 1px = 2px (reduced spacing)
        # Additional spacing: 1px (after volume, before track button)
        left_controls_width = 110 + 4 + 66 + 2 + 1  # = 183px
        # Pin, minimize, restore, close: 4 * 22px = 88px
        # Spacing between right buttons: 3 * 1px = 3px (reduced spacing)
        right_buttons_width = 88 + 3  # = 91px
        
        # Measure track button text width
        track_text = self.track_menu_btn.text()
        font_metrics = QFontMetrics(self.track_menu_btn.font())
        track_text_width = font_metrics.horizontalAdvance(track_text)
        # Add padding (left: 6px, no right padding)
        track_text_width_with_padding = track_text_width + 6
        
        # Calculate maximum width for track button - allow it to get closer to right buttons
        # Use minimal gap (1px) to allow more text to be visible while still preventing overlap
        max_track_width = available_width - left_controls_width - right_buttons_width - 1  # Subtract right buttons width + minimal gap
        
        # Set fixed width for track button based on text
        # Use text elision if text is too long to prevent any overflow
        track_width = max(track_text_width_with_padding, 80)  # Minimum 80px
        # Limit to max width - if text is too long, it will be elided
        track_width = min(track_width, max_track_width)  # Don't exceed calculated max
        self.track_menu_btn.setFixedWidth(track_width)
        self.track_menu_btn.updateGeometry()
        
        # Update album button width (bottom row - after progress bar)
        if hasattr(self, 'album_menu_btn'):
            # Album button is in bottom row, fixed width based on text
            # Calculate maximum width to prevent overflow past time label (same approach as track button)
            album_text = self.album_menu_btn.text()
            font_metrics = QFontMetrics(self.album_menu_btn.font())
            album_text_width = font_metrics.horizontalAdvance(album_text)
            # Add padding: left 6px + right 1px (minimal, matching track button)
            album_text_width_with_padding = album_text_width + 7
            
            # Calculate maximum width for album button - prevent it from extending past time label
            # Progress bar width matches control buttons width (same as left_controls_width)
            progress_bar_width = left_controls_width  # Progress bar matches control buttons width
            
            # Time label width: measure longest possible format
            if hasattr(self, 'time_label'):
                time_font_metrics = QFontMetrics(self.time_label.font())
                time_text_width1 = time_font_metrics.horizontalAdvance("00:00/00:00")
                time_text_width2 = time_font_metrics.horizontalAdvance("-00:00/00:00")
                max_time_width = max(time_text_width1, time_text_width2) + 12  # +12 for padding
            else:
                max_time_width = 80  # Fallback estimate
            
            # Spacing: progress bar to album button (4px), minimal gap before time label (1px)
            spacing_between = 4  # Spacing between progress bar and album button
            minimal_gap = 1  # Minimal gap before time label to prevent overlap
            # Calculate max album width: available width - progress bar - time label - spacing - minimal gap
            max_album_width = available_width - progress_bar_width - max_time_width - spacing_between - minimal_gap
            
            # Set fixed width for album button based on text
            # Limit to max width - text will be clipped by paint event if too long (same as track button)
            album_width = max(album_text_width_with_padding, 60)  # Minimum 60px
            # Limit to max width - if text is too long, it will be clipped
            album_width = min(album_width, max_album_width)  # Don't exceed calculated max
            
            self.album_menu_btn.setFixedWidth(album_width)
        self.album_menu_btn.updateGeometry()
    
    def showEvent(self, event):
        """Handle window show event - update cover art height."""
        super().showEvent(event)
        if hasattr(self, 'cover_art_label'):
            self.cover_art_label.setFixedHeight(self.height())
        
        # Update loading widget position and size to match cover art
        if hasattr(self, 'cover_art_loading_widget') and self.cover_art_loading_widget:
            self.cover_art_loading_widget.setGeometry(0, 0, self.cover_art_label.width(), self.cover_art_label.height())
        
        # Force layout activation FIRST to ensure all widget sizes are calculated
        # This is critical - without this, expanding widgets (like our buttons) may have
        # incorrect rect() values in their paint events
        layout = self.layout()
        if layout:
            layout.activate()  # Force layout to calculate all widget sizes immediately
        
        # Use processEvents to ensure window has valid size before calculating
        QApplication.processEvents()
        
        # Now update button widths based on the activated layout
        self._update_button_widths()
        
        # Update container widths to cover text overflow (after layout is activated)
        if hasattr(self, '_extend_container_width'):
            QTimer.singleShot(50, self._extend_container_width)
        if hasattr(self, '_extend_time_container_width'):
            QTimer.singleShot(50, self._extend_time_container_width)
        
        # Update progress bar width after layout is activated
        QTimer.singleShot(50, self._update_progress_bar_width)
        
        # Also trigger one-time layout activation after a short delay as backup
        # This ensures buttons get correct geometry even if timing is off
        if not self._one_time_resize_done:
            QTimer.singleShot(100, self._perform_one_time_resize_trick)
        
        # Update cover art when window is shown
        QTimer.singleShot(500, self._update_cover_art)
        
        # Check if URL is currently loading and show loading animation
        self._check_and_show_loading_animation()
    
    def _update_progress_bar_width(self):
        """Update progress bar width to match control buttons width exactly."""
        if not hasattr(self, 'progress_bar') or not hasattr(self, 'prev_album_btn'):
            return
        
        try:
            # Calculate width of all control buttons (8 buttons: prev album, prev track, play, next track, next album, shuffle, repeat, volume)
            # Measure the actual rendered width from first button to last button
            if (hasattr(self, 'volume_btn') and self.volume_btn.isVisible() and 
                hasattr(self, 'prev_album_btn') and self.prev_album_btn.isVisible()):
                # Get the right edge of the volume button (including its width)
                volume_right = self.volume_btn.geometry().right()
                # Get the left edge of the first button (prev_album_btn)
                prev_left = self.prev_album_btn.geometry().left()
                # Calculate exact width from first button left to last button right
                # The geometry() returns positions relative to the parent widget
                # Since both controls_row and bottom_row are in right_layout, they should align
                buttons_width = volume_right - prev_left
                if buttons_width > 0:
                    self.progress_bar.setFixedWidth(buttons_width)
                    # Force update to ensure it takes effect
                    self.progress_bar.updateGeometry()
                    return
        except Exception as e:
            logger.debug(f"Error calculating progress bar width from geometry: {e}")
        
        # Fallback: use calculated width based on button sizes
        # 8 buttons * 22px = 176px
        # 7 spaces * 1px = 7px  
        # Total: 183px
        buttons_width = 8 * 22 + 7 * 1
        self.progress_bar.setFixedWidth(buttons_width)
        self.progress_bar.updateGeometry()
    
    def resizeEvent(self, event):
        """Handle window resize - update edge widget positions."""
        super().resizeEvent(event)
        self._update_resize_edge_positions()
        # Ensure edge widgets stay on top after resize
        if hasattr(self, '_left_resize_edge') and self._left_resize_edge:
            self._left_resize_edge.raise_()
        if hasattr(self, '_right_resize_edge') and self._right_resize_edge:
            self._right_resize_edge.raise_()
        # Update button widths based on text content
        self._update_button_widths()
        # Update progress bar width to match control buttons (with small delay to ensure geometry is ready)
        QTimer.singleShot(10, self._update_progress_bar_width)
        # Also update album button width after progress bar is updated (to account for time label)
        QTimer.singleShot(20, self._update_button_widths)
        # Update cover art height to match window height
        if hasattr(self, 'cover_art_label'):
            self.cover_art_label.setFixedHeight(self.height())
            # Update loading widget position and size to match cover art
            if hasattr(self, 'cover_art_loading_widget') and self.cover_art_loading_widget:
                self.cover_art_loading_widget.setGeometry(0, 0, self.cover_art_label.width(), self.cover_art_label.height())
        # Update container widths to cover text overflow (with delay to ensure geometry is ready)
        if hasattr(self, '_extend_container_width'):
            QTimer.singleShot(10, self._extend_container_width)
        if hasattr(self, '_extend_time_container_width'):
            QTimer.singleShot(10, self._extend_time_container_width)
        # Force layout update (don't call processEvents() here to avoid conflicts with manual resize)
        if hasattr(self, 'track_menu_btn') and hasattr(self, 'album_menu_btn'):
            self.updateGeometry()
    
    def eventFilter(self, obj, event):
        """Handle events for window dragging, snapping, album menu delete key, and drag-and-drop."""
        # Handle drag-and-drop on album button
        if hasattr(self, 'album_menu_btn') and obj == self.album_menu_btn:
            if event.type() == QEvent.Type.DragEnter:
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                    # Add visual feedback (highlight)
                    self._dragging_over_album_btn = True
                    # Update button style to show highlight
                    highlight_style = self._original_album_btn_style + """
                        QPushButton {
                            background-color: #3a5a7a !important;
                        }
                        QPushButton:hover {
                            background-color: #4a6a8a !important;
                        }
                    """
                    self.album_menu_btn.setStyleSheet(highlight_style)
                    self.album_menu_btn.update()
                    return True
                else:
                    event.ignore()
                    return True
            elif event.type() == QEvent.Type.DragMove:
                # Keep accepting while dragging over button
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                    return True
                else:
                    event.ignore()
                    return True
            elif event.type() == QEvent.Type.DragLeave:
                # Remove visual feedback
                self._dragging_over_album_btn = False
                # Restore original style (remove highlight)
                if hasattr(self, '_original_album_btn_style'):
                    self.album_menu_btn.setStyleSheet(self._original_album_btn_style)
                self.album_menu_btn.update()
                return True
            elif event.type() == QEvent.Type.Drop:
                # Extract all URLs
                urls = []
                if event.mimeData().hasUrls():
                    url_list = event.mimeData().urls()
                    urls = [url.toString() for url in url_list]
                elif event.mimeData().hasText():
                    text = event.mimeData().text().strip()
                    if text:
                        lines = [line.strip() for line in text.split('\n') if line.strip()]
                        urls = lines
                
                if not urls:
                    event.ignore()
                    # Remove visual feedback
                    self._dragging_over_album_btn = False
                    if hasattr(self, '_original_album_btn_style'):
                        self.album_menu_btn.setStyleSheet(self._original_album_btn_style)
                    self.album_menu_btn.update()
                    return True
                
                # Process all URLs - add to playlist
                if self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
                    added_count = 0
                    skipped_count = 0
                    existing_urls = [item.get("url") if isinstance(item, dict) else item 
                                    for item in self.parent_window.playlist_manager.playlist]
                    
                    for url in urls:
                        # Try to resolve redirects
                        resolved = None
                        if self.parent_window and hasattr(self.parent_window, 'resolve_url_redirects'):
                            resolved = self.parent_window.resolve_url_redirects(url)
                        
                        if resolved:
                            url = resolved
                        
                        # Normalize URL
                        url = url.strip().rstrip('/')
                        if not url.startswith(('http://', 'https://')):
                            url = 'https://' + url
                        
                        # Only add if it's a Bandcamp URL and not already in playlist
                        if 'bandcamp.com' in url.lower():
                            if url not in existing_urls:
                                self.parent_window.playlist_manager.add_url(url)
                                added_count += 1
                                existing_urls.append(url)
                            else:
                                skipped_count += 1
                        else:
                            skipped_count += 1
                    
                    # Save playlist after adding all URLs
                    if added_count > 0:
                        self.parent_window.playlist_manager.save_playlist()
                        if hasattr(self.parent_window, 'update_playlist_display'):
                            self.parent_window.update_playlist_display()
                    
                    # Show feedback message
                    if len(urls) > 1:
                        msg = QMessageBox(self)
                        msg.setWindowTitle("Add URLs")
                        if added_count > 0 and skipped_count > 0:
                            msg.setText(f"Added {added_count} URL(s) to playlist.\nSkipped {skipped_count} (duplicates or invalid).")
                        elif added_count > 0:
                            msg.setText(f"Added {added_count} URL(s) to playlist.")
                        else:
                            msg.setText("No URLs added. All were duplicates or invalid.")
                        msg.setStyleSheet("""
                            QMessageBox {
                                background-color: #2b2b2b;
                                color: #e0e0e0;
                            }
                            QMessageBox QLabel {
                                color: #e0e0e0;
                                background-color: transparent;
                            }
                            QMessageBox QPushButton {
                                background-color: #3a3a3a;
                                color: #e0e0e0;
                                border: 1px solid #4a4a4a;
                                border-radius: 4px;
                                padding: 5px 15px;
                                min-width: 60px;
                            }
                            QMessageBox QPushButton:hover {
                                background-color: #4a4a4a;
                            }
                        """)
                        msg.exec()
                    elif len(urls) == 1:
                        # Single URL - show tooltip feedback
                        if added_count > 0:
                            message = "URL added to playlist"
                        else:
                            message = "URL not added (duplicate or invalid)"
                        global_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().center())
                        QToolTip.showText(global_pos, message, self.album_menu_btn, QRect(), 2000)
                
                # Remove visual feedback
                self._dragging_over_album_btn = False
                if hasattr(self, '_original_album_btn_style'):
                    self.album_menu_btn.setStyleSheet(self._original_album_btn_style)
                self.album_menu_btn.update()
                
                event.acceptProposedAction()
                return True
        
        # Handle delete key in album menu
        if hasattr(self, '_album_list') and obj == self._album_list and event.type() == QEvent.Type.KeyPress:
            if event.key() == Qt.Key.Key_Delete:
                selected_items = self._album_list.selectedItems()
                if selected_items:
                    for item in selected_items:
                        url = item.data(Qt.ItemDataRole.UserRole)
                        if url and self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
                            self.parent_window.playlist_manager.remove_url(url)
                        row = self._album_list.row(item)
                        self._album_list.takeItem(row)
                    return True
        
        # Prevent window dragging when interacting with progress bar
        if hasattr(self, 'progress_bar') and obj == self.progress_bar:
            # Let the slider handle all its own events
            return False
        
        # Handle dragging from cover art label
        if hasattr(self, 'cover_art_label') and obj == self.cover_art_label:
            if event.type() == QEvent.Type.MouseButtonPress:
                if event.button() == Qt.MouseButton.LeftButton:
                    # Start dragging from cover art
                    self._drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                    return True
            elif event.type() == QEvent.Type.MouseMove:
                # Handle dragging
                if self._drag_position is not None and event.buttons() == Qt.MouseButton.LeftButton:
                    new_pos = event.globalPosition().toPoint() - self._drag_position
                    
                    # If docked, check if user is trying to drag away (undock)
                    if self._docked_edge and self._docked_y_position is not None:
                        screen = QApplication.primaryScreen()
                        if screen:
                            screen_geometry = screen.availableGeometry()
                            # Check if intended Y position is far enough from edge to undock
                            should_undock = False
                            if self._docked_edge == 'top':
                                if abs(new_pos.y() - screen_geometry.top()) > self._snap_threshold * 2:
                                    should_undock = True
                            elif self._docked_edge == 'bottom':
                                window_height = self.height()
                                if abs(new_pos.y() + window_height - screen_geometry.bottom()) > self._snap_threshold * 2:
                                    should_undock = True
                            
                            if should_undock:
                                # Undock and allow normal movement
                                self._undock()
                                self.move(new_pos)
                                # Check for snapping (which may dock again)
                                self._check_snap_to_edges()
                            else:
                                # Still docked - constrain to horizontal movement only
                                self.move(new_pos.x(), self._docked_y_position)
                        else:
                            # No screen info - just constrain to horizontal
                            self.move(new_pos.x(), self._docked_y_position)
                    else:
                        # Normal dragging - allow both X and Y movement
                        self.move(new_pos)
                        # Check for snapping (which may dock)
                        self._check_snap_to_edges()
                    return True
            elif event.type() == QEvent.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    self._drag_position = None
                    return True
            return False
        
        # Handle resize edge widgets (check if they exist first and are not None)
        if (hasattr(self, '_left_resize_edge') and self._left_resize_edge is not None and
            hasattr(self, '_right_resize_edge') and self._right_resize_edge is not None and
            (obj == self._left_resize_edge or obj == self._right_resize_edge)):
            if event.type() == QEvent.Type.MouseButtonPress:
                if event.button() == Qt.MouseButton.LeftButton:
                    # Determine which edge
                    edge = 'left' if obj == self._left_resize_edge else 'right'
                    self._resize_edge = edge
                    self._resize_start_pos = event.globalPosition().toPoint()
                    self._resize_start_geometry = self.frameGeometry()
                    return True
            elif event.type() == QEvent.Type.MouseMove:
                # Cursor is already set on the edge widgets, but handle resize if dragging
                if self._resize_edge is not None and self._resize_start_pos is not None and self._resize_start_geometry is not None:
                    if event.buttons() == Qt.MouseButton.LeftButton:
                        current_pos = event.globalPosition().toPoint()
                        delta_x = current_pos.x() - self._resize_start_pos.x()
                        
                        if self._resize_edge == 'left':
                            # Resize from left edge
                            new_width = self._resize_start_geometry.width() - delta_x
                            new_x = self._resize_start_geometry.x() + delta_x
                            
                            # Enforce minimum width
                            if new_width < self.minimumWidth():
                                new_width = self.minimumWidth()
                                new_x = self._resize_start_geometry.x() + self._resize_start_geometry.width() - new_width
                            
                            # Update window geometry
                            self.setGeometry(new_x, self._resize_start_geometry.y(), new_width, self._resize_start_geometry.height())
                        elif self._resize_edge == 'right':
                            # Resize from right edge
                            new_width = self._resize_start_geometry.width() + delta_x
                            
                            # Enforce minimum width
                            if new_width < self.minimumWidth():
                                new_width = self.minimumWidth()
                            
                            # Update window geometry (x stays the same, only width changes)
                            self.setGeometry(self._resize_start_geometry.x(), self._resize_start_geometry.y(), new_width, self._resize_start_geometry.height())
                        
                        return True
            elif event.type() == QEvent.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    self._resize_edge = None
                    self._resize_start_pos = None
                    self._resize_start_geometry = None
                    return True
            return False
        
        # Handle window dragging and snapping
        if obj == self:
            # Handle mouse events for dragging
            if event.type() == QEvent.Type.MouseButtonPress:
                if event.button() == Qt.MouseButton.LeftButton:
                    # Check if click is on a button, slider, or label - don't drag in that case
                    # EXCEPT: allow dragging from cover art label
                    click_pos = event.position().toPoint()
                    child = self.childAt(click_pos)
                    
                    # Walk up the widget hierarchy to check if we're clicking on a control
                    widget = child
                    while widget:
                        # Allow dragging from cover art label
                        if hasattr(self, 'cover_art_label') and widget == self.cover_art_label:
                            # Start dragging from cover art
                            self._drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                            return True
                        if isinstance(widget, (QPushButton, QSlider, QLabel, QListWidget)):
                            # Click is on a control (but not cover art) - don't start dragging
                            return False
                        widget = widget.parentWidget() if hasattr(widget, 'parentWidget') else None
                    
                    # Not on a control - start dragging
                    self._drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                    return True
            elif event.type() == QEvent.Type.MouseMove:
                
                # Handle dragging
                if self._drag_position is not None:
                    # Once dragging has started, continue dragging regardless of what widget we're over
                    # (only check on press, not during move)
                    new_pos = event.globalPosition().toPoint() - self._drag_position
                    
                    # If docked, check if user is trying to drag away (undock)
                    if self._docked_edge and self._docked_y_position is not None:
                        screen = QApplication.primaryScreen()
                        if screen:
                            screen_geometry = screen.availableGeometry()
                            # Check if intended Y position is far enough from edge to undock
                            should_undock = False
                            if self._docked_edge == 'top':
                                if abs(new_pos.y() - screen_geometry.top()) > self._snap_threshold * 2:
                                    should_undock = True
                            elif self._docked_edge == 'bottom':
                                window_height = self.height()
                                if abs(new_pos.y() + window_height - screen_geometry.bottom()) > self._snap_threshold * 2:
                                    should_undock = True
                            
                            if should_undock:
                                # Undock and allow normal movement
                                self._undock()
                                self.move(new_pos)
                                # Check for snapping (which may dock again)
                                self._check_snap_to_edges()
                            else:
                                # Still docked - constrain to horizontal movement only
                                self.move(new_pos.x(), self._docked_y_position)
                        else:
                            # No screen info - just constrain to horizontal
                            self.move(new_pos.x(), self._docked_y_position)
                    else:
                        # Normal dragging - allow both X and Y movement
                        self.move(new_pos)
                        # Check for snapping (which may dock)
                        self._check_snap_to_edges()
                    return True
            elif event.type() == QEvent.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    self._drag_position = None
                    self._resize_edge = None
                    self._resize_start_pos = None
                    self._resize_start_geometry = None
                    self.setCursor(Qt.CursorShape.ArrowCursor)
                    return True
            elif event.type() == QEvent.Type.Leave:
                # Reset cursor when mouse leaves window (if not actively resizing)
                if self._resize_edge is None:
                    self.setCursor(Qt.CursorShape.ArrowCursor)
                return False
        
        return super().eventFilter(obj, event)
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event on the nano player window"""
        # Only accept if it's a URL or text (not web content)
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def dropEvent(self, event: QDropEvent):
        """Handle drop event on the nano player window - load first URL"""
        # Check if drop is over album button - if so, let it handle it
        if hasattr(self, 'album_menu_btn'):
            pos = event.position().toPoint()
            album_btn_rect = self.album_menu_btn.geometry()
            if album_btn_rect.contains(pos):
                # Let album button handle it
                return
        
        # Extract first URL
        url = None
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls:
                url = urls[0].toString()
        elif event.mimeData().hasText():
            text = event.mimeData().text().strip()
            if text:
                lines = [line.strip() for line in text.split('\n') if line.strip()]
                if lines:
                    url = lines[0]
        
        if not url:
            event.ignore()
            return
        
        # Validate URL before processing
        # Try to resolve redirects if it's not already a Bandcamp URL
        resolved_url = None
        if self.parent_window and hasattr(self.parent_window, 'resolve_url_redirects'):
            resolved_url = self.parent_window.resolve_url_redirects(url)
        
        if resolved_url:
            url = resolved_url
        
        # Check if it's a Bandcamp URL
        if 'bandcamp.com' not in url.lower():
            # Not a Bandcamp URL - show message
            QMessageBox.warning(self, "Invalid URL", "Please enter a Bandcamp URL")
            event.ignore()
            return
        
        # Process URL using parent window's handler (same as main window)
        if self.parent_window:
            self.parent_window._handle_global_drop(url)
        
        event.acceptProposedAction()
    
    def contextMenuEvent(self, event):
        """Handle right-click context menu on nano player."""
        menu = QMenu(self)
        self._context_menu = menu  # Store reference to prevent autohide
        
        # Paste URL
        paste_url_action = QAction("Paste URL", self)
        if HAS_QT_AWESOME:
            icon = get_icon('paste', color='#e0e0e0')
            if icon:
                paste_url_action.setIcon(icon)
        else:
            paste_url_action.setText(" Paste URL")
        paste_url_action.triggered.connect(lambda: self.parent_window.on_paste_url() if self.parent_window else None)
        menu.addAction(paste_url_action)
        
        menu.addSeparator()
        
        # Get current page URL for "Open in Browser" and "Copy URL"
        current_url = None
        if self.parent_window and hasattr(self.parent_window, 'web_view') and self.parent_window.web_view:
            current_url = self.parent_window.web_view.url().toString()
        
        if current_url and current_url != "about:blank":
            # Open in Browser
            open_browser_action = QAction("Open in Browser", self)
            if HAS_QT_AWESOME:
                icon = get_icon('external-link-alt', color='#e0e0e0')
                if icon:
                    open_browser_action.setIcon(icon)
            else:
                open_browser_action.setText(" Open in Browser")
            open_browser_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl(current_url)))
            menu.addAction(open_browser_action)
            
            # Copy URL
            copy_url_action = QAction("Copy URL", self)
            if HAS_QT_AWESOME:
                icon = get_icon('copy', color='#e0e0e0')
                if icon:
                    copy_url_action.setIcon(icon)
            else:
                copy_url_action.setText(" Copy URL")
            def copy_url_with_feedback():
                QApplication.clipboard().setText(current_url)
                global_pos = self.mapToGlobal(self.rect().center())
                QToolTip.showText(global_pos, "URL copied", self, QRect(), 1500)
            copy_url_action.triggered.connect(copy_url_with_feedback)
            menu.addAction(copy_url_action)
            
            menu.addSeparator()
        
        # Autohide Nano when Docked (only enabled when docked)
        autohide_action = QAction("Autohide Nano when Docked", self)
        autohide_action.setCheckable(True)
        autohide_action.setChecked(self.nano_autohide_when_docked)
        autohide_action.setEnabled(self._docked_edge is not None)
        def toggle_autohide():
            self.nano_autohide_when_docked = not self.nano_autohide_when_docked
            if self.nano_autohide_when_docked and self._docked_edge:
                self._autohide_timer.start()
                # Initially hide window after a short delay
                QTimer.singleShot(500, lambda: self._initial_autohide())
            else:
                self._autohide_timer.stop()
                # Hide hover area if it exists (legacy, not used anymore)
                if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
                    self._autohide_hover_area.hide()
                if self._is_autohidden:
                    # Restore window position
                    if hasattr(self, '_autohide_saved_pos') and self._autohide_saved_pos:
                        self.move(self._autohide_saved_pos)
                        self._autohide_saved_pos = None
                    self.show()
                    self._is_autohidden = False
        autohide_action.triggered.connect(toggle_autohide)
        menu.addAction(autohide_action)
        
        # Autohide Sensitivity submenu (only enabled when docked and autohide is enabled)
        sensitivity_menu = QMenu("Autohide Sensitivity", self)
        sensitivity_menu.setStyleSheet(menu.styleSheet())
        sensitivity_menu.setEnabled(self._docked_edge is not None and self.nano_autohide_when_docked)
        
        # Get current player height for "Player Height" option
        player_height = self.height() if self.height() > 0 else 50
        
        # Preset options
        presets = [
            ("5px", 5),
            ("10px", 10),
            ("20px", 20),
            ("50px", 50),
            (f"Player Height ({player_height}px)", player_height)
        ]
        
        for preset_name, preset_value in presets:
            preset_action = QAction(preset_name, self)
            preset_action.setCheckable(True)
            preset_action.setChecked(abs(self.nano_autohide_sensitivity - preset_value) < 1)  # Check if within 1px
            def set_sensitivity(value):
                self.nano_autohide_sensitivity = value
                # Clamp to valid range (5px to player height)
                max_sensitivity = self.height() if self.height() > 0 else 200
                self.nano_autohide_sensitivity = max(5, min(self.nano_autohide_sensitivity, max_sensitivity))
                self.parent_window.settings['nano_autohide_sensitivity'] = self.nano_autohide_sensitivity
                self.parent_window.save_settings()
                # Update hover area with new sensitivity
                self._update_autohide_hover_area()
            preset_action.triggered.connect(lambda checked, val=preset_value: set_sensitivity(val))
            sensitivity_menu.addAction(preset_action)
        
        sensitivity_menu.addSeparator()
        
        # Custom option
        custom_action = QAction("Custom...", self)
        def show_custom_dialog():
            dialog = QDialog(self)
            dialog.setWindowTitle("Autohide Sensitivity")
            dialog.setModal(True)
            dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                }
                QLabel {
                    color: #e0e0e0;
                }
                QSlider::groove:horizontal {
                    border: 1px solid #4a4a4a;
                    height: 8px;
                    background: #3a3a3a;
                    border-radius: 4px;
                }
                QSlider::handle:horizontal {
                    background: #4a90e2;
                    border: 1px solid #3a7bc8;
                    width: 18px;
                    height: 18px;
                    margin: -5px 0;
                    border-radius: 9px;
                }
                QSlider::handle:horizontal:hover {
                    background: #5aa0f2;
                }
                QPushButton {
                    background-color: #3a3a3a;
                    color: #e0e0e0;
                    border: 1px solid #4a4a4a;
                    border-radius: 4px;
                    padding: 6px 20px;
                    min-width: 60px;
                }
                QPushButton:hover {
                    background-color: #4a4a4a;
                }
                QPushButton:pressed {
                    background-color: #2a2a2a;
                }
            """)
            
            layout = QVBoxLayout(dialog)
            layout.setSpacing(15)
            layout.setContentsMargins(20, 20, 20, 20)
            
            # Label showing current value
            value_label = QLabel(f"Sensitivity: {self.nano_autohide_sensitivity}px")
            value_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            value_label.setStyleSheet("font-size: 14px; font-weight: bold;")
            layout.addWidget(value_label)
            
            # Slider
            slider = QSlider(Qt.Orientation.Horizontal)
            # Calculate max sensitivity: use current player height or 200px, whichever is larger
            current_player_height = self.height() if self.height() > 0 else 50
            max_sensitivity = max(current_player_height, self.nano_autohide_sensitivity, 200)  # At least 200px max
            slider.setMinimum(5)
            slider.setMaximum(max_sensitivity)
            # Clamp current value to valid range
            current_value = max(5, min(self.nano_autohide_sensitivity, max_sensitivity))
            slider.setValue(current_value)
            slider.setTickPosition(QSlider.TickPosition.TicksBelow)
            tick_interval = max(5, max_sensitivity // 20)  # Reasonable tick interval
            slider.setTickInterval(tick_interval)
            
            def update_label(value):
                value_label.setText(f"Sensitivity: {value}px")
            
            slider.valueChanged.connect(update_label)
            layout.addWidget(slider)
            
            # Info label
            info_label = QLabel(f"Range: 5px - {max_sensitivity}px\nAdjust how much of the player acts as a hotspot.\nLower values = smaller hotspot (less blocking).")
            info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            info_label.setStyleSheet("color: #a0a0a0; font-size: 11px;")
            layout.addWidget(info_label)
            
            # Buttons
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            button_layout.addWidget(cancel_btn)
            
            ok_btn = QPushButton("OK")
            ok_btn.setDefault(True)
            def apply_sensitivity():
                self.nano_autohide_sensitivity = slider.value()
                self.parent_window.settings['nano_autohide_sensitivity'] = self.nano_autohide_sensitivity
                self.parent_window.save_settings()
                # Update hover area with new sensitivity
                self._update_autohide_hover_area()
                dialog.accept()
            ok_btn.clicked.connect(apply_sensitivity)
            button_layout.addWidget(ok_btn)
            
            layout.addLayout(button_layout)
            
            dialog.resize(300, 150)
            dialog.exec()
        
        custom_action.triggered.connect(show_custom_dialog)
        sensitivity_menu.addAction(custom_action)
        
        # Add sensitivity submenu
        sensitivity_action = menu.addMenu(sensitivity_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('sliders-h', color='#e0e0e0')
            if icon:
                sensitivity_action.setIcon(icon)
        
        menu.addSeparator()
        
        # Autoplay
        autoplay_action = QAction("Autoplay", self)
        autoplay_action.setCheckable(True)
        if self.parent_window:
            autoplay_action.setChecked(self.parent_window.autoplay)
            def toggle_autoplay():
                if self.parent_window:
                    self.parent_window.autoplay = not self.parent_window.autoplay
                    self.parent_window.autoplay_action.setChecked(self.parent_window.autoplay)
                    self.parent_window.save_settings()
            autoplay_action.triggered.connect(toggle_autoplay)
        menu.addAction(autoplay_action)
        
        # Autoplay on Startup
        autoplay_on_startup_action = QAction("Autoplay on Startup", self)
        autoplay_on_startup_action.setCheckable(True)
        if self.parent_window:
            autoplay_on_startup_action.setChecked(self.parent_window.autoplay_on_startup)
            def toggle_autoplay_on_startup():
                if self.parent_window:
                    self.parent_window.autoplay_on_startup = not self.parent_window.autoplay_on_startup
                    self.parent_window.autoplay_on_startup_action.setChecked(self.parent_window.autoplay_on_startup)
                    self.parent_window.save_settings()
            autoplay_on_startup_action.triggered.connect(toggle_autoplay_on_startup)
        menu.addAction(autoplay_on_startup_action)
        
        # Style the menu
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 20px 6px 30px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #3a3a3a;
            }
            QMenu::item:disabled {
                color: #666666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #4a4a4a;
                margin: 4px 0;
            }
        """)
        
        menu.exec(event.globalPos())
        # Clear menu reference after it closes
        self._context_menu = None
    
    def _check_snap_to_edges(self):
        """Check if window should snap to top or bottom edge of screen, and handle docking."""
        # If already docked, don't check for snapping (allow smooth dragging)
        if self._docked_edge:
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        screen_geometry = screen.availableGeometry()
        window_geometry = self.frameGeometry()
        
        # Calculate distances to edges
        dist_to_top = abs(window_geometry.top() - screen_geometry.top())
        dist_to_bottom = abs(window_geometry.bottom() - screen_geometry.bottom())
        
        # Check which edge is closer and snap to it if within threshold
        if dist_to_top < self._snap_threshold and dist_to_top <= dist_to_bottom:
            # Snap to top edge
            self.move(window_geometry.left(), screen_geometry.top())
            # Dock to top edge
            self._docked_edge = 'top'
            self._docked_y_position = screen_geometry.top()
            # Start autohide timer if enabled (but don't trigger immediately)
            if self.nano_autohide_when_docked:
                self._autohide_timer.start()
                # Don't call _initial_autohide immediately - let showEvent set cooldown first
                # The timer will handle autohide after cooldown expires
        elif dist_to_bottom < self._snap_threshold:
            # Snap to bottom edge
            self.move(window_geometry.left(), screen_geometry.bottom() - window_geometry.height())
            # Dock to bottom edge
            self._docked_edge = 'bottom'
            self._docked_y_position = screen_geometry.bottom() - window_geometry.height()
            # Start autohide timer if enabled (but don't trigger immediately)
            if self.nano_autohide_when_docked:
                self._autohide_timer.start()
                # Don't call _initial_autohide immediately - let showEvent set cooldown first
                # The timer will handle autohide after cooldown expires
    
    def _initial_autohide(self):
        """Initially move window off-screen when autohide is enabled after docking."""
        # Don't autohide if we're in cooldown (window was just shown)
        if self._autohide_cooldown:
            return
        
        if self._docked_edge and self.nano_autohide_when_docked and not self._is_autohidden:
            # Small delay to let user see the window first, then show only a sliver at the edge
            if self.isVisible():
                # Save current position (ensure it's a valid QPoint)
                current_pos = self.pos()
                if current_pos is not None:
                    self._autohide_saved_pos = current_pos
                # Move window so only a small sliver (3px) is visible at the docked edge
                screen = QApplication.primaryScreen()
                if screen:
                    screen_geometry = screen.geometry()
                    window_height = self.height()
                    sliver_size = 2  # Show 1px sliver at the edge
                    
                    if self._docked_edge == 'top':
                        # Position so only top 3px is visible
                        self.move(self.x(), screen_geometry.top() - window_height + sliver_size)
                    elif self._docked_edge == 'bottom':
                        # Position so only bottom 3px is visible
                        self.move(self.x(), screen_geometry.bottom() - sliver_size)
                self._is_autohidden = True
                # Hide cover art when autohidden so only interface color shows in sliver
                if hasattr(self, 'cover_art_label') and self.cover_art_label:
                    self.cover_art_label.hide()
    
    def _undock(self):
        """Undock window from edge."""
        self._docked_edge = None
        self._docked_y_position = None
        self._autohide_timer.stop()
        # Hide hover area
        if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
            self._autohide_hover_area.hide()
        # Restore window position if it was autohidden
        if self._is_autohidden:
            if hasattr(self, '_autohide_saved_pos') and self._autohide_saved_pos:
                self.move(self._autohide_saved_pos)
                self._autohide_saved_pos = None
            self.show()
            self._is_autohidden = False
    
    def _update_autohide_hover_area(self):
        """Update the autohide hover area position and size based on docking state."""
        if not hasattr(self, '_autohide_hover_area') or not self._autohide_hover_area:
            return
        
        if not self._docked_edge or not self.nano_autohide_when_docked:
            self._autohide_hover_area.hide()
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        screen_geometry = screen.availableGeometry()
        
        # Position hover area at the screen edge (top or bottom)
        # The hover area is only as tall as the sensitivity setting
        if self._docked_edge == 'top':
            # Position at top of screen, full width, height = sensitivity
            self._autohide_hover_area.setGeometry(
                screen_geometry.left(),
                screen_geometry.top(),
                screen_geometry.width(),
                self.nano_autohide_sensitivity
            )
        elif self._docked_edge == 'bottom':
            # Position at bottom of screen, full width, height = sensitivity
            self._autohide_hover_area.setGeometry(
                screen_geometry.left(),
                screen_geometry.bottom() - self.nano_autohide_sensitivity,
                screen_geometry.width(),
                self.nano_autohide_sensitivity
            )
        
        # Show hover area when autohide is enabled and window is hidden
        # Also show it initially when docked (will hide when window is shown)
        if self._is_autohidden or not self.isVisible():
            # Make sure it's shown and can receive mouse events
            self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
            # Show and raise the hover area
            self._autohide_hover_area.show()
            self._autohide_hover_area.raise_()
            # Ensure it's on top and can receive events
            self._autohide_hover_area.setWindowState(Qt.WindowState.WindowNoState)
            # Force update to ensure it's visible
            self._autohide_hover_area.update()
            # Process events to ensure widget is shown and positioned
            QApplication.processEvents()
        else:
            # Hide hover area when window is visible (mouse over window keeps it visible)
            self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._autohide_hover_area.hide()
    
    def _check_autohide_after_leave(self):
        """Check if window should hide after mouse leaves hover area."""
        if not self._docked_edge or not self.nano_autohide_when_docked:
            return
        
        # Don't autohide if context menu is open
        if self._context_menu and self._context_menu.isVisible():
            return
        
        # Check if mouse is over the window or menu
        global_pos = QCursor.pos()
        window_geometry = self.frameGeometry()
        mouse_over_window = window_geometry.contains(global_pos)
        
        mouse_over_menu = False
        if self._context_menu:
            menu_geometry = self._context_menu.geometry()
            mouse_over_menu = menu_geometry.contains(global_pos)
        
        # Only hide if mouse is not over window or menu
        if not mouse_over_window and not mouse_over_menu:
            if not self._is_autohidden and self.isVisible():
                self.hide()
                self._is_autohidden = True
                # Update hover area to show it
                self._update_autohide_hover_area()
    
    def _check_autohide(self):
        """Check if window should show/hide based on mouse position relative to screen edge.
        
        Uses a simple timer-based approach that checks if mouse is within sensitivity
        pixels of the docked screen edge.
        """
        if not self._docked_edge or not self.nano_autohide_when_docked:
            return
        
        # Don't autohide if context menu is open
        if self._context_menu and self._context_menu.isVisible():
            return
        
        # Don't autohide if we're in cooldown (window was just shown)
        if self._autohide_cooldown:
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        # Get global mouse position and screen geometry
        # Use geometry() not availableGeometry() to get full screen including taskbar area
        global_pos = QCursor.pos()
        screen_geometry = screen.geometry()  # Full screen geometry
        window_geometry = self.frameGeometry()
        
        # Check if mouse is over the window
        mouse_over_window = window_geometry.contains(global_pos)
        
        # Check if mouse is over the menu (additional safety check)
        mouse_over_menu = False
        if self._context_menu:
            menu_geometry = self._context_menu.geometry()
            mouse_over_menu = menu_geometry.contains(global_pos)
        
        # Check if mouse is within sensitivity pixels of the docked screen edge
        # This checks the actual screen edge, not the window position
        mouse_near_edge = False
        if self._docked_edge == 'top':
            # Check if mouse Y is within sensitivity pixels of top edge of screen
            # screen_geometry.top() is the top of the screen
            mouse_near_edge = global_pos.y() <= screen_geometry.top() + self.nano_autohide_sensitivity
        elif self._docked_edge == 'bottom':
            # Check if mouse Y is within sensitivity pixels of bottom edge of screen
            # screen_geometry.bottom() is the bottom of the screen
            mouse_near_edge = global_pos.y() >= screen_geometry.bottom() - self.nano_autohide_sensitivity
        
        # Show window if mouse is near edge, over window, or over menu
        if mouse_near_edge or mouse_over_window or mouse_over_menu:
            if self._is_autohidden:
                # Restore window position (move back on-screen)
                if hasattr(self, '_autohide_saved_pos') and self._autohide_saved_pos is not None:
                    self.move(self._autohide_saved_pos)
                    self._autohide_saved_pos = None
                else:
                    # If no saved position, restore to docked position
                    if self._docked_edge == 'top' and self._docked_y_position is not None:
                        self.move(self.x(), self._docked_y_position)
                    elif self._docked_edge == 'bottom' and self._docked_y_position is not None:
                        self.move(self.x(), self._docked_y_position)
                self.show()
                self._is_autohidden = False
                # Show cover art when window is restored
                if hasattr(self, 'cover_art_label') and self.cover_art_label:
                    self.cover_art_label.show()
                # Hide hover area if it exists
                if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
                    self._autohide_hover_area.hide()
        else:
            # Move window so only a small sliver is visible at the docked edge (keeps it in taskbar)
            if not self._is_autohidden and self.isVisible():
                # Save current position (ensure it's a valid QPoint)
                current_pos = self.pos()
                if current_pos is not None:
                    self._autohide_saved_pos = current_pos
                # Move window so only a small sliver (3px) is visible at the docked edge
                screen_geometry = screen.geometry()
                window_height = self.height()
                sliver_size = 2  # Show 1px sliver at the edge
                
                if self._docked_edge == 'top':
                    # Position so only top 3px is visible
                    self.move(self.x(), screen_geometry.top() - window_height + sliver_size)
                elif self._docked_edge == 'bottom':
                    # Position so only bottom 3px is visible
                    self.move(self.x(), screen_geometry.bottom() - sliver_size)
                self._is_autohidden = True
                # Hide cover art when autohidden so only interface color shows in sliver
                if hasattr(self, 'cover_art_label') and self.cover_art_label:
                    self.cover_art_label.hide()
    
    def _update_button_tooltip(self, button, full_text):
        """Update button tooltip to show full text if it would be truncated."""
        if not button or not full_text:
            return
        
        try:
            # Get the button's current geometry and font
            font = button.font()
            
            # Nano mode buttons use 11px font and 6px left padding, 1px right padding
            font.setPixelSize(11)
            text_rect = button.rect().adjusted(6, 2, -1, -2)
            
            # Check if text would be truncated
            font_metrics = QFontMetrics(font)
            text_width = font_metrics.horizontalAdvance(full_text)
            available_width = text_rect.width()
            
            # Also check using elided text (more reliable)
            elided_text = font_metrics.elidedText(full_text, Qt.TextElideMode.ElideRight, available_width)
            would_be_truncated = (elided_text != full_text) or (text_width > available_width)
            
            # Set tooltip to full text if truncated, otherwise clear it (use default tooltip)
            if would_be_truncated:
                button.setToolTip(full_text)
            else:
                # Restore default tooltip based on button type
                if hasattr(self, 'album_menu_btn') and button == self.album_menu_btn:
                    button.setToolTip("Select Album")
                elif hasattr(self, 'track_menu_btn') and button == self.track_menu_btn:
                    button.setToolTip("Select Track")
        except Exception as e:
            # Silently fail - tooltip is not critical
            logger.debug(f"_update_button_tooltip: Error updating tooltip: {e}")
    
    def _on_prev_album(self):
        """Handle previous album button click."""
        if self.parent_window and hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
            self.parent_window.playlist_sidebar.load_previous_album()
    
    def _on_prev_track(self):
        """Handle previous track button click."""
        if self.parent_window:
            self.parent_window._trigger_previous_track()
    
    def _on_play_pause(self):
        """Handle play/pause button click."""
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        # Get saved track number if available (for resuming playback on the same track)
        saved_track_number = None
        if self.parent_window and hasattr(self.parent_window, 'settings'):
            saved_track_number = self.parent_window.settings.get("last_played_track_number")
            if saved_track_number is not None:
                try:
                    saved_track_number = int(saved_track_number)
                except (ValueError, TypeError):
                    saved_track_number = None
        
        # Toggle play/pause via JavaScript with support for loading saved track or first track if needed
        js_code = f"""
        (function() {{
            var audio = document.querySelector('audio');
            
            // If audio exists and is ready, toggle play/pause
            if (audio && audio.readyState >= 2) {{  // HAVE_CURRENT_DATA or higher
                if (audio.paused) {{
                    var playPromise = audio.play();
                    if (playPromise !== undefined) {{
                        playPromise.catch(function(error) {{
                            console.log('Bandcamp Player: audio.play() failed, trying fallback:', error);
                            // Fallback to clicking play button
                            var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                            if (playBtn) {{
                                playBtn.click();
                            }}
                        }});
                    }}
                }} else {{
                    audio.pause();
                }}
                return;
            }}
            
            // If audio exists but not ready, try clicking play button
            if (audio) {{
                var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                if (playBtn) {{
                    playBtn.click();
                    return;
                }}
            }}
            
            // No audio or play button found - need to load track
            // Check if this is a single track page
            var isSingleTrackPage = window.location.href.indexOf('/track/') !== -1;
            var player = document.querySelector('#player');
            
            if (isSingleTrackPage && player) {{
                // For singles, try to find and click the play button directly
                var playBtn = player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"], button[aria-label*="play"], button[aria-label*="Play"]');
                if (playBtn && playBtn.offsetParent !== null) {{
                    playBtn.click();
                    return;
                }}
            }}
            
            // For albums, try clicking the saved track number or first track
            // Use a function with retry logic to wait for tracklist to be ready
            function loadTrackWithRetry(retryCount) {{
                retryCount = retryCount || 0;
                var maxRetries = 10;
                var retryDelay = 100;
                
                var tracklist = document.querySelector('#tracklist');
                if (!tracklist && retryCount < maxRetries) {{
                    // Tracklist not ready yet, retry
                    setTimeout(function() {{
                        loadTrackWithRetry(retryCount + 1);
                    }}, retryDelay);
                    return;
                }}
                
                if (!tracklist) {{
                    // Tracklist not found after retries, use fallback
                    var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                    if (playBtn) {{
                        playBtn.click();
                    }}
                    return;
                }}
                
                var targetTrack = null;
                var savedTrackNum = {saved_track_number if saved_track_number is not None else 'null'};
                
                // Try to find saved track number first (if available)
                if (savedTrackNum !== null && savedTrackNum > 0) {{
                    targetTrack = tracklist.querySelector('li.track[data-num="' + savedTrackNum + '"]');
                    // If saved track not found or not playable, fall back to first track
                    if (targetTrack) {{
                        var isPlayable = targetTrack.classList.contains('playable') || 
                                        targetTrack.classList.contains('has-audio') ||
                                        targetTrack.querySelector('.info') !== null;
                        if (!isPlayable) {{
                            targetTrack = null;
                        }}
                    }}
                }}
                
                // If no saved track or saved track not found, use first track
                if (!targetTrack) {{
                    // Find first track - try data-num="1" first, then fall back to first .track element
                    targetTrack = tracklist.querySelector('li.track[data-num="1"]');
                    if (!targetTrack) {{
                        // Fallback: get first track element
                        var tracks = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                        if (tracks.length > 0) {{
                            targetTrack = tracks[0];
                        }}
                    }}
                }}
                
                if (targetTrack) {{
                    var infoDiv = targetTrack.querySelector('.info');
                    
                    // Step 1: Click target track to load it
                    if (infoDiv) {{
                        infoDiv.click();
                    }} else {{
                        targetTrack.click();
                    }}
                    
                    // Step 2: Wait for track to load, then try to play
                    setTimeout(function() {{
                        var audioElement = document.querySelector('audio');
                        if (audioElement) {{
                            var playPromise = audioElement.play();
                            if (playPromise !== undefined) {{
                                playPromise.catch(function(error) {{
                                    // Fallback: try play button
                                    var player = document.querySelector('#player');
                                    var playBtn = player ? player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]') : null;
                                    if (playBtn && playBtn.offsetParent !== null) {{
                                        playBtn.click();
                                    }}
                                }});
                            }}
                        }} else {{
                            // Audio not found yet, try play button
                            var player = document.querySelector('#player');
                            var playBtn = player ? player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]') : null;
                            if (playBtn && playBtn.offsetParent !== null) {{
                                playBtn.click();
                            }}
                        }}
                    }}, 800); // Wait 800ms for track to load
                    return;
                }} else {{
                    // No track found, use fallback
                    var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                    if (playBtn) {{
                        playBtn.click();
                    }}
                }}
            }}
            
            // Start loading track with retry
            loadTrackWithRetry();
            
            // Final fallback: try to find any play button
            var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
            if (playBtn) {{
                playBtn.click();
            }}
        }})();
        """
        self.parent_window.web_view.page().runJavaScript(js_code)
    
    def _on_next_track(self):
        """Handle next track button click."""
        if self.parent_window:
            self.parent_window._trigger_next_track()
    
    def _on_next_album(self):
        """Handle next album button click."""
        if self.parent_window and hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
            self.parent_window.playlist_sidebar.load_next_album()
    
    def _on_shuffle(self):
        """Handle shuffle button toggle - uses centralized PlayerWindow method."""
        if self.parent_window and hasattr(self.parent_window, 'toggle_shuffle'):
            self.parent_window.toggle_shuffle()
    
    def _on_repeat(self):
        """Handle repeat button toggle - uses centralized PlayerWindow method."""
        if self.parent_window and hasattr(self.parent_window, 'toggle_repeat'):
            self.parent_window.toggle_repeat()
    
    def _on_volume_click(self):
        """Handle volume button click - show volume popup."""
        if self.parent_window:
            self.parent_window.show_volume_control(auto_hide=True, delay_ms=1200)
    
    def _show_track_menu(self):
        """Show track menu with tracks from current album (read-only, double-click to play)."""
        # Create a dialog-based menu (like playlist) for resizable list
        if not hasattr(self, '_track_menu_dialog') or not self._track_menu_dialog:
            self._track_menu_dialog = QDialog(self)
            self._track_menu_dialog.setWindowTitle("Tracks")
            self._track_menu_dialog.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Popup)
            self._track_menu_dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    border: 1px solid #4a90e2;
                    border-top: 1px solid #4a90e2;
                    border-right: 1px solid #4a90e2;
                    border-bottom: 1px solid #4a90e2;
                    border-left: 1px solid #4a90e2;
                }
            """)
            
            layout = QVBoxLayout(self._track_menu_dialog)
            layout.setContentsMargins(1, 1, 1, 1)  # 1px margin to account for border
            layout.setSpacing(0)
            
            # List widget for tracks (read-only)
            self._track_list = QListWidget()
            self._track_list.setStyleSheet("""
                QListWidget {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: none;
                    font-size: 11px;
                }
                QListWidget::item {
                    padding: 2px 8px;
                    border: none;
                }
                QListWidget::item:selected {
                    background-color: #4a90e2;
                    color: #ffffff;
                }
                QListWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """)
            # Use NoSelection mode - we handle highlighting via custom delegate (blue text for current track)
            self._track_list.setSelectionMode(QListWidget.SelectionMode.NoSelection)
            self._track_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # Hide horizontal scrollbar
            # Enable mouse tracking for hover state detection
            self._track_list.setMouseTracking(True)
            # Enable tooltips
            self._track_list.setToolTipDuration(3000)  # Show tooltips for 3 seconds
            self._track_list.itemClicked.connect(self._on_track_clicked)
            
            # Use TracklistDelegate for two-column layout (title on left, duration on right)
            track_delegate = TracklistDelegate()
            self._track_list.setItemDelegate(track_delegate)
            
            # Set minimum/maximum constraints (actual height will be calculated based on items)
            self._track_list.setMinimumHeight(100)
            self._track_list.setMaximumHeight(600)
            # Don't set fixed height here - will be calculated based on items
            
            # Make dialog resizable
            self._track_menu_dialog.setMinimumSize(200, 100)
            self._track_menu_dialog.setMaximumSize(400, 600)
            # Don't set initial size here - will be calculated based on items
            
            layout.addWidget(self._track_list)
            
            # Track resize events to save height (allow list to resize with dialog)
            def on_track_menu_resize(event):
                if self._track_menu_dialog and self._track_list:
                    new_height = self._track_menu_dialog.height()
                    # Update list height to match dialog (resize, not fixed)
                    self._track_list.resize(self._track_list.width(), new_height - 2)  # Account for borders
                    if self.parent_window:
                        self.parent_window.settings['nano_track_menu_height'] = new_height
                        self.parent_window.save_settings()
                super(QDialog, self._track_menu_dialog).resizeEvent(event)
            
            self._track_menu_dialog.resizeEvent = on_track_menu_resize
        
        # Populate tracks
        self._track_list.clear()
        
        if self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            js_code = """
            (function() {
                // Helper function to clean track title - removes time patterns, lyrics text, and extra whitespace
                function cleanTrackTitle(text) {
                    if (!text) return '';
                    // Remove all time patterns (not just at end) - matches patterns like "00:00", "03:33", "00:00 03:33"
                    // Pattern: optional whitespace, digits, colon, digits, optional colon and digits, optional whitespace
                    text = text.replace(/\\s*\\d{1,2}:\\d{2}(?::\\d{2})?\\s*/g, ' ');
                    // Remove "lyrics" text (case-insensitive) - can appear anywhere
                    text = text.replace(/\\s*lyrics\\s*/gi, ' ');
                    // Remove any leading/trailing numbers with periods (like "01. " or "1. ")
                    text = text.replace(/^\\d+\\.\\s*/, '');
                    // Clean up multiple spaces and trim
                    text = text.replace(/\\s+/g, ' ').trim();
                    return text;
                }
                
                var tracks = [];
                // Use the same method as autoplay - find tracks via #tracklist
                var tracklist = document.querySelector('#tracklist');
                if (tracklist) {
                    // Get all tracks - same selectors as autoplay uses
                    var trackElements = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                    
                    trackElements.forEach(function(trackEl, index) {
                        // Get track number from data-num attribute if available
                        var trackNum = trackEl.getAttribute('data-num');
                        var trackIndex = trackNum ? parseInt(trackNum) - 1 : index; // data-num is 1-based
                        
                        // Get track title - look for .info div first (same as autoplay clicks)
                        var infoDiv = trackEl.querySelector('.info');
                        var title = null;
                        
                        if (infoDiv) {
                            // Get title from .info div - look for title span or text
                            var titleSpan = infoDiv.querySelector('.title, span.title, a.title');
                            if (titleSpan) {
                                title = titleSpan.textContent.trim();
                                title = cleanTrackTitle(title);
                            } else {
                                // Get text from info div, but exclude time/duration
                                var infoText = infoDiv.textContent.trim();
                                title = cleanTrackTitle(infoText);
                            }
                        }
                        
                        // Fallback: look for .track-title or similar
                        if (!title || title.length === 0) {
                            var titleEl = trackEl.querySelector('.track-title, .track_title, .title');
                            if (titleEl) {
                                title = titleEl.textContent.trim();
                                title = cleanTrackTitle(title);
                            }
                        }
                        
                        // Fallback: get text from track element, clean it up
                        if (!title || title.length === 0) {
                            var clone = trackEl.cloneNode(true);
                            var playBtn = clone.querySelector('.playbutton, button');
                            if (playBtn) playBtn.remove();
                            // Remove time elements if they exist
                            var timeEls = clone.querySelectorAll('.time, .duration, [class*="time"], [class*="duration"]');
                            timeEls.forEach(function(el) { el.remove(); });
                            title = clone.textContent.trim();
                            title = cleanTrackTitle(title);
                        }
                        
                        // Final fallback
                        if (!title || title.length === 0) {
                            title = 'Track ' + (trackIndex + 1);
                        }
                        
                        // Check if track is playable
                        var isPlayable = false;
                        var playStatus = trackEl.querySelector('.play_status');
                        if (!playStatus) {
                            var playCol = trackEl.querySelector('td.play-col, .play-col');
                            if (playCol) {
                                playStatus = playCol.querySelector('.play_status');
                            }
                        }
                        if (playStatus) {
                            isPlayable = !playStatus.classList.contains('disabled');
                        } else {
                            isPlayable = trackEl.classList.contains('playable') || trackEl.classList.contains('has-audio');
                        }
                        
                        // Get duration if available - specifically look for .duration class element
                        var duration = null;
                        // First try to find the .duration element specifically (as user mentioned)
                        var durationEl = trackEl.querySelector('time.duration, .duration');
                        if (durationEl) {
                            var timeText = durationEl.textContent.trim();
                            // Only use if it looks like a time (contains colon or is a short number)
                            if (timeText.indexOf(':') !== -1 || (timeText.length <= 10 && /^[\d:\.]+$/.test(timeText))) {
                                duration = timeText;
                            }
                        }
                        // Fallback: look for other time elements if .duration not found
                        if (!duration) {
                            var timeEl = trackEl.querySelector('.time:not(.duration), .track-length, [class*="time"]:not([class*="title"]):not(.duration)');
                            if (timeEl) {
                                var timeText = timeEl.textContent.trim();
                                // Only use if it looks like a time (contains colon or is a short number)
                                if (timeText.indexOf(':') !== -1 || (timeText.length <= 10 && /^[\d:\.]+$/.test(timeText))) {
                                    duration = timeText;
                                }
                            }
                        }
                        
                        tracks.push({
                            index: trackIndex,
                            title: title,
                            dataNum: trackNum,
                            isPlayable: isPlayable,
                            duration: duration
                        });
                    });
                }
                return tracks;
            })();
            """
            def on_tracks_received(result):
                if result and isinstance(result, list):
                    self._track_data = {}  # Store track index mapping
                    for track_info in result:
                        track_index = track_info.get('index', 0)
                        track_title = track_info.get('title', 'Track')
                        data_num = track_info.get('dataNum')
                        is_playable = track_info.get('isPlayable', True)
                        duration = track_info.get('duration', '')
                        
                        # Format display text: "01. Track Name" (zero-padded track number with period)
                        # Use data_num if available (1-based), otherwise use track_index + 1
                        if data_num:
                            track_num = int(data_num)
                        else:
                            track_num = track_index + 1  # Convert 0-based index to 1-based
                        
                        # Validate duration - only use if it looks like a time
                        validated_duration = None
                        if duration:
                            # Check if duration looks like a time (e.g., "3:45" or "12:34:56") or is a short number
                            is_valid_duration = (':' in duration) or (len(duration) <= 10 and duration.replace('.', '').replace(':', '').isdigit())
                            if is_valid_duration and track_title.lower() not in duration.lower():
                                validated_duration = duration
                        
                        # Display text is just the track number and title (duration will be shown in right column by delegate)
                        display_text = f"{track_num:02d}. {track_title}"
                        
                        item = QListWidgetItem(display_text)
                        # Store duration and full title in track_data so delegate can access it
                        track_data = {'index': track_index, 'dataNum': data_num, 'isPlayable': is_playable, 'duration': validated_duration, 'fullTitle': track_title}
                        item.setData(Qt.ItemDataRole.UserRole, track_data)
                        # Initialize current marker to False (don't highlight by default)
                        item.setData(Qt.ItemDataRole.UserRole + 1, False)
                        
                        # Grey out unplayable tracks
                        if not is_playable:
                            item.setForeground(QColor("#888888"))
                            item.setFlags(item.flags() & ~Qt.ItemFlag.ItemIsEnabled)
                        
                        self._track_list.addItem(item)
                        self._track_data[track_index] = track_title
                    
                    # Clear any default selection (Qt may auto-select first item)
                    self._track_list.clearSelection()
                    self._track_list.setCurrentItem(None)
                    
                    # Highlight current track after items are added (only if we have current track info)
                    if self._current_track_number is not None:
                        self._highlight_current_track()
                    
                    # Calculate ideal height based on number of items
                    item_count = len(result)
                    if item_count > 0:
                        # Force layout update to ensure items are rendered
                        self._track_list.updateGeometry()
                        QApplication.processEvents()
                        
                        # Calculate actual item height from the first item if available
                        if self._track_list.item(0):
                            # Get the visual item height (size hint)
                            item_height = self._track_list.sizeHintForRow(0)
                            if item_height <= 0:
                                # Fallback: estimate item height: padding (4px top + 4px bottom) + font height (~11px) = ~19px per item
                                item_height = 19
                        else:
                            # Fallback: estimate item height
                            item_height = 19
                        # Add 2px for borders
                        ideal_height = item_count * item_height + 2
                        
                        # Get screen/viewport bounds
                        btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
                        # Get screen containing the main window (not just primary screen)
                        screen = None
                        if self.parent_window:
                            screen = self.parent_window.screen()
                        if not screen:
                            screen = QApplication.primaryScreen()
                        if screen:
                            screen_geometry = screen.availableGeometry()
                            # Calculate max available height based on button position
                            # Try upward first (above button)
                            space_above = btn_pos.y() - screen_geometry.top()
                            # Try downward (below button)
                            space_below = screen_geometry.bottom() - btn_pos.y()
                            # Use the larger space, but be more generous with margins (only -5px instead of -10px)
                            # This allows the menu to grow larger to show more items
                            max_available_height = min(max(space_above, space_below) - 5, 600)  # -5 for minimal margins
                            
                            # Set height to fit items - prioritize showing all items
                            # Use ideal height if it fits in viewport, otherwise use max available
                            if ideal_height <= max_available_height:
                                # All items fit - use ideal height
                                dialog_height = ideal_height
                            else:
                                # Too many items - use max available (but still try to show as many as possible)
                                dialog_height = max_available_height
                            # Cap at maximum height (600) and ensure minimum height (100)
                            dialog_height = min(dialog_height, 600)
                            dialog_height = max(dialog_height, 100)
                            
                            # Update dialog and list heights
                            self._track_menu_dialog.resize(250, dialog_height)
                            # Set height but allow resizing (use resize instead of setFixedHeight)
                            self._track_list.resize(self._track_list.width(), dialog_height - 2)  # Account for borders
                            
                            # Check if opening upward would go off screen
                            if btn_pos.y() - dialog_height < screen_geometry.top():
                                # Not enough room above - open downward
                                dialog_y = btn_pos.y() + 2
                            else:
                                # Open upward (above button)
                                dialog_y = btn_pos.y() - dialog_height - 2
                            self._track_menu_dialog.move(btn_pos.x(), dialog_y)
                        else:
                            # Fallback: use ideal height or max
                            dialog_height = min(ideal_height, 600)
                            dialog_height = max(dialog_height, 100)
                            self._track_menu_dialog.resize(250, dialog_height)
                            self._track_list.setFixedHeight(dialog_height - 2)
                            self._track_menu_dialog.move(btn_pos.x(), btn_pos.y() - dialog_height - 2)
                    else:
                        # No tracks - use default height
                        btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
                        self._track_menu_dialog.move(btn_pos.x(), btn_pos.y() - self._track_menu_dialog.height() - 2)
                    
                    self._track_menu_dialog.exec()
                else:
                    # No tracks found
                    item = QListWidgetItem("No tracks available")
                    item.setFlags(Qt.ItemFlag.NoItemFlags)
                    self._track_list.addItem(item)
                    btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
                    self._track_menu_dialog.move(btn_pos.x(), btn_pos.y() + 2)
                    self._track_menu_dialog.exec()
            
            self.parent_window.web_view.page().runJavaScript(js_code, on_tracks_received)
        else:
            item = QListWidgetItem("No tracks available")
            item.setFlags(Qt.ItemFlag.NoItemFlags)
            self._track_list.addItem(item)
            # Show dialog - open upward by default, downward if near top of screen
            btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
            # Get screen containing the main window (not just primary screen)
            screen = None
            if self.parent_window:
                screen = self.parent_window.screen()
            if not screen:
                screen = QApplication.primaryScreen()
            if screen:
                screen_geometry = screen.availableGeometry()
                dialog_height = self._track_menu_dialog.height()
                # Check if opening upward would go off screen
                if btn_pos.y() - dialog_height < screen_geometry.top():
                    # Not enough room above - open downward
                    dialog_y = btn_pos.y() + 2
                else:
                    # Open upward (above button)
                    dialog_y = btn_pos.y() - dialog_height - 2
                self._track_menu_dialog.move(btn_pos.x(), dialog_y)
            else:
                # Fallback: open upward
                self._track_menu_dialog.move(btn_pos.x(), btn_pos.y() - self._track_menu_dialog.height() - 2)
            self._track_menu_dialog.exec()
    
    def _on_track_clicked(self, item):
        """Handle track click - play the selected track using same method as autoplay."""
        track_data = item.data(Qt.ItemDataRole.UserRole)
        if track_data is not None and self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            # Get track index and data-num if available
            track_index = track_data if isinstance(track_data, int) else track_data.get('index', 0)
            data_num = track_data.get('dataNum') if isinstance(track_data, dict) else None
            
            # Use the same method as autoplay - find track via #tracklist and click .info div
            if data_num:
                # Use data-num attribute to find the track (more reliable)
                js_code = f"""
                (function() {{
                    var tracklist = document.querySelector('#tracklist');
                    if (tracklist) {{
                        // Find track by data-num attribute (same as autoplay)
                        var trackEl = tracklist.querySelector('li.track[data-num="{data_num}"]');
                        if (!trackEl) {{
                            // Fallback: get by index
                            var tracks = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                            if (tracks.length > {track_index}) {{
                                trackEl = tracks[{track_index}];
                            }}
                        }}
                        
                        if (trackEl) {{
                            // Use same method as autoplay - click .info div first
                            var infoDiv = trackEl.querySelector('.info');
                            if (infoDiv) {{
                                console.log('Bandcamp Player: Clicking track .info div (track {track_index + 1})');
                                infoDiv.click();
                            }} else {{
                                console.log('Bandcamp Player: Clicking track element (track {track_index + 1})');
                                trackEl.click();
                            }}
                        }}
                    }}
                }})();
                """
            else:
                # Fallback: use index
                js_code = f"""
                (function() {{
                    var tracklist = document.querySelector('#tracklist');
                    if (tracklist) {{
                        var tracks = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                        if (tracks.length > {track_index}) {{
                            var trackEl = tracks[{track_index}];
                            // Use same method as autoplay - click .info div first
                            var infoDiv = trackEl.querySelector('.info');
                            if (infoDiv) {{
                                console.log('Bandcamp Player: Clicking track .info div (track {track_index + 1})');
                                infoDiv.click();
                            }} else {{
                                console.log('Bandcamp Player: Clicking track element (track {track_index + 1})');
                                trackEl.click();
                            }}
                        }}
                    }}
                }})();
                """
            self.parent_window.web_view.page().runJavaScript(js_code)
            self._track_menu_dialog.close()
    
    def _show_album_context_menu(self, position):
        """Show playlist menu on right-click of album button."""
        if not self.parent_window or not hasattr(self.parent_window, 'playlist_sidebar') or not self.parent_window.playlist_sidebar:
            return
        
        # Access playlist sidebar methods
        playlist_sidebar = self.parent_window.playlist_sidebar
        
        # Create menu using the same method as playlist sidebar
        menu = QMenu(self)
        
        # Apply dark theme styling to match the rest of the app
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        
        # Show currently loaded playlist at the top (inactive, blue text)
        current_playlist_name = self.parent_window.playlist_manager.get_current_playlist_name()
        
        # Use QWidgetAction to create a styled label
        current_playlist_widget = QWidget()
        current_playlist_layout = QHBoxLayout(current_playlist_widget)
        current_playlist_layout.setContentsMargins(20, 6, 20, 6)
        current_playlist_label = QLabel(f"Current: {current_playlist_name}")
        current_playlist_label.setStyleSheet("color: #4a90e2; font-weight: normal;")
        current_playlist_layout.addWidget(current_playlist_label)
        
        current_playlist_action = QWidgetAction(self)
        current_playlist_action.setDefaultWidget(current_playlist_widget)
        current_playlist_action.setEnabled(False)
        menu.addAction(current_playlist_action)
        
        menu.addSeparator()
        
        # Save Playlist (updates current)
        save_action = QAction("Save Playlist", self)
        if HAS_QT_AWESOME:
            icon = get_icon('save', color='#e0e0e0')
            if icon:
                save_action.setIcon(icon)
        else:
            save_action.setText(" Save Playlist")
        save_action.triggered.connect(playlist_sidebar.save_current_playlist)
        menu.addAction(save_action)
        
        # Save Playlist As...
        save_as_action = QAction("Save Playlist As...", self)
        if HAS_QT_AWESOME:
            icon = get_icon('save', color='#e0e0e0')
            if icon:
                save_as_action.setIcon(icon)
        else:
            save_as_action.setText(" Save As...")
        save_as_action.triggered.connect(playlist_sidebar.save_playlist_as)
        menu.addAction(save_as_action)
        
        menu.addSeparator()
        
        # Load Playlist (submenu with available playlists)
        load_menu = QMenu("Load Playlist", self)
        load_menu.setStyleSheet(menu.styleSheet())
        
        # Get list of available playlists
        playlists = self.parent_window.playlist_manager.list_playlist_files()
        current_playlist_name = self.parent_window.playlist_manager.get_current_playlist_name()
        
        if playlists:
            for playlist_info in playlists:
                playlist_name = playlist_info["name"]
                playlist_file = playlist_info["file"]
                
                # Create action for this playlist
                playlist_action = QAction(playlist_name, self)
                # Mark current playlist with checkmark
                if playlist_name == current_playlist_name:
                    playlist_action.setText(f" {playlist_name}")
                    playlist_action.setEnabled(False)  # Disable current playlist
                playlist_action.triggered.connect(
                    lambda checked, file=playlist_file: playlist_sidebar.load_playlist_from_file(str(file))
                )
                load_menu.addAction(playlist_action)
        
        # Also check for old lowercase "default.json" and offer to migrate it
        old_default_file = self.parent_window.playlist_manager.playlists_dir / "default.json"
        if old_default_file.exists():
            # Check if Default.json already exists
            default_file = self.parent_window.playlist_manager.playlists_dir / "Default.json"
            if not default_file.exists():
                # Offer to migrate
                migrate_action = QAction("default (migrate to Default)", self)
                migrate_action.triggered.connect(
                    lambda: playlist_sidebar.migrate_default_playlist()
                )
                load_menu.addAction(migrate_action)
        else:
            # No playlists found
            no_playlists_action = QAction("No playlists found", self)
            no_playlists_action.setEnabled(False)
            load_menu.addAction(no_playlists_action)
        
        # Add Load Playlist submenu
        load_action = menu.addMenu(load_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('folder-open', color='#e0e0e0')
            if icon:
                load_action.setIcon(icon)
        else:
            load_action.setText(" Load Playlist")
        
        # Delete Playlist (submenu with available playlists)
        delete_menu = QMenu("Delete Playlist", self)
        delete_menu.setStyleSheet(menu.styleSheet())
        
        # Get list of available playlists
        playlists = self.parent_window.playlist_manager.list_playlist_files()
        current_playlist_name = self.parent_window.playlist_manager.get_current_playlist_name()
        
        if playlists:
            for playlist_info in playlists:
                playlist_name = playlist_info["name"]
                playlist_file = playlist_info["file"]
                
                # Create action for this playlist
                playlist_action = QAction(playlist_name, self)
                # Disable if it's the only playlist (can't delete the last playlist)
                if len(playlists) == 1:
                    playlist_action.setEnabled(False)
                    playlist_action.setText(f"{playlist_name} (cannot delete only playlist)")
                playlist_action.triggered.connect(
                    lambda checked, name=playlist_name: playlist_sidebar.delete_playlist(name)
                )
                delete_menu.addAction(playlist_action)
        else:
            # No playlists found
            no_playlists_action = QAction("No playlists found", self)
            no_playlists_action.setEnabled(False)
            delete_menu.addAction(no_playlists_action)
        
        # Add Delete Playlist submenu
        delete_action = menu.addMenu(delete_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('trash', color='#e0e0e0')
            if icon:
                delete_action.setIcon(icon)
        else:
            delete_action.setText(" Delete Playlist")
        
        menu.addSeparator()
        
        # Export Playlist URLs
        export_action = QAction("Export Playlist URLs", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file-export', color='#e0e0e0')
            if icon:
                export_action.setIcon(icon)
        else:
            export_action.setText(" Export Playlist URLs")
        export_action.triggered.connect(playlist_sidebar.export_playlist_urls)
        menu.addAction(export_action)
        
        # Import Playlist URLs
        import_action = QAction("Import Playlist URLs", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file-import', color='#e0e0e0')
            if icon:
                import_action.setIcon(icon)
        else:
            import_action.setText(" Import Playlist URLs")
        import_action.triggered.connect(playlist_sidebar.import_playlist_urls)
        menu.addAction(import_action)
        
        menu.addSeparator()
        
        # Clear Playlist
        clear_action = QAction("Clear Playlist", self)
        if HAS_QT_AWESOME:
            icon = get_icon('trash', color='#e0e0e0')
            if icon:
                clear_action.setIcon(icon)
        else:
            clear_action.setText(" Clear Playlist")
        clear_action.triggered.connect(playlist_sidebar.clear_playlist)
        menu.addAction(clear_action)
        
        menu.addSeparator()
        
        # Close Menu
        close_menu_action = QAction("Close Menu", self)
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_menu_action.setIcon(icon)
        else:
            close_menu_action.setText(" Close Menu")
        close_menu_action.triggered.connect(lambda: menu.close())
        menu.addAction(close_menu_action)
        
        # Show menu at button position
        global_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().bottomLeft())
        menu.exec(global_pos)
    
    def _show_album_menu(self):
        """Show album menu with playlist contents (full features: rearrange, delete, drag, double-click to load)."""
        # Create a dialog-based menu (like playlist) for resizable list with full features
        if not hasattr(self, '_album_menu_dialog') or not self._album_menu_dialog:
            self._album_menu_dialog = QDialog(self)
            self._album_menu_dialog.setWindowTitle("Playlist")
            self._album_menu_dialog.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Popup)
            self._album_menu_dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    border: 1px solid #4a90e2;
                    border-top: 1px solid #4a90e2;
                    border-right: 1px solid #4a90e2;
                    border-bottom: 1px solid #4a90e2;
                    border-left: 1px solid #4a90e2;
                }
            """)
            
            layout = QVBoxLayout(self._album_menu_dialog)
            layout.setContentsMargins(1, 1, 1, 1)  # 1px margin to account for border
            layout.setSpacing(0)
            
            # List widget for playlist (full features)
            self._album_list = QListWidget()
            
            # Apply Windows 11 detection for consistent spacing
            is_windows_11 = RegularPlayerWidget._detect_windows_11()
            if is_windows_11:
                item_padding = "0px 8px"
                item_min_height = "min-height: 18px;"
            else:
                item_padding = "2px 8px"
                item_min_height = ""
            
            album_stylesheet = """
                QListWidget {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: none;
                    font-size: 11px;
                }
                QListWidget::item {
                    padding: """ + item_padding + """;
                    border: none;
                    """ + item_min_height + """
                }
                QListWidget::item:selected {
                    background-color: #4a90e2;
                    color: #ffffff;
                }
                QListWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """
            self._album_list.setStyleSheet(album_stylesheet)
            self._album_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
            self._album_list.setDragDropMode(QListWidget.DragDropMode.InternalMove)
            self._album_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # Hide horizontal scrollbar
            # Enable mouse tracking for hover state detection and tooltips
            self._album_list.setMouseTracking(True)
            # Enable tooltips
            self._album_list.setToolTipDuration(3000)  # Show tooltips for 3 seconds
            self._album_list.itemClicked.connect(self._on_album_clicked)
            
            # Set custom delegate for highlighting current album (blue text, no background)
            album_delegate = NanoMenuDelegate()
            self._album_list.setItemDelegate(album_delegate)
            
            # Disable drag and drop in albumlist menu to allow tooltips to work properly
            # (Drag and drop is still available in the playlist sidebar)
            self._album_list.setAcceptDrops(False)
            self._album_list.setDragDropMode(QListWidget.DragDropMode.NoDragDrop)
            
            # Override drag/drop events to handle URLs
            original_drag_enter = self._album_list.dragEnterEvent
            original_drop = self._album_list.dropEvent
            
            def drag_enter_event(event):
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                else:
                    if original_drag_enter:
                        original_drag_enter(event)
            
            def drop_event(event):
                if event.mimeData().hasUrls():
                    urls = event.mimeData().urls()
                    for url in urls:
                        url_str = url.toString()
                        if 'bandcamp.com' in url_str.lower() and self.parent_window:
                            if hasattr(self.parent_window, 'playlist_manager'):
                                self.parent_window.playlist_manager.add_url(url_str)
                                # Add to list - get display text and convert to "Album by Artist" format
                                display_text = self.parent_window.playlist_manager.get_url_display_text(url_str)
                                if not display_text and hasattr(self.parent_window, 'extract_artist_album_from_url'):
                                    extracted = self.parent_window.extract_artist_album_from_url(url_str)
                                    if extracted:
                                        # Convert "Artist - Album" to "Album by Artist" format
                                        if ' - ' in extracted:
                                            parts = extracted.split(' - ', 1)
                                            if len(parts) == 2:
                                                artist = parts[0].strip()
                                                album = parts[1].strip()
                                                display_text = f"{album} by {artist}"
                                            else:
                                                display_text = extracted
                                        else:
                                            display_text = extracted
                                if not display_text:
                                    display_text = url_str.split('/')[-1] if '/' in url_str else url_str
                                    # Remove query parameters for cleaner display
                                    if '?' in display_text:
                                        display_text = display_text.split('?')[0]
                                item = QListWidgetItem(display_text)
                                item.setData(Qt.ItemDataRole.UserRole, url_str)
                                self._album_list.addItem(item)
                    event.acceptProposedAction()
                elif event.mimeData().hasText():
                    text = event.mimeData().text().strip()
                    lines = [line.strip() for line in text.split('\n') if line.strip()]
                    for line in lines:
                        if 'bandcamp.com' in line.lower() and self.parent_window:
                            if hasattr(self.parent_window, 'playlist_manager'):
                                self.parent_window.playlist_manager.add_url(line)
                                # Add to list - get display text and convert to "Album by Artist" format
                                display_text = self.parent_window.playlist_manager.get_url_display_text(line)
                                if not display_text and hasattr(self.parent_window, 'extract_artist_album_from_url'):
                                    extracted = self.parent_window.extract_artist_album_from_url(line)
                                    if extracted:
                                        # Convert "Artist - Album" to "Album by Artist" format
                                        if ' - ' in extracted:
                                            parts = extracted.split(' - ', 1)
                                            if len(parts) == 2:
                                                artist = parts[0].strip()
                                                album = parts[1].strip()
                                                display_text = f"{album} by {artist}"
                                            else:
                                                display_text = extracted
                                        else:
                                            display_text = extracted
                                if not display_text:
                                    display_text = line.split('/')[-1] if '/' in line else line
                                    # Remove query parameters for cleaner display
                                    if '?' in display_text:
                                        display_text = display_text.split('?')[0]
                                item = QListWidgetItem(display_text)
                                item.setData(Qt.ItemDataRole.UserRole, line)
                                self._album_list.addItem(item)
                    event.acceptProposedAction()
                else:
                    if original_drop:
                        original_drop(event)
            
            self._album_list.dragEnterEvent = drag_enter_event
            self._album_list.dropEvent = drop_event
            
            # Set minimum/maximum constraints (actual height will be calculated based on items)
            self._album_list.setMinimumHeight(100)
            self._album_list.setMaximumHeight(600)
            # Don't set fixed height here - will be calculated based on items
            
            # Make dialog resizable
            self._album_menu_dialog.setMinimumSize(200, 100)
            self._album_menu_dialog.setMaximumSize(400, 600)
            # Don't set initial size here - will be calculated based on items
            
            layout.addWidget(self._album_list)
            
            # Connect signals for reordering
            self._album_list.model().rowsMoved.connect(self._on_playlist_reordered)
            
            # Enable delete key
            self._album_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self._album_list.customContextMenuRequested.connect(self._show_album_list_context_menu)
            
            # Track resize events to save height (allow list to resize with dialog)
            def on_album_menu_resize(event):
                if self._album_menu_dialog and self._album_list:
                    new_height = self._album_menu_dialog.height()
                    # Update list height to match dialog (resize, not fixed)
                    self._album_list.resize(self._album_list.width(), new_height - 2)  # Account for borders
                    if self.parent_window:
                        self.parent_window.settings['nano_album_menu_height'] = new_height
                        self.parent_window.save_settings()
                super(QDialog, self._album_menu_dialog).resizeEvent(event)
            
            self._album_menu_dialog.resizeEvent = on_album_menu_resize
            
            # Install event filter for delete key
            self._album_list.installEventFilter(self)
        
        # Populate playlist
        self._album_list.clear()
        
        if self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
            playlist = self.parent_window.playlist_manager.get_playlist()
            for url in playlist:
                # Use get_url_display_text which checks saved metadata first (preferred - has correct formatting from page)
                display_text = None
                if hasattr(self.parent_window.playlist_manager, 'get_url_display_text'):
                    display_text = self.parent_window.playlist_manager.get_url_display_text(url)
                
                # Fall back to URL parsing if no stored metadata
                if not display_text:
                    # Use the main window's extract_artist_album_from_url method which correctly
                    # extracts artist from subdomain and album/track from path
                    if self.parent_window and hasattr(self.parent_window, 'extract_artist_album_from_url'):
                        extracted = self.parent_window.extract_artist_album_from_url(url)
                        if extracted:
                            # extract_artist_album_from_url now returns "Album by Artist" format
                            display_text = extracted
                    
                    # Final fallback if extraction failed
                    if not display_text:
                        try:
                            from urllib.parse import urlparse
                            parsed = urlparse(url)
                            path_parts = [p for p in parsed.path.strip('/').split('/') if p]
                            if len(path_parts) >= 2 and path_parts[0] in ['album', 'track']:
                                # Format: album/album-name or track/track-name
                                # Extract artist from subdomain
                                hostname = parsed.hostname or ""
                                artist = None
                                if ".bandcamp.com" in hostname.lower():
                                    subdomain = hostname.lower().replace(".bandcamp.com", "")
                                    if "-" in subdomain:
                                        artist = " ".join(word.capitalize() for word in subdomain.split("-"))
                                    else:
                                        import re
                                        words = re.findall(r'[a-z]+|[A-Z][a-z]*', subdomain)
                                        if len(words) > 1:
                                            artist = " ".join(word.capitalize() for word in words)
                                        else:
                                            # Single word (all lowercase or no camelCase) - try to split on common word endings
                                            common_endings = ['pony', 'ponies', 'music', 'records', 'label', 'band', 'group', 'crew', 'team', 'sound', 'audio', 'tunes', 'tracks']
                                            subdomain_lower = subdomain.lower()
                                            for ending in common_endings:
                                                if subdomain_lower.endswith(ending) and len(subdomain_lower) > len(ending):
                                                    # Split before the ending
                                                    prefix = subdomain_lower[:-len(ending)]
                                                    if len(prefix) > 0:
                                                        # Capitalize both parts
                                                        artist = f"{prefix.capitalize()} {ending.capitalize()}"
                                                        break
                                            
                                            # Final fallback: just capitalize the first letter
                                            if not artist:
                                                artist = subdomain.capitalize()
                                
                                name = path_parts[1]
                                name = " ".join(word.capitalize() for word in name.split("-"))
                                if artist:
                                    # Convert to "Album by Artist" format to match regular mode
                                    display_text = f"{name} by {artist}"
                                else:
                                    display_text = name
                            elif len(path_parts) == 1:
                                display_text = path_parts[0].replace('-', ' ').title()
                            else:
                                display_text = url.split('/')[-1] if '/' in url else url
                        except Exception:
                            display_text = url.split('/')[-1] if '/' in url else url
                
                item = QListWidgetItem(display_text)
                item.setData(Qt.ItemDataRole.UserRole, url)
                # Initialize current marker to False (don't highlight by default)
                item.setData(Qt.ItemDataRole.UserRole + 1, False)
                self._album_list.addItem(item)
        
        # Clear any default selection (Qt may auto-select first item)
        self._album_list.clearSelection()
        
        # Highlight current album after items are added (match by URL)
        self._highlight_current_album()
        
        # Calculate ideal height based on number of items
        item_count = self._album_list.count()
        if item_count > 0:
            # Force layout update to ensure items are rendered
            self._album_list.updateGeometry()
            QApplication.processEvents()
            
            # Calculate actual item height from the first item if available
            if self._album_list.item(0):
                # Get the visual item height (size hint)
                item_height = self._album_list.sizeHintForRow(0)
                if item_height <= 0:
                    # Fallback: estimate item height: padding (4px top + 4px bottom) + font height (~11px) = ~19px per item
                    item_height = 19
            else:
                # Fallback: estimate item height
                item_height = 19
            # Add 2px for borders
            ideal_height = item_count * item_height + 2
            
            # Get screen/viewport bounds
            btn_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().bottomLeft())
            # Get screen containing the main window (not just primary screen)
            screen = None
            if self.parent_window:
                screen = self.parent_window.screen()
            if not screen:
                screen = QApplication.primaryScreen()
            if screen:
                screen_geometry = screen.availableGeometry()
                # Calculate max available height based on button position
                # For album list (bottom row), prioritize using maximum available space
                # Try upward first (above button) - this is usually much larger for bottom row buttons
                space_above = btn_pos.y() - screen_geometry.top()
                # Try downward (below button) - usually small for bottom row buttons
                space_below = screen_geometry.bottom() - btn_pos.y()
                # For bottom row buttons, space_above is usually much larger, so prioritize it
                # Use the larger space, with minimal margins to maximize available space
                max_available_height = min(max(space_above, space_below) - 2, 600)  # -2 for very minimal margins
                
                # Set height to fit items - prioritize showing all items
                # For album list, if ideal_height is reasonable (under 600px), use it regardless of viewport
                # This allows the menu to grow to show all items, opening upward if needed
                if ideal_height <= 600:
                    # Use ideal height to show all items (will open upward if needed)
                    dialog_height = ideal_height
                else:
                    # Too many items - use max available, but still try to maximize
                    dialog_height = max_available_height
                # Cap at maximum height (600) and ensure minimum height (100)
                dialog_height = min(dialog_height, 600)
                dialog_height = max(dialog_height, 100)
                
                # Update dialog and list heights
                self._album_menu_dialog.resize(250, dialog_height)
                # Set height but allow resizing (use resize instead of setFixedHeight)
                self._album_list.resize(self._album_list.width(), dialog_height - 2)  # Account for borders
                # Force geometry update
                self._album_menu_dialog.updateGeometry()
                self._album_list.updateGeometry()
                
                # Check if opening upward would go off screen
                if btn_pos.y() - dialog_height < screen_geometry.top():
                    # Not enough room above - open downward
                    dialog_y = btn_pos.y() + 2
                else:
                    # Open upward (above button)
                    dialog_y = btn_pos.y() - dialog_height - 2
                self._album_menu_dialog.move(btn_pos.x(), dialog_y)
            else:
                # Fallback: use ideal height or max
                dialog_height = min(ideal_height, 600)
                dialog_height = max(dialog_height, 100)
                self._album_menu_dialog.resize(250, dialog_height)
                self._album_list.setFixedHeight(dialog_height - 2)
                self._album_menu_dialog.updateGeometry()
                self._album_list.updateGeometry()
                self._album_menu_dialog.move(btn_pos.x(), btn_pos.y() - dialog_height - 2)
        else:
            # Empty playlist - use default height
            item = QListWidgetItem("Playlist is empty")
            item.setFlags(Qt.ItemFlag.NoItemFlags)
            self._album_list.addItem(item)
            btn_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().bottomLeft())
            self._album_menu_dialog.move(btn_pos.x(), btn_pos.y() - self._album_menu_dialog.height() - 2)
        
        self._album_menu_dialog.exec()
    
    def _on_playlist_reordered(self, parent, start, end, destination, row):
        """Handle playlist reordering in album menu."""
        if not self.parent_window or not hasattr(self.parent_window, 'playlist_manager'):
            return
        
        # Get new order from list widget
        new_order = []
        for i in range(self._album_list.count()):
            item = self._album_list.item(i)
            if item:
                url = item.data(Qt.ItemDataRole.UserRole)
                if url:
                    new_order.append(url)
        
        # Update playlist order
        if new_order:
            self.parent_window.playlist_manager.reorder_playlist(new_order)
    
    def _on_album_clicked(self, item):
        """Handle album click - load the selected album."""
        url = item.data(Qt.ItemDataRole.UserRole)
        if url and self.parent_window:
            self.parent_window.load_url(url)
            self._album_menu_dialog.close()
    
    def _highlight_current_track(self):
        """Highlight the currently playing track in the track list menu."""
        if not hasattr(self, '_track_list') or not self._track_list:
            return
        
        # Use stored current track number
        current_track_num = self._current_track_number
        if current_track_num is None:
            # Fallback: try to extract from button text
            track_btn_text = self.track_menu_btn.text()
            if track_btn_text and track_btn_text != "Artist - Track":
                try:
                    # Track button format is "01. Track Name" or "01. Track Name (Artist)"
                    track_num_str = track_btn_text.split('.')[0].strip()
                    current_track_num = int(track_num_str)
                except (ValueError, IndexError):
                    return
            else:
                return
        
        # Clear all items' current marker
        for i in range(self._track_list.count()):
            item = self._track_list.item(i)
            if item:
                item.setData(Qt.ItemDataRole.UserRole + 1, False)
        
        # Find and highlight the matching track
        for i in range(self._track_list.count()):
            item = self._track_list.item(i)
            if item:
                # Get track data to check track number
                track_data = item.data(Qt.ItemDataRole.UserRole)
                if track_data:
                    # Check if this item matches the current track number
                    data_num = track_data.get('dataNum') if isinstance(track_data, dict) else None
                    track_index = track_data.get('index', 0) if isinstance(track_data, dict) else track_data
                    
                    # Match by data_num (preferred) or by index
                    item_track_num = None
                    if data_num:
                        try:
                            item_track_num = int(data_num)
                        except (ValueError, TypeError):
                            pass
                    
                    if item_track_num is None:
                        # Fallback: use index + 1 (convert 0-based to 1-based)
                        item_track_num = track_index + 1
                    
                    if item_track_num == current_track_num:
                        # This is the current track - highlight it
                        item.setData(Qt.ItemDataRole.UserRole + 1, True)
                        # Scroll to make it visible
                        self._track_list.scrollToItem(item, QListWidget.ScrollHint.EnsureVisible)
                        break
    
    def _highlight_current_album(self):
        """Highlight the currently playing album in the album list menu by matching URL."""
        if not hasattr(self, '_album_list') or not self._album_list:
            return
        
        # Get current URL from parent window's web view
        current_url = None
        if self.parent_window and hasattr(self.parent_window, 'web_view') and self.parent_window.web_view:
            current_url = self.parent_window.web_view.url().toString()
        
        # Fallback: try to get from settings
        if not current_url and self.parent_window:
            current_url = self.parent_window.settings.get("last_played_url")
        
        if not current_url:
                return
        
        # Normalize URL for comparison (same logic as playlist sidebar)
        def normalize_url(u):
            if not u:
                return ""
            u = u.strip().rstrip('/')
            # Remove query parameters and fragments for comparison
            if '?' in u:
                u = u.split('?')[0]
            if '#' in u:
                u = u.split('#')[0]
            if u.startswith('http://'):
                u = 'https://' + u[7:]
            return u.lower()
        
        normalized_current_url = normalize_url(current_url)
        
        # Clear all items' current marker
        for i in range(self._album_list.count()):
            item = self._album_list.item(i)
            if item:
                item.setData(Qt.ItemDataRole.UserRole + 1, False)
        
        # Find and highlight the matching album by URL
        for i in range(self._album_list.count()):
            item = self._album_list.item(i)
            if item:
                item_url = item.data(Qt.ItemDataRole.UserRole)
                if item_url:
                    # Normalize item URL for comparison
                    normalized_item_url = normalize_url(item_url)
                    
                    # Match by normalized URL
                    if normalized_item_url == normalized_current_url:
                        # This is the current album - highlight it
                        item.setData(Qt.ItemDataRole.UserRole + 1, True)
                        # Clear selection state to prevent white outline
                        item.setSelected(False)
                        # Force repaint
                        self._album_list.update()
                        # Scroll to make it visible
                        self._album_list.scrollToItem(item, QListWidget.ScrollHint.EnsureVisible)
                        break
    
    def _on_time_label_clicked(self, event):
        """Handle time label click - cycle between display modes."""
        # Cycle between modes: 0 = elapsed/total, 1 = elapsed/remaining
        self.time_display_mode = (self.time_display_mode + 1) % 2
        
        # Save preference
        if self.parent_window:
            self.parent_window.settings['nano_time_display_mode'] = self.time_display_mode
            self.parent_window.save_settings()
        
        # Trigger immediate update to show new mode
        self._update_track_info()
    
    def _show_album_list_context_menu(self, position):
        """Show context menu for album list (delete option)."""
        item = self._album_list.itemAt(position)
        if not item:
            return
        
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
        """)
        
        delete_action = QAction("Delete", self)
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                delete_action.setIcon(icon)
        delete_action.triggered.connect(lambda: self._delete_selected_albums())
        menu.addAction(delete_action)
        
        menu.exec(self._album_list.mapToGlobal(position))
    
    def _delete_selected_albums(self):
        """Delete selected albums from playlist."""
        selected_items = self._album_list.selectedItems()
        if not selected_items:
            return
        
        for item in selected_items:
            url = item.data(Qt.ItemDataRole.UserRole)
            if url and self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
                self.parent_window.playlist_manager.remove_url(url)
            row = self._album_list.row(item)
            self._album_list.takeItem(row)
    
    def _on_album_selected(self, url):
        """Handle album selection from menu - load the selected album."""
        if self.parent_window:
            self.parent_window.load_url(url)
    
    def _on_pin_toggle(self):
        """Handle pin button toggle - toggle always on top."""
        self.nano_always_on_top = self.pin_btn.isChecked()
        if self.parent_window:
            self.parent_window.settings['nano_always_on_top'] = self.nano_always_on_top
            self.parent_window.save_settings()
        
        # Update window flags
        flags = Qt.WindowType.FramelessWindowHint | Qt.WindowType.Window
        if self.nano_always_on_top:
            flags |= Qt.WindowType.WindowStaysOnTopHint
        self.setWindowFlags(flags)
        self.show()  # Must show again after changing window flags
        
        # Update icon color (match main interface)
        if HAS_QT_AWESOME:
            icon_color = '#4a90e2' if self.nano_always_on_top else '#a0a0a0'
            icon = get_icon('thumbtack', color=icon_color)  # Match main interface
            if icon:
                self.pin_btn.setIcon(icon)
    
    def _on_restore(self):
        """Handle restore button click - restore main window."""
        logger.debug("Nano player restore button clicked")
        if self.parent_window:
            # Directly call _exit_nano_mode to ensure it's called
            # (showNormal() might not trigger changeEvent if window is hidden, not minimized)
            if hasattr(self.parent_window, '_main_window_hidden_for_nano') and self.parent_window._main_window_hidden_for_nano:
                logger.debug("Calling _exit_nano_mode from restore button")
                self.parent_window._exit_nano_mode()
            else:
                logger.debug("Not in nano mode, using showNormal() fallback")
                # Fallback: try showNormal() if not in nano mode
                self.parent_window.showNormal()
                self.parent_window.raise_()
                self.parent_window.activateWindow()
    
    def _on_progress_pressed(self):
        """Handle progress bar press - start dragging."""
        self._progress_dragging = True
    
    def _on_progress_released(self):
        """Handle progress bar release - seek to position."""
        self._progress_dragging = False
        if self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            # Get current duration and calculate seek position
            js_code = """
            (function() {
                var audio = document.querySelector('audio');
                if (audio && audio.duration) {
                    return audio.duration;
                }
                return 0;
            })();
            """
            def on_duration_received(duration):
                if duration and duration > 0:
                    # Calculate seek position from slider value (0-1000)
                    slider_value = self.progress_bar.value()
                    seek_seconds = (slider_value / 1000.0) * duration
                    # Seek to position
                    seek_js = f"""
                    (function() {{
                        var audio = document.querySelector('audio');
                        if (audio) {{
                            audio.currentTime = {seek_seconds};
                        }}
                    }})();
                    """
                    self.parent_window.web_view.page().runJavaScript(seek_js)
            
            self.parent_window.web_view.page().runJavaScript(js_code, on_duration_received)
    
    def _on_progress_changed(self, value):
        """Handle progress bar value change (only update if not dragging)."""
        # This is called during dragging, but we only seek on release
        # So we don't need to do anything here
        pass
    
    def _check_and_show_loading_animation(self):
        """Check if URL is loading and show loading animation if needed."""
        if not hasattr(self, 'cover_art_loading_widget') or not self.cover_art_loading_widget:
            return
        
        if not self.parent_window:
            return
        
        # Only show loading animation when URL is actually loading
        is_loading = getattr(self.parent_window, 'is_loading', False)
        
        # Show loading animation only when URL is actively loading
        if is_loading:
            self._show_loading_animation()
        else:
            self._hide_loading_animation()
    
    def _show_loading_animation(self):
        """Show loading animation on cover art."""
        if hasattr(self, 'cover_art_loading_widget') and self.cover_art_loading_widget:
            # Update position and size
            if hasattr(self, 'cover_art_label') and self.cover_art_label:
                self.cover_art_loading_widget.setGeometry(0, 0, self.cover_art_label.width(), self.cover_art_label.height())
            self.cover_art_loading_widget.show()
            self.cover_art_loading_widget.raise_()
    
    def _hide_loading_animation(self):
        """Hide loading animation on cover art."""
        if hasattr(self, 'cover_art_loading_widget') and self.cover_art_loading_widget:
            self.cover_art_loading_widget.hide()
    
    def _update_cover_art(self):
        """Update cover art display by fetching image URL from page."""
        if not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            return
        
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        # Show loading animation only if URL is currently loading
        # (Don't show it just for cover art updates - only during URL loading)
        if getattr(self.parent_window, 'is_loading', False):
            self._show_loading_animation()
        
        # JavaScript to get cover art image URL
        js_code = """
        (function() {
            try {
                var albumArt = document.querySelector('#tralbum-art-carousel');
                if (!albumArt) {
                    return null;
                }
                
                // Find the visible/active image
                var visibleImg = null;
                
                // Method 1: Look for active carousel item
                var activeItem = albumArt.querySelector('.carousel-item.active, [class*="active"]');
                if (activeItem) {
                    visibleImg = activeItem.querySelector('img');
                }
                
                // Method 2: Find visible image
                if (!visibleImg) {
                    var allImgs = albumArt.querySelectorAll('img');
                    for (var i = 0; i < allImgs.length; i++) {
                        var img = allImgs[i];
                        var style = window.getComputedStyle(img);
                        if (style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
                            var rect = img.getBoundingClientRect();
                            if (rect && rect.width > 0 && rect.height > 0) {
                                visibleImg = img;
                                break;
                            }
                        }
                    }
                }
                
                // Method 3: Fallback to first image
                if (!visibleImg) {
                    visibleImg = albumArt.querySelector('img');
                }
                
                if (!visibleImg) {
                    return null;
                }
                
                // Get image URL - try multiple sources
                var imgSrc = null;
                
                // Method 1: Try data-src (lazy loading)
                imgSrc = visibleImg.getAttribute('data-src') || visibleImg.getAttribute('data-lazy-src');
                
                // Method 2: Try srcset for higher resolution
                if (!imgSrc) {
                    var srcset = visibleImg.getAttribute('srcset');
                    if (srcset) {
                        var srcsetParts = srcset.split(',').map(function(s) { return s.trim(); });
                        if (srcsetParts.length > 0) {
                            var lastEntry = srcsetParts[srcsetParts.length - 1];
                            imgSrc = lastEntry.split(/\\s+/)[0];
                        }
                    }
                }
                
                // Method 3: Use current src
                if (!imgSrc) {
                    imgSrc = visibleImg.src || visibleImg.getAttribute('src');
                }
                
                return imgSrc;
            } catch (e) {
                console.log('Bandcamp Player: Error getting cover art URL:', e);
                return null;
            }
        })();
        """
        
        def on_url_received(url):
            # Hide loading animation if page is no longer loading (cover art might load later)
            if not getattr(self.parent_window, 'is_loading', False):
                self._hide_loading_animation()
            
            if url and hasattr(self, 'cover_art_label') and self.cover_art_label:
                # Only update if URL has changed
                current_url = getattr(self, '_current_cover_art_url', None)
                if url != current_url:
                    self._current_cover_art_url = url
                    
                    # Check shared cache first
                    if (hasattr(self, 'parent_window') and self.parent_window and
                        hasattr(self.parent_window, '_cover_art_cache') and
                        url in self.parent_window._cover_art_cache):
                        # Use cached pixmap immediately
                        pixmap = self.parent_window._cover_art_cache[url]
                        # Scale for nano mode (50px width)
                        scaled_pixmap = pixmap.scaled(50, 50, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                        self.cover_art_label.setPixmap(scaled_pixmap)
                        self.cover_art_label.update()
                        self._hide_loading_animation()
                    else:
                        # Load image
                        self._load_cover_art_image(url)
            elif not url:
                # No cover art URL found - hide animation if page is no longer loading
                if not getattr(self.parent_window, 'is_loading', False):
                    self._hide_loading_animation()
        
        self.parent_window.web_view.page().runJavaScript(js_code, on_url_received)
    
    def _update_buffering_state(self, is_buffering):
        """Update buffering animation on play button."""
        if not hasattr(self, 'play_pause_btn'):
            return
        
        # Only update if state changed to avoid unnecessary updates
        if is_buffering != self._is_buffering:
            self._is_buffering = is_buffering
            # Use set_buffering method if it's an AnimatedPlayButton
            if isinstance(self.play_pause_btn, AnimatedPlayButton):
                self.play_pause_btn.set_buffering(is_buffering)
            
            # Also update image viewer play button if it exists
            if hasattr(self, 'parent_window') and self.parent_window:
                if hasattr(self.parent_window, '_image_viewer_controls'):
                    image_viewer_controls = self.parent_window._image_viewer_controls
                    if 'play_pause_btn' in image_viewer_controls:
                        image_viewer_play_btn = image_viewer_controls['play_pause_btn']
                        if isinstance(image_viewer_play_btn, AnimatedPlayButton):
                            image_viewer_play_btn.set_buffering(is_buffering)
    
    def _load_cover_art_image(self, url):
        """Load cover art image from URL."""
        if not url or not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            return
        
        try:
            request = QNetworkRequest(QUrl(url))
            reply = self.network_manager.get(request)
            reply.setProperty('url', url)  # Store URL for verification
        except Exception as e:
            logger.debug(f"Error loading cover art: {e}")
    
    def _on_cover_art_loaded(self, reply):
        """Handle cover art image loaded."""
        try:
            if reply.error() == QNetworkReply.NetworkError.NoError:
                url = reply.property('url')
                # Verify URL matches current (in case multiple requests)
                if url and hasattr(self, '_current_cover_art_url') and url == self._current_cover_art_url:
                    data = reply.readAll()
                    pixmap = QPixmap()
                    if pixmap.loadFromData(data):
                        # Store in shared cache if parent_window exists
                        if hasattr(self, 'parent_window') and self.parent_window:
                            if not hasattr(self.parent_window, '_cover_art_cache'):
                                self.parent_window._cover_art_cache = {}
                            self.parent_window._cover_art_cache[url] = pixmap
                            self.parent_window._current_cover_art_url = url
                            # Update all other modes immediately
                            self.parent_window._update_all_modes_cover_art()
                        
                        if hasattr(self, 'cover_art_label') and self.cover_art_label:
                            # Scale for nano mode (50px width)
                            scaled_pixmap = pixmap.scaled(50, 50, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
                            self.cover_art_label.setPixmap(scaled_pixmap)
                            # Hide loading animation when cover art is successfully loaded
                            self._hide_loading_animation()
                else:
                    # URL mismatch or error - hide animation if page is no longer loading
                    if not getattr(self.parent_window, 'is_loading', False):
                        self._hide_loading_animation()
            else:
                # Network error - hide animation if page is no longer loading
                if not getattr(self.parent_window, 'is_loading', False):
                    self._hide_loading_animation()
            reply.deleteLater()
        except Exception as e:
            logger.debug(f"Error processing cover art: {e}")
            # Hide animation on error if page is no longer loading
            if not getattr(self.parent_window, 'is_loading', False):
                self._hide_loading_animation()
            if hasattr(reply, 'deleteLater'):
                reply.deleteLater()
    
    def _update_track_info(self):
        """Update track info, time display, and progress bar."""
        # Safety check - don't update if window is being destroyed
        if not self or not self.isVisible():
            return
        
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        js_code = """
        (function() {
            var info = {};
            
            // Get artist and track
            var artistEl = document.querySelector('.tralbum-artist');
            var albumEl = document.querySelector('.tralbum-name');
            
            // Try multiple selectors to get the track title and track number
            var trackEl = null;
            var trackNumber = null;
            // Method 1: Look for track title span (not track number)
            var currentTrack = document.querySelector('.current-track');
            if (currentTrack) {
                // Find track number span
                var trackNumEl = currentTrack.querySelector('.track-number, .track-num');
                if (trackNumEl) {
                    trackNumber = trackNumEl.textContent.trim();
                    // Remove any non-digit characters, keep just the number
                    trackNumber = trackNumber.replace(/[^\\d]/g, '');
                }
                // If no track number class, try to find it in spans
                if (!trackNumber) {
                    var spans = currentTrack.querySelectorAll('span');
                    for (var i = 0; i < spans.length; i++) {
                        var span = spans[i];
                        var text = span.textContent.trim();
                        // Check if this span is just a number (likely track number)
                        if (/^\\d+$/.test(text)) {
                            trackNumber = text;
                            break;
                        }
                    }
                }
                // Find span that's not the track number (the actual track title)
                var spans = currentTrack.querySelectorAll('span');
                for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    var classes = span.className || '';
                    var text = span.textContent.trim();
                    // Skip track number spans
                    if (!classes.includes('track-number') && 
                        !classes.includes('track-num') && 
                        text && 
                        text.length > 0 &&
                        !/^\\d+$/.test(text)) {  // Not just a number
                        trackEl = span;
                        break;
                    }
                }
            }
            // Method 2: Fallback to .track-title
            if (!trackEl) {
                trackEl = document.querySelector('.track-title');
            }
            // Method 3: Fallback to any span in .current-track (last resort)
            if (!trackEl && currentTrack) {
                trackEl = currentTrack.querySelector('span:not(.track-number):not(.track-num)');
            }
            
            if (artistEl) {
                var artistText = artistEl.textContent.trim();
                info.artist = artistText.replace(/^by\\s+/i, '');
            }
            if (trackEl) {
                var trackText = trackEl.textContent.trim();
                // Remove track number if it's at the start (e.g., "1. Track Name" -> "Track Name")
                trackText = trackText.replace(/^\\d+\\.?\\s*/, '');
                info.track = trackText;
            }
            // Store track number if found
            if (trackNumber) {
                info.trackNumber = trackNumber;
            }
            if (albumEl) {
                info.album = albumEl.textContent.trim();
            }
            
            // Get time info and buffering state
            var audio = document.querySelector('audio');
            if (audio) {
                info.isPlaying = !audio.paused;
                info.currentTime = audio.currentTime || 0;
                info.duration = audio.duration || 0;
                
                // Detect buffering/seeking state
                // Buffering occurs when:
                // 1. Audio is seeking (user scrubbed or track changed)
                // 2. Audio is playing but doesn't have enough data (readyState < 4 = HAVE_ENOUGH_DATA)
                // 3. Network is actively loading (networkState === 2 = NETWORK_LOADING)
                // 4. Audio is waiting for data (readyState < 3 = HAVE_FUTURE_DATA)
                var isSeeking = audio.seeking === true;
                var hasEnoughData = audio.readyState >= 4;  // HAVE_ENOUGH_DATA
                var isNetworkLoading = audio.networkState === 2;  // NETWORK_LOADING
                var hasFutureData = audio.readyState >= 3;  // HAVE_FUTURE_DATA
                
                // Consider buffering if:
                // - Currently seeking, OR
                // - Playing but not enough data loaded, OR
                // - Network is actively loading data
                info.isBuffering = isSeeking || 
                                  (info.isPlaying && !hasEnoughData) || 
                                  (info.isPlaying && isNetworkLoading && !hasFutureData);
            } else {
                info.isBuffering = false;
            }
            
            return info;
        })();
        """
        
        def on_info_received(result):
            if not result:
                return
            
            # Update track menu button text (full text, no truncation - will expand with button)
            artist = result.get('artist', '')
            track = result.get('track', '')
            track_number = result.get('trackNumber', '')
            
            # Format: 01. Track Name (zero-padded track number with period, no artist)
            if track_number and track:
                try:
                    # Convert to int and format with zero-padding (01, 02, etc.)
                    track_num = int(track_number)
                    formatted_number = f"{track_num:02d}"
                    display_text = f"{formatted_number}. {track}"
                except (ValueError, TypeError):
                    # If conversion fails, use track_number as-is with period
                    display_text = f"{track_number}. {track}"
            elif track:
                display_text = track
            else:
                display_text = "Track"
            
            self.track_menu_btn.setText(display_text)
            # Update tooltip if text is truncated
            self._update_button_tooltip(self.track_menu_btn, display_text)
            
            # Update album menu button text (full text, no truncation - will expand with button)
            album = result.get('album', '')
            artist = result.get('artist', '')
            if album and artist:
                # Use "Album by Artist" format to match regular mode
                display_text = f"{album} by {artist}"
                self.album_menu_btn.setText(display_text)
                # Update tooltip if text is truncated
                self._update_button_tooltip(self.album_menu_btn, display_text)
                self._current_album_name = album  # Store for highlighting
                # Save this metadata to the playlist for the current URL
                if self.parent_window and self.parent_window.web_view:
                    current_url = self.parent_window.web_view.url().toString()
                    if current_url and current_url != 'about:blank':
                        # Get playlist manager and save metadata
                        if hasattr(self.parent_window, 'playlist_manager') and self.parent_window.playlist_manager:
                            self.parent_window.playlist_manager.update_url_metadata(current_url, display_text)
            elif album:
                self.album_menu_btn.setText(album)
                # Update tooltip if text is truncated
                self._update_button_tooltip(self.album_menu_btn, album)
                self._current_album_name = album  # Store for highlighting
                # Save album-only metadata if we have a URL
                if self.parent_window and self.parent_window.web_view:
                    current_url = self.parent_window.web_view.url().toString()
                    if current_url and current_url != 'about:blank':
                        if hasattr(self.parent_window, 'playlist_manager') and self.parent_window.playlist_manager:
                            self.parent_window.playlist_manager.update_url_metadata(current_url, album)
            else:
                self.album_menu_btn.setText("Album")
                # Update tooltip if text is truncated
                self._update_button_tooltip(self.album_menu_btn, "Album")
                self._current_album_name = None
            
            # Store current track number for highlighting and persistence
            if track_number:
                try:
                    new_track_num = int(track_number)
                    track_changed = (self._current_track_number != new_track_num)
                    
                    # During startup with autoplay enabled, don't overwrite saved track number
                    # until after autoplay has loaded the correct track
                    should_update_track_number = True
                    if self.parent_window:
                        # Check if this is a startup load with autoplay enabled
                        is_startup = getattr(self.parent_window, '_is_startup_load', False)
                        autoplay_on_startup = getattr(self.parent_window, 'autoplay_on_startup', False)
                        saved_track = self.parent_window.settings.get("last_played_track_number")
                        
                        # If startup + autoplay enabled + we have a saved track + detected track is different
                        # Don't update yet - wait for autoplay to load the correct track
                        if is_startup and autoplay_on_startup and saved_track is not None:
                            try:
                                saved_track_int = int(saved_track)
                                if new_track_num != saved_track_int:
                                    # This is likely the initial page load showing track 1 before autoplay
                                    # Don't overwrite the saved track number yet
                                    should_update_track_number = False
                                    logger.debug(f"Nano player: Skipping track number update during startup (detected {new_track_num}, saved {saved_track_int})")
                            except (ValueError, TypeError):
                                pass  # If saved track isn't a valid int, proceed with update
                    
                    if should_update_track_number:
                        self._current_track_number = new_track_num
                        # Also update parent window's track number for persistence
                        if self.parent_window:
                            self.parent_window._current_track_number = self._current_track_number
                            # Save settings immediately when track number changes (regardless of autoplay settings)
                            if track_changed:
                                self.parent_window.save_settings()
                except (ValueError, TypeError):
                    self._current_track_number = None
                    if self.parent_window:
                        self.parent_window._current_track_number = None
            else:
                self._current_track_number = None
                if self.parent_window:
                    self.parent_window._current_track_number = None
            
            # Update button widths based on new text content
            self._update_button_widths()
            # Force button update to ensure new text is displayed immediately
            if hasattr(self, 'track_menu_btn') and self.track_menu_btn:
                self.track_menu_btn.update()
                self.track_menu_btn.updateGeometry()
            if hasattr(self, 'album_menu_btn') and self.album_menu_btn:
                self.album_menu_btn.update()
                self.album_menu_btn.updateGeometry()
            # Force layout update
            QApplication.processEvents()
            
            # Update buffering state for play button animation
            is_buffering = result.get('isBuffering', False)
            self._update_buffering_state(is_buffering)
            
            # Update cover art
            self._update_cover_art()
            
            # Update highlighting in menus if they're open
            if hasattr(self, '_track_list') and self._track_list and self._track_list.count() > 0:
                self._highlight_current_track()
            if hasattr(self, '_album_list') and self._album_list and self._album_list.count() > 0:
                self._highlight_current_album()
            
            # Update time display based on current mode
            current_time = result.get('currentTime', 0)
            duration = result.get('duration', 0)
            if duration > 0:
                current_mins = int(current_time // 60)
                current_secs = int(current_time % 60)
                
                if self.time_display_mode == 0:
                    # Mode 0: elapsed / total
                    total_mins = int(duration // 60)
                    total_secs = int(duration % 60)
                    self.time_label.setText(f"{current_mins:02d}:{current_secs:02d}/{total_mins:02d}:{total_secs:02d}")
                else:
                    # Mode 1: elapsed / remaining
                    remaining = duration - current_time
                    remaining_mins = int(remaining // 60)
                    remaining_secs = int(remaining % 60)
                    self.time_label.setText(f"{current_mins:02d}:{current_secs:02d}/-{remaining_mins:02d}:{remaining_secs:02d}")
            else:
                self.time_label.setText("00:00/00:00")
            
            # Update progress bar (only if not dragging)
            if not self._progress_dragging and duration > 0:
                progress_value = int((current_time / duration) * 1000)
                self.progress_bar.setValue(progress_value)
            
            # Update play/pause button icon
            is_playing = result.get('isPlaying', False)
            if HAS_QT_AWESOME:
                icon_name = 'pause' if is_playing else 'play'
                icon = get_icon(icon_name, color='#e0e0e0')
                if icon:
                    self.play_pause_btn.setIcon(icon)
                else:
                    self.play_pause_btn.setText("" if is_playing else "")
            else:
                self.play_pause_btn.setText("" if is_playing else "")
            
            # Sync shuffle and repeat button states
            self._sync_shuffle_repeat_buttons()
        
        self.parent_window.web_view.page().runJavaScript(js_code, on_info_received)
    
    def _sync_shuffle_repeat_buttons(self):
        """Sync shuffle and repeat button states from centralized PlayerWindow state (with defensive checks)."""
        try:
            if (self.parent_window and 
                hasattr(self.parent_window, 'shuffle_mode') and
                hasattr(self.parent_window, 'repeat_mode')):
                
                # Sync shuffle button
                if hasattr(self, 'shuffle_btn') and self.shuffle_btn:
                    shuffle_mode = getattr(self.parent_window, 'shuffle_mode', 0)
                    # Always sync, not just if different (ensures correct state on startup)
                    self.shuffle_btn.blockSignals(True)
                    is_active = shuffle_mode > 0
                    self.shuffle_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button if available, otherwise generate
                    if (hasattr(self.parent_window, 'playlist_sidebar') and 
                        self.parent_window.playlist_sidebar and
                        hasattr(self.parent_window.playlist_sidebar, 'shuffle_btn')):
                        tooltip = self.parent_window.playlist_sidebar.shuffle_btn.toolTip()
                    else:
                        tooltip = f"Shuffle: {'On' if is_active else 'Off'}"
                    self.shuffle_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            self.shuffle_btn.setIcon(icon)
                    self.shuffle_btn.blockSignals(False)
                
                # Sync repeat button
                if hasattr(self, 'repeat_btn') and self.repeat_btn:
                    repeat_mode = getattr(self.parent_window, 'repeat_mode', 0)
                    # Always sync, not just if different (ensures correct state on startup)
                    self.repeat_btn.blockSignals(True)
                    is_active = repeat_mode > 0
                    self.repeat_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button if available, otherwise generate
                    if (hasattr(self.parent_window, 'playlist_sidebar') and 
                        self.parent_window.playlist_sidebar and
                        hasattr(self.parent_window.playlist_sidebar, 'repeat_btn')):
                        tooltip = self.parent_window.playlist_sidebar.repeat_btn.toolTip()
                    else:
                        tooltip = "Repeat: Off"
                    self.repeat_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            self.repeat_btn.setIcon(icon)
                    self.repeat_btn.blockSignals(False)
                    
                    # Sync repeat overlay (for mode 3 - "1" overlay)
                    self._update_repeat_overlay_nano(repeat_mode)
                
                # Also sync detached playlist buttons if they exist
                if hasattr(self.parent_window, '_detached_repeat_btn') and self.parent_window._detached_repeat_btn:
                    repeat_mode = getattr(self.parent_window, 'repeat_mode', 0)
                    self.parent_window._detached_repeat_btn.blockSignals(True)
                    is_active = repeat_mode > 0
                    self.parent_window._detached_repeat_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button if available, otherwise generate
                    if (hasattr(self.parent_window, 'playlist_sidebar') and 
                        self.parent_window.playlist_sidebar and
                        hasattr(self.parent_window.playlist_sidebar, 'repeat_btn')):
                        tooltip = self.parent_window.playlist_sidebar.repeat_btn.toolTip()
                    else:
                        tooltip = "Repeat: Off"
                    self.parent_window._detached_repeat_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            self.parent_window._detached_repeat_btn.setIcon(icon)
                    self.parent_window._detached_repeat_btn.blockSignals(False)
                    # Update overlay for detached repeat button (for mode 3 - "1" overlay)
                    if hasattr(self.parent_window, '_update_detached_repeat_overlay'):
                        QTimer.singleShot(0, lambda: self.parent_window._update_detached_repeat_overlay(repeat_mode))
                
                if hasattr(self.parent_window, '_detached_shuffle_btn') and self.parent_window._detached_shuffle_btn:
                    shuffle_mode = getattr(self.parent_window.playlist_sidebar, 'shuffle_mode', 0)
                    self.parent_window._detached_shuffle_btn.blockSignals(True)
                    is_active = shuffle_mode > 0
                    self.parent_window._detached_shuffle_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button
                    if hasattr(self.parent_window.playlist_sidebar, 'shuffle_btn'):
                        tooltip = self.parent_window.playlist_sidebar.shuffle_btn.toolTip()
                    else:
                        tooltip = "Shuffle: Off"
                    self.parent_window._detached_shuffle_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            self.parent_window._detached_shuffle_btn.setIcon(icon)
                    self.parent_window._detached_shuffle_btn.blockSignals(False)
        except (AttributeError, RuntimeError) as e:
            # Playlist sidebar might be destroyed or in invalid state - ignore sync errors
            logger.debug(f"Nano player sync error (non-critical): {e}")
            pass
    
    def _update_repeat_overlay_nano(self, repeat_mode):
        """Update overlay on nano player repeat button based on mode:
        - Mode 3 (Track): "1" overlay (white)
        - Other modes: no overlay
        """
        if not hasattr(self, 'repeat_btn') or not self.repeat_btn:
            return
        
        # Remove existing overlay if it exists
        if hasattr(self, '_repeat_overlay_label_nano') and self._repeat_overlay_label_nano is not None:
            try:
                self._repeat_overlay_label_nano.deleteLater()
            except (AttributeError, RuntimeError):
                pass  # Label might already be deleted
            self._repeat_overlay_label_nano = None
        
        # Show overlay only for mode 3 ("1")
        if repeat_mode == 3:
            # Create overlay label
            from PyQt6.QtWidgets import QLabel
            from PyQt6.QtCore import Qt
            
            # Set overlay text to "1" for mode 3
            overlay_text = "1"
            
            # Set overlay color: white for mode 3 (track)
            overlay_color = 'white'
            
            # Create overlay as child of button's parent widget to ensure it's on top
            # Get the button's parent widget (the container)
            button_parent = self.repeat_btn.parent()
            if button_parent:
                self._repeat_overlay_label_nano = QLabel(overlay_text, button_parent)
            else:
                # Fallback to button itself if no parent
                self._repeat_overlay_label_nano = QLabel(overlay_text, self.repeat_btn)
            
            self._repeat_overlay_label_nano.setAlignment(Qt.AlignmentFlag.AlignCenter)
            # Make overlay transparent to mouse events so clicks pass through to button
            self._repeat_overlay_label_nano.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._repeat_overlay_label_nano.setStyleSheet(f"""
                QLabel {{
                    background-color: transparent;
                    color: {overlay_color};
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                }}
            """)
            # Position will be updated when button is shown/resized
            # Use a method to update position
            def update_overlay_position():
                if hasattr(self, '_repeat_overlay_label_nano') and self._repeat_overlay_label_nano and self.repeat_btn:
                    try:
                        # Get button position relative to its parent widget
                        btn_pos = self.repeat_btn.pos()
                        btn_size = self.repeat_btn.size()
                        overlay_size = 12  # Smaller overlay to ensure it stays within button bounds
                        # Calculate position relative to button's parent, centered on button
                        x = btn_pos.x() + (btn_size.width() - overlay_size) // 2
                        y = btn_pos.y() + (btn_size.height() - overlay_size) // 2
                        # Ensure overlay stays within button bounds
                        x = max(btn_pos.x(), min(x, btn_pos.x() + btn_size.width() - overlay_size))
                        y = max(btn_pos.y(), min(y, btn_pos.y() + btn_size.height() - overlay_size))
                        self._repeat_overlay_label_nano.setGeometry(x, y, overlay_size, overlay_size)
                        self._repeat_overlay_label_nano.show()
                        self._repeat_overlay_label_nano.raise_()
                    except (RuntimeError, AttributeError):
                        pass  # Button or overlay might have been deleted
            
            # Update position immediately and on button resize
            QTimer.singleShot(0, update_overlay_position)
            # Also update when button is resized (if button has resizeEvent, we'd need to override it)
            # Use multiple delays to ensure button is fully rendered and positioned
            QTimer.singleShot(50, update_overlay_position)
            QTimer.singleShot(100, update_overlay_position)
            QTimer.singleShot(200, update_overlay_position)
        else:
            # Ensure overlay is removed for other modes
            if hasattr(self, '_repeat_overlay_label_nano') and self._repeat_overlay_label_nano:
                self._repeat_overlay_label_nano.hide()
        
    def showEvent(self, event):
        """Handle window show event - update hover area if needed."""
        super().showEvent(event)
        # Ensure window stays in taskbar (Window flag should keep it there)
        # No need to change flags - they're already set correctly in __init__
        # Update repeat overlay when window is shown (in case mode changed while hidden)
        if hasattr(self, 'parent_window') and self.parent_window:
            if hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                repeat_mode = getattr(self.parent_window.playlist_sidebar, 'repeat_mode', 0)
                if hasattr(self, '_update_repeat_overlay_nano'):
                    self._update_repeat_overlay_nano(repeat_mode)
        
        # Reset autohidden state when window is shown
        self._is_autohidden = False
        # Show cover art when window is shown (in case it was hidden during autohide)
        if hasattr(self, 'cover_art_label') and self.cover_art_label:
            self.cover_art_label.show()
        
        # Check if window is off-screen or in sliver position (was autohidden) and restore to valid position
        screen = QApplication.primaryScreen()
        if screen:
            screen_geometry = screen.geometry()
            current_pos = self.pos()
            window_height = self.height()
            sliver_size = 2
            
            # Check if window is way off-screen (more than 1000px to the right) OR in sliver position
            is_off_screen = current_pos.x() > screen_geometry.right() + 1000
            is_in_sliver = False
            
            # Check if window is in sliver position (only 1px visible at edge)
            if self._docked_edge == 'top':
                # Window is in sliver if it's positioned so only top 1px is visible
                expected_sliver_y = screen_geometry.top() - window_height + sliver_size
                is_in_sliver = abs(current_pos.y() - expected_sliver_y) < 5  # Allow 5px tolerance
            elif self._docked_edge == 'bottom':
                # Window is in sliver if it's positioned so only bottom 1px is visible
                expected_sliver_y = screen_geometry.bottom() - sliver_size
                is_in_sliver = abs(current_pos.y() - expected_sliver_y) < 5  # Allow 5px tolerance
            
            if is_off_screen or is_in_sliver:
                # Window is off-screen or in sliver position, restore to docked position or saved position
                if hasattr(self, '_autohide_saved_pos') and self._autohide_saved_pos is not None:
                    self.move(self._autohide_saved_pos)
                    self._autohide_saved_pos = None
                elif self._docked_edge and self._docked_y_position is not None:
                    # Restore to docked position
                    if self._docked_edge == 'top':
                        self.move(self.x(), screen_geometry.top())
                    elif self._docked_edge == 'bottom':
                        self.move(self.x(), screen_geometry.bottom() - self.height())
                else:
                    # No saved position and not docked - restore to a visible position
                    # Use saved position from settings or default position
                    if self.parent_window:
                        saved_pos = self.parent_window.settings.get("nano_player_position", None)
                        if saved_pos and len(saved_pos) == 2:
                            # Validate position is on a valid screen (multi-monitor support)
                            saved_pos_point = QPoint(saved_pos[0], saved_pos[1])
                            screen = QApplication.screenAt(saved_pos_point)
                            if screen:
                                # Position is on a valid screen, use it
                                self.move(saved_pos_point)
                            else:
                                # Position is off-screen, find the closest screen or use primary
                                screens = QApplication.screens()
                                target_screen = None
                                min_distance = float('inf')
                                
                                for s in screens:
                                    screen_geom = s.geometry()
                                    # Calculate distance from saved position to screen center
                                    screen_center = screen_geom.center()
                                    distance = ((saved_pos_point.x() - screen_center.x()) ** 2 + 
                                               (saved_pos_point.y() - screen_center.y()) ** 2) ** 0.5
                                    if distance < min_distance:
                                        min_distance = distance
                                        target_screen = s
                                
                                if not target_screen:
                                    target_screen = QApplication.primaryScreen()
                                
                                # Move to primary screen (or closest screen) - center it
                                target_geometry = target_screen.availableGeometry()
                                self.move(
                                    target_geometry.center().x() - self.width() // 2,
                                    target_geometry.center().y() - self.height() // 2
                                )
                        else:
                            # Default to center of screen
                            self.move(
                                screen_geometry.center().x() - self.width() // 2,
                                screen_geometry.center().y() - self.height() // 2
                            )
        
        # Clear any saved position (window is now visible, don't restore old position)
        if hasattr(self, '_autohide_saved_pos'):
            self._autohide_saved_pos = None
        
        # Check if window is at a screen edge and should be docked (only if not already docked)
        # Use a small delay to ensure window geometry is fully calculated
        if not self._docked_edge:
            def check_dock_on_startup():
                screen = QApplication.primaryScreen()
                if not screen:
                    return
                
                screen_geometry = screen.availableGeometry()
                window_geometry = self.frameGeometry()
                
                # Calculate distances to edges
                dist_to_top = abs(window_geometry.top() - screen_geometry.top())
                dist_to_bottom = abs(window_geometry.bottom() - screen_geometry.bottom())
                
                # Check which edge is closer and dock to it if within threshold
                if dist_to_top < self._snap_threshold and dist_to_top <= dist_to_bottom:
                    # Dock to top edge
                    self.move(window_geometry.left(), screen_geometry.top())
                    self._docked_edge = 'top'
                    self._docked_y_position = screen_geometry.top()
                    # Start autohide timer if enabled
                    if self.nano_autohide_when_docked:
                        self._autohide_timer.start()
                elif dist_to_bottom < self._snap_threshold:
                    # Dock to bottom edge
                    self.move(window_geometry.left(), screen_geometry.bottom() - window_geometry.height())
                    self._docked_edge = 'bottom'
                    self._docked_y_position = screen_geometry.bottom() - window_geometry.height()
                    # Start autohide timer if enabled
                    if self.nano_autohide_when_docked:
                        self._autohide_timer.start()
            
            # Small delay to ensure window geometry is fully calculated
            QTimer.singleShot(100, check_dock_on_startup)
        
        # Set cooldown to prevent autohide from triggering immediately after window is shown
        # Use longer cooldown (2 seconds) to ensure window stays visible
        self._autohide_cooldown = True
        QTimer.singleShot(2000, lambda: setattr(self, '_autohide_cooldown', False))  # 2 second cooldown
        
        if self._docked_edge and self.nano_autohide_when_docked and not self._is_autohidden:
            # Hide hover area when window is shown
            if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
                self._autohide_hover_area.hide()
    
    def _save_nano_position(self):
        """Save nano player position and size to settings."""
        if not self.parent_window:
            return
        
        try:
            # Save position
            pos = self.pos()
            self.parent_window.settings['nano_player_position'] = [pos.x(), pos.y()]
            
            # Save size
            size = self.size()
            self.parent_window.settings['nano_player_size'] = f"{size.width()}x{size.height()}"
            
            # Save autohide settings
            self.parent_window.settings['nano_autohide_when_docked'] = self.nano_autohide_when_docked
            self.parent_window.settings['nano_autohide_sensitivity'] = self.nano_autohide_sensitivity
            
            self.parent_window.save_settings()
        except Exception as e:
            logger.debug(f"Error saving nano player position: {e}")
    
    def moveEvent(self, event):
        """Handle window move event - save position when moved."""
        super().moveEvent(event)
        # Save position when window is moved (debounced to avoid too many saves)
        if not hasattr(self, '_position_save_timer'):
            self._position_save_timer = QTimer(self)
            self._position_save_timer.setSingleShot(True)
            self._position_save_timer.timeout.connect(self._save_nano_position)
        
        # Debounce saves - only save after 500ms of no movement
        self._position_save_timer.stop()
        self._position_save_timer.start(500)
    
    def hideEvent(self, event):
        """Handle window hide event - show hover area if autohidden, and save position."""
        super().hideEvent(event)
        if self._docked_edge and self.nano_autohide_when_docked and self._is_autohidden:
            # Show hover area when window is hidden
            self._update_autohide_hover_area()
        
        # Save position when hidden (e.g., when switching back to main interface)
        self._save_nano_position()
    
    def closeEvent(self, event):
        """Handle window close - save position and size, and close entire app."""
        # Clean up hover area
        if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
            self._autohide_hover_area.hide()
            self._autohide_hover_area.deleteLater()
            self._autohide_hover_area = None
        
        # Save position before closing
        self._save_nano_position()
        
        # Close entire app (same as close on main window)
        if self.parent_window:
            self.parent_window.close()
        
        super().closeEvent(event)


if __name__ == "__main__":
    # CRITICAL: Allocate console FIRST on Windows (before any other operations)
    # This is essential for Windows 10 when double-clicking .py files
    # Double-clicking may use pythonw.exe (no console), causing silent failures
    # BUT: Skip console allocation in launcher mode (console is intentionally freed)
    _console_allocated = False
    launcher_mode = os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1'
    
    if sys.platform == "win32" and not launcher_mode:
        try:
            import ctypes
            kernel32 = ctypes.windll.kernel32
            user32 = ctypes.windll.user32
            
            # Check if we have a console window
            hwnd = kernel32.GetConsoleWindow()
            
            # If no console exists, try to allocate one
            # This happens when double-clicking .py files on Windows 10
            # or when using pythonw.exe
            if not hwnd:
                # FreeConsole first if attached to parent console
                try:
                    kernel32.FreeConsole()
                except:
                    pass
                
                # Allocate a new console
                if kernel32.AllocConsole():
                    _console_allocated = True
                    # Redirect stdout/stderr to the new console
                    import msvcrt
                    import io
                    try:
                        # Reopen stdout/stderr
                        sys.stdout = io.TextIOWrapper(io.BufferedWriter(io.FileIO(1, 'wb')), encoding='utf-8', line_buffering=True)
                        sys.stderr = io.TextIOWrapper(io.BufferedWriter(io.FileIO(2, 'wb')), encoding='utf-8', line_buffering=True)
                    except:
                        # Fallback: use CONOUT$
                        try:
                            sys.stdout = open('CONOUT$', 'w', encoding='utf-8')
                            sys.stderr = open('CONOUT$', 'w', encoding='utf-8')
                        except:
                            pass  # If even this fails, continue anyway
                    
                    # Show the console window
                    hwnd = kernel32.GetConsoleWindow()
                    if hwnd:
                        user32.ShowWindow(hwnd, 1)  # SW_SHOWNORMAL
                        # Print a message so user knows console is available
                        print("Bandcamp Player - Console allocated for error messages", file=sys.stderr)
        except Exception:
            pass  # Continue even if console allocation fails
    
    # CRITICAL: Change to script directory (after console is available for errors)
    # This is essential for Windows 10 when double-clicking .py files
    # The working directory might not be the script's directory
    try:
        if hasattr(sys, 'frozen'):
            # Running as compiled executable
            script_dir = Path(sys.executable).resolve().parent
        elif __file__:
            # Running as script - use __file__ to get script directory
            script_dir = Path(__file__).resolve().parent
        else:
            # Fallback to current directory
            script_dir = Path(os.getcwd())
        
        # Change to script directory if we're not already there
        current_dir = Path(os.getcwd()).resolve()
        if current_dir != script_dir:
            os.chdir(str(script_dir))
            # Use print instead of logger since logger might not be initialized yet
            try:
                logger.debug(f"Changed working directory from {current_dir} to {script_dir}")
            except:
                pass  # Logger not initialized yet - that's okay
    except Exception as e:
        # Log but continue - some operations might still work
        try:
            logger.warning(f"Could not change to script directory: {e}")
        except:
            # Logger not initialized - print to stderr as fallback
            try:
                print(f"Warning: Could not change to script directory: {e}", file=sys.stderr)
            except:
                pass  # Even stderr might not be available
    
    # CRITICAL for Windows 10: Ensure we have a way to show errors
    # If running with pythonw.exe (no console), we need Qt available to show error dialogs
    _error_dialog_available = False
    try:
        from PyQt6.QtWidgets import QApplication, QMessageBox
        _error_dialog_available = True
    except:
        pass  # Qt not available yet - will try again later
    
    # Wrap everything in try-except to catch import errors and early crashes
    # This is critical for Windows 10 where errors might be silent
    try:
        # Try to run main()
        main()
    except KeyboardInterrupt:
        sys.exit(0)
    except SystemExit:
        raise  # Re-raise SystemExit
    except ImportError as e:
        # Import errors are critical - show immediately
        import traceback
        error_msg = f"Import error: {str(e)}\n\nThis usually means a required module is missing.\n\n{traceback.format_exc()}"
        
        # Try to show error dialog
        try:
            if not _error_dialog_available:
                from PyQt6.QtWidgets import QApplication, QMessageBox
                app = QApplication.instance()
                if app is None:
                    app = QApplication(sys.argv)
                _error_dialog_available = True
            
            if _error_dialog_available:
                msg_box = QMessageBox()
                msg_box.setIcon(QMessageBox.Icon.Critical)
                msg_box.setWindowTitle("Import Error")
                msg_box.setText(f"Failed to import required module:\n\n{str(e)}\n\nPlease install dependencies:\npip install -r requirements.txt")
                msg_box.setDetailedText(traceback.format_exc())
                msg_box.exec()
        except:
            # Fallback to console/file
            pass
        
        # Also try to save to file and print
        try:
            script_dir = Path(__file__).parent if __file__ else Path.cwd()
            logs_dir = script_dir / "Logs"
            logs_dir.mkdir(exist_ok=True)
            error_log_file = logs_dir / "crash_log.txt"
            import time
            with open(error_log_file, 'a', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write(f"IMPORT ERROR - {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("=" * 80 + "\n")
                f.write(error_msg + "\n")
                f.write("=" * 80 + "\n\n")
        except:
            pass
        
        # Print to console if available
        try:
            print("=" * 60, file=sys.stderr)
            print("IMPORT ERROR - Bandcamp Player Failed to Start", file=sys.stderr)
            print("=" * 60, file=sys.stderr)
            print(error_msg, file=sys.stderr)
            print("=" * 60, file=sys.stderr)
        except:
            pass
        
        # Keep console open on Windows so user can read error
        if sys.platform == "win32":
            try:
                input("\nPress Enter to exit...")
            except:
                import time
                time.sleep(5)  # Wait so user can read error
        
        sys.exit(1)
    except Exception as e:
        # Catch ALL other errors including import errors
        import traceback
        error_msg = f"Fatal error: {str(e)}\n\n{traceback.format_exc()}"
        
        # Save error to log file
        try:
            script_dir = Path(__file__).parent if __file__ else Path.cwd()
            logs_dir = script_dir / "Logs"
            logs_dir.mkdir(exist_ok=True)
            error_log_file = logs_dir / "crash_log.txt"
            import time
            with open(error_log_file, 'a', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write(f"STARTUP CRASH - {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("=" * 80 + "\n")
                f.write(error_msg + "\n")
                f.write("=" * 80 + "\n\n")
        except Exception as log_error:
            print(f"Warning: Could not write to crash log: {log_error}", file=sys.stderr)
        
        # Always print to console first (Windows 10 visibility)
        print("=" * 60, file=sys.stderr)
        print("FATAL ERROR - Bandcamp Player Failed to Start", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        print(error_msg, file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        try:
            print(f"\nError has been saved to: {error_log_file}", file=sys.stderr)
        except:
            print("\nError has been saved to: Logs/crash_log.txt", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        
        # Try to show error dialog if Qt is available
        try:
            from PyQt6.QtWidgets import QApplication, QMessageBox
            app = QApplication.instance()
            if app is None:
                app = QApplication(sys.argv)
            
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Icon.Critical)
            msg_box.setWindowTitle("Fatal Error")
            msg_box.setText(f"Failed to start Bandcamp Player:\n\n{str(e)}")
            msg_box.setDetailedText(traceback.format_exc())
            msg_box.exec()
        except Exception:
            # Qt not available - console message already printed above
            pass
        
        # Keep console open on Windows so user can read error
        if sys.platform == "win32":
            try:
                input("\nPress Enter to exit...")
            except:
                import time
                time.sleep(5)  # Wait so user can read error
        
        sys.exit(1)
