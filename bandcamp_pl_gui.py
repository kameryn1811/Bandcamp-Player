#!/usr/bin/env python3
"""
Bandcamp Player - A standalone mini player for Bandcamp
Proof of concept using PyQt6 with QWebEngineView
"""

# Application version (update this when releasing)
__version__ = "1.0.0"

import sys
import os
import subprocess
import json
import random
import logging
import time
import webbrowser
from pathlib import Path
import urllib.request
import urllib.error
from urllib.parse import urlparse

# Windows-specific imports for media key support (safe import)
_HAS_CTYPES = False
if sys.platform == 'win32':
    try:
        import ctypes
        from ctypes import wintypes
        _HAS_CTYPES = True
    except ImportError:
        _HAS_CTYPES = False

# Note: Console window hiding is deferred until after initialization
# This ensures errors are visible if something fails early

# ============================================================================
# CONSTANTS
# ============================================================================

# Window constants
WINDOW_DEFAULT_WIDTH = 260
WINDOW_DEFAULT_HEIGHT = 640
WINDOW_MIN_WIDTH = 260
WINDOW_MIN_HEIGHT = 150
WINDOW_MAX_WIDTH = 260

# Playlist constants
PLAYLIST_MIN_HEIGHT = 100
PLAYLIST_MAX_HEIGHT = 600
PLAYLIST_DEFAULT_HEIGHT = 250

# Timer intervals (milliseconds)
PLAYBACK_CHECK_INTERVAL = 1000  # 1 second
ADDRESS_BAR_HIDE_DELAY = 150
ADDRESS_BAR_SHOW_DELAY = 600
OVERLAY_FADE_DURATION = 150
PAGE_FADE_DURATION = 150

# Animation durations (milliseconds)
LOADING_ANIMATION_DURATION = 1500
PULSE_ANIMATION_DURATION = 1500

# ============================================================================
# LOGGING SETUP
# ============================================================================

# Set up logging - wrap in try-except for Windows 10 compatibility
try:
    log_level = logging.DEBUG if os.environ.get('DEBUG') else logging.INFO
    
    # Create logs directory if it doesn't exist
    script_dir = Path(__file__).parent if __file__ else Path.cwd()
    logs_dir = script_dir / "Logs"
    logs_dir.mkdir(exist_ok=True)
    
    # Set up file handler for error logging
    log_file = logs_dir / "error_log.txt"
    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setLevel(logging.ERROR)  # Only log errors and above to file
    file_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s\n%(pathname)s:%(lineno)d\n',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    file_handler.setFormatter(file_formatter)
    
    # Set up console handler (only if not in launcher mode or if console is available)
    # In launcher mode, console is freed, so stdout/stderr may be None
    launcher_mode = os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1'
    if not launcher_mode and sys.stdout and sys.stderr:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(log_level)
        console_formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%H:%M:%S')
        console_handler.setFormatter(console_formatter)
        console_handler.stream = sys.stdout  # Explicitly set to stdout
    else:
        # In launcher mode or if stdout/stderr are None, skip console handler
        console_handler = None
    
    # Configure root logger
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    if console_handler:
        root_logger.addHandler(console_handler)
    root_logger.addHandler(file_handler)
    
    logger = logging.getLogger(__name__)
except Exception as e:
    # If logging setup fails, create a basic logger
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    if not logger.handlers:
        # Only add console handler if stdout/stderr are available
        if sys.stdout and sys.stderr:
            handler = logging.StreamHandler()
            handler.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
            logger.addHandler(handler)
    # Only print to stderr if it's available (not None after FreeConsole)
    if sys.stderr:
        try:
            print(f"Warning: Could not set up file logging: {e}", file=sys.stderr)
        except (AttributeError, OSError):
            pass  # stderr is None or not writable

# PyQt6 imports
from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, 
                              QPushButton, QLineEdit, QListWidget, QListWidgetItem,
                              QMenu, QSystemTrayIcon, QMessageBox, QSizePolicy,
                              QApplication, QLabel, QDialog, QTextEdit, QFrame,
                              QStyledItemDelegate, QStyleOptionViewItem, QStyleOptionButton, QToolTip, QSlider,
                              QFileDialog, QInputDialog, QWidgetAction, QSizeGrip)
from PyQt6.QtWebEngineWidgets import QWebEngineView
from PyQt6.QtWebEngineCore import QWebEnginePage, QWebEngineProfile, QWebEngineSettings
from PyQt6.QtCore import Qt, QUrl, pyqtSignal, QSize, QPoint, QPropertyAnimation, QEasingCurve, QTimer, pyqtProperty, QRect, QMimeData, QByteArray, QEvent, QThread, QAbstractNativeEventFilter, QObject
from PyQt6.QtNetwork import QLocalServer, QLocalSocket, QNetworkAccessManager, QNetworkRequest, QNetworkReply
from PyQt6.QtGui import QIcon, QAction, QKeySequence, QShortcut, QColor, QPainter, QBrush, QPen, QPainterPath, QConicalGradient, QRegion, QDragEnterEvent, QDropEvent, QTextCharFormat, QTextCursor, QTextFormat, QFont, QDesktopServices, QPixmap, QCursor, QFontMetrics, QScreen
from PyQt6.QtWidgets import QStyle
from PyQt6.QtWidgets import QGraphicsOpacityEffect

# ============================================================================
# FONTAWESOME ICONS
# ============================================================================
# FontAwesome icons via qtawesome library
# 
# ICON STYLES (FontAwesome 5):
#   - fa5.* = Solid (bold, filled) - most common
#   - fa5r.* = Regular (outline, lighter weight)
#   - fa5b.* = Brands (logos like GitHub, Twitter, etc.)
# 
# FINDING ICONS:
#   1. FontAwesome website: https://fontawesome.com/icons
#      - Search for icon name (e.g., "play", "trash", "cog")
#      - Click icon to see name (e.g., "play" icon = fa-play)
#      - Use with style prefix: fa5.play, fa5r.play, etc.
#   
#   2. qtawesome documentation: https://qtawesome.readthedocs.io/
#      - Lists available icon sets and names
#   
#   3. Common icons used in this app:
#      - fa5.cog (settings/gear)
#      - fa5.trash (delete)
#      - fa5.play (play)
#      - fa5.step-backward, fa5.step-forward (previous/next)
#      - fa5.random (shuffle)
#      - fa5.redo (repeat)
#      - fa5.paste, fa5.copy (clipboard)
#      - fa5.list (playlist)
#      - fa5.external-link-alt (open in browser)
#      - fa5.times (close/X)
#      - fa5.minus, fa5.square (minimize/maximize)
#      - fa5.thumbtack (pin/always on top)
# 
# PERFORMANCE:
#   - Icons are pre-loaded at startup to avoid delays
#   - Helper function get_icon() provides fallback to emojis
#   - If qtawesome fails, app gracefully falls back to emoji icons
# ============================================================================

# FontAwesome icons - auto-install if missing, detect after QApplication exists
try:
    import qtawesome as qta
    HAS_QT_AWESOME = True
    FA_PREFIX = None  # Will be detected lazily after QApplication is created
    _FA_PREFIX_DETECTED = False
except ImportError:
    HAS_QT_AWESOME = False
    FA_PREFIX = None
    _FA_PREFIX_DETECTED = False
    # Try to auto-install qtawesome
    try:
        logger.info("qtawesome not found - attempting automatic installation...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", "qtawesome>=1.2.0", "--quiet", "--disable-pip-version-check"])
        import qtawesome as qta
        HAS_QT_AWESOME = True
        logger.info("qtawesome installed successfully!")
    except Exception as e:
        logger.warning(f"Could not auto-install qtawesome: {e} - falling back to emoji icons")
        HAS_QT_AWESOME = False

def _detect_fontawesome_prefix():
    """Detect which FontAwesome version is available (call after QApplication exists)"""
    global FA_PREFIX, _FA_PREFIX_DETECTED
    
    if _FA_PREFIX_DETECTED or not HAS_QT_AWESOME:
        return FA_PREFIX
    
    # Check if QApplication exists
    try:
        from PyQt6.QtWidgets import QApplication
        app = QApplication.instance()
        if app is None:
            # QApplication not created yet - return None, will detect later
            return None
    except:
        return None
    
    # Now safe to detect - QApplication exists
    try:
        # Try FontAwesome 5 solid first
        try:
            test_icon = qta.icon('fa5s.cog')
            FA_PREFIX = 'fa5s'
            logger.info("Detected FontAwesome 5 solid (fa5s)")
            _FA_PREFIX_DETECTED = True
            return FA_PREFIX
        except Exception as e:
            logger.debug(f"fa5s not available: {e}")
            # Try FontAwesome 5 regular
            try:
                test_icon = qta.icon('fa5.cog')
                FA_PREFIX = 'fa5'
                logger.info("Detected FontAwesome 5 (fa5)")
                _FA_PREFIX_DETECTED = True
                return FA_PREFIX
            except Exception as e:
                logger.debug(f"fa5 not available: {e}")
                # Fall back to FontAwesome 4
                try:
                    test_icon = qta.icon('fa.cog')
                    FA_PREFIX = 'fa'
                    logger.info("Detected FontAwesome 4 (fa)")
                    _FA_PREFIX_DETECTED = True
                    return FA_PREFIX
                except Exception as e:
                    logger.warning(f"Could not detect FontAwesome version: {e} - using 'fa' as fallback")
                    FA_PREFIX = 'fa'  # Default fallback
                    _FA_PREFIX_DETECTED = True
                    return FA_PREFIX
    except Exception as e:
        logger.warning(f"Error detecting FontAwesome prefix: {e}")
        FA_PREFIX = 'fa'  # Default fallback
        _FA_PREFIX_DETECTED = True
        return FA_PREFIX

# Helper function for faster icon creation (with caching)
def get_icon(icon_name, color='#e0e0e0'):
    """Get FontAwesome icon with fallback to emoji
    
    Returns QIcon if successful, None if not available.
    Always check HAS_QT_AWESOME before calling setIcon() with the result.
    """
    if not HAS_QT_AWESOME:
        return None
    
    # Detect prefix if not already detected (lazy detection after QApplication exists)
    if not _FA_PREFIX_DETECTED:
        _detect_fontawesome_prefix()
    
    if not FA_PREFIX:
        return None
    
    try:
        # If icon_name already has a prefix (fa, mdi, ph, msc, ei, etc.), use it as-is
        if '.' in icon_name and (icon_name.startswith('fa') or icon_name.startswith('mdi') or icon_name.startswith('ph') or icon_name.startswith('msc') or icon_name.startswith('ei')):
            # Already has prefix, use as-is
            full_name = icon_name
        else:
            # No prefix, add detected prefix
            full_name = f'{FA_PREFIX}.{icon_name}'
        icon = qta.icon(full_name, color=color)
        if icon and not icon.isNull():
            return icon
        else:
            logger.debug(f"Icon {full_name} returned null or empty")
            # Try with 'fa' prefix as fallback (only for non-prefixed icons)
            if FA_PREFIX != 'fa' and not ('.' in icon_name and (icon_name.startswith('fa') or icon_name.startswith('mdi') or icon_name.startswith('ph') or icon_name.startswith('msc') or icon_name.startswith('ei'))):
                try:
                    fallback_icon = qta.icon(f'fa.{icon_name}', color=color)
                    if fallback_icon and not fallback_icon.isNull():
                        return fallback_icon
                except:
                    pass
            return None
    except Exception as e:
        logger.debug(f"Failed to create icon {icon_name} with prefix {FA_PREFIX}: {e}")
        # Try with 'fa' prefix as fallback (only for non-prefixed icons)
        if FA_PREFIX != 'fa' and not ('.' in icon_name and (icon_name.startswith('fa') or icon_name.startswith('mdi') or icon_name.startswith('ph') or icon_name.startswith('msc') or icon_name.startswith('ei'))):
            try:
                fallback_icon = qta.icon(f'fa.{icon_name}', color=color)
                if fallback_icon and not fallback_icon.isNull():
                    return fallback_icon
            except:
                pass
        return None

def set_icon_safe(widget, icon_name, color='#e0e0e0', fallback_text=None):
    """Safely set icon on widget, falling back to text if icon fails"""
    if HAS_QT_AWESOME:
        icon = get_icon(icon_name, color=color)
        if icon:
            widget.setIcon(icon)
            return True
    # Fallback to text if icon not available
    if fallback_text:
        widget.setText(fallback_text)
    return False

# Required Python version
REQUIRED_PYTHON_VERSION = (3, 11, 6)


# ============================================================================
# CSS INJECTOR CLASS
# ============================================================================

class CSSInjector:
    """Handles CSS injection for compact and bandcamp modes"""
    
    def __init__(self):
        # Lazy load CSS - only generate when first needed
        self._base_css = None
        self._compact_css = None
        self._dark_css = None
        self._bandcamp_css = None
        self._mini_mode_css = None
    
    def get_css(self, compact=False, bandcamp_mode=False, mini_mode_state=0, webview_scrollbar_visible=False):
        """Get combined CSS based on modes (lazy-loaded)
        
        Args:
            compact: Enable compact mode
            bandcamp_mode: Enable bandcamp mode
            mini_mode_state: 0 = Regular, 1 = Mini (cover art), 2 = Micro (player only)
            webview_scrollbar_visible: Show minimalist scrollbar in webview
        """
        # Lazy load CSS only when needed
        if self._base_css is None:
            self._base_css = self.get_base_css()
        if self._compact_css is None:
            self._compact_css = self.get_compact_css()
        if self._bandcamp_css is None:
            self._bandcamp_css = self.get_bandcamp_css()
        if self._mini_mode_css is None:
            self._mini_mode_css = self.get_mini_mode_css()
        
        css_parts = [self._base_css]
        
        if bandcamp_mode:
            css_parts.append(self._bandcamp_css)
        
        if compact:
            css_parts.append(self._compact_css)
        
        # Add mini mode CSS based on state
        if mini_mode_state == 1:
            # Mini mode: overlay player on cover art
            css_parts.append(self._mini_mode_css)
        elif mini_mode_state == 2:
            # Micro mode: show only player
            css_parts.append(self._mini_mode_css)
        
        # Add scrollbar CSS based on setting
        if webview_scrollbar_visible:
            css_parts.append(self._get_scrollbar_css())
        else:
            css_parts.append(self._get_hidden_scrollbar_css())
        
        return "\n\n".join(css_parts)
    
    def get_base_css(self):
        """Base CSS for enhanced button interactions and hover effects"""
        return """
/* Disable text and image selection in web interface */
* {
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
}

/* Disable image dragging */
img {
    -webkit-user-drag: none !important;
    -khtml-user-drag: none !important;
    -moz-user-drag: none !important;
    -o-user-drag: none !important;
    user-drag: none !important;
    pointer-events: auto !important; /* Keep images clickable but not draggable */
}

/* Allow selection in input fields and textareas for functionality */
input, textarea, [contenteditable="true"], [contenteditable="true"] * {
    -webkit-user-select: text !important;
    -moz-user-select: text !important;
    -ms-user-select: text !important;
    user-select: text !important;
}

/* Cover Art Modal - ensure it works on both light and dark pages */
#bandcamp-player-cover-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    z-index: 10000 !important;
    cursor: pointer;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    /* Ensure modal is always on top, regardless of page type */
    pointer-events: auto !important;
}

/* Ensure modal works correctly on dark pages */
body.dark-page #bandcamp-player-cover-modal,
body:not(.light-page) #bandcamp-player-cover-modal {
    z-index: 10000 !important;
    position: fixed !important;
    pointer-events: auto !important;
}

#bandcamp-player-cover-modal.active {
    display: flex !important;
    z-index: 10000 !important;
    position: fixed !important;
    pointer-events: auto !important;
}

/* Ensure active modal works on dark pages */
body.dark-page #bandcamp-player-cover-modal.active,
body:not(.light-page) #bandcamp-player-cover-modal.active {
    display: flex !important;
    z-index: 10000 !important;
    position: fixed !important;
    pointer-events: auto !important;
}

#bandcamp-player-cover-modal-content {
    max-width: 90vw;
    max-height: 90vh;
    object-fit: contain;
    cursor: zoom-in;
    pointer-events: auto !important;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    border-radius: 4px;
    transition: transform 0.1s ease-out;
    transform-origin: center center;
    /* Ensure image is visible on both light and dark pages */
    z-index: 10001 !important;
    position: relative !important;
}

/* Ensure modal content works on dark pages */
body.dark-page #bandcamp-player-cover-modal-content,
body:not(.light-page) #bandcamp-player-cover-modal-content {
    pointer-events: auto !important;
    z-index: 10001 !important;
    position: relative !important;
}

#bandcamp-player-cover-modal-close {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    background-color: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    color: white;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    z-index: 10002 !important;
    pointer-events: auto !important;
}

/* Ensure close button works on dark pages */
body.dark-page #bandcamp-player-cover-modal-close,
body:not(.light-page) #bandcamp-player-cover-modal-close {
    z-index: 10002 !important;
    pointer-events: auto !important;
    position: absolute !important;
}

#bandcamp-player-cover-modal-close:hover {
    background-color: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
    transform: scale(1.1);
}

/* Make cover art clickable - ensure it works on both light and dark pages */
#tralbum-art-carousel,
#tralbum-art-carousel img,
.tralbum-art-carousel-container,
.tralbum-art-carousel-container img {
    cursor: zoom-in !important;
    pointer-events: auto !important;
}

/* Ensure cover art is clickable on dark pages */
body.dark-page #tralbum-art-carousel,
body.dark-page #tralbum-art-carousel img,
body.dark-page .tralbum-art-carousel-container,
body.dark-page .tralbum-art-carousel-container img,
body:not(.light-page) #tralbum-art-carousel,
body:not(.light-page) #tralbum-art-carousel img,
body:not(.light-page) .tralbum-art-carousel-container,
body:not(.light-page) .tralbum-art-carousel-container img {
    cursor: zoom-in !important;
    pointer-events: auto !important;
}

/* Disable zoom-in cursor when menu or volume popup is open */
#tralbum-art-carousel.cursor-disabled,
#tralbum-art-carousel.cursor-disabled img,
.tralbum-art-carousel-container.cursor-disabled,
.tralbum-art-carousel-container.cursor-disabled img {
    cursor: default !important;
}

/* Enhanced Button Hover Styles - only for actually clickable/interactive elements */
.play-btn, .pause-btn, .next-btn, .prev-btn,
.play_cell, .pause_cell, .next_cell, .prev_cell,
.playbutton, .prevbutton, .nextbutton,
.playButton, .prevButton, .nextButton,
button[title*="play"], button[title*="Play"],
button[title*="pause"], button[title*="Pause"],
button[title*="next"], button[title*="Next"],
button[title*="previous"], button[title*="Previous"],
.player-controls button,
.transport-controls button,
.control-button,
[class*="play"]:not([class*="track"]):not([class*="Track"]), 
[class*="Play"]:not([class*="track"]):not([class*="Track"]),
[class*="pause"]:not([class*="track"]):not([class*="Track"]), 
[class*="Pause"]:not([class*="track"]):not([class*="Track"]),
[class*="next"]:not([class*="track"]):not([class*="Track"]), 
[class*="Next"]:not([class*="track"]):not([class*="Track"]),
[class*="prev"]:not([class*="track"]):not([class*="Track"]), 
[class*="Prev"]:not([class*="track"]):not([class*="Track"]),
.clickable, .interactive, .hoverable,
[onclick], [role="button"],
.inline_player .playbutton,
.progbar, .time_elapsed, .time_total,
.prev_button, .next_button, .play_pause_button,
a, button, input[type="button"], input[type="submit"] {
    cursor: pointer !important;
    transition: all 0.2s ease !important;
}

/* Tracks are clickable, so they get pointer cursor */
.track, .tracklist-item, .playlist-item,
.track-item, .song-item, .music-item,
.track_row_view, .track_list .track,
.scrobbler-track, .lastfm-track {
    cursor: pointer !important;
    transition: all 0.2s ease !important;
}

/* Hover effects - subtle, no zoom */
.play-btn:hover, .pause-btn:hover, .next-btn:hover, .prev-btn:hover,
.play_cell:hover, .pause_cell:hover, .next_cell:hover, .prev_cell:hover,
.playbutton:hover, .prevbutton:hover, .nextbutton:hover,
.playButton:hover, .prevButton:hover, .nextButton:hover,
button[title*="play"]:hover, button[title*="Play"]:hover,
button[title*="pause"]:hover, button[title*="Pause"]:hover,
button[title*="next"]:hover, button[title*="Next"]:hover,
button[title*="previous"]:hover, button[title*="Previous"]:hover,
.player-controls button:hover,
.transport-controls button:hover,
.control-button:hover,
[class*="play"]:hover, [class*="Play"]:hover,
[class*="pause"]:hover, [class*="Pause"]:hover,
[class*="next"]:hover, [class*="Next"]:hover,
[class*="prev"]:hover, [class*="Prev"]:hover {
    opacity: 0.9 !important;
    filter: brightness(1.1) !important;
}

/* Override body hover effects - prevent unwanted opacity/brightness changes */
/* Place AFTER other hover rules and use high specificity to ensure these rules always apply */
html body:hover,
body:hover,
body[class]:hover,
body[class*="webkit"]:hover,
body[class*="safari"]:hover,
body[class*="safariLte14"]:hover,
body[class*="tralbum"]:hover,
body[class*="tralbum-page"]:hover,
body[class*="dynamic"]:hover,
body[class*="dynamic-cart"]:hover,
body[class*="enable"]:hover,
body[class*="enable-cookie-control"]:hover,
body[class*="vue"]:hover,
body[class*="vue-prevent-scroll"]:hover,
body[class*="light"]:hover,
body[class*="light-page"]:hover {
    opacity: 1 !important;
    filter: brightness(1) !important;
}

/* Remove pointer cursor from body to allow native cursor states */
/* Place AFTER other cursor rules and use high specificity to ensure this rule always applies */
html body,
body,
body[class],
body[class*="webkit"],
body[class*="safari"],
body[class*="safariLte14"],
body[class*="tralbum"],
body[class*="tralbum-page"],
body[class*="dynamic"],
body[class*="dynamic-cart"],
body[class*="enable"],
body[class*="enable-cookie-control"],
body[class*="vue"],
body[class*="vue-prevent-scroll"],
body[class*="light"],
body[class*="light-page"] {
    cursor: default !important;
}

/* Prevent tracklist container from highlighting on hover */
#tracklist:hover,
.tracklist:hover,
[class*="tracklist"]:hover:not([class*="track"]):not([class*="item"]) {
    background-color: transparent !important;
    backdrop-filter: none !important;
}

/* Playlist/track item hover effects - only for individual tracks */
.track:hover,
.tracklist-item:hover,
.playlist-item:hover,
.track-item:hover,
.song-item:hover,
.music-item:hover,
.scrobbler-track:hover,
.lastfm-track:hover,
.track_row_view:hover,
.track_list .track:hover,
[class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks),
[class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks),
[class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks),
[class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks) {
    background-color: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    /* Use pseudo-element for full-width background to avoid affecting content position */
    position: relative !important;
}

/* Full-width hover background using pseudo-element - keeps content in place */
.track:hover::before,
.tracklist-item:hover::before,
.playlist-item:hover::before,
.track-item:hover::before,
.song-item:hover::before,
.music-item:hover::before,
.scrobbler-track:hover::before,
.lastfm-track:hover::before,
.track_row_view:hover::before,
.track_list .track:hover::before,
[class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
[class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
[class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
[class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before {
    content: '' !important;
    position: absolute !important;
    top: 0 !important;
    /* Base track has margin-left: 2px, so extend 22px left (2px margin + 20px extension) to reach container edge */
    left: -22px !important;
    /* Extend all the way to the right edge - account for margin-right: -2px */
    right: 0px !important;
    bottom: 0 !important;
    background-color: rgba(255, 255, 255, 0.05) !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    z-index: -1 !important;
    pointer-events: none !important;
}

/* Base track styles - applied in all modes */
.track, .tracklist-item {
    padding: 4px 0px 4px 5px !important;
    margin: 2px -2px 0px 2px !important;
}

/* Ensure track-num doesn't inherit or get affected by parent padding/margin */
.track .track-num,
.track .track-number,
.tracklist-item .track-num,
.tracklist-item .track-number,
[class*="track"] .track-num:not([class*="tracklist"]),
[class*="track"] .track-number:not([class*="tracklist"]) {
    padding: 0 !important;
    margin: 0 !important;
    margin-right: 8px !important; /* Add space between track number and track name */
    position: relative !important;
    transform: none !important;
    transition: none !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
    white-space: nowrap !important; /* Prevent track number from wrapping */
    display: inline-block !important; /* Ensure it stays inline */
}

/* Ensure track-num doesn't move when parent track is hovered */
.track:hover .track-num,
.track:hover .track-number,
.tracklist-item:hover .track-num,
.tracklist-item:hover .track-number,
[class*="track"]:hover .track-num:not([class*="tracklist"]),
[class*="track"]:hover .track-number:not([class*="tracklist"]) {
    padding: 0 !important;
    margin: 0 !important;
    margin-right: 8px !important; /* Maintain spacing */
    position: relative !important;
    transform: none !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
    white-space: nowrap !important; /* Prevent track number from wrapping */
    display: inline-block !important; /* Ensure it stays inline */
}

/* Disable all hover effects on track numbers in the player (all modes) */
#player .track-number:hover,
#player .track-num:hover,
#player:hover .track-number,
#player:hover .track-num,
.player-container .track-number:hover,
.player-container .track-num:hover,
.player-container:hover .track-number,
.player-container:hover .track-num,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-number,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-num {
    background-color: transparent !important;
    background: transparent !important;
    color: inherit !important;
    opacity: 1 !important;
    filter: none !important;
    transform: none !important;
    padding: 0 !important;
    margin: 0 !important;
    margin-right: 8px !important;
    border: none !important;
    box-shadow: none !important;
    text-decoration: none !important;
    transition: none !important;
}

/* Prevent track-action button from moving on hover */
.track .track-action,
.track button.track-action,
.tracklist-item .track-action,
.tracklist-item button.track-action,
[class*="track"] .track-action:not([class*="tracklist"]),
[class*="track"] button.track-action:not([class*="tracklist"]) {
    position: relative !important;
    margin: 0 !important;
    padding: 0 !important;
    transform: none !important;
    transition: none !important;
}

/* Ensure track-action doesn't move when parent track is hovered */
.track:hover .track-action,
.track:hover button.track-action,
.tracklist-item:hover .track-action,
.tracklist-item:hover button.track-action,
[class*="track"]:hover .track-action:not([class*="tracklist"]),
[class*="track"]:hover button.track-action:not([class*="tracklist"]) {
    position: relative !important;
    margin: 0 !important;
    padding: 0 !important;
    transform: none !important;
    left: 0 !important;
    right: 0 !important;
    top: 0 !important;
    bottom: 0 !important;
}

/* Disable hover effects for track-info elements */
.track-info:hover,
.track-info:focus,
.track-info:focus-within {
    background-color: transparent !important;
    backdrop-filter: none !important;
    border-radius: 0 !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
}

/* Currently playing track highlighting */
.track.playing, .tracklist-item.playing, .playlist-item.playing,
.track-item.playing, .song-item.playing, .music-item.playing,
.track.current, .tracklist-item.current, .playlist-item.current,
.track-item.current, .song-item.current, .music-item.current,
.track.active, .tracklist-item.active, .playlist-item.active,
.track-item.active, .song-item.active, .music-item.active,
[class*="track"].playing, [class*="Track"].playing,
[class*="song"].playing, [class*="Song"].playing,
[class*="track"].current, [class*="Track"].current,
[class*="song"].current, [class*="Song"].current,
[class*="track"].active, [class*="Track"].active,
[class*="song"].active, [class*="Song"].active,
.track_row_view.playing, .track_list .track.playing,
.scrobbler-track.playing, .lastfm-track.playing,
[aria-current="true"], [data-playing="true"],
.now-playing, .currently-playing, .is-playing {
    position: relative !important;
    background-color: transparent !important;
    background: transparent !important;
    /* Keep content in place - don't change padding/margin */
}

/* Full-width highlight background for currently playing track using pseudo-element */
.track.playing::before, .tracklist-item.playing::before, .playlist-item.playing::before,
.track-item.playing::before, .song-item.playing::before, .music-item.playing::before,
.track.current::before, .tracklist-item.current::before, .playlist-item.current::before,
.track-item.current::before, .song-item.current::before, .music-item.current::before,
.track.active::before, .tracklist-item.active::before, .playlist-item.active::before,
.track-item.active::before, .song-item.active::before, .music-item.active::before,
[class*="track"].playing::before, [class*="Track"].playing::before,
[class*="song"].playing::before, [class*="Song"].playing::before,
[class*="track"].current::before, [class*="Track"].current::before,
[class*="song"].current::before, [class*="Song"].current::before,
[class*="track"].active::before, [class*="Track"].active::before,
[class*="song"].active::before, [class*="Song"].active::before,
.track_row_view.playing::before, .track_list .track.playing::before,
.scrobbler-track.playing::before, .lastfm-track.playing::before,
[aria-current="true"]::before, [data-playing="true"]::before,
.now-playing::before, .currently-playing::before, .is-playing::before {
    content: '' !important;
    position: absolute !important;
    top: 0 !important;
    /* Extend to full viewport width: left edge at viewport left, width spans full viewport */
    left: calc(-50vw + 50%) !important;
    width: 100vw !important;
    height: 100% !important;
    background: linear-gradient(90deg, 
        rgba(255, 215, 0, 0.15) 0%, 
        rgba(255, 215, 0, 0.08) 50%, 
        rgba(255, 215, 0, 0.15) 100%) !important;
    border-left: 3px solid rgba(255, 215, 0, 0.6) !important;
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.2) !important;
    border-radius: 4px !important;
    animation: currentTrackPulse 2s ease-in-out infinite alternate !important;
    z-index: 0 !important;
    pointer-events: none !important;
}

@keyframes currentTrackPulse {
    0% { 
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.2) !important;
    }
    100% { 
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.4) !important;
    }
}

/* Darker hover and currently playing track styles for light-colored pages */
/* Uses .light-page class added by JavaScript detection - applies to ALL modes (regular, mini, micro) */
body.light-page .track:hover::before,
body.light-page.mini-mode .track:hover::before,
body.light-page.micro-mode .track:hover::before,
body.light-page .tracklist-item:hover::before,
body.light-page.mini-mode .tracklist-item:hover::before,
body.light-page.micro-mode .tracklist-item:hover::before,
body.light-page .playlist-item:hover::before,
body.light-page.mini-mode .playlist-item:hover::before,
body.light-page.micro-mode .playlist-item:hover::before,
body.light-page .track-item:hover::before,
body.light-page.mini-mode .track-item:hover::before,
body.light-page.micro-mode .track-item:hover::before,
body.light-page .song-item:hover::before,
body.light-page.mini-mode .song-item:hover::before,
body.light-page.micro-mode .song-item:hover::before,
body.light-page .music-item:hover::before,
body.light-page.mini-mode .music-item:hover::before,
body.light-page.micro-mode .music-item:hover::before,
body.light-page .scrobbler-track:hover::before,
body.light-page.mini-mode .scrobbler-track:hover::before,
body.light-page.micro-mode .scrobbler-track:hover::before,
body.light-page .lastfm-track:hover::before,
body.light-page.mini-mode .lastfm-track:hover::before,
body.light-page.micro-mode .lastfm-track:hover::before,
body.light-page .track_row_view:hover::before,
body.light-page.mini-mode .track_row_view:hover::before,
body.light-page.micro-mode .track_row_view:hover::before,
body.light-page .track_list .track:hover::before,
body.light-page.mini-mode .track_list .track:hover::before,
body.light-page.micro-mode .track_list .track:hover::before,
body.light-page [class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.mini-mode [class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.micro-mode [class*="track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page [class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.mini-mode [class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.micro-mode [class*="Track"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page [class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.mini-mode [class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.micro-mode [class*="song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page [class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.mini-mode [class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before,
body.light-page.micro-mode [class*="Song"]:hover:not([class*="tracklist"]):not(.track-info):not(.tracks)::before {
    background-color: rgba(0, 0, 0, 0.15) !important;
}

/* Darker currently playing track for light pages - applies to ALL modes (regular, mini, micro) */
body.light-page .track.playing::before,
body.light-page.mini-mode .track.playing::before,
body.light-page.micro-mode .track.playing::before,
body.light-page .tracklist-item.playing::before,
body.light-page.mini-mode .tracklist-item.playing::before,
body.light-page.micro-mode .tracklist-item.playing::before,
body.light-page .playlist-item.playing::before,
body.light-page.mini-mode .playlist-item.playing::before,
body.light-page.micro-mode .playlist-item.playing::before,
body.light-page .track-item.playing::before,
body.light-page.mini-mode .track-item.playing::before,
body.light-page.micro-mode .track-item.playing::before,
body.light-page .song-item.playing::before,
body.light-page.mini-mode .song-item.playing::before,
body.light-page.micro-mode .song-item.playing::before,
body.light-page .music-item.playing::before,
body.light-page.mini-mode .music-item.playing::before,
body.light-page.micro-mode .music-item.playing::before,
body.light-page .track.current::before,
body.light-page.mini-mode .track.current::before,
body.light-page.micro-mode .track.current::before,
body.light-page .tracklist-item.current::before,
body.light-page.mini-mode .tracklist-item.current::before,
body.light-page.micro-mode .tracklist-item.current::before,
body.light-page .playlist-item.current::before,
body.light-page.mini-mode .playlist-item.current::before,
body.light-page.micro-mode .playlist-item.current::before,
body.light-page .track-item.current::before,
body.light-page.mini-mode .track-item.current::before,
body.light-page.micro-mode .track-item.current::before,
body.light-page .song-item.current::before,
body.light-page.mini-mode .song-item.current::before,
body.light-page.micro-mode .song-item.current::before,
body.light-page .music-item.current::before,
body.light-page.mini-mode .music-item.current::before,
body.light-page.micro-mode .music-item.current::before,
body.light-page .track.active::before,
body.light-page.mini-mode .track.active::before,
body.light-page.micro-mode .track.active::before,
body.light-page .tracklist-item.active::before,
body.light-page.mini-mode .tracklist-item.active::before,
body.light-page.micro-mode .tracklist-item.active::before,
body.light-page .playlist-item.active::before,
body.light-page.mini-mode .playlist-item.active::before,
body.light-page.micro-mode .playlist-item.active::before,
body.light-page .track-item.active::before,
body.light-page.mini-mode .track-item.active::before,
body.light-page.micro-mode .track-item.active::before,
body.light-page .song-item.active::before,
body.light-page.mini-mode .song-item.active::before,
body.light-page.micro-mode .song-item.active::before,
body.light-page .music-item.active::before,
body.light-page.mini-mode .music-item.active::before,
body.light-page.micro-mode .music-item.active::before,
body.light-page [class*="track"].playing::before,
body.light-page.mini-mode [class*="track"].playing::before,
body.light-page.micro-mode [class*="track"].playing::before,
body.light-page [class*="Track"].playing::before,
body.light-page.mini-mode [class*="Track"].playing::before,
body.light-page.micro-mode [class*="Track"].playing::before,
body.light-page [class*="song"].playing::before,
body.light-page.mini-mode [class*="song"].playing::before,
body.light-page.micro-mode [class*="song"].playing::before,
body.light-page [class*="Song"].playing::before,
body.light-page.mini-mode [class*="Song"].playing::before,
body.light-page.micro-mode [class*="Song"].playing::before,
body.light-page [class*="track"].current::before,
body.light-page.mini-mode [class*="track"].current::before,
body.light-page.micro-mode [class*="track"].current::before,
body.light-page [class*="Track"].current::before,
body.light-page.mini-mode [class*="Track"].current::before,
body.light-page.micro-mode [class*="Track"].current::before,
body.light-page [class*="song"].current::before,
body.light-page.mini-mode [class*="song"].current::before,
body.light-page.micro-mode [class*="song"].current::before,
body.light-page [class*="Song"].current::before,
body.light-page.mini-mode [class*="Song"].current::before,
body.light-page.micro-mode [class*="Song"].current::before,
body.light-page [class*="track"].active::before,
body.light-page.mini-mode [class*="track"].active::before,
body.light-page.micro-mode [class*="track"].active::before,
body.light-page [class*="Track"].active::before,
body.light-page.mini-mode [class*="Track"].active::before,
body.light-page.micro-mode [class*="Track"].active::before,
body.light-page [class*="song"].active::before,
body.light-page.mini-mode [class*="song"].active::before,
body.light-page.micro-mode [class*="song"].active::before,
body.light-page [class*="Song"].active::before,
body.light-page.mini-mode [class*="Song"].active::before,
body.light-page.micro-mode [class*="Song"].active::before,
body.light-page .track_row_view.playing::before,
body.light-page.mini-mode .track_row_view.playing::before,
body.light-page.micro-mode .track_row_view.playing::before,
body.light-page .track_list .track.playing::before,
body.light-page.mini-mode .track_list .track.playing::before,
body.light-page.micro-mode .track_list .track.playing::before,
body.light-page .scrobbler-track.playing::before,
body.light-page.mini-mode .scrobbler-track.playing::before,
body.light-page.micro-mode .scrobbler-track.playing::before,
body.light-page .lastfm-track.playing::before,
body.light-page.mini-mode .lastfm-track.playing::before,
body.light-page.micro-mode .lastfm-track.playing::before,
body.light-page [aria-current="true"]::before,
body.light-page.mini-mode [aria-current="true"]::before,
body.light-page.micro-mode [aria-current="true"]::before,
body.light-page [data-playing="true"]::before,
body.light-page.mini-mode [data-playing="true"]::before,
body.light-page.micro-mode [data-playing="true"]::before,
body.light-page .now-playing::before,
body.light-page.mini-mode .now-playing::before,
body.light-page.micro-mode .now-playing::before,
body.light-page .currently-playing::before,
body.light-page.mini-mode .currently-playing::before,
body.light-page.micro-mode .currently-playing::before,
body.light-page .is-playing::before,
body.light-page.mini-mode .is-playing::before,
body.light-page.micro-mode .is-playing::before {
    background: linear-gradient(90deg, 
        rgba(255, 165, 0, 0.35) 0%, 
        rgba(255, 165, 0, 0.25) 50%, 
        rgba(255, 165, 0, 0.35) 100%) !important;
    border-left: 3px solid rgba(255, 140, 0, 0.8) !important;
    box-shadow: 0 0 10px rgba(255, 140, 0, 0.4) !important;
    animation: currentTrackPulseLight 2s ease-in-out infinite alternate !important;
}

/* Darker pulse animation for light pages */
@keyframes currentTrackPulseLight {
    0% { 
        box-shadow: 0 0 10px rgba(255, 140, 0, 0.4) !important;
    }
    100% { 
        box-shadow: 0 0 15px rgba(255, 140, 0, 0.6) !important;
    }
}

/* Progress bar hover effects */
.progbar:hover, .progress-bar:hover, .seek-bar:hover,
[class*="progress"]:hover, [class*="Progress"]:hover,
[class*="seek"]:hover, [class*="Seek"]:hover {
    cursor: pointer !important;
    filter: brightness(1.3) !important;
}

/* Disable "Go to track page" disclose links - keep visible but not clickable */
a.disclose,
a[class*="disclose"],
a[aria-label*="Go to track page"],
a[aria-label*="go to track page"],
a[href*="/track/"].disclose {
    pointer-events: none !important;
    cursor: default !important;
    opacity: 0.5 !important; /* Make it visually distinct that it's disabled */
}

/* Make disclose arrow darker on light pages for better contrast - applies to ALL modes (regular, mini, micro) */
body.light-page a.disclose,
body.light-page.mini-mode a.disclose,
body.light-page.micro-mode a.disclose,
body.light-page a[class*="disclose"],
body.light-page.mini-mode a[class*="disclose"],
body.light-page.micro-mode a[class*="disclose"],
body.light-page a[aria-label*="Go to track page"],
body.light-page.mini-mode a[aria-label*="Go to track page"],
body.light-page.micro-mode a[aria-label*="Go to track page"],
body.light-page a[aria-label*="go to track page"],
body.light-page.mini-mode a[aria-label*="go to track page"],
body.light-page.micro-mode a[aria-label*="go to track page"],
body.light-page a[href*="/track/"].disclose,
body.light-page.mini-mode a[href*="/track/"].disclose,
body.light-page.micro-mode a[href*="/track/"].disclose,
body.light-page a.disclose .goto-icon,
body.light-page.mini-mode a.disclose .goto-icon,
body.light-page.micro-mode a.disclose .goto-icon,
body.light-page a.disclose svg,
body.light-page.mini-mode a.disclose svg,
body.light-page.micro-mode a.disclose svg,
body.light-page a[class*="disclose"] .goto-icon,
body.light-page.mini-mode a[class*="disclose"] .goto-icon,
body.light-page.micro-mode a[class*="disclose"] .goto-icon,
body.light-page a[class*="disclose"] svg,
body.light-page.mini-mode a[class*="disclose"] svg,
body.light-page.micro-mode a[class*="disclose"] svg {
    opacity: 0.7 !important; /* Slightly more visible on light pages */
    filter: brightness(0) !important; /* Make it black/dark instead of white */
}

/* Hide disclose link icon for currently playing track */
.track.playing a.disclose,
.track.playing a[class*="disclose"],
.track.playing a[aria-label*="Go to track page"],
.track.playing a[aria-label*="go to track page"],
.track.playing a[href*="/track/"].disclose,
.tracklist-item.playing a.disclose,
.tracklist-item.playing a[class*="disclose"],
.tracklist-item.playing a[aria-label*="Go to track page"],
.tracklist-item.playing a[aria-label*="go to track page"],
.tracklist-item.playing a[href*="/track/"].disclose,
[class*="track"].playing a.disclose,
[class*="track"].playing a[class*="disclose"],
[class*="track"].playing a[aria-label*="Go to track page"],
[class*="track"].playing a[aria-label*="go to track page"],
[class*="track"].playing a[href*="/track/"].disclose {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    width: 0 !important;
    height: 0 !important;
    overflow: hidden !important;
}
"""
    
    def get_compact_css(self):
        """CSS for compact mode - hides non-essential elements"""
        return """
/* Compact Mode - Hide non-essential elements */
.header, .site-header, .page-header,
.footer, .site-footer, .page-footer,
.sidebar, .navigation, nav,
.comments, .comment-section,
.share-buttons, .social-share,
.related-albums, .recommendations,
.bio, .artist-bio, .description-text {
    display: none !important;
}

/* Compact player controls */
.inline_player, .player-container {
    padding: 5px !important;
    margin: 5px !important;
}

/* Reduce spacing */
.track, .tracklist-item {
    padding: 4px 0px 4px 5px !important;
    margin: 2px -2px 0px 2px !important;
}

/* Compact album art */
.album-art, .cover-art, img[class*="art"] {
    max-width: 100px !important;
    max-height: 100px !important;
}
"""
    
    def get_dark_css(self):
        """CSS for dark mode"""
        return """
/* Dark Mode */
body, html {
    background-color: #1a1a1a !important;
    color: #e0e0e0 !important;
}

/* Dark backgrounds */
.container, .content, .main-content,
.album, .track-list, .playlist {
    background-color: #1a1a1a !important;
    color: #e0e0e0 !important;
}

/* Dark cards/panels */
.card, .panel, .box, .item {
    background-color: #2a2a2a !important;
    color: #e0e0e0 !important;
    border-color: #3a3a3a !important;
}

/* Dark links */
a, a:link, a:visited {
    color: #4a9eff !important;
}

a:hover, a:active {
    color: #6bb3ff !important;
}

/* Dark buttons */
button, .button, .btn {
    background-color: #3a3a3a !important;
    color: #e0e0e0 !important;
    border-color: #4a4a4a !important;
}

button:hover, .button:hover, .btn:hover {
    background-color: #4a4a4a !important;
}

/* Dark inputs */
input, textarea, select {
    background-color: #2a2a2a !important;
    color: #e0e0e0 !important;
    border-color: #3a3a3a !important;
}
"""
    
    def get_bandcamp_css(self):
        """CSS for Bandcamp mode - hides unwanted elements, shows only essential player content"""
        return """
/* Bandcamp Mode - Hide unwanted elements, show only essential player content */

/* Ensure scrolling still works with smooth behavior */
html, body {
    overflow-x: hidden !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch !important; /* Smooth scrolling on iOS/WebKit */
    scroll-behavior: smooth !important; /* Smooth scrolling for programmatic scrolling */
}

/* Hide the annoying sticky player overlay in all modes */
#sticky-player,
.sticky-player-container,
#sticky-player-marker {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    z-index: -1 !important;
    position: absolute !important;
    top: -9999px !important;
    left: -9999px !important;
    transform: translateX(-9999px) !important;
}

/* Override all possible sticky player states */
#sticky-player.sliding,
#sticky-player.visible,
#sticky-player.sliding.visible,
.sticky-player-container.sliding,
.sticky-player-container.visible,
.sticky-player-container.sliding.visible {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    z-index: -1 !important;
    position: absolute !important;
    top: -9999px !important;
    left: -9999px !important;
    transform: translateX(-9999px) !important;
}

/* Hide specific unwanted elements */
nav#menubar.logged-in,
header#tralbum-header.tralbum-header,
div#tralbum-actions.tralbum-actions-container.desktop-right,
div#tralbum-digital-only.tralbum-digital-only-container.desktop-left,
section#supporters.supporters-container.desktop-right,
section#tags.tags-container.desktop-left,
section#artist-profile.desktop-sidebar.artist-profile-container,
section#recommendations-footer.recommendations-footer-container.desktop-footer,
section#tralbum-credits,
section#purchase-options,
div#TralbumPage {
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
    margin: 0 !important;
    padding: 0 !important;
}

/* Ensure our 4 key sections remain visible */
#tralbum-art-carousel,
#player,
#tracklist,
#about-tralbum {
    visibility: visible !important;
}

/* Hide carousel controls/indicators */
.carousel-indication,
[role="tablist"][data-tabroot="tralbum-art-carousel"],
.img-indicator,
button[role="tab"][data-tabroot="tralbum-art-carousel"],
button[aria-label*="View carousel panel"],
button[aria-label*="carousel panel"] {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
    pointer-events: none !important;
    width: 0 !important;
    height: 0 !important;
    overflow: hidden !important;
}

/* Responsive cover art - scales to fit window */
#tralbum-art-carousel {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

#tralbum-art-carousel img {
    margin: 0 auto !important;
    display: block !important;
    max-width: 100% !important;
    height: auto !important;
    width: auto !important;
}

.p-tralbum-page-container .tralbum-art-carousel-container {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

.p-tralbum-page-container .tralbum-art-carousel-container .carousel {
    width: 100% !important;
    max-width: 100% !important;
}

.p-tralbum-page-container .tralbum-art-carousel-container .carousel .carousel-item {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

.p-tralbum-page-container .tralbum-art-carousel-container .carousel .carousel-item img {
    width: 100% !important;
    max-width: 100% !important;
    height: auto !important;
    object-fit: contain !important;
}

.p-tralbum-page-container .player-container .progress-container {
    margin-top: 12px !important;    
}

/* Fix white background at bottom of page in Bandcamp mode */
body {
    background-color: #212121 !important;
    /* Prevent extra height that could show dark background block */
    min-height: auto !important;
    height: auto !important;
    /* Ensure body only shows background where there's actual content */
    overflow-y: auto !important;
}

/* Override dark body background for light pages in micro mode - keep tracklist readable */
/* This must be more specific than the general body rule above */
body.micro-mode.light-page,
body.micro-mode.light-page html {
    background-color: transparent !important;
    background: transparent !important;
}

/* Override dark page container backgrounds for light pages in micro mode */
body.micro-mode.light-page #pgBd,
body.micro-mode.light-page .p-tralbum-page-container,
body.micro-mode.light-page .leftColumn,
body.micro-mode.light-page .rightColumn {
    background-color: transparent !important;
    background: transparent !important;
}

/* Prevent dark block at bottom - ensure html doesn't have extra height */
html {
    height: auto !important;
    min-height: auto !important;
    overflow-y: auto !important;
}

/* Additional safeguard: ensure page container doesn't create extra space */
#pgBd,
.p-tralbum-page-container {
    min-height: auto !important;
    height: auto !important;
}

/* Responsive container - scales with window */
#pgBd,
.p-tralbum-page-container,
.leftColumn,
.rightColumn {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* Responsive player */
#player {
    width: 100% !important;
    max-width: 100% !important;
    margin-bottom: 5px !important;
    box-sizing: border-box !important;
    /* Ensure player is NOT absolutely positioned unless in mini/micro mode */
    position: relative !important;
}

/* Explicitly reset player positioning when NOT in mini/micro mode (but preserve spacing) */
body:not(.mini-mode):not(.micro-mode) #player {
    position: relative !important;
    bottom: auto !important;
    left: auto !important;
    right: auto !important;
    z-index: auto !important;
    /* Don't remove margin/padding - preserve spacing in regular mode */
}

/* Additional safeguard: prevent any absolute positioning on player container when not in mini mode */
body:not(.mini-mode):not(.micro-mode) .player-container {
    position: relative !important;
    bottom: auto !important;
}

#player * {
    max-width: 90% !important;
    box-sizing: border-box !important;
}

/* Next/Previous controls sizing - ensure buttons maintain their size */
/* These rules must come after #player * and have higher specificity */
#player .next-prev-controls,
#player .next-prev-controls *,
.next-prev-controls,
.next-prev-controls * {
    min-width: auto !important;
    width: auto !important;
    max-width: none !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    box-sizing: border-box !important;
}

/* Ensure the container itself maintains proper display */
#player .next-prev-controls {
    display: inline-flex !important;
    align-items: center !important;
}

/* Ensure next/previous track buttons are always visible and maintain default size */
/* Use both #player prefix and no prefix to match micro mode pattern */
.next-prev-controls button,
.next-prev-controls button[aria-label*="Skip to previous"],
.next-prev-controls button[aria-label*="Skip to next"],
.next-prev-controls button[aria-label*="previous"],
.next-prev-controls button[aria-label*="next"],
#player .next-prev-controls button,
#player .next-prev-controls button[aria-label*="Skip to previous"],
#player .next-prev-controls button[aria-label*="Skip to next"],
#player .next-prev-controls button[aria-label*="previous"],
#player .next-prev-controls button[aria-label*="next"] {
    min-width: 24px !important;
    width: 24px !important;
    height: 24px !important;
    min-height: 24px !important;
    max-width: 24px !important;
    max-height: 24px !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    visibility: visible !important;
    display: inline-block !important;
    opacity: 1 !important;
    pointer-events: auto !important;
    position: relative !important;
    margin: 0 2px !important;
    padding: 0 !important;
}

.next-prev-controls svg,
.next-prev-controls button svg,
#player .next-prev-controls svg,
#player .next-prev-controls button svg {
    width: 16px !important;
    height: 16px !important;
    min-width: 16px !important;
    min-height: 16px !important;
    max-width: 16px !important;
    max-height: 16px !important;
    flex-shrink: 0 !important;
}

/* Responsive tracklist */
#tracklist {
    width: 100% !important;
    max-width: 100% !important;
    margin-top: 5px !important;
    padding-top: 3px !important;
    box-sizing: border-box !important;
}

/* Tracklist arrow/goto icon styling for better visibility */
#tracklist .goto-icon,
#tracklist svg[class*="arrow"],
#tracklist svg[class*="goto"],
#tracklist svg[class*="chevron"] {
    filter: brightness(0) invert(1) !important;
}

/* Make goto icon darker on light pages for better contrast - applies to ALL modes (regular, mini, micro) */
body.light-page #tracklist .goto-icon,
body.light-page.mini-mode #tracklist .goto-icon,
body.light-page.micro-mode #tracklist .goto-icon,
body.light-page #tracklist svg[class*="arrow"],
body.light-page.mini-mode #tracklist svg[class*="arrow"],
body.light-page.micro-mode #tracklist svg[class*="arrow"],
body.light-page #tracklist svg[class*="goto"],
body.light-page.mini-mode #tracklist svg[class*="goto"],
body.light-page.micro-mode #tracklist svg[class*="goto"],
body.light-page #tracklist svg[class*="chevron"],
body.light-page.mini-mode #tracklist svg[class*="chevron"],
body.light-page.micro-mode #tracklist svg[class*="chevron"],
body.light-page .goto-icon,
body.light-page.mini-mode .goto-icon,
body.light-page.micro-mode .goto-icon,
body.light-page svg[class*="arrow"],
body.light-page.mini-mode svg[class*="arrow"],
body.light-page.micro-mode svg[class*="arrow"],
body.light-page svg[class*="goto"],
body.light-page.mini-mode svg[class*="goto"],
body.light-page.micro-mode svg[class*="goto"],
body.light-page svg[class*="chevron"],
body.light-page.mini-mode svg[class*="chevron"],
body.light-page.micro-mode svg[class*="chevron"] {
    filter: brightness(0) !important; /* Make it black/dark instead of white on light pages */
}

#tracklist * {
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* Tracklist ol.tracks styling for regular mode */
ol.tracks {
    background-color: transparent !important;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    margin-left: -20px !important;
    margin-right: 0px !important;
    padding-left: 20px !important;
    padding-right: 0px !important;
}

/* Override track number calculation in grid */
:where(.p-tralbum-page-container) section.tracklist-container ol.tracks li.track,
.p-tralbum-page-container section.tracklist-container ol.tracks li.track,
section.tracklist-container ol.tracks li.track,
ol.tracks li.track {
    grid-template-columns: calc(1rem + var(--track-num-padding)) minmax(0, 1fr) auto min-content !important;
}

/* Responsive about section */
#about-tralbum {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

#about-tralbum * {
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* Ensure images don't overflow */
img {
    max-width: 100% !important;
    height: auto !important;
    object-fit: contain !important;
}

/* Enhanced minimize mode - hide everything except player */
body.bandcamp-minimized {
    background-color: #212121 !important;
}

body.bandcamp-minimized #tralbum-art-carousel,
body.bandcamp-minimized #tracklist,
body.bandcamp-minimized #about-tralbum {
    visibility: hidden !important;
    height: 0 !important;
    overflow: hidden !important;
    margin: 0 !important;
    padding: 0 !important;
}

body.bandcamp-minimized #player {
    visibility: visible !important;
}
"""
    
    def _get_hidden_scrollbar_css(self):
        """CSS to hide scrollbars completely"""
        return """
/* Hide scrollbars but keep scrolling functionality */
::-webkit-scrollbar {
    width: 0px !important;
    height: 0px !important;
    background: transparent !important;
}

::-webkit-scrollbar-track {
    background: transparent !important;
}

::-webkit-scrollbar-thumb {
    background: transparent !important;
}

/* Hide scrollbars for Firefox */
* {
    scrollbar-width: none !important;
    -ms-overflow-style: none !important;
}
"""
    
    def _get_scrollbar_css(self):
        """CSS for minimalist, unobtrusive scrollbar (similar to playlist style)"""
        return """
/* Minimalist scrollbar - thin, unobtrusive, similar to playlist style */
/* Style both vertical and horizontal scrollbars to match */
/* Base rule - applies to all scrollbars - MUST come first */
::-webkit-scrollbar,
*::-webkit-scrollbar,
html::-webkit-scrollbar,
body::-webkit-scrollbar,
#pgBd::-webkit-scrollbar,
.p-tralbum-page-container::-webkit-scrollbar {
    width: 10px !important;
    height: 10px !important; /* Match vertical scrollbar thickness - CRITICAL for horizontal */
    background: transparent !important;
}

/* Vertical scrollbar track */
::-webkit-scrollbar:vertical {
    width: 10px !important;
    background: transparent !important;
}

/* Horizontal scrollbar track - match vertical thickness */
/* Use more specific selectors to ensure it applies everywhere */
::-webkit-scrollbar:horizontal,
*::-webkit-scrollbar:horizontal,
html::-webkit-scrollbar:horizontal,
body::-webkit-scrollbar:horizontal {
    height: 10px !important; /* Match vertical scrollbar width (10px) */
    background: transparent !important;
    width: auto !important;
}

::-webkit-scrollbar-track {
    background: transparent !important;
    border-radius: 5px !important;
}

/* Ensure horizontal scrollbar track matches vertical - dark grey background */
::-webkit-scrollbar-track:horizontal,
*::-webkit-scrollbar-track:horizontal,
html::-webkit-scrollbar-track:horizontal,
body::-webkit-scrollbar-track:horizontal,
#tralbum-art-carousel::-webkit-scrollbar-track:horizontal,
.tralbum-art-carousel-container::-webkit-scrollbar-track:horizontal,
#tralbum-art-carousel *::-webkit-scrollbar-track:horizontal,
.tralbum-art-carousel-container *::-webkit-scrollbar-track:horizontal {
    background: rgba(43, 43, 43, 0.8) !important; /* Dark grey background to match vertical */
    border-radius: 5px !important;
    height: 10px !important;
}

/* Vertical scrollbar thumb */
::-webkit-scrollbar-thumb:vertical {
    background-color: rgba(74, 74, 74, 0.5) !important;
    border-radius: 5px !important;
    border: 2px solid transparent !important;
    background-clip: padding-box !important;
    min-height: 20px !important;
    transition: background-color 0.15s ease !important; /* Faster transition for responsiveness */
    /* Hardware acceleration for smooth scrolling */
    will-change: background-color, transform !important;
    transform: translateZ(0) !important;
    /* Ensure smooth scrolling performance */
    -webkit-font-smoothing: antialiased !important;
    backface-visibility: hidden !important;
}

/* Horizontal scrollbar thumb - match vertical styling */
::-webkit-scrollbar-thumb:horizontal {
    background-color: rgba(74, 74, 74, 0.5) !important;
    border-radius: 5px !important;
    border: 2px solid transparent !important;
    background-clip: padding-box !important;
    min-width: 20px !important; /* Use min-width for horizontal */
    transition: background-color 0.15s ease !important;
    /* Hardware acceleration for smooth scrolling */
    will-change: background-color, transform !important;
    transform: translateZ(0) !important;
    -webkit-font-smoothing: antialiased !important;
    backface-visibility: hidden !important;
}

/* Fallback for any scrollbar thumb (for compatibility) */
::-webkit-scrollbar-thumb {
    background-color: rgba(74, 74, 74, 0.5) !important;
    border-radius: 5px !important;
    border: 2px solid transparent !important;
    background-clip: padding-box !important;
    transition: background-color 0.15s ease !important;
    will-change: background-color, transform !important;
    transform: translateZ(0) !important;
    -webkit-font-smoothing: antialiased !important;
    backface-visibility: hidden !important;
}

/* Hover states for both vertical and horizontal */
::-webkit-scrollbar-thumb:hover,
::-webkit-scrollbar-thumb:vertical:hover,
::-webkit-scrollbar-thumb:horizontal:hover {
    background-color: rgba(90, 90, 90, 0.7) !important;
}

/* Active states for both vertical and horizontal */
::-webkit-scrollbar-thumb:active,
::-webkit-scrollbar-thumb:vertical:active,
::-webkit-scrollbar-thumb:horizontal:active {
    background-color: rgba(106, 106, 106, 0.9) !important;
}

/* Ensure smooth scrolling behavior */
html, body {
    scroll-behavior: smooth !important;
    -webkit-overflow-scrolling: touch !important; /* Smooth scrolling on iOS/WebKit */
    overflow-x: hidden !important; /* Hide horizontal scrolling */
    overflow-y: auto !important; /* Allow vertical scrolling */
}

/* Firefox scrollbar styling - dark grey background to match vertical scrollbar */
* {
    scrollbar-width: thin !important;
    scrollbar-color: rgba(74, 74, 74, 0.5) #212121 !important; /* Dark grey background instead of transparent */
}

/* Hide horizontal scrolling on main containers, but allow carousels to work */
body, html, #pgBd, .p-tralbum-page-container, .leftColumn, .rightColumn {
    overflow-x: hidden !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* IMPORTANT: Don't force overflow-x: hidden on carousel containers */
/* Carousels use CSS transforms/positioning to show only the active image */
/* Forcing overflow-x: hidden breaks the carousel's display mechanism */
/* Let Bandcamp's own carousel CSS handle the overflow properly */
#tralbum-art-carousel,
.tralbum-art-carousel-container {
    /* Don't override carousel's overflow - let it handle its own display */
    /* Just ensure it doesn't exceed container width */
    max-width: 100% !important;
    box-sizing: border-box !important;
}

/* Force ALL horizontal scrollbars to match vertical scrollbar thickness */
/* Target carousel and all other elements aggressively */
#tralbum-art-carousel::-webkit-scrollbar:horizontal,
.tralbum-art-carousel-container::-webkit-scrollbar:horizontal,
#tralbum-art-carousel *::-webkit-scrollbar:horizontal,
.tralbum-art-carousel-container *::-webkit-scrollbar:horizontal,
.carousel::-webkit-scrollbar:horizontal,
.carousel *::-webkit-scrollbar:horizontal,
[class*="carousel"]::-webkit-scrollbar:horizontal,
[class*="carousel"] *::-webkit-scrollbar:horizontal {
    height: 10px !important; /* Match vertical scrollbar width (10px) */
    max-height: 10px !important; /* Force maximum height */
    min-height: 10px !important; /* Force minimum height */
    background: transparent !important;
    width: auto !important;
}

/* Ensure ALL horizontal scrollbar thumbs match vertical styling */
#tralbum-art-carousel::-webkit-scrollbar-thumb:horizontal,
.tralbum-art-carousel-container::-webkit-scrollbar-thumb:horizontal,
#tralbum-art-carousel *::-webkit-scrollbar-thumb:horizontal,
.tralbum-art-carousel-container *::-webkit-scrollbar-thumb:horizontal,
.carousel::-webkit-scrollbar-thumb:horizontal,
.carousel *::-webkit-scrollbar-thumb:horizontal,
[class*="carousel"]::-webkit-scrollbar-thumb:horizontal,
[class*="carousel"] *::-webkit-scrollbar-thumb:horizontal {
    background-color: rgba(74, 74, 74, 0.5) !important;
    border-radius: 5px !important;
    border: 2px solid transparent !important;
    background-clip: padding-box !important;
    min-width: 20px !important;
    height: 10px !important; /* Match scrollbar track height */
    max-height: 10px !important;
    transition: background-color 0.15s ease !important;
}
"""
    
    def get_mini_mode_css(self):
        """CSS for mini mode - overlays player on cover art, keeps tracklist scrollable"""
        return """
/* Mini Mode - Overlay player on cover art (state 1) */
/* Window height = image height, player overlays image, tracklist scrollable below */
body.mini-mode #tralbum-art-carousel {
    position: relative !important;
    z-index: 1 !important;
    margin: 0 !important;
    padding: 0 !important;
}

/* Keep original page background - only darken the player itself */
/* Removed page container darkening to preserve tracklist readability */

body.mini-mode #player {
    position: absolute !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    z-index: 1000 !important;
    margin: 0 !important;
    padding: 15px !important;
    border-radius: 8px 8px 0 0 !important;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3) !important;
    background-color: rgba(20, 20, 20, 0.7) !important; /* Slightly more transparent */
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    width: 108% !important;
    max-width: 110% !important;
    /* Ensure player is visible on both light and dark pages */
    pointer-events: auto !important;
}

/* Ensure mini player works correctly on dark pages */
body.dark-page.mini-mode #player,
body:not(.light-page).mini-mode #player {
    z-index: 1000 !important;
    position: absolute !important;
    pointer-events: auto !important;
    visibility: visible !important;
    opacity: 1 !important;
}

/* Force player background to always be transparent in mini mode */
body.mini-mode #player,
body.mini-mode #player:hover,
body.mini-mode #player:focus,
body.mini-mode #player:active,
body.mini-mode .player-container,
body.mini-mode .player-container:hover,
body.mini-mode .player-container:focus,
body.mini-mode .player-container:active {
    background-color: rgba(20, 20, 20, 0.7) !important; /* Slightly more transparent */
    background: rgba(20, 20, 20, 0.7) !important;
}

/* Ensure all player child elements have transparent backgrounds but full opacity for text/UI */
body.mini-mode #player *,
body.mini-mode .player-container * {
    background-color: transparent !important;
    background: transparent !important;
}

/* Force all text and UI elements to be bright white in mini mode (like dark-themed pages) */
body.mini-mode #player span,
body.mini-mode #player div,
body.mini-mode #player p,
body.mini-mode #player .tralbum-name,
body.mini-mode #player .tralbum-name *,
body.mini-mode #player .tralbum-artist,
body.mini-mode #player .tralbum-artist *,
body.mini-mode #player .current-track,
body.mini-mode #player .current-track *,
body.mini-mode #player .track-info,
body.mini-mode #player .track-info *,
body.mini-mode #player .track-number,
body.mini-mode #player .time_elapsed,
body.mini-mode #player .time_total,
body.mini-mode #player .duration-text {
    opacity: 1 !important;
    color: #ffffff !important;
}

/* Force all SVG icons and buttons to be bright white in mini mode */
body.mini-mode #player svg,
body.mini-mode #player button svg,
body.mini-mode #player .next-prev-controls svg,
body.mini-mode #player .play-pause-button svg,
body.mini-mode #player .playbutton svg,
body.mini-mode #player .pausebutton svg {
    fill: #ffffff !important;
    stroke: #ffffff !important;
    color: #ffffff !important;
    opacity: 1 !important;
}

/* Force button elements to have white/bright styling */
body.mini-mode #player button,
body.mini-mode #player .play-pause-button,
body.mini-mode #player .playbutton,
body.mini-mode #player .pausebutton,
body.mini-mode #player .next-prev-controls button {
    color: #ffffff !important;
    opacity: 1 !important;
}

/* Force play button outline/border to be white in mini mode */
body.mini-mode #player button[aria-label*="Play"],
body.mini-mode #player button[aria-label*="play"],
body.mini-mode #player button[aria-label*="Pause"],
body.mini-mode #player button[aria-label*="pause"],
body.mini-mode #player .play-pause-button,
body.mini-mode #player .playbutton,
body.mini-mode #player .pausebutton,
body.mini-mode #player button[class*="play"],
body.mini-mode #player button[class*="Play"],
body.mini-mode #player button[class*="pause"],
body.mini-mode #player button[class*="Pause"],
body.mini-mode #player button[title*="Play"],
body.mini-mode #player button[title*="play"],
body.mini-mode #player button[title*="Pause"],
body.mini-mode #player button[title*="pause"] {
    border-color: #ffffff !important;
    outline-color: #ffffff !important;
    outline: 2px solid #ffffff !important;
    outline-offset: 0 !important;
}

/* Constrain text elements to single line with truncation in mini mode */
body.mini-mode .tralbum-name,
body.mini-mode .tralbum-name *,
body.mini-mode #player .tralbum-name,
body.mini-mode #player .tralbum-name * {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 100% !important;
    width: auto !important;
    display: block !important;
    line-height: 1.2 !important;
    box-sizing: border-box !important;
    min-width: 0 !important;
    flex: 0 1 auto !important;
    /* Ensure it doesn't overflow past the player edge */
    padding-right: 0 !important;
    margin-right: 0 !important;
}

body.mini-mode .tralbum-artist,
body.mini-mode .tralbum-artist *,
body.mini-mode #player .tralbum-artist,
body.mini-mode #player .tralbum-artist * {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 100% !important;
    width: auto !important;
    display: block !important;
    line-height: 1.2 !important;
    box-sizing: border-box !important;
    min-width: 0 !important;
    flex: 0 1 auto !important;
    padding-right: 0 !important;
    margin-right: 0 !important;
}

/* Hide track info button in mini mode to keep player size consistent */
body.mini-mode .track-action.track-info.player-action,
body.mini-mode button.track-action.track-info[aria-label*="track info"],
body.mini-mode button.track-action.track-info[aria-label*="View track info"],
body.mini-mode #player .track-action.track-info.player-action,
body.mini-mode #player button.track-action.track-info[aria-label*="track info"],
body.mini-mode #player button.track-action.track-info[aria-label*="View track info"] {
    display: none !important;
    visibility: hidden !important;
    width: 0 !important;
    height: 0 !important;
    opacity: 0 !important;
    pointer-events: none !important;
}

/* Ensure the track-info container allows truncation in mini mode */
body.mini-mode .track-info {
    overflow: hidden !important; /* Allow truncation */
    max-width: 100% !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

/* Exception: text elements that should truncate need hidden overflow in mini mode */
body.mini-mode #player .tralbum-name,
body.mini-mode #player .tralbum-name *,
body.mini-mode #player .tralbum-artist,
body.mini-mode #player .tralbum-artist * {
    overflow: hidden !important;
    max-width: 100% !important;
}

/* Disable hover effects for track title in mini mode */
body.mini-mode #player .current-track:hover,
body.mini-mode #player .current-track:hover *:not(.track-number):not(.track-num),
body.mini-mode #player .track-info .current-track:hover,
body.mini-mode #player .track-info .current-track:hover *:not(.track-number):not(.track-num),
body.mini-mode #player .current-track span:hover,
body.mini-mode #player .current-track span[data-bind*="currentTrack().title"]:hover,
body.mini-mode #player .current-track span[data-bind*="title"]:hover {
    background-color: transparent !important;
    backdrop-filter: none !important;
    border-radius: 0 !important;
}

/* Disable hover effects on track-number in mini mode (fully visible, not autohide) */
body.mini-mode:not(.mini-mode-autohide) #player .track-number:hover,
body.mini-mode:not(.mini-mode-autohide) #player .track-num:hover,
body.mini-mode:not(.mini-mode-autohide) #player:hover .track-number,
body.mini-mode:not(.mini-mode-autohide) #player:hover .track-num,
body.mini-mode:not(.mini-mode-autohide) #player .current-track:hover .track-number,
body.mini-mode:not(.mini-mode-autohide) #player .current-track:hover .track-num,
body.mini-mode:not(.mini-mode-autohide) #player .current-track:hover * .track-number,
body.mini-mode:not(.mini-mode-autohide) #player .current-track:hover * .track-num {
    background-color: transparent !important;
    background: transparent !important;
    color: inherit !important;
    opacity: 1 !important;
    filter: none !important;
    transform: none !important;
    padding: 0 !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
    margin: 0 !important;
    margin-left: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    margin-right: 8px !important;
    border: none !important;
    box-shadow: none !important;
    text-decoration: none !important;
    transition: none !important;
}

/* Make progress bar visible in mini mode (same as micro mode) */
body.mini-mode .progress-container {
    width: 100% !important;
    max-width: 100% !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
    box-sizing: border-box !important;
}

body.mini-mode .progress-bar,
body.mini-mode .progress-container .progress-bar {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
}

/* Make progress bar line/track visible in mini mode */
body.mini-mode input[type="range"],
body.mini-mode input.progress,
body.mini-mode .progbar,
body.mini-mode .progress-bar input,
body.mini-mode .progress-container input[type="range"],
body.mini-mode .progress-container .progbar {
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
    background-color: rgba(255, 255, 255, 0.3) !important;
    -webkit-appearance: none !important;
    appearance: none !important;
    height: 4px !important;
    width: 100% !important;
    cursor: pointer !important;
}

/* Progress bar track (the line) */
body.mini-mode input[type="range"]::-webkit-slider-runnable-track,
body.mini-mode input.progress::-webkit-slider-runnable-track,
body.mini-mode .progbar::-webkit-slider-runnable-track {
    background-color: rgba(255, 255, 255, 0.3) !important;
    height: 4px !important;
    opacity: 1 !important;
    visibility: visible !important;
}

body.mini-mode input[type="range"]::-moz-range-track,
body.mini-mode input.progress::-moz-range-track,
body.mini-mode .progbar::-moz-range-track {
    background-color: rgba(255, 255, 255, 0.3) !important;
    height: 4px !important;
    opacity: 1 !important;
    visibility: visible !important;
}

/* Progress bar thumb (the handle) */
body.mini-mode input[type="range"]::-webkit-slider-thumb,
body.mini-mode input.progress::-webkit-slider-thumb,
body.mini-mode .progbar::-webkit-slider-thumb {
    -webkit-appearance: none !important;
    appearance: none !important;
    width: 12px !important;
    height: 12px !important;
    background-color: #ffffff !important;
    border-radius: 50% !important;
    cursor: pointer !important;
    opacity: 1 !important;
    visibility: visible !important;
    margin-top: -4px !important;
}

body.mini-mode input[type="range"]::-moz-range-thumb,
body.mini-mode input.progress::-moz-range-thumb,
body.mini-mode .progbar::-moz-range-thumb {
    width: 12px !important;
    height: 12px !important;
    background-color: #ffffff !important;
    border-radius: 50% !important;
    cursor: pointer !important;
    opacity: 1 !important;
    visibility: visible !important;
    border: none !important;
}

/* Ensure next/previous track buttons are always visible and maintain default size in mini mode */
/* Exception: next-prev-controls should not be constrained by any max-width rules */
body.mini-mode #player .next-prev-controls,
body.mini-mode #player .next-prev-controls *,
body.mini-mode .next-prev-controls,
body.mini-mode .next-prev-controls * {
    min-width: auto !important;
    width: auto !important;
    max-width: none !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    left: -6px !important;
}

/* Ensure the container itself maintains proper display in mini mode */
body.mini-mode #player .next-prev-controls,
body.mini-mode .next-prev-controls {
    display: inline-flex !important;
    align-items: center !important;
    position: relative !important;
    left: -10px !important;
    top: 12px !important;
}

body.mini-mode #player .next-prev-controls button,
body.mini-mode #player .next-prev-controls button[aria-label*="Skip to previous"],
body.mini-mode #player .next-prev-controls button[aria-label*="Skip to next"],
body.mini-mode #player .next-prev-controls button[aria-label*="previous"],
body.mini-mode #player .next-prev-controls button[aria-label*="next"],
body.mini-mode .next-prev-controls button,
body.mini-mode .next-prev-controls button[aria-label*="Skip to previous"],
body.mini-mode .next-prev-controls button[aria-label*="Skip to next"],
body.mini-mode .next-prev-controls button[aria-label*="previous"],
body.mini-mode .next-prev-controls button[aria-label*="next"] {
    min-width: 24px !important;
    width: 24px !important;
    height: 24px !important;
    min-height: 24px !important;
    max-width: 24px !important;
    max-height: 24px !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    visibility: visible !important;
    display: inline-block !important;
    opacity: 1 !important;
    pointer-events: auto !important;
    position: relative !important;
    margin: 0 2px !important;
    padding: 0 !important;
}

body.mini-mode #player .next-prev-controls svg,
body.mini-mode #player .next-prev-controls button svg,
body.mini-mode .next-prev-controls svg,
body.mini-mode .next-prev-controls button svg {
    width: 16px !important;
    height: 16px !important;
    min-width: 16px !important;
    min-height: 16px !important;
    max-width: 16px !important;
    max-height: 16px !important;
    flex-shrink: 0 !important;
}

/* Keep tracklist in DOM but position it below viewport - scrollable */
/* Use transform instead of display/visibility to avoid re-render issues */
body.mini-mode #tracklist,
body.mini-mode #about-tralbum {
    position: relative !important;
    z-index: 0 !important;
    /* Keep in layout but below the visible area - user can scroll to see it */
    margin-top: 0 !important;
    padding-top: 10px !important;
}

/* Tracklist ol.tracks styling for mini mode */
body.mini-mode ol.tracks {
    background-color: transparent !important;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    margin-left: -20px !important;
    margin-right: 0px !important;
    padding-left: 20px !important;
    padding-right: 0px !important;
}

/* Override track number calculation in grid for mini mode */
body.mini-mode :where(.p-tralbum-page-container) section.tracklist-container ol.tracks li.track,
body.mini-mode .p-tralbum-page-container section.tracklist-container ol.tracks li.track,
body.mini-mode section.tracklist-container ol.tracks li.track,
body.mini-mode ol.tracks li.track {
    grid-template-columns: calc(1rem + var(--track-num-padding)) minmax(0, 1fr) auto min-content !important;
}

/* Ensure cover art is visible in mini mode and remove extra space */
body.mini-mode #tralbum-art-carousel {
    height: auto !important;
    min-height: 0 !important;
    max-height: none !important;
    overflow: visible !important;
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
}

body.mini-mode #tralbum-art-carousel img {
    display: block !important;
    visibility: visible !important;
    margin: 0 auto !important;
}

/* Hide any extra spacing or padding in mini mode */
body.mini-mode .p-tralbum-page-container,
body.mini-mode #pgBd {
    padding-bottom: 0 !important;
    margin-bottom: 0 !important;
}

/* Mini Mode Player Autohide - Hide player when idle, show on hover */
/* CRITICAL: Keep pointer-events enabled so hover can be detected */
body.mini-mode.mini-mode-autohide #player {
    opacity: 0 !important;
    transition: opacity 250ms ease-in-out !important;
    /* Must keep pointer-events enabled for hover to work */
    pointer-events: auto !important;
    visibility: visible !important;
    /* Hardware acceleration for smooth transitions */
    will-change: opacity !important;
    transform: translateZ(0) !important;
    backface-visibility: hidden !important;
}

/* Override general mini-mode opacity rules for child elements when autohide is enabled */
/* In idle state: explicitly set to 0 to override general mini-mode opacity: 1 rules */
body.mini-mode.mini-mode-autohide #player span,
body.mini-mode.mini-mode-autohide #player div,
body.mini-mode.mini-mode-autohide #player p,
body.mini-mode.mini-mode-autohide #player button,
body.mini-mode.mini-mode-autohide #player svg,
body.mini-mode.mini-mode-autohide #player .tralbum-name,
body.mini-mode.mini-mode-autohide #player .tralbum-name *,
body.mini-mode.mini-mode-autohide #player .tralbum-artist,
body.mini-mode.mini-mode-autohide #player .tralbum-artist *,
body.mini-mode.mini-mode-autohide #player .current-track,
body.mini-mode.mini-mode-autohide #player .current-track *,
body.mini-mode.mini-mode-autohide #player .track-info,
body.mini-mode.mini-mode-autohide #player .track-info *,
body.mini-mode.mini-mode-autohide #player .track-number,
body.mini-mode.mini-mode-autohide #player .time_elapsed,
body.mini-mode.mini-mode-autohide #player .time_total,
body.mini-mode.mini-mode-autohide #player .duration-text,
body.mini-mode.mini-mode-autohide #player .next-prev-controls,
body.mini-mode.mini-mode-autohide #player .next-prev-controls *,
body.mini-mode.mini-mode-autohide #player .play-pause-button,
body.mini-mode.mini-mode-autohide #player .playbutton,
body.mini-mode.mini-mode-autohide #player .pausebutton,
body.mini-mode.mini-mode-autohide #player .progress-container,
body.mini-mode.mini-mode-autohide #player .progress-bar,
body.mini-mode.mini-mode-autohide #player .progbar,
body.mini-mode.mini-mode-autohide #player input,
body.mini-mode.mini-mode-autohide #player * {
    opacity: 0 !important;
    transition: opacity 250ms ease-in-out !important;
    pointer-events: auto !important;
}

/* Show player when hovering - use class-based approach for reliable hover detection */
body.mini-mode.mini-mode-autohide #player.player-hovered {
    opacity: 1 !important;
    /* Ensure smooth transition when showing */
    will-change: opacity !important;
}

/* Player visibility toggle button - top center in mini mode */
/* Hidden by default - only shown in mini mode */
#bandcamp-player-visibility-toggle {
    position: fixed !important;
    top: 8px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    width: 24px !important;
    height: 24px !important;
    background-color: rgba(21, 21, 21, 0.4) !important;
    border: 1px solid rgba(176, 176, 176, 0.2) !important;
    border-radius: 12px !important;
    cursor: pointer !important;
    z-index: 10001 !important;
    display: none !important;
    align-items: center !important;
    justify-content: center !important;
    color: #b0b0b0 !important;
    font-size: 14px !important;
    font-weight: bold !important;
    filter: grayscale(100%) !important;
    transition: background-color 200ms ease, border-color 200ms ease, color 200ms ease, filter 200ms ease !important;
    pointer-events: none !important;
    opacity: 0 !important;
    visibility: hidden !important;
}

#bandcamp-player-visibility-toggle:hover {
    background-color: rgba(43, 43, 43, 0.7) !important;
    border-color: rgba(176, 176, 176, 0.5) !important;
    color: #e0e0e0 !important;
    filter: grayscale(100%) !important;
}

/* Ensure toggle button is always visible, even when player is hidden */
/* Use fixed positioning so it's always in view and not affected by player visibility */
/* Only show in mini mode, hide in micro mode */
/* This rule ensures the button is always visible in mini mode */
body.mini-mode:not(.micro-mode) #bandcamp-player-visibility-toggle {
    opacity: 1 !important;
    visibility: visible !important;
    pointer-events: auto !important;
    z-index: 10002 !important;
    position: fixed !important;
    display: flex !important;
    /* Position relative to viewport, not player - top center */
    top: 8px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
}

/* Hide button in regular mode (not mini-mode and not micro-mode) */
body:not(.mini-mode):not(.micro-mode) #bandcamp-player-visibility-toggle {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    display: none !important;
}

/* Hide button in micro mode */
body.micro-mode #bandcamp-player-visibility-toggle {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    display: none !important;
}

/* Button is always visible in mini mode, regardless of autohide or hidden state */
body.mini-mode.mini-mode-autohide #bandcamp-player-visibility-toggle {
    opacity: 1 !important;
    visibility: visible !important;
    pointer-events: auto !important;
    display: flex !important;
}

/* Hide button when image viewer modal is active */
#bandcamp-player-cover-modal.active ~ #bandcamp-player-visibility-toggle,
body:has(#bandcamp-player-cover-modal.active) #bandcamp-player-visibility-toggle {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
    display: none !important;
}

/* When player is completely hidden, button should still be visible */
body.mini-mode.mini-mode-player-hidden #bandcamp-player-visibility-toggle {
    opacity: 0.8 !important;
    visibility: visible !important;
    pointer-events: auto !important;
    z-index: 10002 !important;
    filter: grayscale(100%) !important;
}

/* When player is hidden completely (separate from autohide) */
body.mini-mode.mini-mode-player-hidden #player {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

body.mini-mode.mini-mode-player-hidden #player * {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

/* When both hidden and autohide are enabled, hidden takes precedence */
body.mini-mode.mini-mode-player-hidden.mini-mode-autohide #player {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

body.mini-mode.mini-mode-player-hidden.mini-mode-autohide #player.player-hovered {
    opacity: 0 !important;
    visibility: hidden !important;
    pointer-events: none !important;
}

/* CRITICAL: On hover (using class), override ALL child element opacity rules - must come after idle rules */
/* Use maximum specificity to ensure these rules win over everything */
body.mini-mode.mini-mode-autohide #player.player-hovered span,
body.mini-mode.mini-mode-autohide #player.player-hovered div,
body.mini-mode.mini-mode-autohide #player.player-hovered p,
body.mini-mode.mini-mode-autohide #player.player-hovered button,
body.mini-mode.mini-mode-autohide #player.player-hovered svg,
body.mini-mode.mini-mode-autohide #player.player-hovered .tralbum-name,
body.mini-mode.mini-mode-autohide #player.player-hovered .tralbum-name *,
body.mini-mode.mini-mode-autohide #player.player-hovered .tralbum-artist,
body.mini-mode.mini-mode-autohide #player.player-hovered .tralbum-artist *,
body.mini-mode.mini-mode-autohide #player.player-hovered .current-track,
body.mini-mode.mini-mode-autohide #player.player-hovered .current-track *,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-info,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-info *,
body.mini-mode.mini-mode-autohide #player.player-hovered .time_elapsed,
body.mini-mode.mini-mode-autohide #player.player-hovered .time_total,
body.mini-mode.mini-mode-autohide #player.player-hovered .duration-text,
body.mini-mode.mini-mode-autohide #player.player-hovered .next-prev-controls,
body.mini-mode.mini-mode-autohide #player.player-hovered .next-prev-controls *,
body.mini-mode.mini-mode-autohide #player.player-hovered .next-prev-controls button,
body.mini-mode.mini-mode-autohide #player.player-hovered .play-pause-button,
body.mini-mode.mini-mode-autohide #player.player-hovered .playbutton,
body.mini-mode.mini-mode-autohide #player.player-hovered .pausebutton,
body.mini-mode.mini-mode-autohide #player.player-hovered .pausebutton svg,
body.mini-mode.mini-mode-autohide #player.player-hovered .progress-container,
body.mini-mode.mini-mode-autohide #player.player-hovered .progress-bar,
body.mini-mode.mini-mode-autohide #player.player-hovered .progbar,
body.mini-mode.mini-mode-autohide #player.player-hovered input,
body.mini-mode.mini-mode-autohide #player.player-hovered button[title*="pause"],
body.mini-mode.mini-mode-autohide #player.player-hovered button.track-action,
body.mini-mode.mini-mode-autohide #player.player-hovered * {
    opacity: 1 !important;
}

/* Ensure track number doesn't change on hover in mini mode autohide */
body.mini-mode.mini-mode-autohide #player.player-hovered .track-number,
body.mini-mode.mini-mode-autohide #player.player-hovered .track-num {
    opacity: 1 !important;
    padding: 0 !important;
    margin: 0 !important;
    margin-right: 8px !important;
    transform: none !important;
    background-color: transparent !important;
    color: inherit !important;
}

/* EXTRA CATCH-ALL: Ensure ALL descendants are visible when player is hovered */
/* This rule should catch any elements not covered by the specific rules above */
body.mini-mode.mini-mode-autohide #player.player-hovered,
body.mini-mode.mini-mode-autohide #player.player-hovered *,
body.mini-mode.mini-mode-autohide #player.player-hovered * *,
body.mini-mode.mini-mode-autohide #player.player-hovered * * * {
    opacity: 1 !important;
}

/* Micro Mode - Show player with cover art visible behind it (state 2) */
/* Window height = player height exactly, cover art shows through transparent player */
/* Keep original page background - only darken the player itself (same as mini mode) */
/* Removed page container darkening to preserve tracklist readability on light pages */

body.micro-mode #tralbum-art-carousel {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    z-index: 1 !important;
    width: 100% !important;
    /* Height will be set dynamically via JavaScript to match player height */
    /* Use max-height as fallback - will be constrained by JavaScript */
    max-height: var(--micro-mode-player-height, 100px) !important;
    height: var(--micro-mode-player-height, 100px) !important;
    overflow: hidden !important;
    pointer-events: none !important;
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
}

body.micro-mode #tralbum-art-carousel img,
body.micro-mode .tralbum-art-carousel-container img,
body.micro-mode .carousel-item img {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover !important;
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
    margin: 0 !important;
    padding: 0 !important;
}

body.micro-mode #player {
    position: relative !important;
    z-index: 1000 !important;
    margin: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    padding: 15px !important;
    padding-top: 15px !important;
    padding-bottom: 15px !important;
    padding-right: 0 !important;
    background-color: rgba(20, 20, 20, 0.75) !important; /* Slightly more transparent */
    backdrop-filter: blur(4px) !important;
    -webkit-backdrop-filter: blur(4px) !important;
    /* Ensure player is visible and interactive */
    visibility: visible !important;
    opacity: 1 !important;
    /* Remove any bottom spacing */
    border-bottom: none !important;
    /* Ensure content doesn't overflow */
    overflow: visible !important;
}

/* Make player background semi-transparent in micro mode (cover art shows through) */
body.micro-mode #player,
body.micro-mode #player:hover,
body.micro-mode #player:focus,
body.micro-mode #player:active,
body.micro-mode .player-container,
body.micro-mode .player-container:hover,
body.micro-mode .player-container:focus,
body.micro-mode .player-container:active {
    background-color: rgba(20, 20, 20, 0.75) !important; /* Slightly more transparent */
    background: rgba(20, 20, 20, 0.75) !important;
}

/* Ensure all player child elements have transparent backgrounds but full opacity for text/UI */
body.micro-mode #player *,
body.micro-mode .player-container * {
    background-color: transparent !important;
    background: transparent !important;
}

/* Force all text and UI elements to be bright white in micro mode (like dark-themed pages) */
body.micro-mode #player span,
body.micro-mode #player div,
body.micro-mode #player p,
body.micro-mode #player .tralbum-name,
body.micro-mode #player .tralbum-name *,
body.micro-mode #player .tralbum-artist,
body.micro-mode #player .tralbum-artist *,
body.micro-mode #player .current-track,
body.micro-mode #player .current-track *,
body.micro-mode #player .track-info,
body.micro-mode #player .track-info *,
body.micro-mode #player .track-number,
body.micro-mode #player .time_elapsed,
body.micro-mode #player .time_total,
body.micro-mode #player .duration-text {
    opacity: 1 !important;
    color: #ffffff !important;
}

/* Force all SVG icons and buttons to be bright white in micro mode */
body.micro-mode #player svg,
body.micro-mode #player button svg,
body.micro-mode #player .next-prev-controls svg,
body.micro-mode #player .play-pause-button svg,
body.micro-mode #player .playbutton svg,
body.micro-mode #player .pausebutton svg {
    fill: #ffffff !important;
    stroke: #ffffff !important;
    color: #ffffff !important;
    opacity: 1 !important;
}

/* Force button elements to have white/bright styling */
body.micro-mode #player button,
body.micro-mode #player .play-pause-button,
body.micro-mode #player .playbutton,
body.micro-mode #player .pausebutton,
body.micro-mode #player .next-prev-controls button {
    color: #ffffff !important;
    opacity: 1 !important;
}

/* Force play button outline/border to be white in micro mode */
body.micro-mode #player button[aria-label*="Play"],
body.micro-mode #player button[aria-label*="play"],
body.micro-mode #player button[aria-label*="Pause"],
body.micro-mode #player button[aria-label*="pause"],
body.micro-mode #player .play-pause-button,
body.micro-mode #player .playbutton,
body.micro-mode #player .pausebutton,
body.micro-mode #player button[class*="play"],
body.micro-mode #player button[class*="Play"],
body.micro-mode #player button[class*="pause"],
body.micro-mode #player button[class*="Pause"],
body.micro-mode #player button[title*="Play"],
body.micro-mode #player button[title*="play"],
body.micro-mode #player button[title*="Pause"],
body.micro-mode #player button[title*="pause"] {
    border-color: #ffffff !important;
    outline-color: #ffffff !important;
    outline: 2px solid #ffffff !important;
    outline-offset: 0 !important;
}

/* Keep tracklist in DOM but position it below player - scrollable (like mini mode) */
body.micro-mode #tracklist,
body.micro-mode #about-tralbum {
    position: relative !important;
    z-index: 0 !important;
    /* Keep in layout but below the visible area - user can scroll to see it */
    margin-top: 0 !important;
    padding-top: 10px !important;
    /* Ensure no gap between player and tracklist */
    margin-bottom: 0 !important;
    padding-bottom: 0 !important;
}

/* Hide footer and other elements that add space below player in micro mode */
body.micro-mode #TralbumPageFooter,
body.micro-mode #tralbum-footer,
body.micro-mode footer#tralbum-footer {
    display: none !important;
    visibility: hidden !important;
    height: 0 !important;
    width: 0 !important;
    overflow: hidden !important;
    margin: 0 !important;
    padding: 0 !important;
    opacity: 0 !important;
    pointer-events: none !important;
    position: absolute !important;
    left: -9999px !important;
    top: -9999px !important;
}

/* Remove all extra space below player in micro mode, but allow cover art to show and tracklist to scroll */
body.micro-mode #pgBd,
body.micro-mode .p-tralbum-page-container {
    height: auto !important;
    min-height: auto !important;
    max-height: none !important;
    padding: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    overflow: visible !important;
    position: relative !important;
}

/* Ensure body height matches player height exactly in micro mode, but allow scrolling */
body.micro-mode {
    height: auto !important;
    min-height: auto !important;
    max-height: none !important;
    overflow: auto !important; /* Allow scrolling to see tracklist */
    padding: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
}

/* Remove any spacing from player container in micro mode */
body.micro-mode .player-container {
    margin: 0 !important;
    margin-bottom: 0 !important;
    padding: 0 !important;
    padding-bottom: 0 !important;
}

/* Hide track info button in micro mode to keep player size consistent */
body.micro-mode .track-action.track-info.player-action,
body.micro-mode button.track-action.track-info[aria-label*="track info"],
body.micro-mode button.track-action.track-info[aria-label*="View track info"] {
    display: none !important;
    visibility: hidden !important;
    width: 0 !important;
    height: 0 !important;
    opacity: 0 !important;
    pointer-events: none !important;
}

/* Constrain text elements to single line with truncation in micro mode */
body.micro-mode .tralbum-name,
body.micro-mode .tralbum-name *,
body.micro-mode #player .tralbum-name,
body.micro-mode #player .tralbum-name * {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 100% !important; /* Reduced width to avoid reaching edge and overlapping buttons */
    width: auto !important;
    display: block !important;
    line-height: 1.2 !important;
    box-sizing: border-box !important;
    min-width: 0 !important;
    flex: 0 1 auto !important;
    /* Ensure it doesn't overflow past the player edge */
    padding-right: 0 !important;
    margin-right: 0 !important;
}

body.micro-mode .tralbum-artist,
body.micro-mode .tralbum-artist *,
body.micro-mode #player .tralbum-artist,
body.micro-mode #player .tralbum-artist * {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 75% !important; /* Reduced width to avoid overlapping with next/previous buttons */
    display: block !important;
    line-height: 1.2 !important;
    box-sizing: border-box !important;
    min-width: 0 !important;
    flex: 0 1 auto !important;
    padding-right: 0 !important;
    margin-right: 0 !important;
}

body.micro-mode .current-track span[data-bind*="currentTrack().title"]:not(.track-number):not(.track-num),
body.micro-mode .current-track span[data-bind*="title"]:not(.track-number):not(.track-num),
body.micro-mode .track-info .current-track span:not(.track-number):not(.track-num),
body.micro-mode .current-track > span:not(.track-number):not(.track-num),
body.micro-mode #player .current-track span[data-bind*="currentTrack().title"]:not(.track-number):not(.track-num),
body.micro-mode #player .current-track span[data-bind*="title"]:not(.track-number):not(.track-num),
body.micro-mode #player .track-info .current-track span:not(.track-number):not(.track-num),
body.micro-mode #player .current-track > span:not(.track-number):not(.track-num) {
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    max-width: 100% !important; /* Reduced width to avoid reaching edge and overlapping buttons */
    display: inline-block !important;
    vertical-align: top !important;
    box-sizing: border-box !important;
    min-width: 0 !important;
    padding-right: 0 !important;
    margin-right: 0 !important;
}

/* Disable hover effects for track title in micro mode */
body.micro-mode #player .current-track:hover,
body.micro-mode #player .current-track:hover *:not(.track-number):not(.track-num),
body.micro-mode #player .track-info .current-track:hover,
body.micro-mode #player .track-info .current-track:hover *:not(.track-number):not(.track-num),
body.micro-mode #player .current-track span:hover,
body.micro-mode #player .current-track span[data-bind*="currentTrack().title"]:hover,
body.micro-mode #player .current-track span[data-bind*="title"]:hover {
    background-color: transparent !important;
    backdrop-filter: none !important;
    border-radius: 0 !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
    opacity: 1 !important;
    filter: none !important;
    box-shadow: none !important;
}

/* Hide duration text in track info (it should only appear in progress bar) */
body.micro-mode .current-track .track-progress-duration,
body.micro-mode .track-info .track-progress-duration,
body.micro-mode .current-track span.track-progress-duration {
    display: none !important;
    visibility: hidden !important;
    width: 0 !important;
    height: 0 !important;
    opacity: 0 !important;
    pointer-events: none !important;
}

/* Add space between track number and title */
body.micro-mode .track-number,
body.micro-mode #player .track-number,
body.micro-mode #player .track-num,
body.micro-mode #player .current-track .track-number,
body.micro-mode #player .current-track .track-num,
body.micro-mode #player .track-info .track-number,
body.micro-mode #player .track-info .track-num,
body.micro-mode .current-track .track-number,
body.micro-mode .current-track .track-num,
body.micro-mode .track-info .track-number,
body.micro-mode .track-info .track-num {
    padding-right: 8px !important; /* Same spacing as mini mode */
    padding-left: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin: 0 !important;
}

/* Disable hover effects on track-number in micro mode */
body.micro-mode #player .track-number:hover,
body.micro-mode #player .track-num:hover,
body.micro-mode #player:hover .track-number,
body.micro-mode #player:hover .track-num,
body.micro-mode #player .current-track:hover .track-number,
body.micro-mode #player .current-track:hover .track-num {
    background-color: transparent !important;
    background: transparent !important;
    color: inherit !important;
    opacity: 1 !important;
    filter: none !important;
    transform: none !important;
    padding-left: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    padding-right: 8px !important;
    margin: 0 !important;
    border: none !important;
    box-shadow: none !important;
    text-decoration: none !important;
    transition: none !important;
}

/* Ensure next/previous track buttons are always visible and maintain default size in micro mode */
body.micro-mode .next-prev-controls,
body.micro-mode .next-prev-controls * {
    min-width: auto !important;
    width: auto !important;
    max-width: none !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
}

body.micro-mode .next-prev-controls button,
body.micro-mode .next-prev-controls button[aria-label*="Skip to previous"],
body.micro-mode .next-prev-controls button[aria-label*="Skip to next"],
body.micro-mode .next-prev-controls button[aria-label*="previous"],
body.micro-mode .next-prev-controls button[aria-label*="next"] {
    min-width: 24px !important;
    width: 24px !important;
    height: 24px !important;
    min-height: 24px !important;
    max-width: 24px !important;
    max-height: 24px !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    visibility: visible !important;
    display: inline-block !important;
    opacity: 1 !important;
    pointer-events: auto !important;
    position: relative !important;
    margin: 0 2px !important;
    padding: 0 !important;
}

body.micro-mode .next-prev-controls svg,
body.micro-mode .next-prev-controls button svg {
    width: 16px !important;
    height: 16px !important;
    min-width: 16px !important;
    min-height: 16px !important;
    max-width: 16px !important;
    max-height: 16px !important;
    flex-shrink: 0 !important;
}

/* Ensure the track-info container doesn't push buttons off screen */
body.micro-mode .track-info {
    display: flex !important;
    align-items: center !important;
    flex-wrap: nowrap !important;
    min-width: 0 !important;
    overflow: hidden !important; /* Changed from visible to hidden to allow truncation */
    padding-right: 0 !important;
    margin-right: 0 !important;
    max-width: 100% !important;
    width: 100% !important;
    box-sizing: border-box !important;
}

body.micro-mode .current-track {
    display: inline-flex !important;
    align-items: center !important;
    flex-wrap: nowrap !important;
    min-width: 0 !important;
    overflow: visible !important;
    flex: 0 1 auto !important;
    padding-right: 8px !important;
    margin-right: 0 !important;
}

/* Ensure next-prev-controls stays visible and doesn't shrink - on same line */
body.micro-mode .next-prev-controls {
    display: inline-flex !important;
    align-items: center !important;
    flex-shrink: 0 !important;
    flex-grow: 0 !important;
    margin-left: auto !important;
    margin-right: 0 !important;
    padding-right: 0 !important;
    order: 999 !important;
    visibility: visible !important;
    opacity: 1 !important;
    position: relative !important;
    top: -20px !important;
    right: -15px;
    overflow: visible !important;
    vertical-align: middle !important;
}

/* Ensure player and track-info containers allow buttons to be fully visible */
body.micro-mode #player * {
    overflow: visible !important;
    max-width: 95% !important;
}

/* Exception: text elements that should truncate need hidden overflow */
body.micro-mode #player .tralbum-name,
body.micro-mode #player .tralbum-name *,
body.micro-mode #player .tralbum-artist,
body.micro-mode #player .tralbum-artist * {
    overflow: hidden !important;
    text-overflow: ellipsis !important;
    white-space: nowrap !important;
}

body.micro-mode .player-container {
    overflow: visible !important;
}

/* Ensure track-info section has proper spacing */
body.micro-mode .track-info .current-track {
    margin-right: 8px !important;
    padding-right: 0 !important;
}

/* Make progress bar full width in micro mode */
body.micro-mode .progress-container {
    width: 100% !important;
    max-width: 100% !important;
    margin-left: 0 !important;
    margin-right: 0 !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
    box-sizing: border-box !important;
}

body.micro-mode .progress-bar,
body.micro-mode .progress-container .progress-bar {
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
}

/* Make progress bar line/track visible in micro mode */
body.micro-mode input[type="range"],
body.micro-mode input.progress,
body.micro-mode .progbar,
body.micro-mode .progress-bar input,
body.micro-mode .progress-container input[type="range"],
body.micro-mode .progress-container .progbar {
    opacity: 1 !important;
    visibility: visible !important;
    display: block !important;
    background-color: rgba(255, 255, 255, 0.3) !important;
    -webkit-appearance: none !important;
    appearance: none !important;
    height: 4px !important;
    width: 100% !important;
    cursor: pointer !important;
}

/* Progress bar track (the line) */
body.micro-mode input[type="range"]::-webkit-slider-runnable-track,
body.micro-mode input.progress::-webkit-slider-runnable-track,
body.micro-mode .progbar::-webkit-slider-runnable-track {
    background-color: rgba(255, 255, 255, 0.3) !important;
    height: 4px !important;
    opacity: 1 !important;
    visibility: visible !important;
}

body.micro-mode input[type="range"]::-moz-range-track,
body.micro-mode input.progress::-moz-range-track,
body.micro-mode .progbar::-moz-range-track {
    background-color: rgba(255, 255, 255, 0.3) !important;
    height: 4px !important;
    opacity: 1 !important;
    visibility: visible !important;
}

/* Progress bar thumb (the handle) */
body.micro-mode input[type="range"]::-webkit-slider-thumb,
body.micro-mode input.progress::-webkit-slider-thumb,
body.micro-mode .progbar::-webkit-slider-thumb {
    -webkit-appearance: none !important;
    appearance: none !important;
    width: 12px !important;
    height: 12px !important;
    background-color: #ffffff !important;
    border-radius: 50% !important;
    cursor: pointer !important;
    opacity: 1 !important;
    visibility: visible !important;
    margin-top: -4px !important;
}

body.micro-mode input[type="range"]::-moz-range-thumb,
body.micro-mode input.progress::-moz-range-thumb,
body.micro-mode .progbar::-moz-range-thumb {
    width: 12px !important;
    height: 12px !important;
    background-color: #ffffff !important;
    border-radius: 50% !important;
    cursor: pointer !important;
    opacity: 1 !important;
    visibility: visible !important;
    border: none !important;
}

/* Position next/previous buttons at the right edge */
body.micro-mode .next-prev-controls {
    margin-right: 0 !important;
    padding-right: 0 !important;
    position: relative !important;
    right: 0 !important;
}

/* Ensure no gap between player and tracklist in micro mode */
body.micro-mode #player {
    margin-bottom: 0 !important;
    padding-bottom: 15px !important; /* Keep internal padding but no external margin */
}

body.micro-mode .player-container {
    margin-bottom: 0 !important;
    padding-bottom: 0 !important;
}

/* Remove any spacing from page containers that could create gaps */
body.micro-mode #pgBd,
body.micro-mode .p-tralbum-page-container {
    margin-bottom: 0 !important;
    padding-bottom: 0 !important;
}

/* Tracklist styling for micro mode (similar to mini mode) */
body.micro-mode ol.tracks {
    background-color: transparent !important;
    background: transparent !important;
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    border-radius: 4px !important;
    margin-left: -20px !important;
    margin-right: 0px !important;
    padding-left: 20px !important;
    padding-right: 0px !important;
}

/* Override track number calculation in grid for micro mode */
body.micro-mode :where(.p-tralbum-page-container) section.tracklist-container ol.tracks li.track,
body.micro-mode .p-tralbum-page-container section.tracklist-container ol.tracks li.track,
body.micro-mode section.tracklist-container ol.tracks li.track,
body.micro-mode ol.tracks li.track {
    grid-template-columns: calc(1rem + var(--track-num-padding)) minmax(0, 1fr) auto min-content !important;
}

"""


# ============================================================================
# PLAYLIST MANAGER CLASS
# ============================================================================

def sanitize_filename(name):
    """Sanitize a filename by removing invalid characters"""
    import re
    # Remove invalid characters for Windows/Linux/Mac
    # Invalid: < > : " / \ | ? * and control characters
    invalid_chars = r'[<>:"/\\|?*\x00-\x1f]'
    sanitized = re.sub(invalid_chars, '', name)
    # Remove leading/trailing spaces and dots (Windows doesn't allow these)
    sanitized = sanitized.strip(' .')
    # Replace multiple spaces with single space
    sanitized = re.sub(r'\s+', ' ', sanitized)
    # If empty after sanitization, use default name
    if not sanitized:
        sanitized = "playlist"
    # Limit length to 255 characters (common filesystem limit)
    if len(sanitized) > 255:
        sanitized = sanitized[:255]
    return sanitized


class PlaylistManager:
    """Manages the playlist of Bandcamp URLs"""
    
    def __init__(self, base_path=None, playlist_file=None):
        if base_path is None:
            base_path = Path(__file__).parent
        self.base_path = base_path
        self.playlists_dir = base_path / "Playlists"
        # Create Playlists directory if it doesn't exist
        self.playlists_dir.mkdir(exist_ok=True)
        
        # Migrate old playlist.json from root to Playlists/Default.json if it exists
        old_playlist_file = base_path / "playlist.json"
        default_playlist_file = self.playlists_dir / "Default.json"
        # Also check for old lowercase default.json and migrate it
        old_default_file = self.playlists_dir / "default.json"
        if old_default_file.exists() and not default_playlist_file.exists():
            try:
                import shutil
                shutil.copy2(old_default_file, default_playlist_file)
                logger.info(f"Migrated old default.json to Default.json")
            except Exception as e:
                logger.warning(f"Failed to migrate old default.json: {e}")
        if old_playlist_file.exists() and not default_playlist_file.exists():
            try:
                # Copy old playlist to new location
                import shutil
                shutil.copy2(old_playlist_file, default_playlist_file)
                logger.info(f"Migrated old playlist.json to Playlists/Default.json")
                # Optionally remove old file (commented out for safety)
                # old_playlist_file.unlink()
            except Exception as e:
                logger.warning(f"Failed to migrate old playlist.json: {e}")
        
        # If playlist_file is provided, use it; otherwise use Default
        if playlist_file:
            self.playlist_file = Path(playlist_file)
            # If relative path, make it relative to playlists_dir
            if not self.playlist_file.is_absolute():
                self.playlist_file = self.playlists_dir / self.playlist_file.name
        else:
            # Default playlist location (capitalized)
            self.playlist_file = self.playlists_dir / "Default.json"
        
        self.playlist = self.load_playlist()
    
    def get_playlist_directory(self):
        """Get the Playlists directory path"""
        return self.playlists_dir
    
    def list_playlist_files(self):
        """List all playlist files in the Playlists directory"""
        playlists = []
        if self.playlists_dir.exists():
            for file_path in sorted(self.playlists_dir.glob("*.json")):
                playlists.append({
                    "name": file_path.stem,  # filename without extension
                    "path": str(file_path),
                    "file": file_path
                })
        return playlists
    
    def load_playlist(self, file_path=None):
        """Load playlist from file (defaults to current playlist_file)"""
        if file_path is None:
            file_path = self.playlist_file
        else:
            file_path = Path(file_path)
            # If relative path, make it relative to playlists_dir
            if not file_path.is_absolute():
                file_path = self.playlists_dir / file_path.name
        
        if file_path.exists():
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    urls = data.get("urls", [])
                    # Support both old format (list of strings) and new format (list of objects)
                    # Convert to new format if needed
                    converted = []
                    for item in urls:
                        if isinstance(item, str):
                            # Old format: just URL string
                            converted.append({"url": item, "display_text": None})
                        elif isinstance(item, dict):
                            # New format: object with url and optional display_text
                            converted.append({"url": item.get("url", ""), "display_text": item.get("display_text")})
                    return converted
            except Exception as e:
                logger.warning(f"Failed to load playlist from {file_path}: {e}")
                return []
        return []
    
    def save_playlist(self, file_path=None):
        """Save playlist to file (defaults to current playlist_file)"""
        if file_path is None:
            file_path = self.playlist_file
        else:
            file_path = Path(file_path)
            # If relative path, make it relative to playlists_dir
            if not file_path.is_absolute():
                file_path = self.playlists_dir / file_path.name
        
        try:
            # Ensure directory exists
            file_path.parent.mkdir(parents=True, exist_ok=True)
            # Save in new format with metadata
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump({"urls": self.playlist}, f, indent=2)
            # Update current playlist_file if saving to a different file
            if file_path != self.playlist_file:
                self.playlist_file = file_path
            return True
        except Exception as e:
            logger.error(f"Failed to save playlist to {file_path}: {e}")
            return False
    
    def save_playlist_as(self, name):
        """Save playlist to a new file with the given name"""
        sanitized_name = sanitize_filename(name)
        if not sanitized_name:
            sanitized_name = "playlist"
        file_path = self.playlists_dir / f"{sanitized_name}.json"
        return self.save_playlist(file_path)
    
    def set_playlist_file(self, file_path):
        """Set the current playlist file and load it"""
        file_path = Path(file_path)
        # If relative path, make it relative to playlists_dir
        if not file_path.is_absolute():
            file_path = self.playlists_dir / file_path.name
        
        if file_path.exists():
            self.playlist_file = file_path
            self.playlist = self.load_playlist()
            return True
        return False
    
    def get_current_playlist_name(self):
        """Get the name of the current playlist (without extension)"""
        return self.playlist_file.stem if self.playlist_file else "Default"
    
    def delete_playlist_file(self, playlist_name):
        """Delete a playlist file by name
        
        Args:
            playlist_name: Name of playlist to delete (without .json extension)
            
        Returns:
            True if deleted successfully, False otherwise
        """
        try:
            playlist_path = self.playlists_dir / f"{playlist_name}.json"
            if playlist_path.exists():
                playlist_path.unlink()
                logger.info(f"Deleted playlist: {playlist_name}")
                return True
            return False
        except Exception as e:
            logger.error(f"Failed to delete playlist {playlist_name}: {e}")
            return False
    
    def ensure_default_playlist_exists(self):
        """Ensure Default.json playlist exists (create empty if it doesn't)"""
        default_path = self.playlists_dir / "Default.json"
        if not default_path.exists():
            try:
                # Create empty default playlist
                with open(default_path, 'w', encoding='utf-8') as f:
                    json.dump({"urls": []}, f, indent=2)
                logger.info("Created empty Default.json playlist")
                return True
            except Exception as e:
                logger.error(f"Failed to create Default.json: {e}")
                return False
        return True
    
    def get_playlist(self):
        """Get the current playlist (returns list of URL strings for backward compatibility)"""
        # Return just URLs for backward compatibility
        return [item["url"] if isinstance(item, dict) else item for item in self.playlist]
    
    def get_playlist_with_metadata(self):
        """Get the current playlist with metadata"""
        return self.playlist.copy()
    
    def add_url(self, url, display_text=None):
        """Add a URL to the playlist (if not already present)"""
        # Normalize URL
        url = url.strip().rstrip('/')
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
        
        # Check if URL already exists
        url_exists = any(item.get("url") == url if isinstance(item, dict) else item == url for item in self.playlist)
        
        if not url_exists:
            self.playlist.append({"url": url, "display_text": display_text})
            self.save_playlist()
    
    def remove_url(self, url):
        """Remove a URL from the playlist (with URL normalization for matching)"""
        # Normalize the URL to remove for matching (same logic as update_url_metadata)
        def normalize_url_for_match(u):
            if not u:
                return ""
            u = u.strip().rstrip('/')
            if u.startswith('http://'):
                u = 'https://' + u[7:]
            return u.lower()
        
        normalized_target = normalize_url_for_match(url)
        
        # Remove items where the normalized URL matches
        original_count = len(self.playlist)
        self.playlist = [item for item in self.playlist 
                        if normalize_url_for_match(item.get("url") if isinstance(item, dict) else item) != normalized_target]
        
        # Only save if something was actually removed
        if len(self.playlist) < original_count:
            self.save_playlist()
    
    def update_url_metadata(self, url, display_text):
        """Update the display text (metadata) for a URL in the playlist"""
        # Normalize URL for comparison (remove trailing slashes, normalize scheme)
        def normalize_url_for_match(u):
            if not u:
                return ""
            u = u.strip().rstrip('/')
            if u.startswith('http://'):
                u = 'https://' + u[7:]
            return u.lower()
        
        normalized_url = normalize_url_for_match(url)
        
        for item in self.playlist:
            item_url = item.get("url") if isinstance(item, dict) else item
            normalized_item_url = normalize_url_for_match(item_url)
            if normalized_item_url == normalized_url:
                if isinstance(item, dict):
                    item["display_text"] = display_text
                else:
                    # Convert old format to new format
                    index = self.playlist.index(item)
                    self.playlist[index] = {"url": item, "display_text": display_text}
                self.save_playlist()
                return
    
    def get_url_metadata(self, url):
        """Get the stored display text (metadata) for a URL"""
        # Normalize URL for comparison (remove trailing slashes, normalize scheme)
        def normalize_url_for_match(u):
            if not u:
                return ""
            u = u.strip().rstrip('/')
            if u.startswith('http://'):
                u = 'https://' + u[7:]
            return u.lower()
        
        normalized_url = normalize_url_for_match(url)
        
        for item in self.playlist:
            item_url = item.get("url") if isinstance(item, dict) else item
            normalized_item_url = normalize_url_for_match(item_url)
            if normalized_item_url == normalized_url:
                if isinstance(item, dict):
                    return item.get("display_text")
        return None
    
    def clear_playlist(self):
        """Clear the entire playlist"""
        self.playlist = []
        self.save_playlist()
    
    def reorder_playlist(self, new_order):
        """Reorder the playlist (new_order is list of URL strings)"""
        # Create a mapping of URL to full item data
        url_to_item = {}
        for item in self.playlist:
            item_url = item.get("url") if isinstance(item, dict) else item
            url_to_item[item_url] = item
        
        # Reorder based on new_order
        reordered = []
        for url in new_order:
            if url in url_to_item:
                reordered.append(url_to_item[url])
        
        # Validate that all URLs in new_order are in current playlist
        if len(reordered) == len(self.playlist) and set(new_order) == set(url_to_item.keys()):
            self.playlist = reordered
            self.save_playlist()


# ============================================================================
# ANIMATED LOADING OVERLAY CLASS
# ============================================================================

class AnimatedLoadingOverlay(QWidget):
    """Animated loading overlay with spinning loader and pulsing text"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Set widget to be opaque
        self.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, True)
        # Note: We don't use WA_AlwaysStackOnTop so playlist can be raised above overlay
        # Stacking order will be controlled via raise_() calls
        # Enable mouse tracking to intercept all mouse events
        self.setMouseTracking(True)
        self.setAttribute(Qt.WidgetAttribute.WA_NoMouseReplay, True)
        self.setStyleSheet("""
            QWidget {
                background-color: rgb(21, 21, 21);
            }
        """)
        
        # Load Bandcamp logo
        logo_path = Path(__file__).parent / "Logo" / "bandcamp-button-circle-line-aqua-128.png"
        if logo_path.exists():
            self.logo_pixmap = QPixmap(str(logo_path))
            # Scale logo to ~50px to fit nicely inside the spinner (which is 60px diameter)
            self.logo_pixmap = self.logo_pixmap.scaled(50, 50, Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
        else:
            self.logo_pixmap = None
        
        # Animation properties (use private attributes for pyqtProperty)
        self._rotation_angle = 0
        self._pulse_opacity = 1.0
        
        # Setup rotation animation
        self.rotation_animation = QPropertyAnimation(self, b"rotation_angle")
        self.rotation_animation.setDuration(1500)  # 1.5 seconds per rotation
        self.rotation_animation.setStartValue(0)
        self.rotation_animation.setEndValue(360)
        self.rotation_animation.setLoopCount(-1)  # Infinite loop
        self.rotation_animation.setEasingCurve(QEasingCurve.Type.Linear)
        
        # Setup pulse animation for text - fade in and out continuously
        self.pulse_animation = QPropertyAnimation(self, b"pulse_opacity")
        self.pulse_animation.setDuration(1500)  # 1.5 seconds to fade in
        self.pulse_animation.setStartValue(0.4)
        self.pulse_animation.setEndValue(1.0)
        self.pulse_animation.setLoopCount(1)  # Run once, then chain to reverse
        # Use InOutSine for smooth fade in and out
        self.pulse_animation.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        # Create a second animation that reverses to create continuous fade in/out
        self.pulse_animation_reverse = QPropertyAnimation(self, b"pulse_opacity")
        self.pulse_animation_reverse.setDuration(1500)  # 1.5 seconds to fade out
        self.pulse_animation_reverse.setStartValue(1.0)
        self.pulse_animation_reverse.setEndValue(0.4)
        self.pulse_animation_reverse.setLoopCount(1)  # Run once, then chain back to forward
        self.pulse_animation_reverse.setEasingCurve(QEasingCurve.Type.InOutSine)
        
        # Chain animations together for continuous fade in/out
        self.pulse_animation.finished.connect(self.pulse_animation_reverse.start)
        self.pulse_animation_reverse.finished.connect(self.pulse_animation.start)
        
        # Connect rotation animation to repaint
        self.rotation_animation.valueChanged.connect(self.update)
        self.pulse_animation.valueChanged.connect(self.update)
        self.pulse_animation_reverse.valueChanged.connect(self.update)
    
    def get_rotation_angle(self):
        return self._rotation_angle
    
    def set_rotation_angle(self, value):
        self._rotation_angle = value
        self.update()
    
    def get_pulse_opacity(self):
        return self._pulse_opacity
    
    def set_pulse_opacity(self, value):
        self._pulse_opacity = value
        self.update()
    
    rotation_angle = pyqtProperty(float, get_rotation_angle, set_rotation_angle)
    pulse_opacity = pyqtProperty(float, get_pulse_opacity, set_pulse_opacity)
    
    def showEvent(self, event):
        """Start animations when shown"""
        super().showEvent(event)
        self.rotation_animation.start()
        self.pulse_animation.start()
    
    def hideEvent(self, event):
        """Stop animations when hidden"""
        super().hideEvent(event)
        self.rotation_animation.stop()
        self.pulse_animation.stop()
        self.pulse_animation_reverse.stop()
    
    def contextMenuEvent(self, event):
        """Prevent right-click context menu during loading overlay"""
        # Block all context menu events on the loading overlay
        event.accept()
    
    def mousePressEvent(self, event):
        """Block all mouse press events during loading overlay"""
        event.accept()
    
    def mouseReleaseEvent(self, event):
        """Block all mouse release events during loading overlay"""
        event.accept()
    
    def mouseMoveEvent(self, event):
        """Block all mouse move events during loading overlay"""
        event.accept()
    
    def paintEvent(self, event):
        """Custom paint event for animated loader"""
        
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Fill the entire background with solid color
        painter.fillRect(self.rect(), QColor(21, 21, 21))
        
        # Get center of widget
        center_x = self.width() / 2
        center_y = self.height() / 2
        
        # Draw spinning circle loader
        loader_radius = 30
        loader_width = 4
        
        # Create gradient for loader
        gradient = QPainterPath()
        gradient.addEllipse(
            center_x - loader_radius,
            center_y - loader_radius - 20,  # Offset up a bit
            loader_radius * 2,
            loader_radius * 2
        )
        
        # Draw spinning arc
        pen = QPen()
        pen.setWidth(loader_width)
        pen.setCapStyle(Qt.PenCapStyle.RoundCap)
        
        # Create colorful gradient for the spinner using shades of #1da0c3
        conical_gradient = QConicalGradient(center_x, center_y - 20, self._rotation_angle)
        # Base color: #1da0c3 (RGB: 29, 160, 195)
        conical_gradient.setColorAt(0.0, QColor(29, 160, 195))   # Base cyan
        conical_gradient.setColorAt(0.25, QColor(20, 140, 175))  # Darker shade
        conical_gradient.setColorAt(0.5, QColor(15, 120, 155))   # Darkest shade
        conical_gradient.setColorAt(0.75, QColor(20, 140, 175))  # Darker shade
        conical_gradient.setColorAt(1.0, QColor(29, 160, 195))    # Base cyan
        
        pen.setBrush(conical_gradient)
        painter.setPen(pen)
        
        # Draw arc (270 degrees, leaving a gap)
        rect = QRect(
            int(center_x - loader_radius),
            int(center_y - loader_radius - 20),
            int(loader_radius * 2),
            int(loader_radius * 2)
        )
        
        start_angle = int(self._rotation_angle * 16)  # Qt uses 1/16th degree units
        span_angle = int(270 * 16)  # 270 degree arc
        
        painter.drawArc(rect, start_angle, span_angle)
        
        # Draw Bandcamp logo in the center of the spinner
        if self.logo_pixmap and not self.logo_pixmap.isNull():
            logo_size = self.logo_pixmap.size()
            logo_x = int(center_x - logo_size.width() / 2)
            logo_y = int(center_y - 20 - logo_size.height() / 2)  # Center at spinner center
            painter.drawPixmap(logo_x, logo_y, self.logo_pixmap)
        
        # Draw pulsing "Loading..." text
        painter.setPen(QColor(220, 220, 220))
        font = painter.font()
        font.setPointSize(14)
        font.setBold(True)
        painter.setFont(font)
        
        # Apply pulse opacity
        text_color = QColor(220, 220, 220)
        text_color.setAlphaF(self._pulse_opacity)
        painter.setPen(text_color)
        
        text = "Loading..."
        text_rect = painter.fontMetrics().boundingRect(text)
        text_x = int(center_x - text_rect.width() / 2)
        text_y = int(center_y + loader_radius + 30)
        
        painter.drawText(text_x, text_y, text)
        
        # Draw three pulsing dots below text
        dot_radius = 4
        dot_spacing = 12
        dots_start_x = center_x - (dot_spacing * 1.5)
        dots_y = center_y + loader_radius + 50
        
        for i in range(3):
            dot_x = dots_start_x + (i * dot_spacing)
            # Stagger the pulse for each dot
            dot_opacity = max(0.3, self._pulse_opacity - (i * 0.2))
            # Use shades of #1da0c3 for dots (lighter shades for variety)
            base_color = QColor(29, 160, 195)  # Base #1da0c3
            # Make each dot slightly lighter for visual variety
            dot_brightness = 1.0 + (i * 0.15)  # Increase brightness for each dot
            dot_color = QColor(
                min(255, int(base_color.red() * dot_brightness)),
                min(255, int(base_color.green() * dot_brightness)),
                min(255, int(base_color.blue() * dot_brightness))
            )
            dot_color.setAlphaF(dot_opacity)
            painter.setBrush(QBrush(dot_color))
            painter.setPen(Qt.PenStyle.NoPen)
            painter.drawEllipse(
                int(dot_x - dot_radius),
                int(dots_y - dot_radius),
                int(dot_radius * 2),
                int(dot_radius * 2)
            )

# ============================================================================
# PLAYLIST ITEM DELEGATE CLASS
# ============================================================================

class PlaylistItemDelegate(QStyledItemDelegate):
    """Custom delegate for playlist items to handle current item highlighting"""
    
    def paint(self, painter, option, index):
        """Paint the item with custom colors for current item"""
        # Check if this is the current item (using custom data role)
        is_current = index.data(Qt.ItemDataRole.UserRole + 1)  # Custom role for current item
        
        if is_current:
            # Current item: bright white text on blue background (ALWAYS blue, even if user-selected)
            # Paint blue background
            painter.fillRect(option.rect, QColor(74, 144, 226))  # Blue background #4a90e2
            
            # Paint white text with elision
            text = index.data(Qt.ItemDataRole.DisplayRole)
            if text:
                painter.setPen(QColor(255, 255, 255))  # White text
                # Use the same font as the list widget
                font = option.font
                painter.setFont(font)
                # Calculate text rect with padding (matching stylesheet padding: 1px 6px)
                text_rect = option.rect.adjusted(6, 1, -6, -1)
                # Elide text if it's too long
                metrics = QFontMetrics(font)
                elided_text = metrics.elidedText(str(text), Qt.TextElideMode.ElideRight, text_rect.width())
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)
            return  # Don't call parent paint - we've painted everything ourselves
        else:
            # Regular item: allow selection highlight if user clicked on it
            # Check if item is actually selected (user clicked on it)
            is_user_selected = option.state & QStyle.StateFlag.State_Selected
            
            if is_user_selected:
                # User-selected item: let stylesheet handle the highlight (light gray background)
                # Set text color to slightly lighter gray for better contrast
                option.palette.setColor(option.palette.ColorRole.Text, QColor(224, 224, 224))  # Light gray text (#e0e0e0)
                # Keep selected state so stylesheet applies the background
            else:
                # Not selected: light gray text, no background
                option.palette.setColor(option.palette.ColorRole.Text, QColor(160, 160, 160))
                # Don't clear selected state here - let Qt handle it naturally
            
            # Enable text elision for regular items
            option.textElideMode = Qt.TextElideMode.ElideRight
        
        # Call parent paint method (will use our modified palette and state)
        super().paint(painter, option, index)


class NanoMenuDelegate(QStyledItemDelegate):
    """Custom delegate for nano player track/album menus - blue text for current item (no background)"""
    
    def paint(self, painter, option, index):
        """Paint the item with blue text for current item"""
        # Check if this is the current item (using custom data role)
        is_current = index.data(Qt.ItemDataRole.UserRole + 1)  # Custom role for current item
        
        if is_current:
            # Current item: blue text, no background, no border/outline
            # Clear any selection state to prevent default highlighting/borders
            option.state &= ~QStyle.StateFlag.State_Selected
            option.state &= ~QStyle.StateFlag.State_HasFocus
            
            # Paint default background (match list background #2b2b2b)
            painter.fillRect(option.rect, QColor(43, 43, 43))  # Match list background #2b2b2b
            
            # Paint blue text
            text = index.data(Qt.ItemDataRole.DisplayRole)
            if text:
                painter.setPen(QColor(74, 144, 226))  # Blue text #4a90e2
                # Use the same font as the list widget
                font = option.font
                painter.setFont(font)
                # Calculate text rect with padding (matching stylesheet padding: 2px 8px)
                text_rect = option.rect.adjusted(8, 2, -8, -2)
                # Elide text if it's too long
                metrics = QFontMetrics(font)
                elided_text = metrics.elidedText(str(text), Qt.TextElideMode.ElideRight, text_rect.width())
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, elided_text)
            return  # Don't call parent paint - we've painted everything ourselves
        else:
            # Regular item: use default styling (light gray text from stylesheet)
            # Clear any selection state to prevent ugly borders on non-current items
            option.state &= ~QStyle.StateFlag.State_Selected
            option.state &= ~QStyle.StateFlag.State_HasFocus
            # Enable text elision for regular items
            option.textElideMode = Qt.TextElideMode.ElideRight
        
        # Call parent paint method (will use default stylesheet colors)
        super().paint(painter, option, index)


# ============================================================================
# CUSTOM VOLUME SLIDER CLASS
# ============================================================================

class VolumeSlider(QWidget):
    """Custom vertical volume slider that fills from bottom up"""
    valueChanged = pyqtSignal(int)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._value = 0
        self._minimum = 0
        self._maximum = 100
        self._is_dragging = False
        self.setFixedSize(20, 120)
        self.setMinimumSize(20, 120)
        self.setMaximumSize(20, 120)
    
    def setMinimum(self, value):
        self._minimum = value
    
    def setMaximum(self, value):
        self._maximum = value
    
    def setValue(self, value):
        if value != self._value:
            self._value = max(self._minimum, min(self._maximum, value))
            self.update()
            self.valueChanged.emit(self._value)
    
    def value(self):
        return self._value
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Use fixed width to prevent resizing (always accommodate 100%)
        width = 20  # Fixed width
        height = self.height()
        
        # Calculate fill height (from bottom up)
        fill_height = int((self._value - self._minimum) / (self._maximum - self._minimum) * height)
        
        # Draw background (unfilled area at top)
        painter.fillRect(0, 0, width, height - fill_height, QColor("#2b2b2b"))
        
        # Draw filled area (blue, from bottom)
        painter.fillRect(0, height - fill_height, width, fill_height, QColor("#4a90e2"))
        
        # Handle is hidden - no circle drawn
    
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self._is_dragging = True
            self._update_value_from_pos(event.position().y())
    
    def mouseMoveEvent(self, event):
        if self._is_dragging:
            self._update_value_from_pos(event.position().y())
    
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self._is_dragging = False
    
    def _update_value_from_pos(self, y):
        height = self.height()
        # Invert y: bottom is 0, top is height
        normalized = 1.0 - (y / height)
        normalized = max(0.0, min(1.0, normalized))
        value = int(self._minimum + normalized * (self._maximum - self._minimum))
        self.setValue(value)

# ============================================================================
# PLAYLIST SIDEBAR CLASS
# ============================================================================

class PlaylistSidebar(QWidget):
    """Integrated sidebar playlist widget - PotPlayer style"""
    
    def __init__(self, parent, playlist_manager, resolve_url_redirects_func, load_url_func):
        super().__init__(parent)
        self.playlist_manager = playlist_manager
        self.resolve_url_redirects = resolve_url_redirects_func
        self.load_url_func = load_url_func
        self.current_item = None  # Track currently playing item
        
        # Undo/redo history
        self.undo_history = []  # List of playlist states (list of dicts with url and display_text)
        self.redo_history = []  # List of playlist states for redo
        self.max_history_size = 50  # Limit history size to prevent memory issues
        self.is_undoing_redoing = False  # Flag to prevent saving history during undo/redo
        self._suppress_history_save = False  # Flag to prevent saving history when called as part of another operation
        self._reorder_save_timer = None  # Timer to debounce drag-and-drop reordering
        
        # Repeat and shuffle state - restore from settings if available
        parent = self.parent()
        while parent and not isinstance(parent, QWidget):
            parent = parent.parent()
        if parent and hasattr(parent, 'settings'):
            # Convert old boolean settings to new mode-based system
            # 0=off, 1=mode1, 2=mode2, 3=mode3
            old_repeat = parent.settings.get('repeat_on', False)
            old_shuffle = parent.settings.get('shuffle_on', False)
            # Migrate: True -> 1, False -> 0
            self.repeat_mode = parent.settings.get('repeat_mode', 1 if old_repeat else 1)  # Default to mode 1 (continuous)
            self.shuffle_mode = parent.settings.get('shuffle_mode', 1 if old_shuffle else 0)
        else:
            self.repeat_mode = 1  # 0=off, 1=continuous, 2=album, 3=track (default to continuous)
            self.shuffle_mode = 0  # 0=off, 1=tracks, 2=albums, 3=super
        
        # Shuffle Tracks mode: shuffled track list for current album
        self._shuffled_track_list = None  # List of track numbers in shuffled order
        self._shuffled_track_index = 0  # Current position in shuffled list
        self._shuffled_track_album_url = None  # URL of album for which we have shuffled list
        
        # Super Shuffle mode: track last 3 played combinations to avoid repeats
        self._super_shuffle_history = []  # List of tuples: [(album_url, track_number), ...] - last 3 played
        self._super_shuffle_max_history = 3  # Maximum number of recent tracks to avoid
        
        self.setup_ui()
        self.load_playlist()
        
        # Enable drag and drop on the entire sidebar widget
        self.setAcceptDrops(True)
        
        # Restore button states (after setup_ui creates the buttons)
        QTimer.singleShot(0, self._restore_button_states)
        
        # Save initial state to history
        QTimer.singleShot(100, self._save_state_to_history)
    
    def _restore_button_states(self):
        """Restore repeat and shuffle button states from settings"""
        if hasattr(self, 'repeat_btn'):
            self._update_repeat_button_ui()
        if hasattr(self, 'shuffle_btn'):
            self._update_shuffle_button_ui()
    
    def setup_ui(self):
        """Setup the sidebar UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 2, 5, 5)  # Reduced top margin to minimize border
        layout.setSpacing(5)
        # Ensure playlist sidebar doesn't exceed window width
        self.setMaximumWidth(260)  # Match window width
        
        # Title bar (clickable to minimize/restore)
        self.title_bar_widget = QWidget()
        # Ensure title bar fits within parent width (260px window - margins)
        # Account for playlist sidebar margins (5px each side = 10px total)
        self.title_bar_widget.setMaximumWidth(250)  # 260 - 10px for margins
        self.title_bar_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        self.title_bar_widget.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border: none;
            }
        """)
        title_bar = QHBoxLayout(self.title_bar_widget)
        title_bar.setContentsMargins(5, 2, 3, 2)  # Reduced left margin to fit more buttons
        title_bar.setSpacing(2)  # Reduced spacing to fit more buttons
        
        # Title label - hidden to save space for buttons
        # title_label = QLabel("Playlist")
        # title_label.setMaximumWidth(50)  # Limit label width to make room for buttons
        # title_label.setStyleSheet("""
        #     QLabel {
        #         font-size: 11px;
        #         font-weight: normal;
        #         color: #e0e0e0;
        #         padding: 0px;
        #         border: none;
        #     }
        # """)
        # title_bar.addWidget(title_label)
        
        # Playlist menu button (to the left of add button)
        playlist_menu_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ph.dots-three-outline-vertical-fill', color='#e0e0e0')
            if icon:
                playlist_menu_btn.setIcon(icon)
            else:
                playlist_menu_btn.setText("")
        else:
            playlist_menu_btn.setText("")
        playlist_menu_btn.setToolTip("Playlist Menu")
        playlist_menu_btn.setFixedSize(22, 22)  # Match other buttons
        playlist_menu_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        playlist_menu_btn.clicked.connect(self.show_playlist_menu)
        title_bar.addWidget(playlist_menu_btn)
        
        title_bar.addStretch()
        
        # Add URL button
        add_btn = QPushButton()
        # Use qtawesome icon if available, fallback to emoji
        if HAS_QT_AWESOME:
            icon = get_icon('plus', color='#e0e0e0')
            if icon:
                add_btn.setIcon(icon)
            else:
                add_btn.setText("")
        else:
            add_btn.setText("")
        add_btn.setToolTip("Add URL(s) From Clipboard (Supports Multiple URLs, One Per Line)")
        add_btn.setFixedSize(22, 22)  # Slightly smaller to fit more buttons
        add_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        add_btn.clicked.connect(self.add_url)
        title_bar.addWidget(add_btn)
        
        # Previous album button
        prev_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-backward', color='#e0e0e0')
            if icon:
                prev_album_btn.setIcon(icon)
            else:
                prev_album_btn.setText("")
        else:
            prev_album_btn.setText("")
        prev_album_btn.setToolTip("Previous Album")
        prev_album_btn.setFixedSize(22, 22)  # Slightly smaller to fit more buttons
        prev_album_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        prev_album_btn.clicked.connect(self.load_previous_album)
        title_bar.addWidget(prev_album_btn)
        
        # Next album button
        next_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-forward', color='#e0e0e0')
            if icon:
                next_album_btn.setIcon(icon)
            else:
                next_album_btn.setText("")
        else:
            next_album_btn.setText("")
        next_album_btn.setToolTip("Next Album")
        next_album_btn.setFixedSize(22, 22)  # Slightly smaller to fit more buttons
        next_album_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        next_album_btn.clicked.connect(self.load_next_album)
        title_bar.addWidget(next_album_btn)
        
        # Shuffle button
        self.shuffle_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('random', color='#a0a0a0')
            if icon:
                self.shuffle_btn.setIcon(icon)
            else:
                self.shuffle_btn.setText("")
        else:
            self.shuffle_btn.setText("")
        self.shuffle_btn.setToolTip("Shuffle: Off")
        self.shuffle_btn.setFixedSize(22, 22)  # Slightly smaller to fit more buttons
        self.shuffle_btn.setCheckable(True)
        self.shuffle_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #a0a0a0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """)
        self.shuffle_btn.clicked.connect(self.toggle_shuffle)
        title_bar.addWidget(self.shuffle_btn)
        
        # Repeat button (checkable for clear on/off state)
        self.repeat_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.repeat', color='#a0a0a0')
            if icon:
                self.repeat_btn.setIcon(icon)
            else:
                self.repeat_btn.setText("")
        else:
            self.repeat_btn.setText("")
        self.repeat_btn.setToolTip("Repeat: Off")
        self.repeat_btn.setFixedSize(22, 22)  # Slightly smaller to fit more buttons
        self.repeat_btn.setCheckable(True)
        self.repeat_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #a0a0a0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """)
        self.repeat_btn.clicked.connect(self.toggle_repeat)
        title_bar.addWidget(self.repeat_btn)
        
        # Detach/Attach button (changes icon based on state)
        self.detach_btn = QPushButton()
        if HAS_QT_AWESOME:
            # Try multiple icon options for detach
            icon = None
            for icon_name in ['fa5s.external-link-alt', 'fa5.external-link', 'ei.external-link', 'fa5s.window-restore']:
                try:
                    icon = get_icon(icon_name, color='#e0e0e0')
                    if icon:
                        break
                except:
                    continue
            if icon:
                self.detach_btn.setIcon(icon)
            else:
                self.detach_btn.setText("")
        else:
            self.detach_btn.setText("")
        self.detach_btn.setToolTip("Detach Playlist to Separate Window")
        self.detach_btn.setFixedSize(22, 22)
        self.detach_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        # Connect to parent window's detach method
        # Use a lambda to ensure we get the parent window at click time
        def get_parent_window():
            parent = self.parent()
            while parent and not isinstance(parent, QMainWindow):
                parent = parent.parent()
            return parent
        
        def on_detach_clicked():
            parent_window = get_parent_window()
            if parent_window and hasattr(parent_window, '_toggle_detach_playlist'):
                parent_window._toggle_detach_playlist()
        
        self.detach_btn.clicked.connect(on_detach_clicked)
        # Store detach button but don't add it yet - we'll add it in the correct order
        
        # Minimize/Maximize button (changes icon based on state) - add first
        self.minimize_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.chevron-down', color='#e0e0e0')
            if icon:
                self.minimize_btn.setIcon(icon)
            else:
                self.minimize_btn.setText("")
        else:
            self.minimize_btn.setText("")
        self.minimize_btn.setToolTip("Minimize Playlist")
        self.minimize_btn.setFixedSize(22, 22)  # Match other buttons
        self.minimize_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                color: white;
            }
        """)
        self.minimize_btn.clicked.connect(self.toggle_minimize_click)
        title_bar.addWidget(self.minimize_btn)  # Add minimize button first
        
        # Add detach button second
        title_bar.addWidget(self.detach_btn)
        
        # Close button
        close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_btn.setIcon(icon)
            else:
                close_btn.setText("")
        else:
            close_btn.setText("")
        close_btn.setToolTip("Close Playlist")
        close_btn.setFixedSize(22, 22)  # Match other buttons
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #e81123;
                color: white;
            }
        """)
        close_btn.clicked.connect(self.close_playlist)
        title_bar.addWidget(close_btn)
        self.close_btn = close_btn  # Store reference for hiding when detached
        
        # Make title bar double-clickable to minimize/restore
        def title_bar_double_click(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.toggle_minimize(event)
        
        self.title_bar_widget.mouseDoubleClickEvent = title_bar_double_click
        self.is_minimized = False
        
        layout.addWidget(self.title_bar_widget)
        
        # List widget for playlist items
        self.list_widget = QListWidget()
        # Set custom delegate for current item highlighting
        self.list_widget.setItemDelegate(PlaylistItemDelegate(self.list_widget))
        self.list_widget.setStyleSheet("""
            QListWidget {
                background-color: #2b2b2b;
                color: #a0a0a0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 0px;
                font-size: 12px;
            }
            QListWidget::item {
                padding: 0px 6px;
                border-radius: 2px;
                color: #a0a0a0;
                min-height: 18px;
            }
            QListWidget::item:hover {
                background-color: #3a3a3a;
            }
            QListWidget::item:selected {
                background-color: #3a3a3a;
                color: #e0e0e0;
                outline: none;
            }
            QListWidget::item:focus {
                outline: none;
            }
            /* Custom scrollbar styling */
            QScrollBar:vertical {
                background-color: #2b2b2b;
                width: 10px;
                margin: 0px;
                border: none;
            }
            QScrollBar::handle:vertical {
                background-color: #4a4a4a;
                min-height: 20px;
                border-radius: 5px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #5a5a5a;
            }
            QScrollBar::handle:vertical:pressed {
                background-color: #6a6a6a;
            }
            QScrollBar::add-line:vertical {
                height: 0px;
                subcontrol-position: bottom;
                subcontrol-origin: margin;
            }
            QScrollBar::sub-line:vertical {
                height: 0px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }
            QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
                background: none;
            }
        """)
        # Enable focus for keyboard shortcuts (Delete key)
        self.list_widget.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        # Enable extended selection for Ctrl+click and Shift+click
        self.list_widget.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        # Make items more compact (reduce spacing between items)
        self.list_widget.setSpacing(0)
        self.list_widget.setUniformItemSizes(True)  # Optimize rendering for uniform item sizes
        # Hide horizontal scrollbar
        self.list_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.list_widget.setAcceptDrops(True)
        self.list_widget.setDragDropMode(QListWidget.DragDropMode.InternalMove)
        self.list_widget.itemDoubleClicked.connect(self.on_item_double_clicked)
        self.list_widget.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.list_widget.customContextMenuRequested.connect(self.show_context_menu)
        # Save playlist when items are reordered (with debouncing to avoid multiple history entries)
        self.list_widget.model().rowsMoved.connect(self._on_rows_moved)
        # Handle drag and drop for adding URLs and Delete key
        self.list_widget.installEventFilter(self)
        layout.addWidget(self.list_widget, 1)
        
        # Blank item at bottom of playlist (for visual spacing)
        self._blank_item = None
    
    def _ensure_blank_item_at_bottom(self):
        """Ensure there's always a blank item at the bottom of the playlist"""
        # Remove existing blank item if it exists
        if self._blank_item:
            try:
                row = self.list_widget.row(self._blank_item)
                if row >= 0:
                    self.list_widget.takeItem(row)
            except RuntimeError:
                # Item has been deleted (e.g., by clear()) - just clear the reference
                pass
            self._blank_item = None
        
        # Add blank item at the bottom
        blank_item = QListWidgetItem(" ")
        blank_item.setData(Qt.ItemDataRole.UserRole, None)  # No URL data
        blank_item.setFlags(Qt.ItemFlag.NoItemFlags)  # Not selectable, not editable
        blank_item.setToolTip("")
        self.list_widget.addItem(blank_item)
        self._blank_item = blank_item
    
    def load_playlist(self):
        """Load playlist URLs into the list widget and refresh all items"""
        # Ensure playlist manager is initialized (safety check for deferred init)
        if hasattr(self, 'parent_window') and self.parent_window:
            if hasattr(self.parent_window, '_ensure_playlist_manager'):
                self.parent_window._ensure_playlist_manager()
        
        # Store current item URL before clearing (to restore highlighting)
        current_url = None
        if self.current_item:
            current_url = self.current_item.data(Qt.ItemDataRole.UserRole)
        
        self.list_widget.clear()
        self.current_item = None  # Clear reference since items are cleared
        self._blank_item = None  # Clear blank item reference since items are cleared
        
        # Get playlist with metadata (playlist_manager is accessed via parent_window)
        playlist_with_metadata = self.playlist_manager.get_playlist_with_metadata()
        for item in playlist_with_metadata:
            url = item.get("url") if isinstance(item, dict) else item
            stored_display_text = item.get("display_text") if isinstance(item, dict) else None
            
            # Resolve URL before adding to ensure correct display
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Use stored metadata if available, otherwise fall back to URL parsing
            if stored_display_text:
                display_text = stored_display_text
            else:
                display_text = self.url_to_display(url)
                if not display_text:
                    display_text = url
            
            # Create list item
            list_item = QListWidgetItem(display_text)
            list_item.setData(Qt.ItemDataRole.UserRole, url)
            list_item.setToolTip(url)
            self.list_widget.addItem(list_item)
        
        # Add blank item at bottom
        self._ensure_blank_item_at_bottom()
        
        # Refresh all items to update display text (in case URLs were resolved)
        self.refresh_all_items()
        
        # Restore highlighting for current item if it still exists
        if current_url:
            self.update_current_item(current_url)
        else:
            # If no current URL stored, try to get it from the parent window's web view
            # This is important for startup when playlist is loaded after URL is already loaded
            parent = self.parent()
            while parent and not isinstance(parent, QMainWindow):
                parent = parent.parent()
            if parent and hasattr(parent, 'web_view') and parent.web_view:
                current_url = parent.web_view.url().toString()
                if current_url:
                    # Small delay to ensure playlist is fully rendered
                    QTimer.singleShot(100, lambda: self.update_current_item(current_url))
    
    def add_item(self, url):
        """Add a URL item to the playlist"""
        # Ensure URL is resolved first
        resolved_url = self.resolve_url_redirects(url)
        if resolved_url:
            url = resolved_url
        
        # Try to get stored metadata first, then fall back to URL parsing
        stored_metadata = self.playlist_manager.get_url_metadata(url)
        if stored_metadata:
            display_text = stored_metadata
        else:
            display_text = self.url_to_display(url)
            if not display_text:
                display_text = url
        
        # Create list item
        item = QListWidgetItem(display_text)
        item.setData(Qt.ItemDataRole.UserRole, url)  # Store full URL as data
        item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Mark as not current (delegate will handle colors)
        item.setToolTip(url)
        
        # Remove blank item temporarily if it exists
        if self._blank_item:
            try:
                row = self.list_widget.row(self._blank_item)
                if row >= 0:
                    self.list_widget.takeItem(row)
            except RuntimeError:
                # Item has been deleted (e.g., by clear()) - just clear the reference
                pass
            self._blank_item = None
        
        # Add the new item
        self.list_widget.addItem(item)
        
        # Re-add blank item at bottom
        self._ensure_blank_item_at_bottom()
    
    def url_to_display(self, url):
        """Convert URL to display format (Artist - Album)"""
        # First, resolve URL redirects if needed
        resolved_url = self.resolve_url_redirects(url)
        if resolved_url:
            url = resolved_url
        
        # Use parent's method if available (this should return "Artist - Album" format)
        if hasattr(self.parent(), 'extract_artist_album_from_url'):
            result = self.parent().extract_artist_album_from_url(url)
            if result:
                return result
        
        # Fallback: parse URL
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            path_parts = [p for p in parsed.path.split('/') if p]
            
            # Try to extract artist from subdomain
            hostname = parsed.hostname or ""
            artist = None
            if ".bandcamp.com" in hostname.lower():
                subdomain = hostname.lower().replace(".bandcamp.com", "")
                if "-" in subdomain:
                    artist = " ".join(word.capitalize() for word in subdomain.split("-"))
                else:
                    import re
                    words = re.findall(r'[a-z]+|[A-Z][a-z]*', subdomain)
                    if len(words) > 1:
                        artist = " ".join(word.capitalize() for word in words)
                    else:
                        artist = subdomain.capitalize()
            
            if artist and path_parts:
                # Extract album/track name from path
                if len(path_parts) >= 2 and path_parts[0] in ['album', 'track']:
                    name = path_parts[1]
                    name = " ".join(word.capitalize() for word in name.split("-"))
                    return f"{artist} - {name}"
                elif len(path_parts) >= 1:
                    name = path_parts[0]
                    name = " ".join(word.capitalize() for word in name.split("-"))
                    return f"{artist} - {name}"
            elif artist:
                return artist
        except:
            pass
        
        return None
    
    def refresh_all_items(self):
        """Refresh display text for all items (useful after URL resolution)"""
        # Store current item to preserve highlighting
        current_item_url = None
        if self.current_item:
            current_item_url = self.current_item.data(Qt.ItemDataRole.UserRole)
        
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                # Re-resolve URL if needed
                resolved_url = self.resolve_url_redirects(url)
                if resolved_url and resolved_url != url:
                    # Update stored URL to resolved version
                    item.setData(Qt.ItemDataRole.UserRole, resolved_url)
                    url = resolved_url
                
                # Check for stored metadata first before falling back to URL parsing
                stored_metadata = self.playlist_manager.get_url_metadata(url)
                if stored_metadata:
                    # Use stored metadata
                    display_text = stored_metadata
                else:
                    # Fall back to URL parsing only if no stored metadata
                    display_text = self.url_to_display(url)
                    if not display_text:
                        display_text = url
                
                # Update display text
                item.setText(display_text)
                item.setToolTip(url)
                
                # Clear custom role (will be set if this is the current item)
                if item != self.current_item:
                    item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Not current
        
        # Restore highlighting for current item if it still exists
        if current_item_url:
            self.update_current_item(current_item_url)
    
    def resolve_url_redirects(self, url):
        """Resolve URL redirects - use parent's method if available"""
        if hasattr(self.parent(), 'resolve_url_redirects'):
            return self.parent().resolve_url_redirects(url)
        return url
    
    def toggle_shuffle(self):
        """Cycle through shuffle modes: 0 (off)  1 (tracks)  2 (albums)  3 (super)  0"""
        # Cycle through modes: 0  1  2  3  0
        self.shuffle_mode = (self.shuffle_mode + 1) % 4
        
        # Update UI
        self._update_shuffle_button_ui()
        
        # Get parent window to access web_view and methods
        # Use same logic as _update_javascript_shuffle_mode to handle detached playlist
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        # If not found and we're in a detached window, try to find main window through detached window
        if not parent_window or not isinstance(parent_window, QMainWindow):
            # Check if we're in a detached playlist window
            current_widget = self
            while current_widget:
                # Check if current widget is a QDialog (detached window)
                if isinstance(current_widget, QDialog):
                    # Try to find the main window by checking all top-level widgets
                    from PyQt6.QtWidgets import QApplication
                    app = QApplication.instance()
                    if app:
                        for widget in app.topLevelWidgets():
                            if isinstance(widget, QMainWindow) and hasattr(widget, 'web_view'):
                                parent_window = widget
                                break
                    break
                current_widget = current_widget.parent()
        if parent_window and hasattr(parent_window, '_detached_shuffle_btn'):
            def update_detached_shuffle_btn():
                try:
                    # Check if button still exists and is valid
                    if not hasattr(parent_window, '_detached_shuffle_btn') or not parent_window._detached_shuffle_btn:
                        return
                    # Try to access widget to verify it's still valid
                    _ = parent_window._detached_shuffle_btn.isVisible()
                except (RuntimeError, AttributeError):
                    # Widget has been deleted - can't update it
                    return
                
                try:
                    parent_window._detached_shuffle_btn.blockSignals(True)  # Prevent recursive updates
                    # Update detached button to match mode
                    is_active = self.shuffle_mode > 0
                    parent_window._detached_shuffle_btn.setChecked(is_active)
                    # Get tooltip from our button
                    tooltip = self.shuffle_btn.toolTip()
                    parent_window._detached_shuffle_btn.setToolTip(tooltip)
                    # Update icon based on mode
                    if HAS_QT_AWESOME:
                        if self.shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            # Clear icon first to force refresh, then set new icon
                            parent_window._detached_shuffle_btn.setIcon(QIcon())
                            parent_window._detached_shuffle_btn.setIcon(icon)
                            # Force button to update/repaint
                            parent_window._detached_shuffle_btn.update()
                            parent_window._detached_shuffle_btn.repaint()
                            # Also update the parent widget to ensure visual refresh
                            if parent_window._detached_shuffle_btn.parent():
                                parent_window._detached_shuffle_btn.parent().update()
                            # Ensure the detached window is visible and updated
                            if hasattr(parent_window, 'detached_playlist_window') and parent_window.detached_playlist_window:
                                try:
                                    parent_window.detached_playlist_window.update()
                                except (RuntimeError, AttributeError):
                                    pass
                    parent_window._detached_shuffle_btn.blockSignals(False)
                except (RuntimeError, AttributeError):
                    # Widget was deleted during update - ignore
                    pass
            # Update immediately
            update_detached_shuffle_btn()
            # Also update with a small delay to ensure visual refresh (with safety check)
            QTimer.singleShot(10, update_detached_shuffle_btn)
        
        # Sync with nano player if exists
        if parent_window and hasattr(parent_window, 'nano_player_window') and parent_window.nano_player_window:
            try:
                if hasattr(parent_window.nano_player_window, 'shuffle_btn') and parent_window.nano_player_window.shuffle_btn:
                    parent_window.nano_player_window.shuffle_btn.blockSignals(True)  # Prevent recursive updates
                    is_active = self.shuffle_mode > 0
                    parent_window.nano_player_window.shuffle_btn.setChecked(is_active)
                    tooltip = self.shuffle_btn.toolTip()
                    parent_window.nano_player_window.shuffle_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if self.shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif self.shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            parent_window.nano_player_window.shuffle_btn.setIcon(icon)
                    parent_window.nano_player_window.shuffle_btn.blockSignals(False)
            except (AttributeError, RuntimeError):
                pass  # Nano player might not be initialized yet
        
        # Save to settings
        parent = self.parent()
        while parent and not isinstance(parent, QWidget):
            parent = parent.parent()
        if parent and hasattr(parent, 'settings'):
            parent.settings['shuffle_mode'] = self.shuffle_mode
            # Keep old setting for backward compatibility (but don't use it)
            parent.settings['shuffle_on'] = self.shuffle_mode > 0
            parent.save_settings()
        
        # Update JavaScript shuffle mode FIRST before handling mode-specific logic
        # This ensures the JavaScript knows the current mode immediately
        self._update_javascript_shuffle_mode()
        
        # Handle shuffle mode changes
        # Get parent window (PlayerWindow) to access web_view and methods
        # Note: parent_window was already retrieved above for detached/nano button sync
        # _shuffled_track_list is stored on PlayerWindow, not PlaylistSidebar
        
        if self.shuffle_mode == 0:
            # Shuffle disabled: Clear Python variables on PlayerWindow
            if parent_window and hasattr(parent_window, '_shuffled_track_list'):
                parent_window._shuffled_track_list = None
                parent_window._shuffled_track_index = 0
            
            # Clear pending Super Shuffle load flag
            if parent_window:
                parent_window._pending_super_shuffle_load = False
            
            # Clear JavaScript variables to stop shuffle behavior
            if parent_window and hasattr(parent_window, 'web_view') and parent_window.web_view and parent_window.web_view.page():
                clear_js = """
                (function() {
                    window.bandcampShuffledTrackList = null;
                    window.bandcampShuffledTrackIndex = 0;
                    console.log('Bandcamp Player: Cleared shuffled track list (shuffle disabled)');
                })();
                """
                parent_window.web_view.page().runJavaScript(clear_js)
                logger.debug("Shuffle disabled: Cleared JavaScript shuffled track list")
            
            # Re-setup button interception to restore normal behavior
            if parent_window and hasattr(parent_window, '_setup_next_prev_button_interception'):
                QTimer.singleShot(150, parent_window._setup_next_prev_button_interception)
        
        elif self.shuffle_mode == 1:
            # Shuffle Tracks mode enabled: Create shuffled list if album is loaded
            # Clear existing Python variables first (will be recreated)
            if parent_window and hasattr(parent_window, '_shuffled_track_list'):
                parent_window._shuffled_track_list = None
                parent_window._shuffled_track_index = 0
            
            # Create shuffled list for current album if one is loaded
            if not parent_window:
                logger.warning("Shuffle Tracks enabled: Could not find parent window to create shuffled list")
            elif not hasattr(parent_window, 'web_view') or not parent_window.web_view:
                logger.warning("Shuffle Tracks enabled: Parent window has no web_view")
            else:
                current_url = parent_window.web_view.url().toString()
                if current_url and current_url.startswith('http'):
                    # Wait a bit to ensure page is ready, then create shuffled list
                    QTimer.singleShot(1000, lambda: parent_window._create_shuffled_track_list(current_url) if parent_window else None)
                    logger.debug(f"Shuffle Tracks enabled: Will create shuffled list for current album: {current_url}")
                else:
                    logger.debug("Shuffle Tracks enabled: No album loaded yet, will create list when album loads")
            
            # Re-setup button interception to ensure it's active for shuffle mode 1
            if parent_window and hasattr(parent_window, '_setup_next_prev_button_interception'):
                QTimer.singleShot(200, parent_window._setup_next_prev_button_interception)
        
        elif self.shuffle_mode == 3:
            # Super Shuffle mode enabled: Load random album and track
            # Clear shuffled track list (not used in Super Shuffle)
            if parent_window and hasattr(parent_window, '_shuffled_track_list'):
                parent_window._shuffled_track_list = None
                parent_window._shuffled_track_index = 0
            
            # Clear JavaScript variables for shuffle tracks mode (not applicable to Super Shuffle)
            if parent_window and hasattr(parent_window, 'web_view') and parent_window.web_view and parent_window.web_view.page():
                clear_js = """
                (function() {
                    window.bandcampShuffledTrackList = null;
                    window.bandcampShuffledTrackIndex = 0;
                })();
                """
                parent_window.web_view.page().runJavaScript(clear_js)
            
            # Check if a track is currently playing - if so, wait until it finishes
            if parent_window and hasattr(parent_window, 'web_view') and parent_window.web_view and parent_window.web_view.page():
                def check_playing_and_load():
                    """Check if audio is playing, and either load immediately or wait for track finish"""
                    check_js = """
                    (function() {
                        var audioElement = document.querySelector('audio');
                        if (audioElement) {
                            var isPlaying = !audioElement.paused && audioElement.currentTime > 0;
                            var currentTime = audioElement.currentTime || 0;
                            var duration = audioElement.duration || 0;
                            return {
                                isPlaying: isPlaying,
                                currentTime: currentTime,
                                duration: duration
                            };
                        }
                        return { isPlaying: false, currentTime: 0, duration: 0 };
                    })();
                    """
                    def on_result(result):
                        try:
                            if result and result.get('isPlaying', False):
                                # Track is playing - set flag to load when track finishes
                                if hasattr(parent_window, '_pending_super_shuffle_load'):
                                    parent_window._pending_super_shuffle_load = True
                                else:
                                    parent_window._pending_super_shuffle_load = True
                                logger.debug("Super Shuffle enabled: Track is playing, will load random album/track when current track finishes")
                            else:
                                # No track playing - load immediately
                                if hasattr(parent_window, '_load_super_shuffle_track'):
                                    parent_window._load_super_shuffle_track()
                                    logger.debug("Super Shuffle enabled: No track playing, loading random album and track immediately")
                        except Exception as e:
                            logger.debug(f"Error checking playback state for Super Shuffle: {e}")
                            # On error, try to load anyway
                            if hasattr(parent_window, '_load_super_shuffle_track'):
                                parent_window._load_super_shuffle_track()
                    
                    parent_window.web_view.page().runJavaScript(check_js, on_result)
                
                # Check after a short delay to ensure page is ready
                QTimer.singleShot(200, check_playing_and_load)
        
        else:
            # Other shuffle modes (2=albums): Clear shuffled track list
            if parent_window and hasattr(parent_window, '_shuffled_track_list'):
                parent_window._shuffled_track_list = None
                parent_window._shuffled_track_index = 0
            
            # Clear JavaScript variables for shuffle tracks mode (not applicable to other modes, but clean up anyway)
            if parent_window and hasattr(parent_window, 'web_view') and parent_window.web_view and parent_window.web_view.page():
                clear_js = """
                (function() {
                    window.bandcampShuffledTrackList = null;
                    window.bandcampShuffledTrackIndex = 0;
                })();
                """
                parent_window.web_view.page().runJavaScript(clear_js)
    
    def toggle_repeat(self):
        """Cycle through repeat modes: 0 (off)  1 (continuous)  2 (album)  3 (track)  0"""
        # Cycle through modes: 0  1  2  3  0
        self.repeat_mode = (self.repeat_mode + 1) % 4
        
        # Update UI
        self._update_repeat_button_ui()
        
        # Sync with detached window button if exists
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        if parent_window and hasattr(parent_window, '_detached_repeat_btn'):
            def update_detached_repeat_btn():
                try:
                    # Check if button still exists and is valid
                    if not hasattr(parent_window, '_detached_repeat_btn') or not parent_window._detached_repeat_btn:
                        return
                    # Try to access widget to verify it's still valid
                    _ = parent_window._detached_repeat_btn.isVisible()
                except (RuntimeError, AttributeError):
                    # Widget has been deleted - can't update it
                    return
                
                try:
                    parent_window._detached_repeat_btn.blockSignals(True)  # Prevent recursive updates
                    # Update detached button to match mode
                    is_active = self.repeat_mode > 0
                    parent_window._detached_repeat_btn.setChecked(is_active)
                    # Get tooltip from our button
                    tooltip = self.repeat_btn.toolTip()
                    parent_window._detached_repeat_btn.setToolTip(tooltip)
                    # Update icon based on mode
                    if HAS_QT_AWESOME:
                        if self.repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            # Clear icon first to force refresh, then set new icon
                            parent_window._detached_repeat_btn.setIcon(QIcon())
                            parent_window._detached_repeat_btn.setIcon(icon)
                            # Force button to update/repaint
                            parent_window._detached_repeat_btn.update()
                            parent_window._detached_repeat_btn.repaint()
                            # Also update the parent widget to ensure visual refresh
                            if parent_window._detached_repeat_btn.parent():
                                parent_window._detached_repeat_btn.parent().update()
                            # Ensure the detached window is visible and updated
                            if hasattr(parent_window, 'detached_playlist_window') and parent_window.detached_playlist_window:
                                try:
                                    parent_window.detached_playlist_window.update()
                                except (RuntimeError, AttributeError):
                                    pass
                    parent_window._detached_repeat_btn.blockSignals(False)
                except (RuntimeError, AttributeError):
                    # Widget was deleted during update - ignore
                    pass
            # Update immediately
            update_detached_repeat_btn()
            # Also update with a small delay to ensure visual refresh (with safety check)
            QTimer.singleShot(10, update_detached_repeat_btn)
            # Update overlay for detached repeat button (for mode 3 - "1" overlay)
            if hasattr(parent_window, '_update_detached_repeat_overlay'):
                def update_overlay_safe():
                    try:
                        if hasattr(parent_window, '_update_detached_repeat_overlay'):
                            parent_window._update_detached_repeat_overlay(self.repeat_mode)
                    except (RuntimeError, AttributeError):
                        pass
                QTimer.singleShot(0, update_overlay_safe)
        
        # Sync with nano player if exists
        if parent_window and hasattr(parent_window, 'nano_player_window') and parent_window.nano_player_window:
            try:
                if hasattr(parent_window.nano_player_window, 'repeat_btn') and parent_window.nano_player_window.repeat_btn:
                    parent_window.nano_player_window.repeat_btn.blockSignals(True)  # Prevent recursive updates
                    is_active = self.repeat_mode > 0
                    parent_window.nano_player_window.repeat_btn.setChecked(is_active)
                    tooltip = self.repeat_btn.toolTip()
                    parent_window.nano_player_window.repeat_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if self.repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif self.repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            parent_window.nano_player_window.repeat_btn.setIcon(icon)
                    parent_window.nano_player_window.repeat_btn.blockSignals(False)
                    # Update overlay for nano player
                    if hasattr(parent_window.nano_player_window, '_update_repeat_overlay_nano'):
                        parent_window.nano_player_window._update_repeat_overlay_nano(self.repeat_mode)
            except (AttributeError, RuntimeError):
                pass  # Nano player might not be initialized yet
        
        # Save to settings
        parent = self.parent()
        while parent and not isinstance(parent, QWidget):
            parent = parent.parent()
        if parent and hasattr(parent, 'settings'):
            parent.settings['repeat_mode'] = self.repeat_mode
            # Keep old setting for backward compatibility (but don't use it)
            parent.settings['repeat_on'] = self.repeat_mode > 0
            parent.save_settings()
    
    def _update_repeat_button(self):
        """Update repeat button appearance based on current state (legacy method - redirects to new method)"""
        self._update_repeat_button_ui()
    
    def _update_repeat_button_ui(self):
        """Update repeat button appearance based on current mode"""
        if not hasattr(self, 'repeat_btn'):
            return
        
        # Mode 0=off, 1=continuous, 2=album, 3=track
        is_active = self.repeat_mode > 0
        self.repeat_btn.setChecked(is_active)
        
        # Determine tooltip and icon color based on mode
        if self.repeat_mode == 0:
            tooltip = "Repeat: Off"
            icon_color = '#a0a0a0'  # Gray
        elif self.repeat_mode == 1:
            tooltip = "Repeat: Continuous (play next album)"
            icon_color = '#4a90e2'  # Blue
        elif self.repeat_mode == 2:
            tooltip = "Repeat: Album (loop current album)"
            icon_color = '#4a90e2'  # Blue
        else:  # mode 3
            tooltip = "Repeat: Track (loop current track)"
            icon_color = '#4a90e2'  # Blue
        
        self.repeat_btn.setToolTip(tooltip)
        
        # Update icon based on mode
        if HAS_QT_AWESOME:
            if self.repeat_mode == 0:
                icon = get_icon('ei.repeat', color=icon_color)
            elif self.repeat_mode == 1:
                icon = get_icon('ei.repeat', color=icon_color)  # Keep repeat for continuous
            elif self.repeat_mode == 2:
                icon = get_icon('ei.heart', color=icon_color)  # Heart for album
            else:  # mode 3
                icon = get_icon('ei.heart', color=icon_color)  # Heart for track
            if icon:
                self.repeat_btn.setIcon(icon)
        
        # Update "1" overlay for Repeat 1 Track mode
        self._update_repeat_overlay()
        
        # Update JavaScript repeat mode
        self._update_javascript_repeat_mode()
        
        # Update JavaScript shuffle mode and set up button interception
        self._update_javascript_shuffle_mode()
    
    def _update_javascript_shuffle_mode(self):
        """Update the JavaScript shuffle mode variable when mode changes"""
        # Get parent window to access web_view
        # First try normal parent chain
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        # If not found and we're in a detached window, try to find main window through detached window
        if not parent_window or not isinstance(parent_window, QMainWindow):
            # Check if we're in a detached playlist window
            current_widget = self
            while current_widget:
                # Check if current widget is a QDialog (detached window)
                if isinstance(current_widget, QDialog):
                    # Try to find the main window by checking all top-level widgets
                    from PyQt6.QtWidgets import QApplication
                    app = QApplication.instance()
                    if app:
                        for widget in app.topLevelWidgets():
                            if isinstance(widget, QMainWindow) and hasattr(widget, 'web_view'):
                                parent_window = widget
                                break
                    break
                current_widget = current_widget.parent()

        if not parent_window or not hasattr(parent_window, 'web_view') or not parent_window.web_view or not parent_window.web_view.page():
            return

        shuffle_mode = self.shuffle_mode
        js_code = f"""
        (function() {{
            window.bandcampShuffleMode = {shuffle_mode};
            console.log('Bandcamp Player: Shuffle mode updated to {shuffle_mode}');
            
            // Remove interception attributes so buttons can be re-setup with new mode
            var nextBtn = document.querySelector('button[aria-label="Skip to next song"], .next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
            if (nextBtn) {{
                nextBtn.removeAttribute('data-bandcamp-player-intercepted');
            }}
            
            var prevBtn = document.querySelector('button[aria-label="Skip to previous song"], .next-prev-controls button[aria-label*="previous"], .next-prev-controls button[aria-label*="Previous"], button[aria-label*="Skip to previous"]');
            if (prevBtn) {{
                prevBtn.removeAttribute('data-bandcamp-player-intercepted');
            }}
        }})();
        """
        parent_window.web_view.page().runJavaScript(js_code)
        
        # If shuffle is disabled, also clear the shuffled track list variables
        if shuffle_mode == 0:
            clear_js = """
            (function() {
                window.bandcampShuffledTrackList = null;
                window.bandcampShuffledTrackIndex = 0;
                console.log('Bandcamp Player: Cleared shuffled track list (shuffle disabled)');
            })();
            """
            parent_window.web_view.page().runJavaScript(clear_js)
        
        # Re-setup button interception when shuffle mode changes (with small delay to ensure JS executed)
        if hasattr(parent_window, '_setup_next_prev_button_interception'):
            QTimer.singleShot(150, parent_window._setup_next_prev_button_interception)
    
    def _update_shuffle_button_ui(self):
        """Update shuffle button appearance based on current mode"""
        if not hasattr(self, 'shuffle_btn'):
            return
        
        # Mode 0=off, 1=tracks, 2=albums, 3=super
        is_active = self.shuffle_mode > 0
        self.shuffle_btn.setChecked(is_active)
        
        # Determine tooltip and icon color based on mode
        if self.shuffle_mode == 0:
            tooltip = "Shuffle: Off"
            icon_color = '#a0a0a0'  # Gray
        elif self.shuffle_mode == 1:
            tooltip = "Shuffle: Tracks (shuffle tracks in album)"
            icon_color = '#4a90e2'  # Blue
        elif self.shuffle_mode == 2:
            tooltip = "Shuffle: Albums (randomize album order)"
            icon_color = '#4a90e2'  # Blue
        else:  # mode 3
            tooltip = "Super Shuffle (random album & track)"
            icon_color = '#4a90e2'  # Blue
        
        self.shuffle_btn.setToolTip(tooltip)
        
        # Update icon based on mode
        if HAS_QT_AWESOME:
            if self.shuffle_mode == 0:
                icon = get_icon('random', color=icon_color)
            elif self.shuffle_mode == 1:
                icon = get_icon('random', color=icon_color)  # Keep random for tracks
            elif self.shuffle_mode == 2:
                icon = get_icon('ei.question', color=icon_color)  # Question for albums
            else:  # mode 3
                icon = get_icon('ei.asl', color=icon_color)  # ASL for super shuffle
            if icon:
                self.shuffle_btn.setIcon(icon)
    
    def _update_repeat_overlay(self):
        """Update overlay on repeat button based on mode:
        - Mode 1 (Continuous): no overlay
        - Mode 2 (Album):  overlay
        - Mode 3 (Track): "1" overlay
        """
        if not hasattr(self, 'repeat_btn'):
            return
        
        # Remove existing overlay if it exists
        if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label is not None:
            try:
                self._repeat_overlay_label.deleteLater()
            except (AttributeError, RuntimeError):
                pass  # Label might already be deleted
            self._repeat_overlay_label = None
        
        # Show overlay only for mode 3 ("1"), mode 2 has no overlay
        if self.repeat_mode == 3:
            # Create overlay label
            from PyQt6.QtWidgets import QLabel
            from PyQt6.QtCore import Qt
            
            # Set overlay text to "1" for mode 3
            overlay_text = "1"
            
            # Set overlay color: white for mode 3 (track)
            overlay_color = 'white'
            
            self._repeat_overlay_label = QLabel(overlay_text, self.repeat_btn)
            self._repeat_overlay_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self._repeat_overlay_label.setStyleSheet(f"""
                QLabel {{
                    background-color: transparent;
                    color: {overlay_color};
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                }}
            """)
            # Position will be updated when button is shown/resized
            # Use a method to update position
            def update_overlay_position():
                if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label and self.repeat_btn:
                    btn_size = self.repeat_btn.size()
                    overlay_size = 16
                    x = (btn_size.width() - overlay_size) // 2
                    y = (btn_size.height() - overlay_size) // 2
                    self._repeat_overlay_label.setGeometry(x, y, overlay_size, overlay_size)
                    self._repeat_overlay_label.show()
                    self._repeat_overlay_label.raise_()
            
            # Update position immediately and on button resize
            QTimer.singleShot(0, update_overlay_position)
            # Also update when button is resized (if button has resizeEvent, we'd need to override it)
            # For now, update on a short delay to ensure button is sized
            QTimer.singleShot(100, update_overlay_position)
        else:
            # Ensure overlay is removed for mode 0, mode 1, and mode 2
            if hasattr(self, '_repeat_overlay_label') and self._repeat_overlay_label:
                self._repeat_overlay_label.hide()
    
    def _update_javascript_repeat_mode(self):
        """Update the JavaScript repeat mode variable when mode changes"""
        # Get parent window to access web_view
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        if not parent_window or not hasattr(parent_window, 'web_view') or not parent_window.web_view or not parent_window.web_view.page():
            return
        
        repeat_mode = self.repeat_mode
        js_code = f"""
        (function() {{
            window.bandcampRepeatMode = {repeat_mode};
            console.log('Bandcamp Player: Repeat mode updated to {repeat_mode}');
        }})();
        """
        parent_window.web_view.page().runJavaScript(js_code)
    
    def toggle_minimize_click(self):
        """Toggle minimize/restore playlist (called by minimize button)"""
        self._toggle_minimize_state()
    
    def toggle_minimize(self, event):
        """Toggle minimize/restore playlist (called by title bar click)"""
        if event.button() == Qt.MouseButton.LeftButton:
            # Don't minimize if clicking on buttons (right side)
            if event.pos().x() > self.title_bar_widget.width() - 80:  # Button area
                return
            
            self._toggle_minimize_state()
    
    def _toggle_minimize_state(self):
        """Internal method to toggle minimize/restore state"""
        self.is_minimized = not self.is_minimized
        self.list_widget.setVisible(not self.is_minimized)
        
        # Update minimize button icon and tooltip based on state
        if hasattr(self, 'minimize_btn'):
            # Always clear both icon and text first to prevent showing both
            self.minimize_btn.setIcon(QIcon())
            self.minimize_btn.setText("")
            
            if self.is_minimized:
                if HAS_QT_AWESOME:
                    icon = get_icon('ei.chevron-up', color='#e0e0e0')
                    if icon:
                        self.minimize_btn.setIcon(icon)
                    else:
                        self.minimize_btn.setText("")
                else:
                    self.minimize_btn.setText("")  # Maximize icon
                self.minimize_btn.setToolTip("Restore Playlist")
            else:
                if HAS_QT_AWESOME:
                    icon = get_icon('ei.chevron-down', color='#e0e0e0')
                    if icon:
                        self.minimize_btn.setIcon(icon)
                    else:
                        self.minimize_btn.setText("")
                else:
                    self.minimize_btn.setText("")  # Minimize icon
                self.minimize_btn.setToolTip("Minimize Playlist")
        
        # Hide/show resize handle based on minimize state
        # Access parent window to get resize handle
        parent = self.parent()
        while parent and not isinstance(parent, QWidget):
            parent = parent.parent()
        if parent and hasattr(parent, 'playlist_resize_handle'):
            handle = parent.playlist_resize_handle
            # Hide resize handle in mini/micro mode (playlist has fixed height)
            is_visible = not self.is_minimized
            if hasattr(parent, 'mini_mode_state') and parent.mini_mode_state in (1, 2):
                is_visible = False  # Always hide in mini/micro mode
            handle.setVisible(is_visible)
            # Set height to 0 when hidden to prevent taking up space
            if is_visible:
                handle.setFixedHeight(4)
            else:
                handle.setFixedHeight(0)
        
        # If in mini mode, update window size to account for playlist state change
        if parent and hasattr(parent, 'mini_mode_state') and parent.mini_mode_state == 1:
            QTimer.singleShot(100, parent.resize_to_mini_mode)
        
        # Save playlist state to settings
        if parent and hasattr(parent, 'settings'):
            parent.settings['playlist_minimized'] = self.is_minimized
            # Remember the attached playlist minimized state separately so detaching can auto-expand
            # without losing the user's preferred attached state.
            try:
                if hasattr(parent, 'playlist_detached') and not parent.playlist_detached:
                    parent.settings['playlist_attached_minimized'] = self.is_minimized
            except Exception:
                pass
            # Don't save playlist height in mini or micro mode - it has fixed heights
            if hasattr(parent, 'mini_mode_state') and parent.mini_mode_state in (1, 2):
                # In mini/micro mode, don't save height changes - use fixed heights
                parent.save_settings()
                return
            # Only save height in regular mode or detached mode
            if hasattr(self, '_restore_height'):
                parent.settings['playlist_height'] = self._restore_height
                # Also save as attached height if playlist is attached (not detached)
                if not parent.playlist_detached:
                    parent.settings['playlist_attached_height'] = self._restore_height
            elif hasattr(self, 'height'):
                parent.settings['playlist_height'] = self.height()
                # Also save as attached height if playlist is attached (not detached)
                if not parent.playlist_detached:
                    parent.settings['playlist_attached_height'] = self.height()
            parent.save_settings()
        
        # Adjust sidebar size when minimized
        if self.is_minimized:
            # Collapse to just show title bar - ensure we account for layout margins
            # Get the actual title bar height plus layout margins
            title_bar_height = self.title_bar_widget.sizeHint().height()
            layout = self.layout()
            if layout:
                margins = layout.getContentsMargins()
                total_height = title_bar_height + margins[1] + margins[3]  # top + bottom margins
            else:
                total_height = title_bar_height + 10  # Add some padding
            # Store current height before minimizing (if not already minimized)
            # BUT: In micro mode, we want to preserve the 115px restore height, so don't overwrite it
            if not hasattr(self, '_restore_height') or not self._restore_height:
                current_height = self.height()
                if current_height > total_height:
                    self._restore_height = current_height
            # Check if we're in micro mode - if so, preserve the 115px restore height
            if parent and hasattr(parent, 'mini_mode_state') and parent.mini_mode_state == 2:
                # In micro mode, ensure restore height is 115 (for when expanded)
                if not hasattr(self, '_restore_height') or self._restore_height != 135:
                    self._restore_height = 135
            self.setFixedHeight(total_height)
            # Ensure full width when minimized
            if parent:
                # Get parent window width (should be 260px)
                parent_width = parent.width() if hasattr(parent, 'width') else 260
                self.setFixedWidth(parent_width)

            # Recompute minimized height after Qt has settled layout/polish (prevents extra padding after reattach)
            try:
                QTimer.singleShot(0, self._recompute_minimized_geometry_if_needed)
                QTimer.singleShot(50, self._recompute_minimized_geometry_if_needed)
            except Exception:
                pass
        else:
            # Restore to normal size (allow resizing)
            self.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
            self.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
            # Restore to previous height if available, otherwise use default
            if hasattr(self, '_restore_height') and self._restore_height:
                restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, self._restore_height))
                self.setFixedHeight(restore_height)
            else:
                # Use default height
                self.setFixedHeight(PLAYLIST_DEFAULT_HEIGHT)
        
        # Ensure playlist stays above loading overlay when minimized/restored
        if parent and hasattr(parent, 'playlist_container') and parent.playlist_container:
            parent.playlist_container.raise_()
            # Force container to update its geometry to match playlist height
            # When minimized, ensure container doesn't reserve extra space
            if self.is_minimized:
                # Set container to match actual minimized height (title bar only)
                actual_height = self.height()
                parent.playlist_container.setMaximumHeight(actual_height)
                parent.playlist_container.setMinimumHeight(actual_height)
            else:
                # When expanded, allow container to match playlist height
                parent.playlist_container.setMaximumHeight(16777215)  # Qt's maximum
                parent.playlist_container.setMinimumHeight(0)
            parent.playlist_container.updateGeometry()
            # Force layout update to ensure container doesn't reserve extra space
            layout = parent.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            QApplication.processEvents()

    def _recompute_minimized_geometry_if_needed(self):
        """Recompute minimized height once UI/layout has settled (fixes extra space after reattach)."""
        try:
            if not getattr(self, 'is_minimized', False):
                return
            if not hasattr(self, 'title_bar_widget') or not self.title_bar_widget:
                return

            # Ensure style/layout is up-to-date before measuring
            try:
                self.ensurePolished()
                self.title_bar_widget.ensurePolished()
            except Exception:
                pass
            self.title_bar_widget.updateGeometry()

            title_bar_height = self.title_bar_widget.sizeHint().height()
            layout = self.layout()
            if layout:
                margins = layout.getContentsMargins()
                total_height = title_bar_height + margins[1] + margins[3]  # top + bottom
            else:
                total_height = title_bar_height + 10

            # Apply corrected minimized height
            self.setFixedHeight(total_height)

            # If attached, keep the container constrained to the minimized height
            parent = self.parent()
            while parent and not isinstance(parent, QWidget):
                parent = parent.parent()
            if parent and hasattr(parent, 'playlist_container') and parent.playlist_container and parent.playlist_container.isVisible():
                parent.playlist_container.setMaximumHeight(total_height)
                parent.playlist_container.setMinimumHeight(total_height)
                parent.playlist_container.updateGeometry()
                layout = parent.centralWidget().layout() if parent.centralWidget() else None
                if layout:
                    layout.update()
                    layout.activate()
        except Exception:
            pass
    
    def close_playlist(self):
        """Close/hide the playlist sidebar"""
        self.hide()
        
        # Get parent window to access settings and methods
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()

        # If the playlist was minimized, the attached playlist container may have been constrained
        # to the minimized title-bar height. Clear those constraints so the layout can collapse.
        if parent_window and hasattr(parent_window, 'playlist_container') and parent_window.playlist_container:
            try:
                parent_window.playlist_container.setMaximumHeight(16777215)  # Qt max
                parent_window.playlist_container.setMinimumHeight(0)
                parent_window.playlist_container.updateGeometry()
            except Exception:
                pass
        
        # Hide resize handle
        if parent_window and hasattr(parent_window, 'playlist_resize_handle'):
            handle = parent_window.playlist_resize_handle
            handle.setVisible(False)
            handle.setFixedHeight(0)
        
        # Update button state
        if parent_window:
            if hasattr(parent_window, 'playlist_btn'):
                parent_window.playlist_btn.setChecked(False)
                parent_window._update_playlist_button_icon(False)
            if hasattr(parent_window, 'show_playlist_action'):
                parent_window.show_playlist_action.setChecked(False)
            
            # Update settings
            parent_window.settings['playlist_visible'] = False
            if hasattr(self, 'is_minimized'):
                parent_window.settings['playlist_minimized'] = self.is_minimized
            # Don't save playlist height in mini or micro mode - it has fixed heights.
            # IMPORTANT: we still continue after this so micro mode can do its resize/layout recalculation.
            skip_height_save = bool(hasattr(parent_window, 'mini_mode_state') and parent_window.mini_mode_state in (1, 2))
            if not skip_height_save:
                # Only save height in regular mode or detached mode
                if hasattr(self, '_restore_height'):
                    parent_window.settings['playlist_height'] = self._restore_height
                    # Also save as attached height if playlist is attached (not detached)
                    if not parent_window.playlist_detached:
                        parent_window.settings['playlist_attached_height'] = self._restore_height
                elif self:
                    parent_window.settings['playlist_height'] = self.height()
                    # Also save as attached height if playlist is attached (not detached)
                    if not parent_window.playlist_detached:
                        parent_window.settings['playlist_attached_height'] = self.height()
            parent_window.save_settings()
            
            # Debug logging for playlist close
            print(f"[DEBUG] close_playlist: playlist_visible set to False, mini_mode_state={parent_window.mini_mode_state if hasattr(parent_window, 'mini_mode_state') else 'N/A'}")
            logger.debug(f"close_playlist: playlist_visible set to False, mini_mode_state={parent_window.mini_mode_state if hasattr(parent_window, 'mini_mode_state') else 'N/A'}")
            
            # If in mini or micro mode, resize to account for playlist visibility change
            if hasattr(parent_window, 'mini_mode_state'):
                # Force layout update to ensure visibility changes are reflected
                if hasattr(parent_window, 'playlist_container') and parent_window.playlist_container:
                    parent_window.playlist_container.updateGeometry()
                if hasattr(parent_window, 'playlist_sidebar') and parent_window.playlist_sidebar:
                    parent_window.playlist_sidebar.updateGeometry()
                # Force the main layout to recalculate
                layout = parent_window.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                QApplication.processEvents()
                
                if parent_window.mini_mode_state == 1:
                    QTimer.singleShot(100, parent_window.resize_to_mini_mode)
                elif parent_window.mini_mode_state == 2:
                    # For micro mode, when closing playlist, use current window height minus 30px
                    # instead of re-measuring (which can be inaccurate due to layout reflow)
                    # Store the current height before closing
                    current_height = parent_window.height()
                    # Calculate new height: current - 30px (playlist title bar)
                    # But only if we're actually removing the playlist (not just minimizing)
                    if hasattr(parent_window, 'settings') and not parent_window.settings.get('playlist_visible', True):
                        # Playlist is being closed - calculate new height directly
                        window_padding = 0
                        if parent_window.title_bar and parent_window.title_bar.isVisible():
                            window_padding += parent_window.title_bar.height()
                        if hasattr(parent_window, 'controls_bar_widget') and parent_window.controls_bar_widget:
                            if hasattr(parent_window, 'autohide_address_bar') and not parent_window.autohide_address_bar:
                                window_padding += parent_window.controls_bar_widget.height()
                        
                        # Use saved exact_bottom if available, otherwise calculate from current height
                        if hasattr(parent_window, 'settings') and 'micro_mode_saved_height' in parent_window.settings:
                            saved_exact_bottom = parent_window.settings.get('micro_mode_saved_height', 0)
                            if saved_exact_bottom > 0:
                                # Use saved value and subtract 30px for playlist title bar
                                new_total_height = saved_exact_bottom + window_padding - 33  # -33 is the standard adjustment
                                print(f"[DEBUG] close_playlist: Using saved exact_bottom={saved_exact_bottom}, new_total_height={new_total_height}")
                                logger.debug(f"close_playlist: Using saved exact_bottom={saved_exact_bottom}, new_total_height={new_total_height}")
                                
                                # Set flag to allow programmatic resize
                                parent_window._micro_mode_resizing = True
                                original_width = WINDOW_DEFAULT_WIDTH
                                
                                # Ensure we don't go below minimum
                                if new_total_height < window_padding + 50:
                                    new_total_height = window_padding + 50
                                
                                # Resize directly
                                parent_window.resize(original_width, new_total_height)
                                parent_window.setMinimumSize(original_width, new_total_height)
                                parent_window.setMaximumSize(original_width, new_total_height)
                                
                                # Clear flag after resize
                                QTimer.singleShot(50, lambda: setattr(parent_window, '_micro_mode_resizing', False))
                                
                                print(f"[DEBUG] close_playlist: Resized directly to {original_width}x{new_total_height}, actual size: {parent_window.width()}x{parent_window.height()}")
                                logger.debug(f"close_playlist: Resized directly to {original_width}x{new_total_height}, actual size: {parent_window.width()}x{parent_window.height()}")
                                return  # Skip the normal resize path
                    
                    # Fallback to normal resize path if direct resize didn't happen
                    # Use a slightly longer delay to ensure settings are fully saved and processed
                    QTimer.singleShot(100, parent_window._resize_to_micro_mode_with_retry)

            # Keep bottom-right playlist quick button in sync (safe)
            try:
                if hasattr(parent_window, 'update_playlist_quick_btn_visibility'):
                    parent_window.update_playlist_quick_btn_visibility()
            except Exception:
                pass
    
    def get_previous_album_url(self):
        """Get the previous album URL based on shuffle and repeat settings"""
        if not self.current_item:
            return None
        
        current_index = self.list_widget.row(self.current_item)
        if current_index < 0:
            return None
        
        playlist_count = self.list_widget.count()
        if playlist_count == 0:
            return None
        
        # If shuffle mode 2 (albums) or 3 (super), pick a random album (excluding current)
        if self.shuffle_mode == 2 or self.shuffle_mode == 3:
            if playlist_count == 1:
                return None  # Only one album, can't shuffle
            # Get all indices except current
            available_indices = [i for i in range(playlist_count) if i != current_index]
            prev_index = random.choice(available_indices)
        else:
            # Sequential: previous album, wrap around if at start
            prev_index = (current_index - 1) % playlist_count
        
        prev_item = self.list_widget.item(prev_index)
        if prev_item:
            return prev_item.data(Qt.ItemDataRole.UserRole)
        return None
    
    def get_next_album_url(self):
        """Get the next album URL based on shuffle and repeat settings"""
        if not self.current_item:
            return None
        
        current_index = self.list_widget.row(self.current_item)
        if current_index < 0:
            return None
        
        playlist_count = self.list_widget.count()
        if playlist_count == 0:
            return None
        
        # If shuffle mode 2 (albums) or 3 (super), pick a random album (excluding current)
        if self.shuffle_mode == 2 or self.shuffle_mode == 3:
            if playlist_count == 1:
                return None  # Only one album, can't shuffle
            # Get all indices except current
            available_indices = [i for i in range(playlist_count) if i != current_index]
            next_index = random.choice(available_indices)
        else:
            # Sequential: next album, wrap around if at end
            next_index = (current_index + 1) % playlist_count
        
        next_item = self.list_widget.item(next_index)
        if next_item:
            return next_item.data(Qt.ItemDataRole.UserRole)
        return None
    
    def load_previous_album(self):
        """Load the previous album in the playlist (loops to last album if at first)"""
        logger.debug("load_previous_album called")
        if not self.current_item:
            logger.debug("No current item set")
            return False
        
        current_index = self.list_widget.row(self.current_item)
        if current_index < 0:
            logger.debug("Current item index is invalid")
            return False
        
        # Get only items with URLs (exclude blank item)
        valid_items = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole):  # Has URL
                valid_items.append((i, item))
        
        if len(valid_items) == 0:
            logger.debug("No valid albums in playlist")
            return False
        
        # Find current item's position in valid items
        current_valid_index = None
        for idx, (orig_idx, item) in enumerate(valid_items):
            if item == self.current_item:
                current_valid_index = idx
                break
        
        if current_valid_index is None:
            logger.debug("Current item not found in valid items")
            return False
        
        # Calculate previous index with wrap-around (only among valid items)
        # Shuffle mode 2 (albums) or 3 (super) use random album selection
        if self.shuffle_mode == 2 or self.shuffle_mode == 3:
            if len(valid_items) == 1:
                return False  # Only one album, can't shuffle
            available_indices = [i for i in range(len(valid_items)) if i != current_valid_index]
            prev_valid_index = random.choice(available_indices)
        else:
            # Sequential: previous album, wrap around to last if at first
            prev_valid_index = (current_valid_index - 1) % len(valid_items)
        
        # Get the actual item and load it
        prev_orig_index, prev_item = valid_items[prev_valid_index]
        prev_url = prev_item.data(Qt.ItemDataRole.UserRole)
        if prev_url:
            logger.debug(f"Loading previous album at index {prev_orig_index} (valid index {prev_valid_index}): {prev_item.text()}")
            self.load_url_func(prev_url)
            self.set_current_item(prev_item)
            return True
        
        logger.debug("No previous album found")
        return False
    
    def load_next_album(self):
        """Load the next album in the playlist (loops to first album if at last)"""
        logger.debug("load_next_album called")
        if not self.current_item:
            logger.debug("No current item set")
            return False
        
        current_index = self.list_widget.row(self.current_item)
        if current_index < 0:
            logger.debug("Current item index is invalid")
            return False
        
        # Get only items with URLs (exclude blank item)
        valid_items = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole):  # Has URL
                valid_items.append((i, item))
        
        if len(valid_items) == 0:
            logger.debug("No valid albums in playlist")
            return False
        
        # Find current item's position in valid items
        current_valid_index = None
        for idx, (orig_idx, item) in enumerate(valid_items):
            if item == self.current_item:
                current_valid_index = idx
                break
        
        if current_valid_index is None:
            logger.debug("Current item not found in valid items")
            return False
        
        # Calculate next index with wrap-around (only among valid items)
        # Shuffle mode 2 (albums) or 3 (super) use random album selection
        if self.shuffle_mode == 2 or self.shuffle_mode == 3:
            if len(valid_items) == 1:
                return False  # Only one album, can't shuffle
            available_indices = [i for i in range(len(valid_items)) if i != current_valid_index]
            next_valid_index = random.choice(available_indices)
        else:
            # Sequential: next album, wrap around to first if at last
            next_valid_index = (current_valid_index + 1) % len(valid_items)
        
        # Get the actual item and load it
        next_orig_index, next_item = valid_items[next_valid_index]
        next_url = next_item.data(Qt.ItemDataRole.UserRole)
        if next_url:
            logger.debug(f"Loading next album at index {next_orig_index} (valid index {next_valid_index}): {next_item.text()}")
            self.load_url_func(next_url)
            self.set_current_item(next_item)
            return True
        
        logger.debug("No next album found")
        return False
    
    def on_item_double_clicked(self, item):
        """Handle double-click on playlist item"""
        # Skip blank item
        if item == self._blank_item:
            return
        url = item.data(Qt.ItemDataRole.UserRole)
        if url:
            # Load the URL - this will trigger update_current_item via load_url
            self.load_url_func(url)
            # Also set directly as backup (load_url will call update_current_item, but this ensures immediate feedback)
            self.set_current_item(item)
    
    def set_current_item(self, item):
        """Set the currently playing item with direct color highlighting"""
        logger.debug(f"set_current_item: Called with item: {item}")
        # Clear ALL items' current item marker first (prevents accumulation from previous selections)
        # But preserve user selection (clicked items) - only clear the current item marker
        logger.debug("set_current_item: Clearing all items' current item marker")
        for i in range(self.list_widget.count()):
            try:
                list_item = self.list_widget.item(i)
                if list_item:
                    list_item.setData(Qt.ItemDataRole.UserRole + 1, False)  # Clear current item marker
                    # Don't clear selection here - let users keep their selection highlight
            except:
                pass
        
        # Clear the current_item reference
            self.current_item = None
        
        self.current_item = item
        if item:
            try:
                item_text = item.text()
                item_url = item.data(Qt.ItemDataRole.UserRole)
                logger.debug(f"set_current_item: Setting item '{item_text}' (URL: {item_url})")
                
                # Verify item is still valid
                item_row = self.list_widget.row(item)
                logger.debug(f"set_current_item: Item row: {item_row}")
                if item_row < 0:
                    logger.warning("set_current_item: Item row is invalid, aborting")
                    self.current_item = None
                    return
                
                # Use custom data role to mark current item (delegate will handle painting)
                # Set custom role (UserRole + 1) to True for current item
                self.current_item.setData(Qt.ItemDataRole.UserRole + 1, True)
                logger.debug("set_current_item: Set custom data role (UserRole + 1) = True")
                
                # Also set selection for compatibility with stylesheet
                item.setSelected(True)
                logger.debug("set_current_item: Set selected=True")
                
                # Force update to trigger delegate repaint
                # Trigger update - just call update() without arguments to refresh the viewport
                self.list_widget.update()
                logger.debug("set_current_item: Called list_widget.update() for item rect")
                
                # Scroll to item to make it visible
                self.list_widget.scrollToItem(item)
                logger.debug("set_current_item: Current item marked successfully")
            except RuntimeError:
                # Item was deleted between assignment and use, clear reference
                self.current_item = None
            except Exception as e:
                # Catch any other errors and log them (but don't crash)
                logger.error(f"Error setting current item colors: {e}", exc_info=True)
                self.current_item = None
    
    def process_urls(self, url_strings):
        """Process a list of URL strings and add valid Bandcamp URLs to the playlist.
        
        Args:
            url_strings: List of URL strings to process
            
        Returns:
            Tuple of (added_count, skipped_count)
        """
        if not url_strings:
            return (0, 0)
        
        # Save state to history before adding URLs
        if not self.is_undoing_redoing:
            self._save_state_to_history()
        
        # Suppress history save when we call save_playlist (we already saved above)
        self._suppress_history_save = True
        
        # Get existing URLs for duplicate checking
        existing_urls = [item.get("url") if isinstance(item, dict) else item for item in self.playlist_manager.playlist]
        
        added_count = 0
        skipped_count = 0
        
        for url_string in url_strings:
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved = self.resolve_url_redirects(url_string)
            if resolved:
                url = resolved
            else:
                # If resolution failed but it looks like a Bandcamp URL, use it as-is
                if 'bandcamp.com' in url_string.lower():
                    url = url_string
                else:
                    # Not a Bandcamp URL, skip it
                    skipped_count += 1
                    continue
            
            # Normalize URL
            url = url.strip().rstrip('/')
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            # Only add if it's a Bandcamp URL and not already in playlist
            if 'bandcamp.com' in url.lower():
                if url not in existing_urls:
                    self.playlist_manager.add_url(url)
                    self.add_item(url)
                    added_count += 1
                    existing_urls.append(url)  # Update list to avoid duplicates in same batch
                else:
                    skipped_count += 1
            else:
                skipped_count += 1
        
        # Save playlist after adding all URLs
        if added_count > 0:
            self.playlist_manager.save_playlist()
        
        # Restore history saving
        self._suppress_history_save = False
        
        # Save state to history after adding completes (so current state is in history)
        if not self.is_undoing_redoing and added_count > 0:
            QTimer.singleShot(50, self._save_state_to_history)
        
        return (added_count, skipped_count)
    
    def paste_urls_from_clipboard(self):
        """Paste URLs from clipboard (same as add_url but with tooltip feedback)"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        if not text:
            # Show feedback that clipboard is empty
            global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
            QToolTip.showText(global_pos, "Clipboard is empty", self.list_widget, QRect(), 1500)
            return
        
        # Split by newlines to handle multiple URLs
        lines = [line.strip() for line in text.split('\n') if line.strip()]
        
        if not lines:
            return
        
        # Process URLs using shared method
        added_count, skipped_count = self.process_urls(lines)
        
        # Show tooltip feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        if added_count > 0 and skipped_count > 0:
            message = f"Added {added_count} URL(s), skipped {skipped_count}"
        elif added_count > 0:
            message = f"Added {added_count} URL(s)"
        else:
            message = "No URLs added (duplicates or invalid)"
        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
    
    def save_current_playlist(self):
        """Save the current playlist to its file"""
        if self.playlist_manager.save_playlist():
            # Get parent window to save settings
            parent_window = self.parent()
            while parent_window and not isinstance(parent_window, QMainWindow):
                parent_window = parent_window.parent()
            if parent_window and hasattr(parent_window, 'save_settings'):
                parent_window.save_settings()
            
            # Show feedback
            global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
            playlist_name = self.playlist_manager.get_current_playlist_name()
            QToolTip.showText(global_pos, f"Saved: {playlist_name}", self.list_widget, QRect(), 1500)
        else:
            QMessageBox.warning(self, "Save Failed", "Failed to save playlist.")
    
    def save_playlist_as(self):
        """Save the current playlist with a new name"""
        current_name = self.playlist_manager.get_current_playlist_name()
        name, ok = QInputDialog.getText(
            self,
            "Save Playlist As",
            "Enter playlist name:",
            text=current_name
        )
        
        if ok and name:
            sanitized_name = sanitize_filename(name)
            if not sanitized_name:
                QMessageBox.warning(self, "Invalid Name", "Please enter a valid playlist name.")
                return
            
            if self.playlist_manager.save_playlist_as(sanitized_name):
                # Get parent window to save settings
                parent_window = self.parent()
                while parent_window and not isinstance(parent_window, QMainWindow):
                    parent_window = parent_window.parent()
                if parent_window and hasattr(parent_window, 'save_settings'):
                    parent_window.save_settings()
                
                # Refresh playlist display
                self.load_playlist()
                
                # Show feedback
                global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                QToolTip.showText(global_pos, f"Saved as: {sanitized_name}", self.list_widget, QRect(), 1500)
            else:
                QMessageBox.warning(self, "Save Failed", "Failed to save playlist.")
    
    def load_playlist_from_file(self, playlist_file):
        """Load a playlist from a specific file"""
        # Save current state to history before loading
        if not self.is_undoing_redoing:
            self._save_state_to_history()
        
        # Load the playlist
        if self.playlist_manager.set_playlist_file(playlist_file):
            # Refresh the display
            self.load_playlist()
            
            # Get parent window to save settings
            parent_window = self.parent()
            while parent_window and not isinstance(parent_window, QMainWindow):
                parent_window = parent_window.parent()
            if parent_window and hasattr(parent_window, 'save_settings'):
                parent_window.save_settings()
            
            # Show feedback
            global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
            playlist_name = self.playlist_manager.get_current_playlist_name()
            QToolTip.showText(global_pos, f"Loaded: {playlist_name}", self.list_widget, QRect(), 1500)
            
            # Save state to history after loading
            if not self.is_undoing_redoing:
                QTimer.singleShot(50, self._save_state_to_history)
        else:
            QMessageBox.warning(self, "Load Failed", f"Failed to load playlist from {playlist_file}.")
    
    def export_playlist_urls(self):
        """Export playlist URLs to a text file or clipboard"""
        urls = self.playlist_manager.get_playlist()
        if not urls:
            QMessageBox.information(self, "Empty Playlist", "Playlist is empty. Nothing to export.")
            return
        
        # Create menu for export options
        export_menu = QMenu(self)
        export_menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
        """)
        
        # Export to file
        file_action = QAction("Export to File...", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file', color='#e0e0e0')
            if icon:
                file_action.setIcon(icon)
        file_action.triggered.connect(self._export_to_file)
        export_menu.addAction(file_action)
        
        # Copy to clipboard
        clipboard_action = QAction("Copy to Clipboard", self)
        if HAS_QT_AWESOME:
            icon = get_icon('copy', color='#e0e0e0')
            if icon:
                clipboard_action.setIcon(icon)
        clipboard_action.triggered.connect(self._export_to_clipboard)
        export_menu.addAction(clipboard_action)
        
        # Show menu at cursor position
        export_menu.exec(QCursor.pos())
    
    def _export_to_file(self):
        """Export URLs to a text file"""
        urls = self.playlist_manager.get_playlist()
        if not urls:
            return
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Playlist URLs",
            "",
            "Text Files (*.txt);;All Files (*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(urls))
                QMessageBox.information(self, "Export Successful", f"Exported {len(urls)} URL(s) to:\n{file_path}")
            except Exception as e:
                QMessageBox.warning(self, "Export Failed", f"Failed to export URLs:\n{str(e)}")
    
    def _export_to_clipboard(self):
        """Copy URLs to clipboard"""
        urls = self.playlist_manager.get_playlist()
        if not urls:
            return
        
        clipboard = QApplication.clipboard()
        clipboard.setText('\n'.join(urls))
        
        # Show feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        QToolTip.showText(global_pos, f"Copied {len(urls)} URL(s) to clipboard", self.list_widget, QRect(), 2000)
    
    def import_playlist_urls(self):
        """Import playlist URLs from a text file or clipboard"""
        # Create menu for import options
        import_menu = QMenu(self)
        import_menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
        """)
        
        # Import from file
        file_action = QAction("Import from File...", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file', color='#e0e0e0')
            if icon:
                file_action.setIcon(icon)
        file_action.triggered.connect(self._import_from_file)
        import_menu.addAction(file_action)
        
        # Paste from clipboard
        clipboard_action = QAction("Paste from Clipboard", self)
        if HAS_QT_AWESOME:
            icon = get_icon('paste', color='#e0e0e0')
            if icon:
                clipboard_action.setIcon(icon)
        clipboard_action.triggered.connect(self._import_from_clipboard)
        import_menu.addAction(clipboard_action)
        
        # Show menu at cursor position
        import_menu.exec(QCursor.pos())
    
    def _import_from_file(self):
        """Import URLs from a text file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Import Playlist URLs",
            "",
            "Text Files (*.txt);;All Files (*)"
        )
        
        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = [line.strip() for line in f.readlines() if line.strip()]
                
                if not lines:
                    QMessageBox.information(self, "Empty File", "The selected file is empty.")
                    return
                
                # Ask user: Add or Replace
                msg_box = QMessageBox(self)
                msg_box.setWindowTitle("Import URLs")
                msg_box.setText(f"Found {len(lines)} URL(s) in file.\n\nAdd to current playlist or replace it?")
                msg_box.setIcon(QMessageBox.Icon.Question)
                
                # Create custom buttons
                add_btn = msg_box.addButton("Add", QMessageBox.ButtonRole.AcceptRole)
                replace_btn = msg_box.addButton("Replace", QMessageBox.ButtonRole.AcceptRole)
                cancel_btn = msg_box.addButton("Cancel", QMessageBox.ButtonRole.RejectRole)
                msg_box.setDefaultButton(add_btn)
                
                reply = msg_box.exec()
                
                if reply == cancel_btn:
                    return
                
                if reply == replace_btn:
                    # Replace: clear current playlist first
                    self.clear_playlist()
                
                # Process URLs
                added_count, skipped_count = self.process_urls(lines)
                
                # Show feedback
                if added_count > 0:
                    message = f"Imported {added_count} URL(s)"
                    if skipped_count > 0:
                        message += f", skipped {skipped_count}"
                    QMessageBox.information(self, "Import Successful", message)
                else:
                    QMessageBox.information(self, "Import Complete", "No URLs were added (duplicates or invalid).")
            except Exception as e:
                QMessageBox.warning(self, "Import Failed", f"Failed to import URLs:\n{str(e)}")
    
    def _import_from_clipboard(self):
        """Import URLs from clipboard"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        
        if not text:
            QMessageBox.information(self, "Empty Clipboard", "Clipboard is empty.")
            return
        
        # Split by newlines
        lines = [line.strip() for line in text.split('\n') if line.strip()]
        
        if not lines:
            QMessageBox.information(self, "No URLs", "Clipboard does not contain any URLs.")
            return
        
        # Ask user: Add or Replace
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Import URLs")
        msg_box.setText(f"Found {len(lines)} URL(s) in clipboard.\n\nAdd to current playlist or replace it?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        
        # Create custom buttons
        add_btn = msg_box.addButton("Add", QMessageBox.ButtonRole.AcceptRole)
        replace_btn = msg_box.addButton("Replace", QMessageBox.ButtonRole.AcceptRole)
        cancel_btn = msg_box.addButton("Cancel", QMessageBox.ButtonRole.RejectRole)
        msg_box.setDefaultButton(add_btn)
        
        reply = msg_box.exec()
        
        if reply == cancel_btn:
            return
        
        if reply == replace_btn:
            # Replace: clear current playlist first
            self.clear_playlist()
        
        # Process URLs
        added_count, skipped_count = self.process_urls(lines)
        
        # Show feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        if added_count > 0 and skipped_count > 0:
            message = f"Imported {added_count} URL(s), skipped {skipped_count}"
        elif added_count > 0:
            message = f"Imported {added_count} URL(s)"
        else:
            message = "No URLs added (duplicates or invalid)"
        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
    
    def extract_artist_url_from_bandcamp_url(self, url):
        """Extract artist page URL from any Bandcamp URL (album, track, or artist page)
        
        Args:
            url: Any Bandcamp URL
            
        Returns:
            Artist page URL or None if extraction fails
        """
        if not url or 'bandcamp.com' not in url.lower():
            return None
        
        try:
            from urllib.parse import urlparse, urlunparse
            
            # Clean URL
            url = url.strip().rstrip('/')
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            parsed = urlparse(url)
            hostname = parsed.hostname or ""
            
            # Extract artist subdomain
            if ".bandcamp.com" in hostname.lower():
                # Format: artist.bandcamp.com
                # Return just the artist page URL
                artist_url = urlunparse((
                    parsed.scheme,
                    hostname,
                    '',  # Empty path = artist page
                    '',
                    '',
                    ''
                ))
                return artist_url.rstrip('/')
            
            return None
            
        except Exception as e:
            logger.warning(f"Error extracting artist URL from {url}: {e}")
            return None
    
    def fetch_artist_discography(self, artist_url):
        """Fetch album URLs from an artist's Bandcamp page
        
        Args:
            artist_url: Artist page URL (e.g., https://artist.bandcamp.com)
            
        Returns:
            List of album URLs, or empty list if failed
        """
        if not artist_url:
            return []
        
        try:
            import re
            
            logger.debug(f"Fetching artist page: {artist_url}")
            
            # Fetch the artist page
            req = urllib.request.Request(artist_url, headers={
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            })
            
            # Use a shorter timeout and ensure it doesn't hang
            try:
                with urllib.request.urlopen(req, timeout=10) as response:
                    html = response.read().decode('utf-8', errors='ignore')
                    logger.debug(f"Fetched {len(html)} characters of HTML")
            except urllib.error.URLError as e:
                logger.warning(f"URLError fetching {artist_url}: {e}")
                raise
            except Exception as e:
                logger.warning(f"Error fetching {artist_url}: {e}")
                raise
            
            # Parse HTML to find album links
            album_urls = []
            base_url = artist_url.rstrip('/')
            
            logger.debug("Parsing HTML for album links...")
            
            # Method 1: Find href attributes pointing to /album/ or /track/ paths
            # Pattern: href="/album/album-name" or href="/track/track-name"
            href_pattern = r'href=["\']([^"\']*(?:/album/|/track/)[^"\']*)["\']'
            matches = list(re.finditer(href_pattern, html, re.IGNORECASE))
            logger.debug(f"Method 1: Found {len(matches)} potential href matches")
            for match in matches:
                href = match.group(1)
                # Skip common non-album links
                if any(skip in href.lower() for skip in ['/music', '/merch', '/about', '/contact', '/shows', '/follow']):
                    continue
                
                # Convert relative URLs to absolute
                if href.startswith('/'):
                    full_url = base_url + href
                elif href.startswith('http'):
                    full_url = href
                else:
                    continue  # Skip malformed URLs
                
                # Normalize URL
                full_url = full_url.rstrip('/')
                
                # Only add Bandcamp album/track URLs
                if 'bandcamp.com' in full_url.lower() and ('/album/' in full_url or '/track/' in full_url):
                    if full_url not in album_urls:
                        album_urls.append(full_url)
            
            # Method 2: Find data-item-url attributes (Bandcamp uses these for album/track items)
            data_item_pattern = r'data-item-url=["\']([^"\']+)["\']'
            matches = list(re.finditer(data_item_pattern, html, re.IGNORECASE))
            logger.debug(f"Method 2: Found {len(matches)} data-item-url matches")
            for match in matches:
                item_url = match.group(1)
                if item_url.startswith('/'):
                    item_url = base_url + item_url
                elif not item_url.startswith('http'):
                    item_url = base_url + '/' + item_url
                
                item_url = item_url.rstrip('/')
                if 'bandcamp.com' in item_url.lower() and item_url not in album_urls:
                    album_urls.append(item_url)
            
            # Method 3: Find links in itemRow elements (Bandcamp's discography grid)
            # Look for <a> tags within elements that have class containing "itemRow"
            item_row_pattern = r'<a[^>]*href=["\']([^"\']*(?:/album/|/track/)[^"\']*)["\'][^>]*>'
            matches = list(re.finditer(item_row_pattern, html, re.IGNORECASE))
            logger.debug(f"Method 3: Found {len(matches)} itemRow matches")
            for match in matches:
                href = match.group(1)
                if any(skip in href.lower() for skip in ['/music', '/merch', '/about', '/contact', '/shows']):
                    continue
                
                if href.startswith('/'):
                    full_url = base_url + href
                elif href.startswith('http'):
                    full_url = href
                else:
                    continue
                
                full_url = full_url.rstrip('/')
                if 'bandcamp.com' in full_url.lower() and ('/album/' in full_url or '/track/' in full_url):
                    if full_url not in album_urls:
                        album_urls.append(full_url)
            
            # Remove duplicates while preserving order
            seen = set()
            unique_urls = []
            for url in album_urls:
                # Normalize URL for comparison (remove trailing slashes, convert to lowercase for comparison)
                normalized = url.lower().rstrip('/')
                if normalized not in seen:
                    seen.add(normalized)
                    unique_urls.append(url)
            
            logger.debug(f"Found {len(unique_urls)} unique album URLs")
            return unique_urls
            
        except urllib.error.URLError as e:
            error_msg = f"Failed to fetch artist page {artist_url}: {e}"
            logger.warning(error_msg)
            raise Exception(error_msg)  # Re-raise so it's shown to user
        except Exception as e:
            error_msg = f"Error parsing artist discography from {artist_url}: {e}"
            logger.warning(error_msg)
            import traceback
            logger.debug(traceback.format_exc())
            raise  # Re-raise so it's shown to user
    
    def load_artist_discography(self, url):
        """Load all albums from an artist's discography into the playlist"""
        # Show progress dialog with Cancel button
        progress_dialog = QMessageBox(self)
        progress_dialog.setWindowTitle("Loading Discography")
        progress_dialog.setText("Fetching Artist Discography...")
        progress_dialog.setStandardButtons(QMessageBox.StandardButton.Cancel)
        progress_dialog.setDefaultButton(QMessageBox.StandardButton.Cancel)
        # Make dialog larger to accommodate cancel button and text
        progress_dialog.setMinimumWidth(450)
        progress_dialog.setMinimumHeight(150)
        
        artist_url = None
        album_urls = []
        error_message = None
        cancelled = [False]  # Use list to allow modification in nested functions
        
        def check_cancel():
            """Check if cancel button was clicked"""
            QApplication.processEvents()
            return cancelled[0]
        
        # Connect cancel button
        def on_cancel_clicked():
            cancelled[0] = True
            progress_dialog.done(QMessageBox.StandardButton.Cancel)
        
        # Find and connect cancel button
        cancel_btn = progress_dialog.button(QMessageBox.StandardButton.Cancel)
        if cancel_btn:
            cancel_btn.clicked.connect(on_cancel_clicked)
        
        try:
            # Extract artist URL from the provided URL
            artist_url = self.extract_artist_url_from_bandcamp_url(url)
            
            if not artist_url:
                progress_dialog.close()
                progress_dialog.deleteLater()
                QApplication.processEvents()
                QMessageBox.warning(self, "Invalid URL", "Could not extract artist URL from the selected item.")
                return
            
            # Update progress dialog
            progress_dialog.setText(f"Fetching Artist Discography From:\n{artist_url}")
            QApplication.processEvents()
            
            # Check if user cancelled
            if cancelled[0]:
                return
            
            # Fetch discography
            logger.info(f"Fetching discography from {artist_url}")
            album_urls = self.fetch_artist_discography(artist_url)
            logger.info(f"Found {len(album_urls)} albums")
            
            # Check if user cancelled during fetch
            if cancelled[0]:
                return
            
        except Exception as e:
            error_message = str(e)
            logger.error(f"Error loading artist discography: {e}", exc_info=True)
        finally:
            # Always close and destroy the progress dialog
            try:
                progress_dialog.close()
                progress_dialog.deleteLater()
                QApplication.processEvents()  # Ensure UI updates immediately
            except:
                pass
        
        # If cancelled, just return
        if cancelled[0]:
            return
        
        # Handle errors
        if error_message:
            QMessageBox.warning(
                self,
                "Error Loading Discography",
                f"Failed to load artist discography:\n\n{error_message}\n\nPlease try again or check your internet connection."
            )
            return
        
        if not album_urls:
            QMessageBox.information(
                self,
                "No Albums Found",
                f"Could not find any albums in the discography.\n\nThe artist page may be empty or require login.\n\nArtist URL: {artist_url}"
            )
            return
        
        # Ensure progress dialog is fully closed before showing next dialog
        QApplication.processEvents()
        
        # Show dialog with count and Add/Replace options
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Load Artist Discography")
        msg_box.setText(f"Found {len(album_urls)} album(s).\n\nAdd to current playlist or replace it?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        
        # Create custom buttons
        add_btn = msg_box.addButton("Add", QMessageBox.ButtonRole.AcceptRole)
        replace_btn = msg_box.addButton("Replace", QMessageBox.ButtonRole.AcceptRole)
        cancel_btn = msg_box.addButton("Cancel", QMessageBox.ButtonRole.RejectRole)
        msg_box.setDefaultButton(add_btn)
        
        reply = msg_box.exec()
        
        if reply == cancel_btn:
            return
        
        if reply == replace_btn:
            # Replace: clear current playlist first
            self.clear_playlist()
        
        # Process URLs
        added_count, skipped_count = self.process_urls(album_urls)
        
        # Show feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        if added_count > 0 and skipped_count > 0:
            message = f"Added {added_count} album(s), skipped {skipped_count}"
        elif added_count > 0:
            message = f"Added {added_count} album(s)"
        else:
            message = "No albums added (duplicates or invalid)"
        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
    
    def delete_playlist(self, playlist_name):
        """Delete a playlist with confirmation"""
        # Get parent window to access playlist manager and settings
        parent_window = self.parent()
        while parent_window and not isinstance(parent_window, QMainWindow):
            parent_window = parent_window.parent()
        
        if not parent_window:
            QMessageBox.warning(self, "Error", "Could not access parent window.")
            return
        
        # Check if this is the only playlist
        playlists = self.playlist_manager.list_playlist_files()
        if len(playlists) <= 1:
            QMessageBox.warning(
                self,
                "Cannot Delete",
                "Cannot delete the only playlist. At least one playlist must exist."
            )
            return
        
        current_playlist_name = self.playlist_manager.get_current_playlist_name()
        is_current_playlist = (playlist_name == current_playlist_name)
        is_default = (playlist_name.lower() == "default")
        
        # Confirmation dialog
        confirm_msg = f"Are you sure you want to delete the playlist '{playlist_name}'?"
        if is_current_playlist:
            confirm_msg += "\n\nThis is the currently loaded playlist. It will be replaced with Default."
        if is_default:
            confirm_msg += "\n\nNote: Default playlist will be recreated as empty."
        
        reply = QMessageBox.question(
            self,
            "Delete Playlist",
            confirm_msg,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        # Delete the playlist file
        if not self.playlist_manager.delete_playlist_file(playlist_name):
            QMessageBox.warning(self, "Delete Failed", f"Failed to delete playlist '{playlist_name}'.")
            return
        
        # If we deleted the current playlist, switch to Default
        if is_current_playlist:
            # Ensure Default exists
            self.playlist_manager.ensure_default_playlist_exists()
            # Load Default playlist
            default_file = self.playlist_manager.playlists_dir / "Default.json"
            if default_file.exists():
                self.load_playlist_from_file(str(default_file))
                # Show feedback
                global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                QToolTip.showText(global_pos, "Switched to Default playlist", self.list_widget, QRect(), 1500)
        
        # If we deleted Default, recreate it as empty
        if is_default:
            self.playlist_manager.ensure_default_playlist_exists()
            # If it was the current playlist, load it
            if is_current_playlist:
                default_file = self.playlist_manager.playlists_dir / "Default.json"
                if default_file.exists():
                    self.load_playlist_from_file(str(default_file))
        
        # Save settings
        if parent_window and hasattr(parent_window, 'save_settings'):
            parent_window.save_settings()
        
        # Show success feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        QToolTip.showText(global_pos, f"Deleted: {playlist_name}", self.list_widget, QRect(), 1500)
    
    def migrate_default_playlist(self):
        """Migrate old lowercase default.json to Default.json"""
        old_default_file = self.playlist_manager.playlists_dir / "default.json"
        default_file = self.playlist_manager.playlists_dir / "Default.json"
        
        if old_default_file.exists() and not default_file.exists():
            try:
                import shutil
                shutil.copy2(old_default_file, default_file)
                # Optionally delete old file
                old_default_file.unlink()
                logger.info("Migrated default.json to Default.json")
                
                # Load the migrated Default playlist
                self.load_playlist_from_file(str(default_file))
                
                # Show feedback
                global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                QToolTip.showText(global_pos, "Migrated to Default playlist", self.list_widget, QRect(), 1500)
            except Exception as e:
                logger.error(f"Failed to migrate default.json: {e}")
                QMessageBox.warning(self, "Migration Failed", f"Failed to migrate default.json:\n\n{str(e)}")
    
    def show_playlist_menu(self):
        """Show playlist menu with additional options"""
        menu_btn = self.sender()
        menu = QMenu(self)
        
        # Apply dark theme styling to match the rest of the app
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        
        # Show currently loaded playlist at the top (inactive, blue text)
        current_playlist_name = self.playlist_manager.get_current_playlist_name()
        
        # Use QWidgetAction to create a styled label
        current_playlist_widget = QWidget()
        current_playlist_layout = QHBoxLayout(current_playlist_widget)
        current_playlist_layout.setContentsMargins(20, 6, 20, 6)
        current_playlist_label = QLabel(f"Current: {current_playlist_name}")
        current_playlist_label.setStyleSheet("color: #4a90e2; font-weight: normal;")
        current_playlist_layout.addWidget(current_playlist_label)
        
        current_playlist_action = QWidgetAction(self)
        current_playlist_action.setDefaultWidget(current_playlist_widget)
        current_playlist_action.setEnabled(False)
        menu.addAction(current_playlist_action)
        
        menu.addSeparator()
        
        # Save Playlist (updates current)
        save_action = QAction("Save Playlist", self)
        if HAS_QT_AWESOME:
            icon = get_icon('save', color='#e0e0e0')
            if icon:
                save_action.setIcon(icon)
        else:
            save_action.setText(" Save Playlist")
        save_action.triggered.connect(self.save_current_playlist)
        menu.addAction(save_action)
        
        # Save Playlist As...
        save_as_action = QAction("Save Playlist As...", self)
        if HAS_QT_AWESOME:
            icon = get_icon('save', color='#e0e0e0')
            if icon:
                save_as_action.setIcon(icon)
        else:
            save_as_action.setText(" Save As...")
        save_as_action.triggered.connect(self.save_playlist_as)
        menu.addAction(save_as_action)
        
        menu.addSeparator()
        
        # Load Playlist (submenu with available playlists)
        load_menu = QMenu("Load Playlist", self)
        load_menu.setStyleSheet(menu.styleSheet())
        
        # Get list of available playlists
        playlists = self.playlist_manager.list_playlist_files()
        current_playlist_name = self.playlist_manager.get_current_playlist_name()
        
        if playlists:
            for playlist_info in playlists:
                playlist_name = playlist_info["name"]
                playlist_file = playlist_info["file"]
                
                # Create action for this playlist
                playlist_action = QAction(playlist_name, self)
                # Mark current playlist with checkmark
                if playlist_name == current_playlist_name:
                    playlist_action.setText(f" {playlist_name}")
                    playlist_action.setEnabled(False)  # Disable current playlist
                playlist_action.triggered.connect(
                    lambda checked, file=playlist_file: self.load_playlist_from_file(str(file))
                )
                load_menu.addAction(playlist_action)
        
        # Also check for old lowercase "default.json" and offer to migrate it
        old_default_file = self.playlist_manager.playlists_dir / "default.json"
        if old_default_file.exists():
            # Check if Default.json already exists
            default_file = self.playlist_manager.playlists_dir / "Default.json"
            if not default_file.exists():
                # Offer to migrate
                migrate_action = QAction("default (migrate to Default)", self)
                migrate_action.triggered.connect(
                    lambda: self.migrate_default_playlist()
                )
                load_menu.addAction(migrate_action)
        else:
            # No playlists found
            no_playlists_action = QAction("No playlists found", self)
            no_playlists_action.setEnabled(False)
            load_menu.addAction(no_playlists_action)
        
        # Add Load Playlist submenu
        load_action = menu.addMenu(load_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('folder-open', color='#e0e0e0')
            if icon:
                load_action.setIcon(icon)
        else:
            load_action.setText(" Load Playlist")
        
        # Delete Playlist (submenu with available playlists)
        delete_menu = QMenu("Delete Playlist", self)
        delete_menu.setStyleSheet(menu.styleSheet())
        
        # Get list of available playlists
        playlists = self.playlist_manager.list_playlist_files()
        current_playlist_name = self.playlist_manager.get_current_playlist_name()
        
        if playlists:
            for playlist_info in playlists:
                playlist_name = playlist_info["name"]
                playlist_file = playlist_info["file"]
                
                # Create action for this playlist
                playlist_action = QAction(playlist_name, self)
                # Disable if it's the only playlist (can't delete the last playlist)
                if len(playlists) == 1:
                    playlist_action.setEnabled(False)
                    playlist_action.setText(f"{playlist_name} (cannot delete only playlist)")
                playlist_action.triggered.connect(
                    lambda checked, name=playlist_name: self.delete_playlist(name)
                )
                delete_menu.addAction(playlist_action)
        else:
            # No playlists found
            no_playlists_action = QAction("No playlists found", self)
            no_playlists_action.setEnabled(False)
            delete_menu.addAction(no_playlists_action)
        
        # Add Delete Playlist submenu
        delete_action = menu.addMenu(delete_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('trash', color='#e0e0e0')
            if icon:
                delete_action.setIcon(icon)
        else:
            delete_action.setText(" Delete Playlist")
        
        menu.addSeparator()
        
        # Export Playlist URLs
        export_action = QAction("Export Playlist URLs", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file-export', color='#e0e0e0')
            if icon:
                export_action.setIcon(icon)
        else:
            export_action.setText(" Export Playlist URLs")
        export_action.triggered.connect(self.export_playlist_urls)
        menu.addAction(export_action)
        
        # Import Playlist URLs
        import_action = QAction("Import Playlist URLs", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file-import', color='#e0e0e0')
            if icon:
                import_action.setIcon(icon)
        else:
            import_action.setText(" Import Playlist URLs")
        import_action.triggered.connect(self.import_playlist_urls)
        menu.addAction(import_action)
        
        menu.addSeparator()
        
        # Clear Playlist (already exists as button, but useful in menu too)
        clear_action = QAction("Clear Playlist", self)
        if HAS_QT_AWESOME:
            icon = get_icon('trash', color='#e0e0e0')
            if icon:
                clear_action.setIcon(icon)
        else:
            clear_action.setText(" Clear Playlist")
        clear_action.triggered.connect(self.clear_playlist)
        menu.addAction(clear_action)
        
        menu.addSeparator()
        
        # Close Menu
        close_menu_action = QAction("Close Menu", self)
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_menu_action.setIcon(icon)
        else:
            close_menu_action.setText(" Close Menu")
        close_menu_action.triggered.connect(lambda: menu.close())
        menu.addAction(close_menu_action)
        
        # Show menu at button position
        global_pos = menu_btn.mapToGlobal(menu_btn.rect().bottomLeft())
        menu.exec(global_pos)
    
    def show_context_menu(self, position):
        """Show context menu for playlist item(s) - adapts to single or multiple selection"""
        # Get selected items (if right-clicked on selected item, use all selected; otherwise use clicked item)
        selected_items = self.list_widget.selectedItems()
        clicked_item = self.list_widget.itemAt(position)
        
        # Check if right-clicked on empty area
        if not clicked_item:
            # Right-clicked on empty area - show paste menu
            menu = QMenu(self)
            menu.setStyleSheet("""
                QMenu {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: 1px solid #3a3a3a;
                    border-radius: 4px;
                    padding: 2px;
                }
                QMenu::item {
                    padding: 6px 20px;
                    border-radius: 2px;
                }
                QMenu::item:selected {
                    background-color: #4a90e2;
                    color: #ffffff;
                }
                QMenu::separator {
                    height: 1px;
                    background-color: #3a3a3a;
                    margin: 4px 8px;
                }
            """)
            
            # Paste URLs action
            paste_action = QAction("Paste URL(s)", self)
            if HAS_QT_AWESOME:
                icon = get_icon('paste', color='#e0e0e0')
                if icon:
                    paste_action.setIcon(icon)
            else:
                paste_action.setText(" Paste URL(s)")
            paste_action.triggered.connect(self.paste_urls_from_clipboard)
            menu.addAction(paste_action)
            
            menu.exec(self.list_widget.mapToGlobal(position))
            return
        
        # If clicked item is not in selection, select only it
        if clicked_item and clicked_item not in selected_items:
            self.list_widget.clearSelection()
            clicked_item.setSelected(True)
            selected_items = [clicked_item]
        
        # If no items selected, try to use clicked item
        if not selected_items and clicked_item:
            selected_items = [clicked_item]
        
        if not selected_items:
            return
        
        menu = QMenu(self)
        # Add hover states to context menu
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        
        is_multiple = len(selected_items) > 1
        
        # Paste URLs action (always available)
        paste_action = QAction("Paste URL(s)", self)
        if HAS_QT_AWESOME:
            icon = get_icon('paste', color='#e0e0e0')
            if icon:
                paste_action.setIcon(icon)
        else:
            paste_action.setText(" Paste URL(s)")
        paste_action.triggered.connect(self.paste_urls_from_clipboard)
        menu.addAction(paste_action)
        
        menu.addSeparator()
        
        # Load/Play action - only enabled for single selection
        if is_multiple:
            load_action = QAction("Load in Player", self)
            if HAS_QT_AWESOME:
                icon = get_icon('play', color='#666666')
                if icon:
                    load_action.setIcon(icon)
            else:
                load_action.setText(" Load in Player")
            load_action.setEnabled(False)  # Disabled for multiple selection
            menu.addAction(load_action)
        else:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            if url:
                load_action = QAction("Load in Player", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('play', color='#e0e0e0')
                    if icon:
                        load_action.setIcon(icon)
                else:
                    load_action.setText(" Load in Player")
                load_action.triggered.connect(lambda: self.load_url_func(url))
                menu.addAction(load_action)
        
        menu.addSeparator()
        
        # Load Artist Discography - only for single selection
        if not is_multiple:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            if url and 'bandcamp.com' in url.lower():
                discography_action = QAction("Load Artist Discography", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('list', color='#e0e0e0')
                    if icon:
                        discography_action.setIcon(icon)
                else:
                    discography_action.setText(" Load Artist Discography")
                discography_action.triggered.connect(lambda: self.load_artist_discography(url))
                menu.addAction(discography_action)
                menu.addSeparator()
        
        # Open in browser - works for single or multiple
        if is_multiple:
            open_action = QAction(f"Open {len(selected_items)} URLs in Browser", self)
            if HAS_QT_AWESOME:
                icon = get_icon('external-link-alt', color='#e0e0e0')
                if icon:
                    open_action.setIcon(icon)
            else:
                open_action.setText(f" Open {len(selected_items)} URLs in Browser")
            open_action.triggered.connect(lambda: self.open_multiple_urls_in_browser(selected_items))
            menu.addAction(open_action)
        else:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            if url:
                open_action = QAction("Open in Browser", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('external-link-alt', color='#e0e0e0')
                if icon:
                    open_action.setIcon(icon)
                else:
                    open_action.setText(" Open in Browser")
                open_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl(url)))
                menu.addAction(open_action)
        
        # Copy URL(s) - works for single or multiple
        if is_multiple:
            copy_action = QAction(f"Copy {len(selected_items)} URLs", self)
            if HAS_QT_AWESOME:
                icon = get_icon('copy', color='#e0e0e0')
                if icon:
                    copy_action.setIcon(icon)
            else:
                copy_action.setText(f" Copy {len(selected_items)} URLs")
            copy_action.triggered.connect(lambda: self.copy_multiple_urls(selected_items))
            menu.addAction(copy_action)
        else:
            url = selected_items[0].data(Qt.ItemDataRole.UserRole)
            if url:
                copy_action = QAction("Copy URL", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('copy', color='#e0e0e0')
                if icon:
                    copy_action.setIcon(icon)
                else:
                    copy_action.setText(" Copy URL")
                def copy_with_feedback():
                    QApplication.clipboard().setText(url)
                    global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                    QToolTip.showText(global_pos, "URL copied", self.list_widget, QRect(), 1500)
                copy_action.triggered.connect(copy_with_feedback)
                menu.addAction(copy_action)
        
        menu.addSeparator()
        
        # Delete - works for single or multiple
        if is_multiple:
            delete_action = QAction(f"Delete {len(selected_items)} Items", self)
            if HAS_QT_AWESOME:
                icon = get_icon('trash', color='#e0e0e0')
                if icon:
                    delete_action.setIcon(icon)
            else:
                delete_action.setText(f" Delete {len(selected_items)} Items")
            delete_action.triggered.connect(lambda: self.delete_selected_items())
        else:
            delete_action = QAction("Delete", self)
            if HAS_QT_AWESOME:
                icon = get_icon('trash', color='#e0e0e0')
                if icon:
                    delete_action.setIcon(icon)
            else:
                delete_action.setText(" Delete")
            delete_action.triggered.connect(lambda: self.delete_item(selected_items[0]))
        menu.addAction(delete_action)
        
        menu.exec(self.list_widget.mapToGlobal(position))
    
    def open_multiple_urls_in_browser(self, items):
        """Open multiple URLs in browser"""
        urls = []
        for item in items:
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                urls.append(url)
        
        # Open each URL
        for url in urls:
            QDesktopServices.openUrl(QUrl(url))
    
    def copy_multiple_urls(self, items):
        """Copy multiple URLs to clipboard (one per line)"""
        urls = []
        for item in items:
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                urls.append(url)
        
        if urls:
            QApplication.clipboard().setText('\n'.join(urls))
            # Show tooltip feedback
            count = len(urls)
            message = f"{count} URL{'s' if count > 1 else ''} copied" if count > 0 else "URLs copied"
            # Show tooltip at mouse position or list widget center
            global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
            QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)  # 2 second duration
    
    def eventFilter(self, obj, event):
        """Event filter to handle Delete key, Ctrl+C for copy, and drag/drop"""
        # Handle keyboard shortcuts on list widget
        if obj == self.list_widget:
            if event.type() == QEvent.Type.KeyPress:
                # Delete key - remove selected items
                if event.key() == Qt.Key.Key_Delete:
                    self.delete_selected_items()
                    return True
                # Ctrl+C - copy selected URLs to clipboard
                elif event.key() == Qt.Key.Key_C and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    selected_items = self.list_widget.selectedItems()
                    if selected_items:
                        self.copy_multiple_urls(selected_items)
                        return True
                # Ctrl+X - cut selected URLs (copy and delete)
                elif event.key() == Qt.Key.Key_X and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    selected_items = self.list_widget.selectedItems()
                    if selected_items:
                        # Copy URLs first
                        self.copy_multiple_urls(selected_items)
                        # Then delete the items
                        self.delete_selected_items()
                        # Show feedback
                        count = len(selected_items)
                        message = f"{count} item{'s' if count > 1 else ''} cut"
                        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
                        return True
                # Ctrl+V - paste URLs from clipboard
                elif event.key() == Qt.Key.Key_V and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    self.paste_urls_from_clipboard()
                    return True
                # Shift+Ctrl+Z - redo (check this first before Ctrl+Z)
                elif event.key() == Qt.Key.Key_Z and event.modifiers() == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.ShiftModifier):
                    self.redo_playlist_change()
                    return True
                # Ctrl+Z - undo
                elif event.key() == Qt.Key.Key_Z and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    self.undo_playlist_change()
                    return True
        
        # Handle drag and drop for adding URLs
        if obj == self.list_widget:
            if event.type() == QEvent.Type.DragEnter:
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                    return True
            elif event.type() == QEvent.Type.Drop:
                # Extract all URLs from drag event - handle multiple URLs
                url_strings = []
                
                # Get URLs from text (most reliable for multiple URLs)
                if event.mimeData().hasText():
                    text = event.mimeData().text().strip()
                    if text:
                        # Split by newlines first (same as paste handler)
                        lines = [line.strip() for line in text.split('\n') if line.strip()]
                        
                        # If we got multiple lines, use them directly
                        if len(lines) > 1:
                            url_strings.extend(lines)
                        else:
                            # Single line - check if it contains multiple concatenated URLs
                            single_line = lines[0] if lines else text
                            if single_line.count('https://') > 1 or single_line.count('http://') > 1:
                                # Extract concatenated URLs
                                extracted = self.extract_urls_from_text(single_line)
                                url_strings.extend(extracted)
                            else:
                                # Single URL
                                url_strings.append(single_line)
                
                # Also get URLs from hasUrls() - each QUrl becomes a separate entry
                if event.mimeData().hasUrls():
                    url_list = event.mimeData().urls()
                    for url in url_list:
                        url_str = url.toString()
                        # Check if this URL string contains multiple concatenated URLs
                        if url_str.count('https://') > 1 or url_str.count('http://') > 1:
                            # Extract all URLs from this concatenated string
                            extracted = self.extract_urls_from_text(url_str)
                            for extracted_url in extracted:
                                if extracted_url not in url_strings:
                                    url_strings.append(extracted_url)
                        else:
                            # Single URL, add it directly
                            if url_str not in url_strings:
                                url_strings.append(url_str)
                
                if not url_strings:
                    event.ignore()
                    return True
                
                # Process all URLs using the same method as paste handler
                added_count, skipped_count = self.process_urls(url_strings)
                
                # Show feedback (same as paste handler)
                global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
                if added_count > 0 and skipped_count > 0:
                    message = f"Added {added_count} URL(s), skipped {skipped_count}"
                elif added_count > 0:
                    message = f"Added {added_count} URL(s)"
                else:
                    message = "No URLs added (duplicates or invalid)"
                QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
                
                event.acceptProposedAction()
                return True
        
        return super().eventFilter(obj, event)
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event on the playlist sidebar - add to playlist instead of loading"""
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def extract_urls_from_text(self, text):
        """Extract all Bandcamp URLs from text, handling various formats.
        
        Handles:
        - URLs separated by newlines
        - URLs separated by spaces
        - URLs concatenated without separators
        - Mixed formats
        """
        import re
        urls = []
        
        if not text:
            return urls
        
        # Handle concatenated URLs by splitting on https:// and http:// patterns
        # This is the most reliable way to extract URLs even when they're concatenated
        url_parts = re.split(r'(https?://)', text, flags=re.IGNORECASE)
        found_urls = []
        
        # Reconstruct URLs from the split parts
        for i in range(1, len(url_parts), 2):  # Start at index 1 (first https://), step by 2
            if i + 1 < len(url_parts):
                protocol = url_parts[i]  # https:// or http://
                url_body = url_parts[i + 1]  # rest of URL
                
                # Find where this URL ends:
                # 1. Next https:// or http:// (for concatenated URLs)
                # 2. Whitespace
                # 3. Special characters that shouldn't be in URLs
                # 4. End of string
                
                # Check for next URL start
                next_https = url_body.find('https://')
                next_http = url_body.find('http://')
                next_url_start = -1
                if next_https >= 0 and next_http >= 0:
                    next_url_start = min(next_https, next_http)
                elif next_https >= 0:
                    next_url_start = next_https
                elif next_http >= 0:
                    next_url_start = next_http
                
                # Find first whitespace or invalid char
                invalid_chars = re.search(r'[\s<>"{}|\\^`\[\]]', url_body)
                invalid_pos = invalid_chars.start() if invalid_chars else len(url_body)
                
                # Take the URL up to the earliest stopping point
                if next_url_start >= 0:
                    url_body = url_body[:min(next_url_start, invalid_pos)]
                else:
                    url_body = url_body[:invalid_pos]
                
                # Construct full URL
                full_url = protocol + url_body.rstrip('/')
                
                # Only add if it's a Bandcamp URL
                if 'bandcamp.com' in full_url.lower():
                    found_urls.append(full_url)
        
        if found_urls:
            # Found URLs using regex (handles concatenated case)
            urls.extend(found_urls)
        else:
            # Fallback: try splitting by newlines first (most common)
            lines = [line.strip() for line in text.split('\n') if line.strip()]
            
            for line in lines:
                if 'bandcamp.com' in line.lower():
                    # Try splitting by spaces (handles space-separated URLs)
                    space_split = [url.strip() for url in line.split() if url.strip() and 'bandcamp.com' in url.lower()]
                    if space_split:
                        urls.extend(space_split)
                    else:
                        # If no spaces, might be a single URL - add it as-is
                        urls.append(line)
        
        # Remove duplicates while preserving order
        seen = set()
        unique_urls = []
        for url in urls:
            # Normalize URL for comparison (remove trailing slashes)
            normalized = url.rstrip('/')
            if normalized not in seen:
                seen.add(normalized)
                unique_urls.append(url)  # Keep original with/without trailing slash
        
        return unique_urls
    
    def dropEvent(self, event: QDropEvent):
        """Handle drop event on the playlist sidebar - take first valid URL only"""
        url = None
        
        # Get first URL from drag event - prioritize URLs list, then text
        if event.mimeData().hasUrls():
            url_list = event.mimeData().urls()
            if url_list:
                url = url_list[0].toString()
        
        # If no URL from list, try text
        if not url and event.mimeData().hasText():
            text = event.mimeData().text().strip()
            if text:
                # Take first line if multiple lines, or entire text if single
                lines = [line.strip() for line in text.split('\n') if line.strip()]
                if lines:
                    url = lines[0]
        
        if not url:
            event.ignore()
            return
        
        # Process single URL using the same method as paste handler
        added_count, skipped_count = self.process_urls([url])
        
        # Show feedback
        global_pos = self.list_widget.mapToGlobal(self.list_widget.rect().center())
        if added_count > 0:
            message = "URL added to playlist"
        else:
            message = "URL not added (duplicate or invalid)"
        QToolTip.showText(global_pos, message, self.list_widget, QRect(), 2000)
        
        event.acceptProposedAction()
    
    def delete_selected_items(self):
        """Delete all selected items from the playlist"""
        selected_items = self.list_widget.selectedItems()
        if not selected_items:
            return
        
        # Save state to history before deleting
        if not self.is_undoing_redoing:
            self._save_state_to_history()
        
        # Suppress history save when we call save_playlist (we already saved above)
        self._suppress_history_save = True
        
        # Get URLs to remove (skip blank item)
        urls_to_remove = []
        items_to_remove = []
        for item in selected_items:
            # Skip blank item
            if item == self._blank_item:
                continue
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                urls_to_remove.append(url)
                items_to_remove.append(item)
        
        # Remove from playlist manager - remove_url handles URL normalization internally
        for url in urls_to_remove:
            self.playlist_manager.remove_url(url)
        
        # Remove from list widget (in reverse order to maintain indices)
        items_to_remove.sort(key=lambda item: self.list_widget.row(item), reverse=True)
        for item in items_to_remove:
            row = self.list_widget.row(item)
            self.list_widget.takeItem(row)
            
            # Clear current item reference if it was deleted
            if self.current_item == item:
                self.current_item = None
        
        # Save playlist (remove_url already saves, but ensure it's saved after all removals)
        self.playlist_manager.save_playlist()
        
        # Restore history saving
        self._suppress_history_save = False
        
        # Ensure blank item is at bottom after deletion
        self._ensure_blank_item_at_bottom()
        
        # Save state to history after deletion completes (so current state is in history)
        if not self.is_undoing_redoing:
            QTimer.singleShot(50, self._save_state_to_history)
    
    def delete_item(self, item):
        """Delete an item from the playlist (backward compatibility - now uses delete_selected_items)"""
        # Skip blank item
        if item == self._blank_item:
            return
        
        # If multiple items are selected, delete all selected
        selected_items = self.list_widget.selectedItems()
        if len(selected_items) > 1:
            self.delete_selected_items()
        else:
            # Single item deletion - save state to history
            if not self.is_undoing_redoing:
                self._save_state_to_history()
            
            # Suppress history save when we call save_playlist (we already saved above)
            self._suppress_history_save = True
            
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                self.playlist_manager.remove_url(url)
                self.playlist_manager.save_playlist()
            
            row = self.list_widget.row(item)
            self.list_widget.takeItem(row)
            
            if self.current_item == item:
                self.current_item = None
            
            # Ensure blank item is at bottom after deletion
            self._ensure_blank_item_at_bottom()
            
            # Restore history saving
            self._suppress_history_save = False
            
            # Save state to history after deletion completes (so current state is in history)
            if not self.is_undoing_redoing:
                QTimer.singleShot(50, self._save_state_to_history)
    
    def add_url(self):
        """Add URL(s) from clipboard - supports multiple URLs (one per line)"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        if not text:
            return
        
        # Split by newlines to handle multiple URLs
        lines = [line.strip() for line in text.split('\n') if line.strip()]
        
        if not lines:
            return
        
        # Get existing URLs for duplicate checking
        existing_urls = [item.get("url") if isinstance(item, dict) else item for item in self.playlist_manager.playlist]
        
        added_count = 0
        skipped_count = 0
        
        for line in lines:
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved = self.resolve_url_redirects(line)
            if resolved:
                url = resolved
            else:
                # If resolution failed but it looks like a Bandcamp URL, use it as-is
                if 'bandcamp.com' in line.lower():
                    url = line
                else:
                    # Not a Bandcamp URL, skip it
                    skipped_count += 1
                    continue
            
            # Normalize URL
            url = url.strip().rstrip('/')
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            # Only add if it's a Bandcamp URL and not already in playlist
            if 'bandcamp.com' in url.lower():
                if url not in existing_urls:
                    self.playlist_manager.add_url(url)
                    self.add_item(url)
                    added_count += 1
                    existing_urls.append(url)  # Update list to avoid duplicates in same batch
                else:
                    skipped_count += 1
            else:
                skipped_count += 1
        
        # Save playlist after adding all URLs
        if added_count > 0:
            self.playlist_manager.save_playlist()
        
        # Show feedback if multiple URLs were processed
        if len(lines) > 1:
            from PyQt6.QtWidgets import QMessageBox
            msg = QMessageBox(self)
            msg.setWindowTitle("Add URLs")
            if added_count > 0 and skipped_count > 0:
                msg.setText(f"Added {added_count} URL(s) to playlist.\nSkipped {skipped_count} (duplicates or invalid).")
            elif added_count > 0:
                msg.setText(f"Added {added_count} URL(s) to playlist.")
            else:
                msg.setText(f"No URLs added. All were duplicates or invalid.")
            msg.setStyleSheet("""
                QMessageBox {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                }
                QMessageBox QLabel {
                    color: #e0e0e0;
                    background-color: transparent;
                }
                QMessageBox QPushButton {
                    background-color: #3a3a3a;
                    color: #e0e0e0;
                    border: 1px solid #4a4a4a;
                    border-radius: 4px;
                    padding: 5px 15px;
                    min-width: 60px;
                }
                QMessageBox QPushButton:hover {
                    background-color: #4a4a4a;
                    border: 1px solid #5a5a5a;
                }
                QMessageBox QPushButton:pressed {
                    background-color: #2a2a2a;
                }
            """)
            msg.exec()
    
    def clear_playlist(self):
        """Clear the playlist"""
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Clear Playlist")
        msg_box.setText("Are you sure you want to clear all URLs from the playlist?")
        msg_box.setIcon(QMessageBox.Icon.Question)
        msg_box.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        msg_box.setDefaultButton(QMessageBox.StandardButton.No)
        
        # Apply styling to ensure readable text on Windows 10
        msg_box.setStyleSheet("""
            QMessageBox {
                background-color: #2b2b2b;
                color: #e0e0e0;
            }
            QMessageBox QLabel {
                color: #e0e0e0;
                background-color: transparent;
            }
            QMessageBox QPushButton {
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 5px 15px;
                min-width: 60px;
            }
            QMessageBox QPushButton:hover {
                background-color: #4a4a4a;
                border: 1px solid #5a5a5a;
            }
            QMessageBox QPushButton:pressed {
                background-color: #2a2a2a;
            }
        """)
        
        reply = msg_box.exec()
        
        if reply == QMessageBox.StandardButton.Yes:
            # Save state to history before clearing
            if not self.is_undoing_redoing:
                self._save_state_to_history()
            
            # Suppress history save (we already saved above)
            self._suppress_history_save = True
            
            self.list_widget.clear()
            self.current_item = None
            self._blank_item = None  # Clear blank item reference
            self.playlist_manager.clear_playlist()
            
            # Add blank item at bottom after clearing
            self._ensure_blank_item_at_bottom()
            
            # Restore history saving
            self._suppress_history_save = False
            
            # Save state to history after clearing completes (so current state is in history)
            if not self.is_undoing_redoing:
                QTimer.singleShot(50, self._save_state_to_history)
    
    def _save_state_to_history(self):
        """Save current playlist state to undo history"""
        if self.is_undoing_redoing:
            return
        
        # Get current playlist state
        playlist_items = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                display_text = item.text()
                playlist_items.append({"url": url, "display_text": display_text})
        
        # Only save if state actually changed
        if self.undo_history and self.undo_history[-1] == playlist_items:
            return
        
        # Add to undo history
        self.undo_history.append(playlist_items)
        
        # Limit history size
        if len(self.undo_history) > self.max_history_size:
            self.undo_history.pop(0)
        
        # Clear redo history when new action is performed
        self.redo_history.clear()
    
    def undo_playlist_change(self):
        """Undo the last playlist change"""
        if not self.undo_history or len(self.undo_history) <= 1:
            # No history or only initial state
            return
        
        # Get previous state (second to last, since last is current)
        previous_state = self.undo_history[-2]
        
        # Save current state to redo history
        current_state = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                display_text = item.text()
                current_state.append({"url": url, "display_text": display_text})
        self.redo_history.append(current_state)
        
        # Remove current state from undo history
        self.undo_history.pop()
        
        # Restore previous state
        self.is_undoing_redoing = True
        self._restore_playlist_state(previous_state)
        self.is_undoing_redoing = False
    
    def redo_playlist_change(self):
        """Redo the last undone playlist change"""
        if not self.redo_history:
            return
        
        # Get state to restore
        state_to_restore = self.redo_history.pop()
        
        # Save current state to undo history
        current_state = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                display_text = item.text()
                current_state.append({"url": url, "display_text": display_text})
        self.undo_history.append(current_state)
        
        # Restore state
        self.is_undoing_redoing = True
        self._restore_playlist_state(state_to_restore)
        self.is_undoing_redoing = False
    
    def _restore_playlist_state(self, state):
        """Restore playlist to a given state"""
        # Store current item URL to restore highlighting
        current_url = None
        if self.current_item:
            current_url = self.current_item.data(Qt.ItemDataRole.UserRole)
        
        # Clear list widget
        self.list_widget.clear()
        self.current_item = None
        
        # Add items from state
        for item_data in state:
            url = item_data.get("url", "")
            display_text = item_data.get("display_text")
            if url:
                # Create list item
                item = QListWidgetItem(display_text if display_text else self.url_to_display(url))
                item.setData(Qt.ItemDataRole.UserRole, url)
                item.setData(Qt.ItemDataRole.UserRole + 1, False)
                item.setToolTip(url)
                self.list_widget.addItem(item)
        
        # Update playlist manager
        self.playlist_manager.playlist = state.copy()
        self.playlist_manager.save_playlist()
        
        # Restore current item highlighting if it still exists
        if current_url:
            QTimer.singleShot(100, lambda: self.update_current_item(current_url))
    
    def _on_rows_moved(self):
        """Handle rows moved signal with debouncing to save history only once per drag operation"""
        # Cancel any existing timer
        if self._reorder_save_timer:
            self._reorder_save_timer.stop()
        
        # Debounce the save - wait 300ms after last move before saving
        # This ensures we only save once per drag operation, not on every intermediate move
        self._reorder_save_timer = QTimer(self)
        self._reorder_save_timer.setSingleShot(True)
        self._reorder_save_timer.timeout.connect(self._save_playlist_after_reorder)
        self._reorder_save_timer.start(300)
    
    def _save_playlist_after_reorder(self):
        """Save playlist after reorder is complete"""
        # Save state to history once when drag completes
        if not self.is_undoing_redoing and not self._suppress_history_save:
            self._save_state_to_history()
        
        # Suppress history save when calling save_playlist (we already saved above)
        self._suppress_history_save = True
        self.save_playlist()
        self._suppress_history_save = False
    
    def save_playlist(self):
        """Save playlist from list widget (with metadata)"""
        # Save state to history before saving (if not undoing/redoing and not suppressed)
        if not self.is_undoing_redoing and not self._suppress_history_save:
            self._save_state_to_history()
        
        playlist_items = []
        for i in range(self.list_widget.count()):
            item = self.list_widget.item(i)
            url = item.data(Qt.ItemDataRole.UserRole)
            if url:
                # Get display text from the item
                display_text = item.text()
                playlist_items.append({"url": url, "display_text": display_text})
        
        self.playlist_manager.playlist = playlist_items
        self.playlist_manager.save_playlist()
    
    def normalize_url(self, url):
        """Normalize URL for comparison (remove trailing slashes, normalize scheme)"""
        if not url:
            return None
        url = url.strip().rstrip('/')
        # Normalize http to https
        if url.startswith('http://'):
            url = 'https://' + url[7:]
        return url.lower()
    
    def get_url_path(self, url):
        """Extract path portion of URL for flexible matching"""
        if not url:
            return None
        try:
            from urllib.parse import urlparse
            parsed = urlparse(url)
            # Get path and remove leading/trailing slashes
            path = parsed.path.strip('/')
            # Include query string if present (for some Bandcamp URLs)
            if parsed.query:
                path = path + '?' + parsed.query
            return path.lower()
        except:
            return None
    
    def update_current_item(self, url):
        """Update the current item based on URL"""
        if not url:
            logger.debug("update_current_item: No URL provided")
            return
            
        logger.debug(f"update_current_item: Looking for URL: {url}")
        
        # Resolve URL to match against stored URLs (in case URL was resolved)
        resolved_url = self.resolve_url_redirects(url)
        if resolved_url:
            logger.debug(f"update_current_item: Resolved URL: {resolved_url}")
            url = resolved_url
        
        # Normalize the URL for comparison
        normalized_url = self.normalize_url(url)
        url_path = self.get_url_path(url)
        logger.debug(f"update_current_item: Normalized URL: {normalized_url}")
        logger.debug(f"update_current_item: URL path: {url_path}")
        logger.debug(f"update_current_item: Playlist has {self.list_widget.count()} items")
        
        # Try to find item by URL match (with normalization)
        best_match = None
        for i in range(self.list_widget.count()):
            try:
                item = self.list_widget.item(i)
                if not item:
                    continue
                    
                item_url = item.data(Qt.ItemDataRole.UserRole)
                if not item_url:
                    continue
                
                logger.debug(f"update_current_item: Item {i}: {item_url}")
                
                # Normalize stored URL
                normalized_item_url = self.normalize_url(item_url)
                logger.debug(f"update_current_item:   Normalized: {normalized_item_url}")
                
                # Also check resolved version of stored URL
                resolved_item_url = self.resolve_url_redirects(item_url) if item_url else None
                if resolved_item_url:
                    logger.debug(f"update_current_item:   Resolved: {resolved_item_url}")
                normalized_resolved_item_url = self.normalize_url(resolved_item_url) if resolved_item_url else None
                
                # Exact match (highest priority)
                if (normalized_item_url == normalized_url or 
                    (normalized_resolved_item_url and normalized_resolved_item_url == normalized_url)):
                    logger.debug(f"update_current_item: EXACT MATCH FOUND at index {i}!")
                    self.set_current_item(item)
                    return
                
                # Path-based match (fallback for URLs with different schemes or trailing slashes)
                if url_path:
                    item_path = self.get_url_path(item_url)
                    resolved_item_path = self.get_url_path(resolved_item_url) if resolved_item_url else None
                    if (item_path and item_path == url_path) or (resolved_item_path and resolved_item_path == url_path):
                        logger.debug(f"update_current_item: PATH MATCH FOUND at index {i} (path: {item_path})")
                        best_match = item  # Store as best match, but continue looking for exact match
            except RuntimeError:
                # Item was deleted during iteration, skip it
                continue
        
        # If no exact match found, use best path-based match
        if best_match:
            logger.debug("update_current_item: Using best path-based match")
            self.set_current_item(best_match)
        else:
            logger.warning(f"update_current_item: NO MATCH FOUND for URL: {url}")
    
    def update_item_display(self, url, display_text):
        """Update the display text for a playlist item by URL"""
        if not url or not display_text:
            return
        
        # Normalize the URL for comparison
        normalized_url = self.normalize_url(url)
        url_path = self.get_url_path(url)
        
        # Try to find item by URL match
        for i in range(self.list_widget.count()):
            try:
                item = self.list_widget.item(i)
                if not item:
                    continue
                    
                item_url = item.data(Qt.ItemDataRole.UserRole)
                if not item_url:
                    continue
                
                # Normalize stored URL
                normalized_item_url = self.normalize_url(item_url)
                
                # Also check resolved version of stored URL
                resolved_item_url = self.resolve_url_redirects(item_url) if item_url else None
                normalized_resolved_item_url = self.normalize_url(resolved_item_url) if resolved_item_url else None
                
                # Exact match (highest priority)
                if (normalized_item_url == normalized_url or 
                    (normalized_resolved_item_url and normalized_resolved_item_url == normalized_url)):
                    item.setText(display_text)
                    item.setToolTip(url)
                    logger.debug(f"Updated playlist item display: {url} -> {display_text}")
                    return
                
                # Path-based match (fallback)
                if url_path:
                    item_path = self.get_url_path(item_url)
                    resolved_item_path = self.get_url_path(resolved_item_url) if resolved_item_url else None
                    if (item_path and item_path == url_path) or (resolved_item_path and resolved_item_path == url_path):
                        item.setText(display_text)
                        item.setToolTip(url)
                        logger.debug(f"Updated playlist item display (path match): {url} -> {display_text}")
                        return
            except RuntimeError:
                # Item was deleted during iteration, skip it
                continue

# ============================================================================
# KEYBOARD SHORTCUTS DIALOG
# ============================================================================

class KeyboardShortcutsDialog(QDialog):
    """Dialog for customizing keyboard shortcuts"""
    
    # Default shortcuts
    DEFAULT_SHORTCUTS = {
        "play_pause": "Ctrl+Alt+Space",
        "next_track": "Ctrl+Alt+Right",
        "previous_track": "Ctrl+Alt+Left",
        "next_album": "Ctrl+Shift+Alt+Right",
        "previous_album": "Ctrl+Shift+Alt+Left",
        "volume_up": "Ctrl+Shift+Up",
        "volume_down": "Ctrl+Shift+Down",
        "mute": "Ctrl+Shift+M",
        "toggle_playlist": "Ctrl+Alt+P",
        "toggle_playlist_expand": "Ctrl+Shift+Alt+P",
        "cycle_app_mode": "Ctrl+Alt+M",
        "save_playlist": "Ctrl+S",
    }
    
    def __init__(self, parent=None, current_shortcuts=None):
        super().__init__(parent)
        self.setWindowTitle("Keyboard Shortcuts")
        self.setMinimumSize(600, 500)
        
        # Apply dark theme
        self.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
                color: #e0e0e0;
            }
            QLabel {
                color: #e0e0e0;
            }
            QLineEdit {
                background-color: #1e1e1e;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 4px;
            }
            QLineEdit:focus {
                border: 1px solid #4a90e2;
            }
            QPushButton {
                background-color: #3a3a3a;
                color: #e0e0e0;
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 6px 12px;
            }
            QPushButton:hover {
                background-color: #4a4a4a;
            }
            QPushButton:pressed {
                background-color: #2a2a2a;
            }
        """)
        
        layout = QVBoxLayout(self)
        
        # Description
        desc_label = QLabel("Customize keyboard shortcuts. Click on a shortcut field and press the desired key combination.")
        desc_label.setWordWrap(True)
        desc_label.setStyleSheet("color: #999; padding: 10px;")
        layout.addWidget(desc_label)
        
        # Shortcuts table
        self.shortcut_widgets = {}
        shortcuts_layout = QVBoxLayout()
        
        # Define shortcuts with labels
        shortcuts_def = [
            ("play_pause", "Play/Pause"),
            ("next_track", "Next Track"),
            ("previous_track", "Previous Track"),
            ("next_album", "Next Album"),
            ("previous_album", "Previous Album"),
            ("volume_up", "Volume Up"),
            ("volume_down", "Volume Down"),
            ("mute", "Mute"),
            ("toggle_playlist", "Toggle Playlist"),
            ("toggle_playlist_expand", "Expand/Collapse Playlist"),
            ("cycle_app_mode", "Cycle App Mode"),
            ("save_playlist", "Save Playlist"),
        ]
        
        for key, label in shortcuts_def:
            row_layout = QHBoxLayout()
            
            # Label
            label_widget = QLabel(label + ":")
            label_widget.setMinimumWidth(150)
            row_layout.addWidget(label_widget)
            
            # Shortcut input
            shortcut_input = QLineEdit()
            shortcut_input.setPlaceholderText("Press keys...")
            shortcut_input.setReadOnly(True)
            shortcut_input.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
            
            # Load current shortcut
            if current_shortcuts and key in current_shortcuts:
                shortcut_input.setText(current_shortcuts[key])
            elif key in self.DEFAULT_SHORTCUTS:
                shortcut_input.setText(self.DEFAULT_SHORTCUTS[key])
            
            # Install event filter to capture key presses
            shortcut_input.installEventFilter(self)
            shortcut_input.setProperty("shortcut_key", key)
            
            row_layout.addWidget(shortcut_input)
            
            # Clear button
            clear_btn = QPushButton("Clear")
            clear_btn.clicked.connect(lambda checked, k=key: self.clear_shortcut(k))
            row_layout.addWidget(clear_btn)
            
            shortcuts_layout.addLayout(row_layout)
            self.shortcut_widgets[key] = shortcut_input
        
        layout.addLayout(shortcuts_layout)
        layout.addStretch()
        
        # Buttons
        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()
        
        reset_btn = QPushButton("Reset to Defaults")
        reset_btn.clicked.connect(self.reset_to_defaults)
        buttons_layout.addWidget(reset_btn)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(cancel_btn)
        
        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(self.accept)
        ok_btn.setDefault(True)
        buttons_layout.addWidget(ok_btn)
        
        layout.addLayout(buttons_layout)
        
        self.current_shortcuts = current_shortcuts or {}
    
    def eventFilter(self, obj, event):
        """Capture key presses in shortcut input fields"""
        if event.type() == QEvent.Type.KeyPress:
            key = obj.property("shortcut_key")
            if key:
                # Build key sequence from event
                modifiers = []
                if event.modifiers() & Qt.KeyboardModifier.ControlModifier:
                    modifiers.append("Ctrl")
                if event.modifiers() & Qt.KeyboardModifier.ShiftModifier:
                    modifiers.append("Shift")
                if event.modifiers() & Qt.KeyboardModifier.AltModifier:
                    modifiers.append("Alt")
                if event.modifiers() & Qt.KeyboardModifier.MetaModifier:
                    modifiers.append("Meta")
                
                # Get the key
                key_name = QKeySequence(event.key()).toString()
                if key_name:
                    if modifiers:
                        key_sequence = "+".join(modifiers) + "+" + key_name
                    else:
                        key_sequence = key_name
                    
                    obj.setText(key_sequence)
                    return True  # Consume the event
        
        return super().eventFilter(obj, event)
    
    def clear_shortcut(self, key):
        """Clear a shortcut"""
        if key in self.shortcut_widgets:
            self.shortcut_widgets[key].setText("")
    
    def reset_to_defaults(self):
        """Reset all shortcuts to defaults"""
        for key, widget in self.shortcut_widgets.items():
            if key in self.DEFAULT_SHORTCUTS:
                widget.setText(self.DEFAULT_SHORTCUTS[key])
            else:
                widget.setText("")
    
    def get_shortcuts(self):
        """Get current shortcuts as a dictionary"""
        shortcuts = {}
        for key, widget in self.shortcut_widgets.items():
            text = widget.text().strip()
            if text:
                shortcuts[key] = text
        return shortcuts

# ============================================================================
# MEDIA KEY NATIVE EVENT FILTER
# ============================================================================

class MediaKeyEventFilter(QAbstractNativeEventFilter):
    """Native event filter to intercept WM_APPCOMMAND for next/previous media keys
    Also handles custom Windows messages from AutoHotkey for keyboard shortcuts"""
    
    def __init__(self):
        super().__init__()
        self.media_next_callback = None
        self.media_prev_callback = None
        # Custom Windows messages for AutoHotkey communication (WM_USER + offset)
        # These allow AutoHotkey to trigger actions without window focus
        self.WM_USER = 0x0400
        self.WM_BANDCAMP_NEXT = self.WM_USER + 1
        self.WM_BANDCAMP_PREV = self.WM_USER + 2
        self.WM_BANDCAMP_PLAY_PAUSE = self.WM_USER + 3
    
    def setCallbacks(self, next_callback, prev_callback):
        """Set callbacks for media key events"""
        self.media_next_callback = next_callback
        self.media_prev_callback = prev_callback
    
    def nativeEventFilter(self, eventType, message):
        """Filter native events to catch WM_APPCOMMAND"""
        # Only process Windows messages
        if sys.platform != 'win32' or not _HAS_CTYPES or eventType != b'windows_generic_MSG':
            return False, 0
        
        try:
            import ctypes
            from ctypes import wintypes
            
            # Windows constants
            WM_APPCOMMAND = 0x0319
            APPCOMMAND_MEDIA_NEXT = 11
            APPCOMMAND_MEDIA_PREV = 12
            APPCOMMAND_MEDIA_PLAY_PAUSE = 14
            
            # In PyQt6, message is a pointer to MSG structure
            # We need to cast it carefully - message might be an integer pointer or a ctypes pointer
            try:
                # Try to interpret message as a pointer
                if isinstance(message, int):
                    # It's a pointer address
                    msg_ptr = ctypes.cast(message, ctypes.POINTER(wintypes.MSG))
                else:
                    # It might already be a pointer-like object
                    msg_ptr = ctypes.cast(ctypes.c_void_p(message), ctypes.POINTER(wintypes.MSG))
                
                msg = msg_ptr.contents
            except (ValueError, TypeError, AttributeError, ctypes.ArgumentError):
                # If we can't cast, just pass through (not a message we can handle)
                return False, 0
            
            # Process WM_APPCOMMAND messages (media keys) and WM_COPYDATA (AutoHotkey IPC)
            WM_APPCOMMAND = 0x0319
            WM_COPYDATA = 0x004A
            
            # Handle WM_COPYDATA messages from AutoHotkey (works without focus)
            if msg.message == WM_COPYDATA:
                try:
                    # WM_COPYDATA structure: lParam points to COPYDATASTRUCT
                    # COPYDATASTRUCT: dwData (ULONG_PTR), cbData (DWORD), lpData (PVOID)
                    # ULONG_PTR size depends on architecture (4 bytes on 32-bit, 8 bytes on 64-bit)
                    import struct
                    is_64bit = struct.calcsize("P") == 8
                    
                    if is_64bit:
                        # 64-bit: dwData (8 bytes), cbData (4 bytes), lpData (8 bytes) = 20 bytes
                        class COPYDATASTRUCT(ctypes.Structure):
                            _fields_ = [("dwData", ctypes.c_ulonglong),  # ULONG_PTR on 64-bit
                                       ("cbData", ctypes.c_ulong),        # DWORD
                                       ("lpData", ctypes.c_void_p)]       # PVOID
                    else:
                        # 32-bit: dwData (4 bytes), cbData (4 bytes), lpData (4 bytes) = 12 bytes
                        class COPYDATASTRUCT(ctypes.Structure):
                            _fields_ = [("dwData", ctypes.c_ulong),      # ULONG_PTR on 32-bit
                                       ("cbData", ctypes.c_ulong),        # DWORD
                                       ("lpData", ctypes.c_void_p)]       # PVOID
                    
                    copy_data = ctypes.cast(msg.lParam, ctypes.POINTER(COPYDATASTRUCT)).contents
                    command_id = copy_data.dwData
                    
                    # Command IDs: 1=Next, 2=Prev, 3=PlayPause
                    if command_id == 1:  # Next track
                        logger.info("WM_COPYDATA: Next track from AutoHotkey")
                        if self.media_next_callback:
                            QTimer.singleShot(0, self.media_next_callback)
                            return True, 0  # Handled
                    elif command_id == 2:  # Previous track
                        logger.info("WM_COPYDATA: Previous track from AutoHotkey")
                        if self.media_prev_callback:
                            QTimer.singleShot(0, self.media_prev_callback)
                            return True, 0  # Handled
                    elif command_id == 3:  # Play/Pause
                        logger.debug("WM_COPYDATA: Play/Pause from AutoHotkey")
                        # Could add callback here if needed
                        return False, 0  # Let Qt handle it for now
                except Exception as e:
                    logger.warning(f"Error processing WM_COPYDATA: {e}")
                    import traceback
                    logger.debug(traceback.format_exc())
                    return False, 0
            
            # Only process WM_APPCOMMAND messages
            if msg.message != WM_APPCOMMAND:
                return False, 0
            
            # Extract command from lParam (high word)
            cmd = (msg.lParam >> 16) & 0x7FFF
            logger.info(f"Media key event filter: Received WM_APPCOMMAND, command={cmd} (hwnd={msg.hwnd})")
            
            if cmd == APPCOMMAND_MEDIA_NEXT:
                logger.info("Media key: Next track detected (nativeEventFilter)")
                if self.media_next_callback:
                    # Use QTimer to call in main thread safely
                    QTimer.singleShot(0, self.media_next_callback)
                    return True, 0  # Handled
                else:
                    logger.warning("Media key: Next callback not set!")
            elif cmd == APPCOMMAND_MEDIA_PREV:
                logger.info("Media key: Previous track detected (nativeEventFilter)")
                if self.media_prev_callback:
                    # Use QTimer to call in main thread safely
                    QTimer.singleShot(0, self.media_prev_callback)
                    return True, 0  # Handled
                else:
                    logger.warning("Media key: Previous callback not set!")
            elif cmd == APPCOMMAND_MEDIA_PLAY_PAUSE:
                # Let Qt handle play/pause (don't intercept)
                logger.debug(f"Media key: Play/Pause detected (letting Qt handle it)")
            
        except Exception as e:
            # Only log unexpected errors (not casting errors which are normal)
            if "cast" not in str(e).lower() and "argument" not in str(e).lower():
                logger.warning(f"Error in nativeEventFilter: {e}")
        
        # Let Qt handle everything else (including play/pause)
        return False, 0

# ============================================================================
# MEDIA KEY LISTENER THREAD (fallback - kept for compatibility)
# ============================================================================

class MediaKeyListenerThread(QThread):
    """Thread to listen for media keys using a Windows message-only window (safer than nativeEvent)"""
    media_next = pyqtSignal()
    media_prev = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.running = True
        self.hwnd = None
    
    def run(self):
        """Run the media key listener using a Windows message-only window"""
        if sys.platform != 'win32' or not _HAS_CTYPES:
            logger.info("Media key listener: Not on Windows or ctypes unavailable, skipping")
            return
        
        try:
            import ctypes
            from ctypes import wintypes
            
            # Windows constants
            WM_APPCOMMAND = 0x0319
            APPCOMMAND_MEDIA_NEXT = 11
            APPCOMMAND_MEDIA_PREV = 12
            HWND_MESSAGE = -3  # Message-only window
            
            # Windows API functions
            user32 = ctypes.windll.user32
            
            # Window class name
            class_name = "BandcampPlayerMediaKeyWindow"
            
            # Define WNDPROC callback
            WNDPROC = ctypes.WINFUNCTYPE(
                wintypes.LPARAM,  # Return type
                wintypes.HWND,    # hwnd
                wintypes.UINT,    # uMsg
                wintypes.WPARAM,  # wParam
                wintypes.LPARAM   # lParam
            )
            
            def window_proc(hwnd, uMsg, wParam, lParam):
                """Window procedure to handle WM_APPCOMMAND"""
                if uMsg == WM_APPCOMMAND:
                    # Extract command from lParam (high word)
                    cmd = (lParam >> 16) & 0x7FFF
                    
                    if cmd == APPCOMMAND_MEDIA_NEXT:
                        logger.info("Media key: Next track detected (message window)")
                        self.media_next.emit()
                        return 1  # Handled
                    elif cmd == APPCOMMAND_MEDIA_PREV:
                        logger.info("Media key: Previous track detected (message window)")
                        self.media_prev.emit()
                        return 1  # Handled
                
                # Default window procedure
                return user32.DefWindowProcW(hwnd, uMsg, wParam, lParam)
            
            # Create window procedure
            wnd_proc = WNDPROC(window_proc)
            
            # Register window class
            wc = wintypes.WNDCLASSW()
            wc.lpfnWndProc = wnd_proc
            wc.lpszClassName = class_name
            wc.hInstance = ctypes.windll.kernel32.GetModuleHandleW(None)
            
            atom = user32.RegisterClassW(ctypes.byref(wc))
            if not atom:
                logger.warning("Failed to register window class for media keys")
                return
            
            # Create message-only window
            self.hwnd = user32.CreateWindowExW(
                0,  # dwExStyle
                class_name,
                None,  # Window name
                0,  # dwStyle
                0, 0, 0, 0,  # x, y, width, height
                HWND_MESSAGE,  # hWndParent (message-only)
                None,  # hMenu
                wc.hInstance,
                None  # lpParam
            )
            
            if not self.hwnd:
                logger.warning("Failed to create message-only window for media keys")
                user32.UnregisterClassW(class_name, wc.hInstance)
                return
            
            logger.info("Message-only window created for media key detection")
            
            # Message loop
            msg = wintypes.MSG()
            bRet = wintypes.BOOL()
            while self.running:
                bRet = user32.GetMessageW(ctypes.byref(msg), None, 0, 0)
                if bRet == 0:  # WM_QUIT
                    break
                elif bRet == -1:  # Error
                    logger.warning("GetMessage error in media key window")
                    break
                else:
                    user32.TranslateMessage(ctypes.byref(msg))
                    user32.DispatchMessageW(ctypes.byref(msg))
            
            # Cleanup
            if self.hwnd:
                user32.DestroyWindow(self.hwnd)
                self.hwnd = None
            user32.UnregisterClassW(class_name, wc.hInstance)
            
        except Exception as e:
            logger.warning(f"Media key listener error: {e}")
            import traceback
            logger.warning(traceback.format_exc())
    
    def stop(self):
        """Stop the listener thread"""
        self.running = False
        # Post a quit message to break the message loop
        if sys.platform == 'win32' and self.hwnd:
            try:
                import ctypes
                from ctypes import wintypes
                user32 = ctypes.windll.user32
                user32.PostQuitMessage(0)
            except Exception:
                pass
        self.quit()
        self.wait()

# ============================================================================
# PLAYER WINDOW CLASS
# ============================================================================

class PlayerWindow(QMainWindow):
    """Main player window with web view and playlist controls"""
    
    def __init__(self):
        super().__init__()
        
        # Minimize console window immediately (like downloader does)
        # This happens AFTER Qt is initialized, which is more reliable on Windows 10
        self._minimize_console_immediately()
        
        # Hide window initially to prevent flash before geometry is restored
        self.setVisible(False)
        QMainWindow.setWindowTitle(self, "Empty - Bandcamp Player")
        self.window_title_label = None  # Will be set in create_custom_title_bar
        self.setMinimumSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT)
        self.setMaximumWidth(WINDOW_MAX_WIDTH)
        
        # Load and set icon
        icon_path = Path(__file__).parent / "icon.ico"
        if icon_path.exists():
            icon = QIcon(str(icon_path))
            self.setWindowIcon(icon)
            self.app_icon = icon
        else:
            self.app_icon = None
        
        # Settings
        self.settings_file = Path(__file__).parent / "settings.json"
        self.settings = self.load_settings()
        
        # Setup persistent storage for WebEngine (for dev tools settings)
        self.setup_webengine_storage()
        
        # State
        self.compact_mode = self.settings.get("compact_mode", True)  # Default to enabled
        self.bandcamp_mode = self.settings.get("bandcamp_mode", True)  # Default to enabled
        self.always_on_top = self.settings.get("always_on_top", True)
        self.frameless_mode = self.settings.get("frameless_mode", True)  # Default to enabled
        self.autoplay = self.settings.get("autoplay", True)  # Default to enabled
        self.autoplay_on_startup = self.settings.get("autoplay_on_startup", True)  # Default to enabled
        self.transparent_overlay = self.settings.get("transparent_overlay", False)  # Default to opaque
        self.autohide_address_bar = self.settings.get("autohide_address_bar", True)  # Default to enabled
        self.mini_mode_player_autohide = self.settings.get("mini_mode_player_autohide", False)  # Default to disabled
        self.webview_scrollbar_visible = self.settings.get("webview_scrollbar_visible", False)  # Default to hidden
        self.nano_mode_on_minimize = self.settings.get("nano_mode_on_minimize", True)  # Default to enabled
        # Remove "fully hidden" mode: migrate any old hidden state to autohide
        legacy_hidden = self.settings.get("mini_mode_player_hidden", False)
        if legacy_hidden and not self.mini_mode_player_autohide:
            self.mini_mode_player_autohide = True
        self.mini_mode_player_hidden = False
        self.volume_level = self.settings.get("volume_level", 100)  # Default to 100% (0-200 range)
        # Load mini_mode_state directly from settings (restore last used mode)
        # With the new restoration logic, we can safely start in any mode
        self.mini_mode_state = self.settings.get("mini_mode_state", 0)  # 0 = Regular, 1 = Mini, 2 = Micro
        # Track current track number for autoplay persistence
        # Initialize from settings if available (preserve last played track)
        self._current_track_number = self.settings.get("last_played_track_number")
        
        # Detachable playlist state
        self.playlist_detached = False
        self.detached_playlist_window = None
        self.playlist_detached_offset = self.settings.get("playlist_detached_offset", (20, 0))  # Default offset to right (for backward compatibility)
        self.playlist_detached_position = self.settings.get("playlist_detached_position", None)  # Absolute position (x, y)
        self.playlist_detached_size = self.settings.get("playlist_detached_size", "260x400")  # Default size
        # Link mode state (playlist window follows main window)
        self.playlist_window_linked = self.settings.get("playlist_window_linked", False)
        self._playlist_window_link_offset = None  # Relative offset when linked
        self._last_main_window_pos = None  # For detecting main window movement
        self._last_detached_playlist_pos = None  # For detecting detached window movement
        self._moving_detached_playlist_programmatically = False  # Flag to prevent recursive updates
        # Track if we minimized the detached playlist (so we can restore it when main window restores)
        self._detached_playlist_minimized_by_main = False
        # Nano mode state
        self.nano_player_window = None
        self._main_window_hidden_for_nano = False  # Track if main window was hidden for nano mode
        self._page_loaded_at_least_once = False  # Track if page has loaded at least once (for startup nano mode)
        self._first_restore_from_nano = False  # Track if this is first restore from nano after startup
        self._doing_quick_sync = False  # Flag to prevent nano mode from activating during quick sync
        self._minimize_button_clicked = False  # Flag to track when minimize button is clicked (to bypass nano mode)
        # Window snapping
        self._snap_threshold = 20  # Pixels - distance threshold for snapping
        # Debounced snapping (prevents jitter by snapping after dragging stops)
        self._snap_debounce_ms = 90
        self._moving_main_window_programmatically = False  # Prevent recursive snap scheduling
        self._detached_snap_timer = QTimer(self)
        self._detached_snap_timer.setSingleShot(True)
        self._detached_snap_timer.timeout.connect(self._handle_playlist_window_snapping)
        # Docking state for main window + playlist window combination
        self._windows_docked_edge = None  # 'top', 'bottom', 'left', 'right', or None
        self._windows_docked = False  # Whether windows are docked together at screen edge
        # Drag state tracking
        self._is_dragging_main_window = False  # Track if main window is being dragged
        self._is_dragging_playlist_window = False  # Track if playlist window is being dragged
        self._snapped_during_drag = False  # Track if windows snapped during drag (to link on release)
        self._playlist_drag_start_pos = None  # Track playlist position when drag started
        self._playlist_breakaway_activated = False  # Track if playlist has broken away (disable snapping for this drag)
        self._playlist_release_window_active = False  # Track if we're in the release window (brief period after unlinking where snapping is disabled)
        self._playlist_release_window_timer = QTimer(self)
        self._playlist_release_window_timer.setSingleShot(True)
        self._playlist_release_window_timer.timeout.connect(lambda: setattr(self, '_playlist_release_window_active', False))
        self._main_snap_timer = QTimer(self)
        self._main_snap_timer.setSingleShot(True)
        self._main_snap_timer.timeout.connect(self._handle_main_window_snapping)
        
        # Shuffle-related state
        self._shuffled_track_list = None  # List of track numbers in shuffled order
        self._shuffled_track_index = 0  # Current position in shuffled list
        self._shuffled_track_album_url = None  # URL of album for which we have shuffled list
        self._pending_super_shuffle_load = False  # Flag to load Super Shuffle track when current track finishes
        self._is_super_shuffle_load = False  # Flag to track if this is a Super Shuffle URL load
        self._super_shuffle_album_url = None  # Store album URL for Super Shuffle track selection

        # Link-mode smoothing (throttle moves to reduce jitter without "lagging behind")
        self._link_move_interval_ms = 8  # target ~120fps (best-effort; OS timer resolution may limit)
        self._pending_linked_detached_pos = None
        self._last_programmatic_detached_pos = None
        self._link_move_idle_ticks = 0
        self._linked_move_timer = QTimer(self)
        self._linked_move_timer.setSingleShot(False)
        self._linked_move_timer.setInterval(self._link_move_interval_ms)
        try:
            # Prefer higher resolution for smoother linking on Windows
            self._linked_move_timer.setTimerType(Qt.TimerType.PreciseTimer)
        except Exception:
            pass
        self._linked_move_timer.timeout.connect(self._apply_pending_linked_detached_move)
        
        # Restore window geometry from settings if available (must be after settings are loaded)
        # Handle geometry based on the mode we're starting in
        if self.mini_mode_state == 0:
            # Regular mode: restore geometry, but ensure default height
            geometry = self.settings.get("window_geometry")
            if geometry:
                try:
                    geometry_bytes = QByteArray.fromHex(geometry.encode())
                    self.restoreGeometry(geometry_bytes)
                    # Always use default height for regular mode
                    self.resize(self.width(), WINDOW_DEFAULT_HEIGHT)
                except Exception as e:
                    # If restore fails, use default size
                    logger.warning(f"Could not restore window geometry: {e}")
                    self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            else:
                self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
        else:
            # Mini/Micro mode: try to use saved height for immediate correct size
            if self.mini_mode_state == 1:
                # Mini mode: use saved cover art height
                saved_mini_height = self.settings.get("mini_mode_saved_height")
                if saved_mini_height and isinstance(saved_mini_height, (int, float)) and saved_mini_height > 0:
                    # Use saved height for immediate correct size (will be refined when page loads)
                    window_padding = 0
                    if hasattr(self, 'title_bar') and self.title_bar:
                        window_padding += 30  # Estimate title bar height
                    if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                        window_padding += 40  # Estimate controls bar height
                    estimated_height = int(saved_mini_height) + window_padding
                    self.resize(WINDOW_DEFAULT_WIDTH, estimated_height)
                    logger.debug(f"Using saved mini mode height: {estimated_height}")
                else:
                    # No saved height, start with default (will resize when page loads)
                    self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            elif self.mini_mode_state == 2:
                # Micro mode: use saved player height
                saved_micro_height = self.settings.get("micro_mode_saved_height")
                if saved_micro_height and isinstance(saved_micro_height, (int, float)) and saved_micro_height > 0:
                    # Use saved height for immediate correct size (will be refined when page loads)
                    window_padding = 0
                    if hasattr(self, 'title_bar') and self.title_bar:
                        window_padding += 30  # Estimate title bar height
                    if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                        window_padding += 40  # Estimate controls bar height
                    estimated_height = int(saved_micro_height) + window_padding
                    self.resize(WINDOW_DEFAULT_WIDTH, estimated_height)
                    logger.debug(f"Using saved micro mode height: {estimated_height}")
                else:
                    # No saved height, start with default (will resize when page loads)
                    self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
        
        # No longer storing/loading original size - each mode uses fixed defaults
        # Regular mode: always WINDOW_DEFAULT_WIDTH x WINDOW_DEFAULT_HEIGHT
        # Mini/Micro modes: always WINDOW_DEFAULT_WIDTH, height calculated dynamically
        
        # Load saved mini mode height from settings
        saved_mini_height = self.settings.get("mini_mode_saved_height")
        if saved_mini_height and isinstance(saved_mini_height, (int, float)):
            self.mini_mode_cover_art_height = int(saved_mini_height)
        else:
            self.mini_mode_cover_art_height = None
        self.dev_tools_window = None
        self.dev_tools_page = None  # Store dev tools page reference for element inspection
        self.inspect_position = None  # Store position for element inspection
        self.title_bar = None  # Custom title bar for frameless mode
        self.volume_popup = None  # Volume control popup widget
        self.volume_hide_timer = None  # Timer for auto-hiding volume popup
        self.volume_popup_fade_animation = None  # Animation for fade in/out
        self._image_viewer_active = False  # Track if image viewer modal is active
        self._js_injected_on_current_page = False  # Track if JavaScript has been injected on current page
        self.is_loading = False  # Track loading state to prevent overlay flicker
        self._was_micro_mode = False  # Track if we were in micro mode (for proper restoration)
        self._original_context_menu_policy = None  # Store original context menu policy to restore after loading
        
        # Components - defer heavy initialization for faster startup
        # Store playlist file path but don't load yet (defer to deferred_init)
        self._current_playlist_file = self.settings.get("current_playlist_file")
        if self._current_playlist_file:
            # Verify the file exists, otherwise fallback to default
            playlist_path = Path(self._current_playlist_file)
            if not playlist_path.is_absolute():
                playlist_path = Path(__file__).parent / "Playlists" / playlist_path.name
            if not playlist_path.exists():
                logger.info(f"Saved playlist file {playlist_path} not found, using default")
                self._current_playlist_file = None
        
        # Create playlist manager but defer loading (faster startup)
        # Will be created in deferred_init, but create a minimal instance if needed early
        self.playlist_manager = None  # Will be created in deferred_init
        self._playlist_manager_initialized = False
        self.css_injector = CSSInjector()
        
        # Setup UI (minimal - defer heavy components)
        self.setup_ui()
        self.setup_web_view()
        # Defer menu setup until after window shows (faster startup)
        self._menu_setup_deferred = True
        # Defer system tray setup until after window shows (faster startup)
        self.tray_icon = None
        # Defer shortcuts setup (faster startup)
        self._shortcuts_setup_deferred = True
        # Defer settings application (faster startup)
        self._settings_applied = False
        
        # Enable drag and drop on the entire window
        self.setAcceptDrops(True)
        
        # Install event filter on central widget to catch drag/drop events
        central_widget = self.centralWidget()
        if central_widget:
            central_widget.installEventFilter(self)
        
        # Defer initial URL loading until after window shows (faster startup)
        self._initial_url_pending = None
        self._is_startup_load = False  # Flag to track if this is the initial startup URL load
        self._has_url_loaded = False  # Flag to track if any URL has been loaded
        self._update_check_done = False  # Flag to track if update check has been performed
        # Store last played URL for deferred loading
        self._last_played_url = self.settings.get("last_played_url")
    
    def _minimize_console_immediately(self):
        """Hide console window immediately at startup (like downloader does)."""
        try:
            if sys.platform == 'win32':
                import ctypes
                kernel32 = ctypes.windll.kernel32
                user32 = ctypes.windll.user32
                hwnd = kernel32.GetConsoleWindow()
                if hwnd:
                    launcher_mode = os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1'
                    if launcher_mode:
                        # In launcher mode, try to free console (may already be freed by launcher)
                        # If it fails, try minimizing as fallback
                        try:
                            kernel32.FreeConsole()
                        except Exception:
                            # If FreeConsole fails, minimize as fallback
                            user32.ShowWindow(hwnd, 6)  # SW_MINIMIZE = 6
                    else:
                        # Not in launcher mode, just minimize (safer for development)
                        # SW_MINIMIZE = 6 - minimizes to taskbar
                        user32.ShowWindow(hwnd, 6)
        except Exception:
            pass  # Silently fail if console hiding doesn't work
    
    def _ensure_playlist_manager(self):
        """Ensure playlist manager is initialized (lazy initialization)."""
        if not self._playlist_manager_initialized:
            if self.playlist_manager is None:
                self.playlist_manager = PlaylistManager(playlist_file=self._current_playlist_file)
            self._playlist_manager_initialized = True
    
    def deferred_init(self):
        """Deferred initialization - runs after window is shown for faster startup"""
        # Create playlist manager now (deferred from __init__ for faster startup)
        self._ensure_playlist_manager()
        
        # Setup menu now (deferred from __init__ for faster startup)
        if getattr(self, '_menu_setup_deferred', False):
            self.setup_menu()
            self._menu_setup_deferred = False
        
        # Setup shortcuts now (deferred from __init__ for faster startup)
        if getattr(self, '_shortcuts_setup_deferred', False):
            self.setup_shortcuts()
            self._shortcuts_setup_deferred = False
        
        # Apply settings now (deferred from __init__ for faster startup)
        if not getattr(self, '_settings_applied', False):
            self.apply_settings()
            self._settings_applied = True
        
        # If in mini/micro mode, apply CSS immediately (before window is shown)
        # This ensures the correct styling is applied from the start
        # However, on first launch, skip CSS injection here if no page is loaded yet
        # The CSS will be injected in on_page_loaded() after the page is ready
        if self.mini_mode_state != 0 and self.web_view:
            # Check if a page is already loaded (has a URL)
            # On first launch, no page is loaded yet, so skip injection here
            page_has_url = False
            if self.web_view.page():
                url = self.web_view.url()
                if url and url.toString() and url.toString() != 'about:blank':
                    page_has_url = True
            
            # Only inject CSS if a page is already loaded
            # On first launch, the page will be loaded later, and CSS will be injected in on_page_loaded()
            if page_has_url:
                # Inject CSS immediately so styling is correct when window appears
                self.inject_css()
            # Apply mini/micro mode settings (this will set up min/max sizes correctly)
            # Note: This is safe to call even on startup - it will handle the mode correctly
            self.apply_mini_mode()
            # Update UI to reflect the mode
            self.update_mini_mode_button()
            self.update_mini_mode_menu_text()
            # Note: Mini mode resize will be applied in on_page_loaded when page is ready
            # This ensures dimensions are available for accurate resizing
        
        # Show window now that geometry is restored (prevents flash)
        self.setVisible(True)
        self.show()
        
        # Setup media key listener after window is ready
        self.setup_media_key_listener()
        
        # Setup IPC server for AutoHotkey communication (named pipe)
        self.setup_ipc_server()
        
        # Setup system tray (non-critical, can be deferred)
        if self.tray_icon is None:
            self.setup_tray()
        
        # Load initial URL from playlist (deferred from __init__ for faster startup)
        if self._initial_url_pending is None:
            # Try to load last played URL from settings, otherwise use first in playlist
            playlist = self.playlist_manager.get_playlist()
            if self._last_played_url:
                # Verify last played URL is still in playlist (or allow it anyway for flexibility)
                if self._last_played_url in playlist or not playlist:
                    self._initial_url_pending = self._last_played_url
                elif playlist:
                    # Last played URL not in playlist, use first item instead
                    self._initial_url_pending = playlist[0]
            elif playlist:
                # No last played URL, use first in playlist
                self._initial_url_pending = playlist[0]
        
        # Restore playlist state from settings
        playlist_visible = self.settings.get("playlist_visible", True)  # Default to visible
        
        # Restore detached state if it was detached
        playlist_detached = self.settings.get("playlist_detached", False)
        if playlist_detached:
            # Set the detached flag immediately to prevent any reattachment
            self.playlist_detached = True
            self.playlist_detached_offset = self.settings.get("playlist_detached_offset", (20, 0))
            self.playlist_detached_position = self.settings.get("playlist_detached_position", None)
            self.playlist_detached_size = self.settings.get("playlist_detached_size", "260x400")
            # Restore link mode state
            self.playlist_window_linked = self.settings.get("playlist_window_linked", False)
            # If playlist was detached, we need to create it and detach it
            # Always restore detached state, regardless of visibility (detached window can be minimized)
            # Always set the restore flag so state is restored when playlist is first created
            self._restore_playlist_state_pending = True
            # Create playlist first, then detach it
            if self.playlist_sidebar is None:
                # Create playlist if it doesn't exist (will be created when toggled)
                if playlist_visible:
                    self.toggle_playlist()
                else:
                    # Even if not visible, we need to create it to detach it
                    # Create it hidden, then detach
                    self.toggle_playlist()
                    # Hide it after creation but before detaching
                    if self.playlist_sidebar:
                        self.playlist_sidebar.hide()
            else:
                self._restore_playlist_state()
            # Detach after a short delay to ensure playlist is fully created and initialized
            # Use a longer delay to ensure everything is ready
            def detach_on_startup():
                # Double-check that we should still be detached (in case something changed)
                if self.settings.get("playlist_detached", False):
                    self._detach_playlist()
                    # Ensure window is shown after detaching (with a small delay to allow window creation)
                    def ensure_window_shown():
                        if hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
                            self.detached_playlist_window.show()
                            self.detached_playlist_window.raise_()
                    QTimer.singleShot(100, ensure_window_shown)
            QTimer.singleShot(300, detach_on_startup)
            # Don't return early - we still need to load the initial URL!
            # Just skip the normal playlist restoration
        else:
            # Normal playlist restoration (not detached)
            # Always set the restore flag so state is restored when playlist is first created
            # This ensures that even if playlist is hidden, its state (height, minimized) is restored
            self._restore_playlist_state_pending = True
            
            # If playlist should be visible, create it now (it's lazy-loaded)
            if playlist_visible:
                # This will create the playlist if it doesn't exist
                if self.playlist_sidebar is None:
                    # Force creation - the restore function will be called automatically
                    # when the playlist is created (see toggle_playlist)
                    self.toggle_playlist()  # This creates the playlist and restores state if flag is set
                else:
                    # Playlist already exists, restore state directly
                    self._restore_playlist_state()
        
        # Check if we should start in nano mode
        # We'll activate it after the page loads (see on_page_loaded)
        start_in_nano = self.settings.get('start_in_nano_mode', False)
        if start_in_nano and self.nano_mode_on_minimize:
            # Set flag to activate nano mode after first page load
            self._activate_nano_after_page_load = True
        else:
            self._activate_nano_after_page_load = False
        
        # Load initial URL if pending (deferred for faster startup)
        # This must run regardless of whether playlist is detached or attached
        if self._initial_url_pending:
            url = self._initial_url_pending
            self._initial_url_pending = None
            # Explicitly pass is_startup_load=True to preserve the flag
            QTimer.singleShot(50, lambda: self.load_url(url, is_startup_load=True))
        else:
            # No URL to load - show welcome message
            if self.welcome_widget:
                self.welcome_widget.show()
                # Update title to indicate empty state
                QMainWindow.setWindowTitle(self, "Empty - Bandcamp Player")
                if self.window_title_label:
                    self.window_title_label.setText("Empty")

        # Keep playlist quick button in sync after startup restoration
        try:
            QTimer.singleShot(0, self.update_playlist_quick_btn_visibility)
        except Exception:
            pass
        
        # Update check will be performed after first URL loads (in on_page_loaded)
    
    def _restore_playlist_state(self):
        """Restore playlist state from settings (called after playlist is created)"""
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # If playlist was detached, don't restore attached playlist state (it will be in detached window)
        playlist_detached = self.settings.get("playlist_detached", False)
        if playlist_detached:
            # Skip restoration - playlist will be moved to detached window
            return
        
        playlist_visible = self.settings.get("playlist_visible", True)  # Default to visible
        # Prefer attached-specific minimized state if present (so detaching/reattaching doesn't lose it)
        playlist_minimized = self.settings.get("playlist_attached_minimized", self.settings.get("playlist_minimized", True))  # Default to minimized
        # Use attached height if available, otherwise use regular playlist_height
        playlist_height = self.settings.get('playlist_attached_height')
        if not playlist_height:
            playlist_height = self.settings.get("playlist_height", 250)
        
        # If playlist_height is 115px (micro mode height), restore from playlist_height_regular instead
        # This handles the case where app was closed in micro mode
        if playlist_height == 135:
            playlist_height_regular = self.settings.get("playlist_height_regular")
            if playlist_height_regular and playlist_height_regular != 135:
                playlist_height = playlist_height_regular
                logger.debug(f"Restoring playlist height from playlist_height_regular (was 115px): {playlist_height}")
            else:
                # No regular height saved, use default
                playlist_height = 250
                logger.debug(f"No playlist_height_regular found, using default: {playlist_height}")
        
        # Restore height first (before visibility/minimized state)
        playlist_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, playlist_height)))
        self.playlist_sidebar.setFixedHeight(playlist_height)
        if hasattr(self.playlist_sidebar, '_restore_height'):
            self.playlist_sidebar._restore_height = playlist_height
        
        # Restore visibility
        self.playlist_sidebar.setVisible(playlist_visible)
        if hasattr(self, 'playlist_resize_handle'):
            handle = self.playlist_resize_handle
            handle.setVisible(playlist_visible)
            # Set height to 0 when hidden to prevent taking up space
            if playlist_visible:
                handle.setFixedHeight(4)
            else:
                handle.setFixedHeight(0)
        if hasattr(self, 'playlist_btn'):
            self.playlist_btn.setChecked(playlist_visible)
            self._update_playlist_button_icon(playlist_visible)
        if hasattr(self, 'show_playlist_action'):
            self.show_playlist_action.setChecked(playlist_visible)
        
        # Restore minimized state (must be done after visibility is set)
        # Only toggle if the current state doesn't match the saved state
        if playlist_minimized != self.playlist_sidebar.is_minimized:
            # Use the internal method that doesn't require an event parameter
            self.playlist_sidebar._toggle_minimize_state()
        else:
            # Even if state matches, update button icon to reflect current state
            if hasattr(self.playlist_sidebar, 'minimize_btn'):
                # Always clear both icon and text first to prevent showing both
                self.playlist_sidebar.minimize_btn.setIcon(QIcon())
                self.playlist_sidebar.minimize_btn.setText("")
                
                if self.playlist_sidebar.is_minimized:
                    if HAS_QT_AWESOME:
                        icon = get_icon('ei.chevron-up', color='#e0e0e0')
                        if icon:
                            self.playlist_sidebar.minimize_btn.setIcon(icon)
                        else:
                            self.playlist_sidebar.minimize_btn.setText("")
                    else:
                        self.playlist_sidebar.minimize_btn.setText("")
                    self.playlist_sidebar.minimize_btn.setToolTip("Restore playlist")
                else:
                    if HAS_QT_AWESOME:
                        icon = get_icon('ei.chevron-down', color='#e0e0e0')
                        if icon:
                            self.playlist_sidebar.minimize_btn.setIcon(icon)
                        else:
                            self.playlist_sidebar.minimize_btn.setText("")
                    else:
                        self.playlist_sidebar.minimize_btn.setText("")
                    self.playlist_sidebar.minimize_btn.setToolTip("Minimize playlist")
        
        # If we're in micro mode and playlist was just restored, ensure it's minimized and trigger resize
        # This handles the first launch case where playlist is created after apply_mini_mode is called
        if hasattr(self, 'mini_mode_state') and self.mini_mode_state == 2:
            if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                # Playlist is visible but not minimized - minimize it for micro mode
                self.playlist_sidebar._toggle_minimize_state()
            # Force geometry update and trigger resize to ensure window accommodates minimized playlist
            self.playlist_sidebar.updateGeometry()
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.updateGeometry()
            layout = self.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            QApplication.processEvents()
            # Trigger resize after a short delay to ensure geometry is updated
            QTimer.singleShot(100, self.resize_to_micro_mode)
    
    def setup_ui(self):
        """Setup the main UI layout"""
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Enable drag and drop on central widget
        central_widget.setAcceptDrops(True)
        
        # Set background color for frameless mode (rounded corners handled by mask)
        if self.frameless_mode:
            central_widget.setStyleSheet("""
                QWidget {
                    background-color: rgb(21, 21, 21);
                }
            """)
        
        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        # Force alignment to top - prevent vertical centering
        layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        
        # Top controls bar - fixed at top (wrap in widget to prevent centering)
        self.controls_bar_widget = QWidget()
        self.controls_bar_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        # When autohide is enabled, make it overlay with semi-transparent background
        controls_bar_widget = self.controls_bar_widget  # Keep local reference for layout
        controls_bar = QHBoxLayout(controls_bar_widget)
        controls_bar.setContentsMargins(5, 5, 5, 5)
        controls_bar.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        
        # Store original style for controls bar (will be modified when autohide is enabled)
        self.controls_bar_original_style = None
        
        # Add stretch to push buttons to the right
        controls_bar.addStretch()
        
        # Always on Top button (Pin) - ORDER: 1
        self.always_on_top_btn = QPushButton()
        icon_color = '#4a90e2' if self.always_on_top else '#a0a0a0'
        if HAS_QT_AWESOME:
            icon = get_icon('thumbtack', color=icon_color)
            if icon:
                self.always_on_top_btn.setIcon(icon)
            else:
                self.always_on_top_btn.setText("")
        else:
            self.always_on_top_btn.setText("")
        self.always_on_top_btn.setFixedSize(30, 30)
        self.always_on_top_btn.setToolTip("Always on Top")
        self.always_on_top_btn.setCheckable(True)
        self.always_on_top_btn.setChecked(self.always_on_top)
        self.always_on_top_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #a0a0a0;
                border: none;
                font-size: 14px;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """)
        self.always_on_top_btn.clicked.connect(self.toggle_always_on_top)
        controls_bar.addWidget(self.always_on_top_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Autohide Top Nav button - ORDER: 2
        self.autohide_nav_btn = QPushButton()
        icon_color = '#4a90e2' if self.autohide_address_bar else '#a0a0a0'
        if HAS_QT_AWESOME:
            icon = get_icon('fa6s.eye', color=icon_color)
            if icon:
                self.autohide_nav_btn.setIcon(icon)
            else:
                self.autohide_nav_btn.setText("")
        else:
            self.autohide_nav_btn.setText("")
        self.autohide_nav_btn.setFixedSize(30, 30)
        self.autohide_nav_btn.setToolTip("Autohide Top Nav")
        self.autohide_nav_btn.setCheckable(True)
        self.autohide_nav_btn.setChecked(self.autohide_address_bar)
        self.autohide_nav_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #a0a0a0;
                border: none;
                font-size: 14px;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """)
        self.autohide_nav_btn.clicked.connect(self.toggle_autohide_address_bar)
        controls_bar.addWidget(self.autohide_nav_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Volume button - ORDER: 3
        self.volume_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('fa5s.volume-up', color='#e0e0e0')
            if icon:
                self.volume_btn.setIcon(icon)
            else:
                self.volume_btn.setText("")
        else:
            self.volume_btn.setText("")
        self.volume_btn.setMinimumWidth(30)
        self.volume_btn.setMaximumWidth(30)
        self.volume_btn.setToolTip("Volume")
        self.volume_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        self.volume_btn.clicked.connect(lambda: self.show_volume_control(auto_hide=True, delay_ms=1200))
        controls_bar.addWidget(self.volume_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Paste button - ORDER: 4
        paste_btn = QPushButton()
        set_icon_safe(paste_btn, 'paste', color='#e0e0e0', fallback_text="")
        paste_btn.setMinimumWidth(30)
        paste_btn.setMaximumWidth(30)
        paste_btn.setToolTip("Paste URL From Clipboard")
        paste_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 16px;
                font-weight: bold;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        paste_btn.clicked.connect(self.on_paste_url)
        controls_bar.addWidget(paste_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Playlist button - ORDER: 5
        self.playlist_btn = QPushButton()
        icon_color = '#a0a0a0'  # Default to light color (playlist hidden by default)
        if HAS_QT_AWESOME:
            # Use the original icon for the top nav (looks better at 30x30)
            icon = get_icon('mdi6.list-box', color=icon_color)
            if icon:
                self.playlist_btn.setIcon(icon)
            else:
                self.playlist_btn.setText("")        
        else:
            self.playlist_btn.setText("")
        self.playlist_btn.setFixedSize(30, 30)
        self.playlist_btn.setToolTip("Toggle Playlist")
        self.playlist_btn.setCheckable(True)
        self.playlist_btn.setChecked(False)  # Playlist is hidden by default
        self.playlist_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #a0a0a0;
                border: none;
                font-size: 14px;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """)
        self.playlist_btn.clicked.connect(self.toggle_playlist)
        controls_bar.addWidget(self.playlist_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Mini Mode button will be added to title bar instead
        # Create it here but don't add to controls bar
        # The button will be added to title bar in create_custom_title_bar
        if not hasattr(self, 'mini_mode_btn') or self.mini_mode_btn is None:
            self.mini_mode_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('square', color='#e0e0e0')
                if icon:
                    self.mini_mode_btn.setIcon(icon)
                else:
                    self.mini_mode_btn.setText("")  # Default icon (will be updated by update_mini_mode_button)
            else:
                self.mini_mode_btn.setText("")  # Default icon (will be updated by update_mini_mode_button)
            self.mini_mode_btn.setFixedSize(28, 30)
            self.mini_mode_btn.setToolTip("Mini Mode")
            self.mini_mode_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 0px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            self.mini_mode_btn.clicked.connect(self.toggle_mini_mode)
        # Update button visibility and state (will be added to title bar later)
        self.update_mini_mode_button()
        
        # Settings button
        menu_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('cog', color='#e0e0e0')
            if icon:
                menu_btn.setIcon(icon)
            else:
                menu_btn.setText("")
        else:
            menu_btn.setText("")
        menu_btn.setMinimumWidth(30)
        menu_btn.setMaximumWidth(30)
        menu_btn.setToolTip("Menu")
        menu_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 6px 8px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        menu_btn.clicked.connect(self.show_menu)
        controls_bar.addWidget(menu_btn, 0, Qt.AlignmentFlag.AlignVCenter)
        
        # Add controls bar widget at the top (fixed size, always at top)
        # When autohide is enabled, we'll make it overlay instead of being in layout
        self.controls_bar_in_layout = True
        layout.addWidget(controls_bar_widget, 0)  # Stretch factor 0 = no expansion
        
        # Create autohide trigger button (visible when address bar is hidden)
        self.autohide_trigger_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('mdi6.dots-horizontal', color='#b0b0b0')
            if icon:
                self.autohide_trigger_btn.setIcon(icon)
            else:
                self.autohide_trigger_btn.setText("")
        else:
            self.autohide_trigger_btn.setText("")
        self.autohide_trigger_btn.setFixedSize(24, 24)
        self.autohide_trigger_btn.setToolTip("Show Menu")
        self.autohide_trigger_btn.setParent(self)  # Parent to main window for absolute positioning
        self.autohide_trigger_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(21, 21, 21, 0.4);
                color: #b0b0b0;
                border: 1px solid rgba(176, 176, 176, 0.2);
                border-radius: 12px;
                font-size: 16px;
                padding: 0px;
            }
            QPushButton:hover {
                background-color: rgba(43, 43, 43, 0.7);
                border-color: rgba(176, 176, 176, 0.5);
                color: #e0e0e0;
            }
        """)
        self.autohide_trigger_btn.clicked.connect(self.show_address_bar_immediate)
        # Override enterEvent to show address bar on hover
        original_enter_event = self.autohide_trigger_btn.enterEvent
        def trigger_enter_event(event):
            if self.autohide_address_bar and not self.controls_bar_widget.isVisible():
                self.show_address_bar_immediate()
            if original_enter_event:
                original_enter_event(event)
        self.autohide_trigger_btn.enterEvent = trigger_enter_event
        self.autohide_trigger_btn.hide()  # Hidden by default, shown when address bar is hidden (will use fade when shown)
        self.autohide_trigger_btn.raise_()  # Ensure it's on top

        # Playlist quick button (bottom-right). Safe/isolated: no animations, no JS interaction.
        # Shows only when playlist is closed (and attached) in regular mode.
        self.playlist_quick_btn = QPushButton()
        if HAS_QT_AWESOME:
            # Match the top-nav playlist icon for consistency
            icon = get_icon('mdi6.list-box', color='#b0b0b0')
            if icon:
                self.playlist_quick_btn.setIcon(icon)
            else:
                self.playlist_quick_btn.setText("")
        else:
            self.playlist_quick_btn.setText("")
        self.playlist_quick_btn.setFixedSize(24, 24)
        self.playlist_quick_btn.setToolTip("Show Playlist")
        self.playlist_quick_btn.setParent(self)  # Absolute positioning
        self.playlist_quick_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(21, 21, 21, 0.4);
                color: #b0b0b0;
                border: 1px solid rgba(176, 176, 176, 0.2);
                border-radius: 12px;
                font-size: 14px;
                padding: 0px;
            }
            QPushButton:hover {
                background-color: rgba(43, 43, 43, 0.7);
                border-color: rgba(176, 176, 176, 0.5);
                color: #e0e0e0;
            }
        """)
        self.playlist_quick_btn.clicked.connect(self._on_playlist_quick_btn_clicked)
        self.playlist_quick_btn.hide()
        self.playlist_quick_btn.raise_()
        
        # Create welcome message widget (shown when no URL has been loaded)
        self.welcome_widget = QWidget()
        self.welcome_widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.welcome_widget.setStyleSheet("""
            QWidget {
                background-color: #212121;
            }
        """)
        welcome_layout = QVBoxLayout(self.welcome_widget)
        welcome_layout.setContentsMargins(20, 40, 20, 40)  # Reduced horizontal margins to prevent cutoff
        welcome_layout.setSpacing(20)
        welcome_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Welcome message (instructions only)
        welcome_message = QLabel("Drop a Bandcamp URL anywhere in this window or use the paste url button in the top menu to get started.")
        welcome_message.setAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignTop)  # Justified text alignment
        welcome_message.setWordWrap(True)
        welcome_message.setMaximumWidth(220)  # Constrain width to prevent cutoff (260px window - 40px margins)
        welcome_message.setStyleSheet("""
            QLabel {
                color: #b0b0b0;
                font-size: 14px;
                background-color: transparent;
                border: none;
                padding: 10px 5px;
                line-height: 1.5;
            }
        """)
        welcome_layout.addWidget(welcome_message)
        
        # Add welcome widget to layout (will be hidden when URL loads)
        layout.addWidget(self.welcome_widget, 1)  # Stretch factor 1 = takes available space
        # Initially hide welcome widget - will be shown in deferred_init if no URL is pending
        self.welcome_widget.hide()
        
        # Web view (will be added in setup_web_view)
        self.web_view = None
        
        # Loading overlay (will be added after web view is created)
        self.loading_overlay = None
        
        # Playlist sidebar (lazy-loaded - only create when first shown)
        self.playlist_sidebar = None
        self._restore_playlist_state_pending = False  # Flag to restore state when playlist is created
        
        # Keep old playlist_widget reference for backward compatibility
        self.playlist_widget = None
        
        # Update playlist display
        self.update_playlist_display()
        
        # Create bottom resize handle for frameless mode (will be shown/hidden based on frameless mode)
        self.bottom_resize_handle = None
        self.resize_start_y = None
        self.resize_start_height = None
        
        # Autohide address bar state (initialize timers before setup_autohide_address_bar)
        self.address_bar_hide_timer = QTimer(self)
        self.address_bar_hide_timer.setSingleShot(True)
        self.address_bar_hide_timer.timeout.connect(self.hide_address_bar)
        self.address_bar_show_timer = QTimer(self)
        self.address_bar_show_timer.setSingleShot(True)
        self.address_bar_show_timer.timeout.connect(self.show_address_bar)
        self.address_bar_animation = None
        
        # Animation for trigger button fade in/out
        self.trigger_btn_animation = None
        
        # Failsafe timer to ensure address bar always hides after no interaction
        self.address_bar_failsafe_timer = QTimer(self)
        self.address_bar_failsafe_timer.setSingleShot(True)
        self.address_bar_failsafe_timer.timeout.connect(self._failsafe_hide_address_bar)
        self.address_bar_failsafe_delay = 5000  # 5 seconds of no interaction
        
        # Mouse tracking timer to check if mouse is within address bar
        self.address_bar_mouse_tracker = QTimer(self)
        self.address_bar_mouse_tracker.timeout.connect(self.check_address_bar_mouse_position)
        self.address_bar_mouse_tracker.setInterval(100)  # Check every 100ms
        
        # Setup autohide address bar if enabled (after timers are initialized)
        self.setup_autohide_address_bar()
    
    def setup_autohide_address_bar(self):
        """Setup autohide address bar functionality"""
        if not hasattr(self, 'controls_bar_widget'):
            return
        
        # Create a hover area widget for backward compatibility (but disabled)
        # The full-width hover area is now disabled - only the icon acts as hotspot
        self.address_bar_hover_area = QWidget(self)
        # Hover area is always 10px at the very top (consistent across all modes)
        hover_height = 10
        self.address_bar_hover_area.setFixedHeight(hover_height)
        self.address_bar_hover_area.setStyleSheet("background-color: transparent;")
        # Always make it transparent for mouse events - disabled functionality
        self.address_bar_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        self.address_bar_hover_area.hide()  # Always hidden - no longer used
        
        # Position hover area function (disabled - kept for backward compatibility)
        def update_hover_area_position():
            # Hover area is now disabled - always keep it hidden and transparent
            if hasattr(self, 'address_bar_hover_area') and self.address_bar_hover_area:
                self.address_bar_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
                self.address_bar_hover_area.hide()
        
        # No longer need to set up event handlers for hover area - it's disabled
        # The icon (autohide_trigger_btn) handles all hover/click interactions now
        
        # Mouse enter/leave events for controls bar
        # When mouse enters the controls bar itself, show it (if autohide is enabled)
        # BUT in all modes, only show when hovering over the trigger button
        def controls_bar_enter(event):
            if self.autohide_address_bar:
                # In all modes (including regular), don't show on enter - only show on trigger button hover
                # The address bar should only show when hovering over the trigger button
                return
        
        def controls_bar_leave(event):
            """Only hide if mouse is truly outside the address bar bounds and trigger icon"""
            if not self.autohide_address_bar:
                return
            
            # Use a small delay to check if mouse moved to a child widget
            # This prevents hiding when moving between buttons/input field
            def check_and_hide():
                if not self.autohide_address_bar:
                    return
                # Get current global mouse position
                global_pos = QCursor.pos()
                # Convert to window coordinates
                window_pos = self.mapFromGlobal(global_pos)
                
                # Check if mouse is over the trigger icon
                if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
                    if self.autohide_trigger_btn.geometry().contains(window_pos):
                        # Mouse is over trigger icon, don't hide
                        return
                
                # Check if mouse is within address bar geometry
                if self.controls_bar_widget.geometry().contains(window_pos):
                    # Mouse is still within address bar, don't hide
                    return
                # Mouse has truly left both the address bar and trigger icon area
                self.schedule_address_bar_hide()
            
            # Small delay to allow mouse to move to child widgets
            QTimer.singleShot(100, check_and_hide)
        
        self.controls_bar_widget.enterEvent = controls_bar_enter
        self.controls_bar_widget.leaveEvent = controls_bar_leave
        
        # Install event filter on controls bar to catch mouse movements within it
        self.controls_bar_widget.installEventFilter(self)
        
        # Show address bar when URL input gets focus (via event filter)
        # This is handled in the existing eventFilter method
        
        # Apply initial state
        if self.autohide_address_bar:
            # Make address bar overlay
            QTimer.singleShot(100, self.make_address_bar_overlay)
            # Start mouse tracking
            self.address_bar_mouse_tracker.start()
            # Hide initially after a short delay
            QTimer.singleShot(600, self.schedule_address_bar_hide)
            # Start failsafe timer after initial delay
            QTimer.singleShot(600 + self.address_bar_failsafe_delay, self._reset_address_bar_failsafe_timer)
        else:
            # Always show if autohide is disabled
            self.show_address_bar_immediate()
            # Stop failsafe timer if autohide is disabled
            self.address_bar_failsafe_timer.stop()
        
        # Store update function for later use (now a no-op, kept for compatibility)
        self.update_hover_area_position = update_hover_area_position
    
    def schedule_address_bar_hide(self, delay=150):
        """Schedule address bar to hide after delay (default 150ms)"""
        if not self.autohide_address_bar:
            return
        self.address_bar_hide_timer.stop()
        self.address_bar_hide_timer.start(delay)
        # Also start failsafe timer as backup
        self._reset_address_bar_failsafe_timer()
    
    def cancel_address_bar_hide(self):
        """Cancel scheduled address bar hide"""
        self.address_bar_hide_timer.stop()
        # Reset failsafe timer on any interaction
        self._reset_address_bar_failsafe_timer()
    
    def hide_address_bar(self):
        """Hide the address bar with smooth fade animation"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Stop failsafe timer since we're hiding normally
        self.address_bar_failsafe_timer.stop()
        
        # Stop any existing animation
        if self.address_bar_animation:
            self.address_bar_animation.stop()
        
        # Create smooth fade out animation
        effect = QGraphicsOpacityEffect(self.controls_bar_widget)
        self.controls_bar_widget.setGraphicsEffect(effect)
        
        self.address_bar_animation = QPropertyAnimation(effect, b"opacity")
        self.address_bar_animation.setDuration(250)  # Smooth fade - 250ms
        self.address_bar_animation.setStartValue(1.0)
        self.address_bar_animation.setEndValue(0.0)
        self.address_bar_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)  # Very smooth easing curve
        
        # Start trigger button fade-in immediately (at the same time as address bar fade-out)
        # This prevents the "pop in" effect by making it appear smoothly as the nav bar fades
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
            self.show_trigger_button(animated=True)
        
        def on_animation_finished():
            self.controls_bar_widget.hide()
            self.controls_bar_widget.setGraphicsEffect(None)
            self.address_bar_animation = None
            # Show hover area when address bar is hidden
            if hasattr(self, 'update_hover_area_position'):
                self.update_hover_area_position()
            # Update overlay position in case window was resized
            if hasattr(self, 'update_address_bar_overlay_position'):
                self.update_address_bar_overlay_position()
        
        self.address_bar_animation.finished.connect(on_animation_finished)
        self.address_bar_animation.start()
    
    def _reset_address_bar_failsafe_timer(self):
        """Reset the failsafe timer that ensures address bar hides after no interaction"""
        if not self.autohide_address_bar:
            self.address_bar_failsafe_timer.stop()
            return
        
        # Only start failsafe timer if address bar is visible
        if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget.isVisible():
            self.address_bar_failsafe_timer.stop()
            self.address_bar_failsafe_timer.start(self.address_bar_failsafe_delay)
        else:
            self.address_bar_failsafe_timer.stop()
    
    def _failsafe_hide_address_bar(self):
        """Failsafe function to force hide address bar if it's stuck visible"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Only force hide if address bar is actually visible
        if self.controls_bar_widget.isVisible():
            logger.debug("Failsafe: Force hiding stuck address bar")
            self.hide_address_bar()
    
    def show_address_bar_immediate(self):
        """Show the address bar immediately (no animation)"""
        if not hasattr(self, 'controls_bar_widget'):
            return
        
        self.cancel_address_bar_hide()
        
        # Stop any existing animation
        if self.address_bar_animation:
            self.address_bar_animation.stop()
            self.address_bar_animation = None
        
        # Hide hover area when showing address bar (always hidden now, but keep for compatibility)
        if hasattr(self, 'address_bar_hover_area') and self.address_bar_hover_area:
            self.address_bar_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self.address_bar_hover_area.hide()
        
        # Reset failsafe timer when showing address bar
        self._reset_address_bar_failsafe_timer()
        
        # Update overlay position if in overlay mode
        if self.autohide_address_bar and hasattr(self, 'update_address_bar_overlay_position'):
            self.update_address_bar_overlay_position()
        
        # Show and make fully opaque
        self.controls_bar_widget.show()
        self.controls_bar_widget.setGraphicsEffect(None)
        self.controls_bar_widget.setWindowOpacity(1.0)
        self.controls_bar_widget.raise_()  # Ensure it's on top
        
        # Hide trigger button when address bar is shown (with fade out)
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
            self.hide_trigger_button(animated=True)
    
    def show_address_bar(self):
        """Show the address bar with smooth fade animation"""
        if not hasattr(self, 'controls_bar_widget'):
            return
        
        self.cancel_address_bar_hide()
        
        # Stop any existing animation
        if self.address_bar_animation:
            self.address_bar_animation.stop()
        
        # Hide hover area when showing address bar (always hidden now, but keep for compatibility)
        if hasattr(self, 'address_bar_hover_area') and self.address_bar_hover_area:
            self.address_bar_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self.address_bar_hover_area.hide()
        
        # Update overlay position if in overlay mode
        if self.autohide_address_bar and hasattr(self, 'update_address_bar_overlay_position'):
            self.update_address_bar_overlay_position()
        
        # Show widget first
        self.controls_bar_widget.show()
        self.controls_bar_widget.raise_()  # Ensure it's on top
        
        # Create smooth fade in animation
        effect = QGraphicsOpacityEffect(self.controls_bar_widget)
        self.controls_bar_widget.setGraphicsEffect(effect)
        effect.setOpacity(0.0)
        
        self.address_bar_animation = QPropertyAnimation(effect, b"opacity")
        self.address_bar_animation.setDuration(250)  # Smooth fade - 250ms
        self.address_bar_animation.setStartValue(0.0)
        self.address_bar_animation.setEndValue(1.0)
        self.address_bar_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)  # Very smooth easing curve
        
        def on_animation_finished():
            self.controls_bar_widget.setGraphicsEffect(None)
            self.address_bar_animation = None
        
        self.address_bar_animation.finished.connect(on_animation_finished)
        self.address_bar_animation.start()
    
    def toggle_autoplay(self):
        """Toggle autoplay setting"""
        self.autoplay = not self.autoplay
        self.autoplay_action.setChecked(self.autoplay)
        self.save_settings()
    
    def toggle_autoplay_on_startup(self):
        """Toggle autoplay on startup setting"""
        self.autoplay_on_startup = not self.autoplay_on_startup
        self.autoplay_on_startup_action.setChecked(self.autoplay_on_startup)
        self.save_settings()
    
    def toggle_autohide_address_bar(self):
        """Toggle autohide address bar"""
        self.autohide_address_bar = not self.autohide_address_bar
        # Update top nav button state and icon color
        if hasattr(self, 'autohide_nav_btn'):
            self.autohide_nav_btn.setChecked(self.autohide_address_bar)
            # Update icon color based on checked state (light when off, blue when on)
            if HAS_QT_AWESOME:
                icon_color = '#4a90e2' if self.autohide_address_bar else '#a0a0a0'
                icon = get_icon('fa6s.eye', color=icon_color)
                if icon:
                    self.autohide_nav_btn.setIcon(icon)
        
        if self.autohide_address_bar:
            # Enable autohide - make address bar overlay
            self.make_address_bar_overlay()
            # Start mouse tracking
            self.address_bar_mouse_tracker.start()
            # Schedule hide after delay
            QTimer.singleShot(600, self.schedule_address_bar_hide)
            # Start failsafe timer
            QTimer.singleShot(600 + self.address_bar_failsafe_delay, self._reset_address_bar_failsafe_timer)
        else:
            # Disable autohide - stop mouse tracking
            self.address_bar_mouse_tracker.stop()
            # Stop failsafe timer
            self.address_bar_failsafe_timer.stop()
            # Hide trigger button
            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
                self.hide_trigger_button(animated=False)
            # Restore to normal layout
            self.restore_address_bar_to_layout()
            # Show immediately and cancel any hide timers
            self.cancel_address_bar_hide()
            self.show_address_bar_immediate()
        
        self.save_settings()
        
        # If in mini or micro mode, resize to account for address bar autohide change
        if self.mini_mode_state == 1:
            QTimer.singleShot(100, self.resize_to_mini_mode)
        elif self.mini_mode_state == 2:
            QTimer.singleShot(100, self.resize_to_micro_mode)
    
    def toggle_nano_mode_on_minimize(self):
        """Toggle nano mode on minimize setting"""
        self.nano_mode_on_minimize = not self.nano_mode_on_minimize
        self.save_settings()
    
    def toggle_mini_mode_player_autohide(self):
        """Toggle mini mode player autohide - toggles between Visible and Autohide only"""
        # Fully hidden mode removed
        self.mini_mode_player_hidden = False
        
        # Toggle autohide
        self.mini_mode_player_autohide = not self.mini_mode_player_autohide
        self.mini_mode_player_autohide_action.setChecked(self.mini_mode_player_autohide)
        
        # Update the CSS class on the body element via JavaScript
        if self.web_view and self.web_view.page():
            js_code = f"""
            (function() {{
                if (document.body) {{
                    var isAutohide = {'true' if self.mini_mode_player_autohide else 'false'};
                    if (isAutohide) {{
                        document.body.classList.add('mini-mode-autohide');
                        // Set player to visible when autohide is enabled
                        document.body.classList.remove('mini-mode-player-hidden');
                        
                        // Setup hover event listeners for autohide
                        function setupAutohideHover() {{
                            var player = document.querySelector('#player');
                            if (player) {{
                                // Remove existing setup attribute to allow re-setup
                                player.removeAttribute('data-autohide-setup');
                                
                                if (!player.hasAttribute('data-autohide-setup')) {{
                                    player.setAttribute('data-autohide-setup', 'true');
                                    
                                    // Add hover class on mouseenter
                                    player.addEventListener('mouseenter', function() {{
                                        player.classList.add('player-hovered');
                                    }});
                                    
                                    // Remove hover class on mouseleave
                                    player.addEventListener('mouseleave', function() {{
                                        player.classList.remove('player-hovered');
                                    }});
                                }}
                            }}
                        }}
                        
                        // Setup immediately
                        setupAutohideHover();
                        
                        // Also setup when player is added dynamically
                        if (typeof MutationObserver !== 'undefined') {{
                            var observer = new MutationObserver(function(mutations) {{
                                setupAutohideHover();
                            }});
                            observer.observe(document.body, {{
                                childList: true,
                                subtree: true
                            }});
                        }}
                    }} else {{
                        document.body.classList.remove('mini-mode-autohide');
                        
                        // Remove hover class if autohide is disabled
                        var player = document.querySelector('#player');
                        if (player) {{
                            player.classList.remove('player-hovered');
                            player.removeAttribute('data-autohide-setup');
                        }}
                    }}
                    
                    // Update button icon to reflect current state
                    var toggleBtn = document.getElementById('bandcamp-player-visibility-toggle');
                    if (toggleBtn) {{
                        var isAutohideState = document.body.classList.contains('mini-mode-autohide');
                        if (isAutohideState) {{
                            toggleBtn.textContent = '';
                        }} else {{
                            toggleBtn.textContent = '';
                        }}
                    }}
                }}
            }})();
            """
            self.web_view.page().runJavaScript(js_code)
        
        self.save_settings()
    
    def toggle_mini_mode_player_visibility(self):
        """Deprecated: previously cycled 3 states; now toggles Visible  Autohide."""
        self.toggle_mini_mode_player_autohide()
        
        # Update menu action state
        self.mini_mode_player_autohide_action.setChecked(self.mini_mode_player_autohide)
        
        # Update the CSS class on the body element via JavaScript
        if self.web_view and self.web_view.page():
            js_code = f"""
            (function() {{
                if (document.body) {{
                    // Update autohide class
                    var isAutohide = {'true' if self.mini_mode_player_autohide else 'false'};
                    if (isAutohide) {{
                        document.body.classList.add('mini-mode-autohide');
                        
                        // Setup hover event listeners for autohide
                        function setupAutohideHover() {{
                            var player = document.querySelector('#player');
                            if (player) {{
                                // Remove existing setup attribute to allow re-setup
                                player.removeAttribute('data-autohide-setup');
                                
                                // Remove any existing listeners by cloning the element
                                // (This is a workaround - in a real app you'd store references)
                                if (!player.hasAttribute('data-autohide-setup')) {{
                                    player.setAttribute('data-autohide-setup', 'true');
                                    
                                    // Add hover class on mouseenter
                                    player.addEventListener('mouseenter', function() {{
                                        player.classList.add('player-hovered');
                                    }});
                                    
                                    // Remove hover class on mouseleave
                                    player.addEventListener('mouseleave', function() {{
                                        player.classList.remove('player-hovered');
                                    }});
                                }}
                            }}
                        }}
                        
                        // Setup immediately
                        setupAutohideHover();
                        
                        // Also setup when player is added dynamically
                        if (typeof MutationObserver !== 'undefined') {{
                            var observer = new MutationObserver(function(mutations) {{
                                setupAutohideHover();
                            }});
                            observer.observe(document.body, {{
                                childList: true,
                                subtree: true
                            }});
                        }}
                    }} else {{
                        document.body.classList.remove('mini-mode-autohide');
                        
                        // Remove hover class if autohide is disabled
                        var player = document.querySelector('#player');
                        if (player) {{
                            player.classList.remove('player-hovered');
                            player.removeAttribute('data-autohide-setup');
                        }}
                    }}
                    
                    // Hidden mode removed
                    document.body.classList.remove('mini-mode-player-hidden');
                    
                    // Update toggle button icon to reflect current state
                    // Ensure button is visible in mini mode
                    var toggleBtn = document.getElementById('bandcamp-player-visibility-toggle');
                    if (toggleBtn) {{
                        var isAutohideState = document.body.classList.contains('mini-mode-autohide');
                        if (isAutohideState) {{
                            toggleBtn.textContent = '';
                        }} else {{
                            toggleBtn.textContent = '';
                        }}
                        // Ensure button is visible in mini mode (not micro mode)
                        if (document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {{
                            toggleBtn.style.display = 'flex';
                            toggleBtn.style.visibility = 'visible';
                            toggleBtn.style.opacity = '1';
                            toggleBtn.style.pointerEvents = 'auto';
                        }}
                    }}
                }}
            }})();
            """
            self.web_view.page().runJavaScript(js_code)
        
        self.save_settings()
    
    def check_address_bar_mouse_position(self):
        """Check if mouse is over trigger button or address bar and keep it visible if so"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Get current global mouse position
        global_pos = QCursor.pos()
        # Convert to window coordinates
        window_pos = self.mapFromGlobal(global_pos)
        
        # Check if mouse is over the trigger button (only way to show hidden address bar)
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
            if self.autohide_trigger_btn.geometry().contains(window_pos):
                # Mouse is over trigger button, show address bar
                self.cancel_address_bar_hide()
                if not self.controls_bar_widget.isVisible():
                    self.show_address_bar_immediate()
                return
        
        # Only check address bar geometry if it's already visible (to keep it visible)
        # Don't show it just because mouse is in that area - only the icon can trigger showing
        if self.controls_bar_widget.isVisible() and self.controls_bar_widget.geometry().contains(window_pos):
            # Mouse is within visible address bar, cancel any hide timer and keep it visible
            self.cancel_address_bar_hide()
    
    def check_and_hide_address_bar_after_menu(self):
        """Check if mouse is outside address bar after menu closes and hide if so"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Get current global mouse position
        global_pos = QCursor.pos()
        # Convert to window coordinates
        window_pos = self.mapFromGlobal(global_pos)
        # Check if mouse is within address bar geometry
        if not self.controls_bar_widget.geometry().contains(window_pos):
            # Mouse is outside address bar, schedule hide
            self.schedule_address_bar_hide()
    
    def check_and_hide_address_bar_after_drag(self):
        """Check if mouse is outside address bar after drag ends and hide if so"""
        if not self.autohide_address_bar or not hasattr(self, 'controls_bar_widget'):
            return
        
        # Don't hide if we're still dragging
        if hasattr(self, 'playlist_start_resize_y') and self.playlist_start_resize_y is not None:
            return
        
        # Get current global mouse position
        global_pos = QCursor.pos()
        # Convert to window coordinates
        window_pos = self.mapFromGlobal(global_pos)
        # Check if mouse is within address bar geometry
        if not self.controls_bar_widget.geometry().contains(window_pos):
            # Also check if mouse is over the trigger icon
            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
                if not self.autohide_trigger_btn.geometry().contains(window_pos):
                    # Mouse is outside both address bar and trigger icon, schedule hide
                    self.schedule_address_bar_hide()
            else:
                # Mouse is outside address bar and no trigger icon visible, schedule hide
                self.schedule_address_bar_hide()
    
    def make_address_bar_overlay(self):
        """Make address bar overlay the content (semi-transparent, absolute positioning)"""
        if not hasattr(self, 'controls_bar_widget') or not self.controls_bar_widget:
            return
        
        # Store original style if not already stored
        if self.controls_bar_original_style is None:
            self.controls_bar_original_style = self.controls_bar_widget.styleSheet()
        
        # Remove from layout if it's in layout
        if self.controls_bar_in_layout:
            layout = self.centralWidget().layout()
            if layout:
                layout.removeWidget(self.controls_bar_widget)
            self.controls_bar_in_layout = False
        
        # Make it overlay with semi-transparent background
        self.controls_bar_widget.setParent(self)
        self.controls_bar_widget.setStyleSheet("""
            QWidget {
                background-color: rgba(21, 21, 21, 0.85);
                border: none;
            }
            QLineEdit {
                background-color: rgba(43, 43, 43, 0.9);
            }
            QPushButton {
                background-color: transparent;
            }
            QPushButton:hover {
                background-color: rgba(58, 58, 58, 0.8);
            }
        """)
        
        # Position absolutely at top
        self.update_address_bar_overlay_position()
        
        # Raise above web view
        self.controls_bar_widget.raise_()
        self.controls_bar_widget.show()
    
    def restore_address_bar_to_layout(self):
        """Restore address bar to normal layout (not overlay)"""
        if not hasattr(self, 'controls_bar_widget') or not self.controls_bar_widget:
            return
        
        # Add back to layout if not already there
        if not self.controls_bar_in_layout:
            # Get the central widget layout
            layout = self.centralWidget().layout()
            if layout:
                # Remove from window parent first (if it's a child of the window)
                if self.controls_bar_widget.parent() == self:
                    self.controls_bar_widget.setParent(None)
                
                # Find the correct position (after title bar if it exists, otherwise at position 0)
                insert_position = 0
                if self.title_bar and self.title_bar.isVisible():
                    # Find title bar index
                    for i in range(layout.count()):
                        item = layout.itemAt(i)
                        if item and item.widget() == self.title_bar:
                            insert_position = i + 1
                            break
                
                # Insert at correct position
                layout.insertWidget(insert_position, self.controls_bar_widget, 0)
            else:
                # If no layout, set parent to central widget
                self.controls_bar_widget.setParent(self.centralWidget())
            
            self.controls_bar_in_layout = True
        
        # Restore original style
        if self.controls_bar_original_style:
            self.controls_bar_widget.setStyleSheet(self.controls_bar_original_style)
        else:
            self.controls_bar_widget.setStyleSheet("")
        
        # Ensure it's visible and properly positioned (not absolutely positioned)
        self.controls_bar_widget.show()
        # Don't call raise_() here as it's in the layout now, not an overlay
    
    def update_address_bar_overlay_position(self):
        """Update address bar overlay position"""
        if not hasattr(self, 'controls_bar_widget') or not self.controls_bar_widget:
            return
        
        if not self.autohide_address_bar or self.controls_bar_in_layout:
            return
        
        # Calculate top offset (title bar if visible)
        top_offset = 0
        if self.title_bar and self.title_bar.isVisible():
            top_offset = self.title_bar.height()
        
        # Get controls bar height
        controls_bar_height = self.controls_bar_widget.sizeHint().height()
        if controls_bar_height <= 0:
            controls_bar_height = 40  # Default height
        
        # Position absolutely at top
        self.controls_bar_widget.setGeometry(0, top_offset, self.width(), controls_bar_height)
        self.controls_bar_widget.raise_()
    
    def update_autohide_trigger_position(self):
        """Update autohide trigger button position (always top right in all modes)"""
        if not hasattr(self, 'autohide_trigger_btn') or not self.autohide_trigger_btn:
            return
        
        if not self.autohide_address_bar:
            return
        
        # Calculate top offset (title bar if visible)
        top_offset = 0
        if self.title_bar and self.title_bar.isVisible():
            top_offset = self.title_bar.height()
        
        button_size = 24
        y_pos = top_offset + 3  # Small offset from top
        
        # Always position at top right in all modes
        x_pos = self.width() - button_size - 5  # Small margin from right edge
        
        self.autohide_trigger_btn.setGeometry(x_pos, y_pos, button_size, button_size)
        self.autohide_trigger_btn.raise_()

    def update_playlist_quick_btn_position(self):
        """Update playlist quick button position (bottom right)."""
        if not hasattr(self, 'playlist_quick_btn') or not self.playlist_quick_btn:
            return

        button_size = 24
        x_pos = self.width() - button_size - 5

        # Avoid overlapping the bottom resize handle if present/visible
        bottom_offset = 0
        try:
            if self.frameless_mode and hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle and self.bottom_resize_handle.isVisible():
                bottom_offset = self.bottom_resize_handle.height()
        except Exception:
            bottom_offset = 0

        y_pos = self.height() - button_size - 5 - bottom_offset
        if y_pos < 0:
            y_pos = 0

        self.playlist_quick_btn.setGeometry(x_pos, y_pos, button_size, button_size)
        self.playlist_quick_btn.raise_()

    def update_playlist_quick_btn_visibility(self):
        """Show/hide the bottom-right playlist quick button based on current app state (safe)."""
        if not hasattr(self, 'playlist_quick_btn') or not self.playlist_quick_btn:
            return

        try:
            # Only in regular mode
            if getattr(self, 'mini_mode_state', 0) != 0:
                self.playlist_quick_btn.hide()
                return

            # Only when playlist is attached (not detached)
            if getattr(self, 'playlist_detached', False):
                self.playlist_quick_btn.hide()
                return

            # Show only when playlist is closed/hidden
            playlist_closed = True
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                playlist_closed = not self.playlist_sidebar.isVisible()

            if playlist_closed:
                self.update_playlist_quick_btn_position()
                self.playlist_quick_btn.show()
                self.playlist_quick_btn.raise_()
            else:
                self.playlist_quick_btn.hide()
        except Exception:
            # Never crash the app due to a helper UI button
            try:
                self.playlist_quick_btn.hide()
            except Exception:
                pass

    def _on_playlist_quick_btn_clicked(self):
        """Open the attached playlist from the bottom-right quick button (safe)."""
        try:
            # Hide immediately to avoid flashing above the opening playlist
            if hasattr(self, 'playlist_quick_btn') and self.playlist_quick_btn:
                self.playlist_quick_btn.hide()

            if getattr(self, 'mini_mode_state', 0) != 0:
                return
            if getattr(self, 'playlist_detached', False):
                return

            # Ensure first click works even when playlist is lazy-created and restore is pending.
            if hasattr(self, 'playlist_btn') and self.playlist_btn:
                self.playlist_btn.setChecked(True)
                self._update_playlist_button_icon(True)
            if hasattr(self, 'show_playlist_action') and self.show_playlist_action:
                self.show_playlist_action.setChecked(True)

            # Only open if currently closed
            if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar or (not self.playlist_sidebar.isVisible()):
                self.toggle_playlist()

            # Recompute visibility after state changes
            self.update_playlist_quick_btn_visibility()
        except Exception:
            pass
    
    def show_trigger_button(self, animated=True):
        """Show trigger button with fade in animation"""
        if not hasattr(self, 'autohide_trigger_btn') or not self.autohide_trigger_btn:
            return
        
        # Check if widget is still valid (not deleted)
        try:
            # Try to access widget properties to verify it's still valid
            _ = self.autohide_trigger_btn.isVisible()
        except RuntimeError:
            # Widget has been deleted - can't show it
            logger.debug("Trigger button widget has been deleted, skipping show")
            return
        
        # Don't show if image viewer is active
        if hasattr(self, '_image_viewer_active') and self._image_viewer_active:
            return
        
        self.update_autohide_trigger_position()
        
        # Stop any existing animation and clean up any existing effect
        if self.trigger_btn_animation:
            try:
                self.trigger_btn_animation.stop()
            except RuntimeError:
                pass  # Animation or effect already deleted
            self.trigger_btn_animation = None
        
        # Clean up any existing graphics effect
        try:
            existing_effect = self.autohide_trigger_btn.graphicsEffect()
            if existing_effect:
                self.autohide_trigger_btn.setGraphicsEffect(None)
        except RuntimeError:
            pass  # Widget or effect already deleted
        
        if animated:
            try:
                # Verify widget is still valid before creating effect
                if not self.autohide_trigger_btn:
                    return
                
                # Create fade in animation with fresh effect
                effect = QGraphicsOpacityEffect(self.autohide_trigger_btn)
                # Store effect reference to prevent garbage collection
                self._trigger_btn_effect = effect
                self.autohide_trigger_btn.setGraphicsEffect(effect)
                effect.setOpacity(0.0)
                
                # Verify effect is still valid before creating animation
                if not effect or not self.autohide_trigger_btn:
                    return
                
                self.autohide_trigger_btn.show()
                self.autohide_trigger_btn.raise_()
                
                # Create animation with effect - verify effect is still valid
                try:
                    self.trigger_btn_animation = QPropertyAnimation(effect, b"opacity")
                    self.trigger_btn_animation.setDuration(250)  # Same duration as address bar fade
                    self.trigger_btn_animation.setStartValue(0.0)
                    self.trigger_btn_animation.setEndValue(1.0)
                    self.trigger_btn_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)
                    
                    def on_animation_finished():
                        try:
                            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
                                self.autohide_trigger_btn.setGraphicsEffect(None)
                            if hasattr(self, '_trigger_btn_effect'):
                                self._trigger_btn_effect = None
                        except RuntimeError:
                            pass  # Widget already deleted
                        self.trigger_btn_animation = None
                    
                    self.trigger_btn_animation.finished.connect(on_animation_finished)
                    self.trigger_btn_animation.start()
                except RuntimeError as anim_error:
                    # Effect was deleted before animation could be created
                    logger.debug(f"Error creating trigger button animation: {anim_error}, falling back to non-animated")
                    try:
                        self.autohide_trigger_btn.setGraphicsEffect(None)
                        self._trigger_btn_effect = None
                        self.autohide_trigger_btn.show()
                        self.autohide_trigger_btn.raise_()
                    except RuntimeError:
                        pass  # Widget already deleted
            except RuntimeError as e:
                # Widget or effect was deleted during setup - fall back to non-animated show
                logger.debug(f"Error creating trigger button animation: {e}, falling back to non-animated")
                try:
                    if hasattr(self, '_trigger_btn_effect'):
                        self._trigger_btn_effect = None
                    if self.autohide_trigger_btn:
                        self.autohide_trigger_btn.show()
                        self.autohide_trigger_btn.raise_()
                        self.autohide_trigger_btn.setGraphicsEffect(None)
                except RuntimeError:
                    pass  # Widget already deleted
        else:
            # Show immediately without animation
            try:
                self.autohide_trigger_btn.show()
                self.autohide_trigger_btn.raise_()
                self.autohide_trigger_btn.setGraphicsEffect(None)
            except RuntimeError:
                pass  # Widget already deleted
    
    def hide_trigger_button(self, animated=True):
        """Hide trigger button with fade out animation"""
        if not hasattr(self, 'autohide_trigger_btn') or not self.autohide_trigger_btn:
            return
        
        # Check if widget is still valid (not deleted)
        try:
            is_visible = self.autohide_trigger_btn.isVisible()
        except RuntimeError:
            # Widget has been deleted - can't hide it
            logger.debug("Trigger button widget has been deleted, skipping hide")
            return
        
        # Stop any existing animation and clean up any existing effect
        if self.trigger_btn_animation:
            try:
                self.trigger_btn_animation.stop()
            except RuntimeError:
                pass  # Animation or effect already deleted
            self.trigger_btn_animation = None
        
        # Clean up any existing graphics effect
        try:
            existing_effect = self.autohide_trigger_btn.graphicsEffect()
            if existing_effect:
                self.autohide_trigger_btn.setGraphicsEffect(None)
        except RuntimeError:
            pass  # Widget or effect already deleted
        
        if animated and is_visible:
            try:
                # Verify widget is still valid before creating effect
                if not self.autohide_trigger_btn:
                    return
                
                # Create fade out animation with fresh effect
                effect = QGraphicsOpacityEffect(self.autohide_trigger_btn)
                # Store effect reference to prevent garbage collection
                self._trigger_btn_effect = effect
                self.autohide_trigger_btn.setGraphicsEffect(effect)
                effect.setOpacity(1.0)
                
                # Verify effect is still valid before creating animation
                if not effect or not self.autohide_trigger_btn:
                    return
                
                # Create animation with effect - verify effect is still valid
                try:
                    self.trigger_btn_animation = QPropertyAnimation(effect, b"opacity")
                    self.trigger_btn_animation.setDuration(250)  # Same duration as address bar fade
                    self.trigger_btn_animation.setStartValue(1.0)
                    self.trigger_btn_animation.setEndValue(0.0)
                    self.trigger_btn_animation.setEasingCurve(QEasingCurve.Type.InOutCubic)
                    
                    def on_animation_finished():
                        try:
                            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
                                self.autohide_trigger_btn.hide()
                                self.autohide_trigger_btn.setGraphicsEffect(None)
                            if hasattr(self, '_trigger_btn_effect'):
                                self._trigger_btn_effect = None
                        except RuntimeError:
                            pass  # Widget already deleted
                        self.trigger_btn_animation = None
                    
                    self.trigger_btn_animation.finished.connect(on_animation_finished)
                    self.trigger_btn_animation.start()
                except RuntimeError as anim_error:
                    # Effect was deleted before animation could be created
                    logger.debug(f"Error creating trigger button hide animation: {anim_error}, falling back to non-animated")
                    try:
                        self.autohide_trigger_btn.setGraphicsEffect(None)
                        self._trigger_btn_effect = None
                        self.autohide_trigger_btn.hide()
                    except RuntimeError:
                        pass  # Widget already deleted
            except RuntimeError as e:
                # Widget or effect was deleted during setup - fall back to non-animated hide
                logger.debug(f"Error creating trigger button hide animation: {e}, falling back to non-animated")
                try:
                    if hasattr(self, '_trigger_btn_effect'):
                        self._trigger_btn_effect = None
                    if self.autohide_trigger_btn:
                        self.autohide_trigger_btn.hide()
                        self.autohide_trigger_btn.setGraphicsEffect(None)
                except RuntimeError:
                    pass  # Widget already deleted
        else:
            # Hide immediately without animation
            try:
                self.autohide_trigger_btn.hide()
                self.autohide_trigger_btn.setGraphicsEffect(None)
            except RuntimeError:
                pass  # Widget already deleted
    
    def setup_webengine_storage(self):
        """Setup persistent storage for WebEngine (enables dev tools settings persistence)"""
        # Use a named profile instead of default for better persistence
        # Named profiles have more reliable persistent storage for DevTools
        storage_path = Path(__file__).parent / "webengine_storage"
        storage_path.mkdir(exist_ok=True)
        
        # Create a named persistent profile (better for DevTools settings)
        profile_name = "BandcampPlayerProfile"
        try:
            # Try to get existing named profile or create new one
            profile = QWebEngineProfile(profile_name)
        except Exception as e:
            # Fallback to default profile if named profile creation fails
            logger.warning(f"Could not create named profile, using default: {e}")
            profile = QWebEngineProfile.defaultProfile()
        
        # Set persistent storage path (for cookies, localStorage, IndexedDB, dev tools settings, etc.)
        # Must be set before creating any pages
        profile.setPersistentStoragePath(str(storage_path))
        profile.setCachePath(str(storage_path / "cache"))
        
        # Force persistent cookies (ensures storage is actually used)
        # This is more aggressive than AllowPersistentCookies
        profile.setPersistentCookiesPolicy(QWebEngineProfile.PersistentCookiesPolicy.ForcePersistentCookies)
        
        # Store profile reference for dev tools
        self.webengine_profile = profile
    
    def setup_web_view(self):
        """Setup the web engine view with mobile user agent"""
        self.web_view = QWebEngineView()
        
        # Enable drag and drop on web view
        self.web_view.setAcceptDrops(True)
        
        # Override drag/drop handlers to catch URL drops
        def web_view_drag_enter(event):
            # Only accept if it's a URL or text (not web content)
            if event.mimeData().hasUrls() or event.mimeData().hasText():
                event.acceptProposedAction()
            else:
                event.ignore()
        
        def web_view_drop(event):
            # Handle URL drops (only first URL - player can only handle one at a time)
            url = None
            if event.mimeData().hasUrls():
                urls = event.mimeData().urls()
                if urls:
                    url = urls[0].toString()
            elif event.mimeData().hasText():
                # Get text and take first URL only
                text = event.mimeData().text().strip()
                if text:
                    # Split by newlines and take first line
                    lines = [line.strip() for line in text.split('\n') if line.strip()]
                    if lines:
                        url = lines[0]
            
            if url:
                self._handle_global_drop(url)
                event.acceptProposedAction()
            else:
                event.ignore()
        
        self.web_view.dragEnterEvent = web_view_drag_enter
        self.web_view.dropEvent = web_view_drop
        
        # Initially hide the web view
        self.web_view.setStyleSheet("QWebEngineView { background-color: #212121; }")
        self.web_view.hide()
        
        # Custom context menu with native Inspect action for proper functionality
        def context_menu_event(position):
            """Custom context menu with proper dark theme styling and native Inspect action"""
            # Disable right-click during loading to prevent crashes
            if self.is_loading:
                return
            
            menu = QMenu(self)
            
            # Apply dark theme styling to context menu
            menu.setStyleSheet("""
                QMenu {
                    background-color: #2b2b2b;
                    border: 1px solid #3a3a3a;
                    color: #e0e0e0;
                    padding: 4px;
                }
                QMenu::item {
                    background-color: transparent;
                    padding: 6px 20px 6px 30px;
                    color: #e0e0e0;
                }
                QMenu::item:selected {
                    background-color: #3a3a3a;
                    color: #ffffff;
                }
                QMenu::item:disabled {
                    color: #666666;
                }
                QMenu::separator {
                    height: 1px;
                    background-color: #3a3a3a;
                    margin: 4px 0px;
                }
            """)
            
            # Get page actions
            page = self.web_view.page()
            
            # Navigation actions
            back_action = page.action(QWebEnginePage.WebAction.Back)
            if back_action and back_action.isEnabled():
                # Add icon to back action
                if HAS_QT_AWESOME:
                    icon = get_icon('ei.arrow-left', color='#e0e0e0')
                    if icon:
                        back_action.setIcon(icon)
                menu.addAction(back_action)
            
            forward_action = page.action(QWebEnginePage.WebAction.Forward)
            if forward_action and forward_action.isEnabled():
                # Add icon to forward action
                if HAS_QT_AWESOME:
                    icon = get_icon('ei.arrow-right', color='#e0e0e0')
                    if icon:
                        forward_action.setIcon(icon)
                menu.addAction(forward_action)
            
            # Reload action with custom icon
            reload_action = page.action(QWebEnginePage.WebAction.Reload)
            if reload_action:
                # Try to add icon to reload action
                if HAS_QT_AWESOME:
                    icon = get_icon('mdi.reload', color='#e0e0e0')
                    if not icon:
                        icon = get_icon('mdi6.reload', color='#e0e0e0')
                    if icon:
                        reload_action.setIcon(icon)
                menu.addAction(reload_action)
            
            menu.addSeparator()
            
            # Copy action
            copy_action = page.action(QWebEnginePage.WebAction.Copy)
            if copy_action and copy_action.isEnabled():
                menu.addAction(copy_action)
            
            # Paste URL action - uses the same handler as the paste URL button
            paste_url_action = QAction("Paste URL", self)
            if HAS_QT_AWESOME:
                icon = get_icon('paste', color='#e0e0e0')
                if icon:
                    paste_url_action.setIcon(icon)
            else:
                paste_url_action.setText(" Paste URL")
            paste_url_action.triggered.connect(self.on_paste_url)
            menu.addAction(paste_url_action)
            
            menu.addSeparator()
            
            # Get current page URL for "Open in Browser" and "Copy URL"
            current_url = self.web_view.url().toString() if self.web_view else None
            if current_url and current_url != "about:blank":
                # Open in Browser
                open_browser_action = QAction("Open in Browser", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('external-link-alt', color='#e0e0e0')
                    if icon:
                        open_browser_action.setIcon(icon)
                else:
                    open_browser_action.setText(" Open in Browser")
                open_browser_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl(current_url)))
                menu.addAction(open_browser_action)
                
                # Copy URL
                copy_url_action = QAction("Copy URL", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('copy', color='#e0e0e0')
                    if icon:
                        copy_url_action.setIcon(icon)
                else:
                    copy_url_action.setText(" Copy URL")
                def copy_url_with_feedback():
                    QApplication.clipboard().setText(current_url)
                    global_pos = self.web_view.mapToGlobal(self.web_view.rect().center())
                    QToolTip.showText(global_pos, "URL copied", self.web_view, QRect(), 1500)
                copy_url_action.triggered.connect(copy_url_with_feedback)
                menu.addAction(copy_url_action)
                
                menu.addSeparator()
            
            # Add Inspect Element action - always available, opens dev tools if needed
            menu.addSeparator()
            # Try to use native InspectElement action if dev tools is already open
            if self.dev_tools_window and self.dev_tools_window.isVisible():
                try:
                    native_inspect_action = page.action(QWebEnginePage.WebAction.InspectElement)
                    if native_inspect_action:
                        # Add icon to native inspect action
                        if HAS_QT_AWESOME:
                            icon = get_icon('fa6s.magnifying-glass', color='#e0e0e0')
                            if icon:
                                native_inspect_action.setIcon(icon)
                        menu.addAction(native_inspect_action)
                    else:
                        # Fallback to custom inspect
                        inspect_action = QAction("Inspect", self)
                        if HAS_QT_AWESOME:
                            icon = get_icon('fa6s.magnifying-glass', color='#e0e0e0')
                            if icon:
                                inspect_action.setIcon(icon)
                        inspect_action.triggered.connect(lambda: self._trigger_inspect_at_position(position))
                        menu.addAction(inspect_action)
                except AttributeError:
                    # InspectElement might not be available in all PyQt6 versions
                    inspect_action = QAction("Inspect", self)
                    if HAS_QT_AWESOME:
                        icon = get_icon('fa6s.magnifying-glass', color='#e0e0e0')
                        if icon:
                            inspect_action.setIcon(icon)
                    inspect_action.triggered.connect(lambda: self._trigger_inspect_at_position(position))
                    menu.addAction(inspect_action)
            else:
                # Dev tools not open - use custom action that opens dev tools first
                inspect_action = QAction("Inspect", self)
                if HAS_QT_AWESOME:
                    icon = get_icon('fa6s.magnifying-glass', color='#e0e0e0')
                    if icon:
                        inspect_action.setIcon(icon)
                def handle_inspect():
                    # Store position for inspection
                    self.inspect_position = position
                    # Open dev tools if not already open
                    if not self.dev_tools_window or not self.dev_tools_window.isVisible():
                        self.toggle_dev_tools()
                        # Wait a bit for dev tools to open, then trigger inspect
                        QTimer.singleShot(500, lambda: self._trigger_inspect_at_position(position))
                    else:
                        # Dev tools already open, trigger inspect immediately
                        self._trigger_inspect_at_position(position)
                inspect_action.triggered.connect(handle_inspect)
                menu.addAction(inspect_action)
            
            menu.addSeparator()
            
            # Close Menu
            close_menu_action = QAction("Close Menu", self)
            if HAS_QT_AWESOME:
                icon = get_icon('times', color='#e0e0e0')
                if icon:
                    close_menu_action.setIcon(icon)
            else:
                close_menu_action.setText(" Close Menu")
            close_menu_action.triggered.connect(lambda: menu.close())
            menu.addAction(close_menu_action)
            
            # Show menu at cursor position (convert local position to global)
            global_pos = self.web_view.mapToGlobal(position)
            menu.exec(global_pos)
        
        self.web_view.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.web_view.customContextMenuRequested.connect(context_menu_event)
        
        # Set mobile user agent to get mobile Bandcamp view
        mobile_user_agent = (
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) "
            "AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
        )
        self.web_view.page().profile().setHttpUserAgent(mobile_user_agent)
        
        # Configure web engine settings to allow autoplay
        settings = self.web_view.page().settings()
        # Disable autoplay restrictions - this allows programmatic playback
        try:
            settings.setAttribute(QWebEngineSettings.WebAttribute.PlaybackRequiresUserGesture, False)
            logger.debug("Disabled PlaybackRequiresUserGesture - autoplay should now work!")
        except Exception as e:
            logger.warning(f"Could not disable autoplay restriction: {e}", exc_info=True)
        
        # Set default zoom to 75%
        self.web_view.setZoomFactor(0.75)
        
        # Show loading overlay when page starts loading
        self.web_view.page().loadStarted.connect(self.on_page_load_started)
        
        # Show page progressively as it loads (at 30% progress)
        self.web_view.page().loadProgress.connect(self.on_page_load_progress)
        
        # Inject CSS when page loads
        self.web_view.page().loadFinished.connect(self.on_page_loaded)
        
        # Initialize image viewer modal structure early (before any page loads)
        # This ensures the modal is ready whenever a URL is loaded
        # Use a small delay to ensure the page object is fully ready
        QTimer.singleShot(100, self._initialize_image_viewer_modal_early)
        
        # Poll for image viewer actions from JavaScript
        self._image_viewer_action_timer = QTimer()
        self._image_viewer_action_timer.timeout.connect(self._poll_image_viewer_actions)
        self._image_viewer_action_timer.start(100)  # Check every 100ms
        
        # Add to layout
        layout = self.centralWidget().layout()
        # Set size policy to prevent centering - web view should expand but not cause centering
        self.web_view.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        # Insert before playlist with stretch factor 1 (takes available space)
        layout.insertWidget(1, self.web_view, 1)
        
        # Create animated loading overlay widget as a true overlay
        # Make it a child of the main window, NOT in the layout, positioned absolutely
        self.loading_overlay = AnimatedLoadingOverlay(self)
        self.loading_overlay.hide()
        # Initialize geometry to zero to prevent dark block on startup
        self.loading_overlay.setGeometry(0, 0, 0, 0)
        # Don't update geometry when overlay is hidden - it will be updated when shown
        # Position it to cover entire web view area (playlist will sit on top)
        # Geometry will be updated when overlay is shown (when is_loading is True)
        # Note: We don't use WA_AlwaysStackOnTop here so playlist can be raised above overlay
        # The overlay will still cover the web view, but playlist container can sit on top
    
    def setup_menu(self):
        """Setup the context menu"""
        self.menu = QMenu(self)
        
        # Apply dark theme styling to match the rest of the app
        self.menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        
        # Version info at top (non-clickable, styled)
        version_string = self._get_version_string()
        # Use QWidgetAction to create a styled label (QAction doesn't support setStyleSheet)
        version_label = QLabel(version_string)
        version_label.setStyleSheet("""
            QLabel {
                color: #4a90e2;
                padding: 6px 20px;
                background-color: transparent;
            }
        """)
        version_label.setEnabled(False)  # Non-clickable
        version_action = QWidgetAction(self)
        version_action.setDefaultWidget(version_label)
        self.menu.addAction(version_action)
        
        # Separator
        self.menu.addSeparator()
        
        # Check for Updates
        check_updates_action = QAction("Check for Updates...", self)
        check_updates_action.triggered.connect(self.check_for_updates)
        self.menu.addAction(check_updates_action)
        
        # Auto-check for updates (checkbox)
        self.auto_check_updates_action = QAction("Automatically Check for Updates", self)
        self.auto_check_updates_action.setCheckable(True)
        self.auto_check_updates_action.setChecked(self.settings.get("auto_check_updates", True))
        self.auto_check_updates_action.triggered.connect(self.on_auto_check_updates_change)
        self.menu.addAction(self.auto_check_updates_action)
        
        # Separator
        self.menu.addSeparator()
        
        # View mode
        # Developer options (hidden by default, shown when dev tools is open)
        self.bandcamp_action = QAction("Bandcamp Mode", self)
        self.bandcamp_action.setCheckable(True)
        self.bandcamp_action.setChecked(self.bandcamp_mode)
        self.bandcamp_action.triggered.connect(self.toggle_bandcamp_mode)
        self.menu.addAction(self.bandcamp_action)
        self.bandcamp_action.setVisible(False)  # Hidden by default
        
        self.compact_action = QAction("Compact Mode", self)
        self.compact_action.setCheckable(True)
        self.compact_action.setChecked(self.compact_mode)
        self.compact_action.triggered.connect(self.toggle_compact_mode)
        self.menu.addAction(self.compact_action)
        self.compact_action.setVisible(False)  # Hidden by default
        
        self.menu.addSeparator()
        
        # Frameless window (hidden by default, shown when dev tools is open)
        self.frameless_action = QAction("Frameless Window", self)
        self.frameless_action.setCheckable(True)
        self.frameless_action.setChecked(self.frameless_mode)
        self.frameless_action.triggered.connect(self.toggle_frameless_mode)
        self.menu.addAction(self.frameless_action)
        self.frameless_action.setVisible(False)  # Hidden by default
        
        self.menu.addSeparator()
        
        # Mini Mode Player Autohide (only show when in mini mode)
        self.mini_mode_player_autohide_action = QAction("Mini Mode Player Autohide", self)
        self.mini_mode_player_autohide_action.setCheckable(True)
        self.mini_mode_player_autohide_action.setChecked(self.mini_mode_player_autohide)
        self.mini_mode_player_autohide_action.triggered.connect(self.toggle_mini_mode_player_autohide)
        self.menu.addAction(self.mini_mode_player_autohide_action)
        # Only show when in mini mode
        self.mini_mode_player_autohide_action.setVisible(self.mini_mode_state == 1)
        
        # Autoplay
        self.autoplay_action = QAction("Autoplay", self)
        self.autoplay_action.setCheckable(True)
        self.autoplay_action.setChecked(self.autoplay)
        self.autoplay_action.triggered.connect(self.toggle_autoplay)
        self.menu.addAction(self.autoplay_action)
        
        # Autoplay on Startup (independent of regular autoplay)
        self.autoplay_on_startup_action = QAction("Autoplay on Startup", self)
        self.autoplay_on_startup_action.setCheckable(True)
        self.autoplay_on_startup_action.setChecked(self.autoplay_on_startup)
        self.autoplay_on_startup_action.triggered.connect(self.toggle_autoplay_on_startup)
        self.menu.addAction(self.autoplay_on_startup_action)
        
        # Webview Scrollbar
        self.webview_scrollbar_action = QAction("Show Webview Scrollbar", self)
        self.webview_scrollbar_action.setCheckable(True)
        self.webview_scrollbar_action.setChecked(self.webview_scrollbar_visible)
        self.webview_scrollbar_action.triggered.connect(self.toggle_webview_scrollbar)
        self.menu.addAction(self.webview_scrollbar_action)
        
        # Transparent Loading Overlay (hidden by default, shown when dev tools is open)
        self.transparent_overlay_action = QAction("Transparent Loading Overlay", self)
        self.transparent_overlay_action.setCheckable(True)
        self.transparent_overlay_action.setChecked(self.transparent_overlay)
        self.transparent_overlay_action.triggered.connect(self.toggle_transparent_overlay)
        self.menu.addAction(self.transparent_overlay_action)
        self.transparent_overlay_action.setVisible(False)  # Hidden by default
        
        self.menu.addSeparator()
        
        # Keyboard Shortcuts
        keyboard_shortcuts_action = QAction("Keyboard Shortcuts...", self)
        keyboard_shortcuts_action.triggered.connect(self.show_keyboard_shortcuts_dialog)
        self.menu.addAction(keyboard_shortcuts_action)
        
        self.menu.addSeparator()
        
        # About
        about_action = QAction("About", self)
        about_action.triggered.connect(self._show_about_dialog)
        self.menu.addAction(about_action)
        
        # GitHub Repository
        github_action = QAction("GitHub Repository", self)
        github_action.triggered.connect(lambda: webbrowser.open("https://github.com/kameryn1811/Bandcamp-Player"))
        self.menu.addAction(github_action)
        
        # Report Issue
        report_issue_action = QAction("Report Issue", self)
        report_issue_action.triggered.connect(lambda: webbrowser.open("https://github.com/kameryn1811/Bandcamp-Player/issues"))
        self.menu.addAction(report_issue_action)
        
        self.menu.addSeparator()
        
        # Developer Tools
        dev_tools_action = QAction("Developer Tools", self)
        dev_tools_action.setShortcut(QKeySequence("F12"))
        dev_tools_action.triggered.connect(self.toggle_dev_tools)
        self.menu.addAction(dev_tools_action)
        
        self.menu.addSeparator()
        
        # Quit
        quit_action = QAction("Quit", self)
        quit_action.triggered.connect(self.close)
        self.menu.addAction(quit_action)
    
    def setup_tray(self):
        """Setup system tray icon"""
        if not QSystemTrayIcon.isSystemTrayAvailable():
            return
        
        self.tray_icon = QSystemTrayIcon(self)
        self.tray_icon.setToolTip("Bandcamp Player")
        
        # Set icon if available
        if self.app_icon:
            self.tray_icon.setIcon(self.app_icon)
        
        # Create tray menu
        tray_menu = QMenu(self)
        # Apply dark theme styling to match the rest of the app
        tray_menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        show_action = QAction("Show", self)
        show_action.triggered.connect(self.show)
        tray_menu.addAction(show_action)
        
        hide_action = QAction("Hide", self)
        hide_action.triggered.connect(self.hide)
        tray_menu.addAction(hide_action)
        
        tray_menu.addSeparator()
        quit_action = QAction("Quit", self)
        quit_action.triggered.connect(self.close)
        tray_menu.addAction(quit_action)
        
        self.tray_icon.setContextMenu(tray_menu)
        self.tray_icon.activated.connect(self.tray_icon_activated)
        self.tray_icon.show()
    
    def setup_shortcuts(self):
        """Setup keyboard shortcuts"""
        # F12 for developer tools
        dev_tools_shortcut = QShortcut(QKeySequence("F12"), self)
        dev_tools_shortcut.activated.connect(self.toggle_dev_tools)
    
    def tray_icon_activated(self, reason):
        """Handle tray icon activation"""
        if reason == QSystemTrayIcon.ActivationReason.DoubleClick:
            self.show()
            self.raise_()
            self.activateWindow()
    
    def show_menu(self):
        """Show the context menu"""
        menu_btn = self.sender()
        
        # Set JavaScript flag to indicate menu is open (do this before menu opens)
        if self.web_view and self.web_view.page():
            self.web_view.page().runJavaScript("""
                window._bandcampPlayerMenuOpen = true;
                if (typeof window._updateCoverArtCursor === 'function') {
                    window._updateCoverArtCursor();
                }
            """)
        
        # Show menu (blocking call)
        self.menu.exec(menu_btn.mapToGlobal(menu_btn.rect().bottomLeft()))
        
        # After menu closes, wait a bit before clearing the flag to handle any queued click events
        # This prevents clicks that happened while menu was open from opening the image viewer
        def clear_menu_flag():
            if self.web_view and self.web_view.page():
                self.web_view.page().runJavaScript("""
                    window._bandcampPlayerMenuOpen = false;
                    if (typeof window._updateCoverArtCursor === 'function') {
                        window._updateCoverArtCursor();
                    }
                """)
        
        # Clear flag after a short delay to catch any queued click events
        QTimer.singleShot(200, clear_menu_flag)
        
        # After menu closes, check if mouse is outside address bar and hide if autohide is enabled
        if self.autohide_address_bar:
            # Use a small delay to allow menu to fully close
            QTimer.singleShot(50, self.check_and_hide_address_bar_after_menu)
    
    def show_volume_control(self, auto_hide=True, delay_ms=1200):
        """Show volume control popup with optional auto-hide"""
        if not self.volume_popup:
            # Create volume popup widget
            self.volume_popup = QWidget(self)
            # Use ToolTip instead of Popup to avoid stealing keyboard focus
            # ToolTip windows don't interfere with keyboard shortcuts
            self.volume_popup.setWindowFlags(Qt.WindowType.ToolTip | Qt.WindowType.FramelessWindowHint)
            # Don't use WA_TranslucentBackground - it makes the background disappear
            # Window opacity will still work for fade animations without this attribute
            self.volume_popup.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, False)
            # Prevent popup from accepting keyboard focus (allows shortcuts to work)
            self.volume_popup.setFocusPolicy(Qt.FocusPolicy.NoFocus)
            # Set fixed width to prevent resizing when volume percentage changes
            self.volume_popup.setFixedWidth(60)
            # Use solid background color (semi-transparency will be handled by window opacity)
            self.volume_popup.setStyleSheet("""
                QWidget {
                    background-color: #2b2b2b;
                    border: 1px solid #3a3a3a;
                    border-radius: 20px;
                }
            """)
            # Keep opaque paint event for proper background rendering
            self.volume_popup.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, True)
            # Enable mouse tracking to detect enter/leave events
            self.volume_popup.setMouseTracking(True)
            
            layout = QVBoxLayout(self.volume_popup)
            layout.setContentsMargins(15, 15, 15, 15)
            layout.setSpacing(10)
            
            # Volume label
            self.volume_label = QLabel(f"{self.volume_level}%")
            self.volume_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.volume_label.setStyleSheet("""
                QLabel {
                    color: #e0e0e0;
                    font-size: 14px;
                    font-weight: bold;
                    background-color: transparent;
                    border: none;
                }
            """)
            # Allow text overflow to be visible
            self.volume_label.setWordWrap(False)
            layout.addWidget(self.volume_label)
            
            # Volume slider (vertical, 0-100) - using custom widget that fills from bottom up
            self.volume_slider = VolumeSlider(self.volume_popup)
            self.volume_slider.setMinimum(0)
            self.volume_slider.setMaximum(100)
            self.volume_slider.setValue(self.volume_level)
            self.volume_slider.valueChanged.connect(self.on_volume_changed)
            # Add with fixed size policy to prevent width changes
            self.volume_slider.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
            layout.addWidget(self.volume_slider, 0, Qt.AlignmentFlag.AlignHCenter)
            
            # Mute button (icon, checkable)
            self.mute_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('fa5s.volume-mute', color='#e0e0e0')
                if icon:
                    self.mute_btn.setIcon(icon)
                else:
                    self.mute_btn.setText("")
            else:
                self.mute_btn.setText("")
            self.mute_btn.setFixedSize(30, 30)
            self.mute_btn.setCheckable(True)
            self.mute_btn.setChecked(self.volume_level == 0)  # Initialize checked state based on current volume
            self.mute_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
                QPushButton:checked {
                    color: #4a90e2;
                    background-color: #3a3a3a;
                    border: 1px solid #4a90e2;
                    border-radius: 3px;
                }
            """)
            self.mute_btn.clicked.connect(self.toggle_mute)
            layout.addWidget(self.mute_btn, 0, Qt.AlignmentFlag.AlignHCenter)
            
            # Install event filter on popup to reset timer on any mouse interaction
            self.volume_popup.installEventFilter(self)
            
            # Install event filter to close popup when clicking outside
            QApplication.instance().installEventFilter(self)
        
        # Position popup near volume button (if called from button) or top-right (if called from shortcut)
        volume_btn = self.sender()
        self._position_volume_popup_onscreen(volume_btn if (volume_btn and hasattr(volume_btn, 'mapToGlobal')) else None)
        
        # Apply rounded corner mask to clip children to rounded corners
        # Wait for widget to be shown and sized before applying mask
        QTimer.singleShot(10, lambda: self._apply_rounded_mask())
        # Reposition after show/layout so final size is used for clamping (prevents offscreen cut-off)
        QTimer.singleShot(0, lambda: self._position_volume_popup_onscreen(volume_btn if (volume_btn and hasattr(volume_btn, 'mapToGlobal')) else None))
        
        # Cancel any ongoing fade out animation
        if self.volume_popup_fade_animation:
            self.volume_popup_fade_animation.stop()
            self.volume_popup_fade_animation = None
        
        # Check if popup is already visible (just resetting timer)
        is_already_visible = self.volume_popup.isVisible()
        
        # Set initial opacity to 0 before showing (for fade in)
        if not is_already_visible:
            self.volume_popup.setWindowOpacity(0.0)
        
        # Show popup first
        self.volume_popup.show()
        self.volume_popup.raise_()
        
        # Always set JavaScript flag to indicate volume popup is open (whether newly shown or already visible)
        # This ensures the flag is set whenever the popup is visible
        # Use a callback to ensure it's set before any clicks can happen
        if self.web_view and self.web_view.page():
            def set_flag_callback(result):
                # Flag is now set - popup is protected from image viewer clicks
                pass
            self.web_view.page().runJavaScript("""
                window._bandcampPlayerVolumePopupOpen = true;
                if (typeof window._updateCoverArtCursor === 'function') {
                    window._updateCoverArtCursor();
                }
            """, set_flag_callback)
        
        # Fade in animation only if popup wasn't already visible
        if not is_already_visible:
            # Use QTimer to ensure widget is fully shown before starting animation
            QTimer.singleShot(10, self._start_fade_in_animation)
        else:
            # Already visible - ensure it's fully opaque
            self.volume_popup.setWindowOpacity(1.0)
        
        # Setup auto-hide timer if requested and mouse is not over popup
        if auto_hide:
            # Check if mouse is currently over the popup
            mouse_over_popup = False
            if self.volume_popup and self.volume_popup.isVisible():
                popup_rect = QRect(
                    self.volume_popup.mapToGlobal(QPoint(0, 0)),
                    self.volume_popup.size()
                )
                mouse_pos = QCursor.pos()
                mouse_over_popup = popup_rect.contains(mouse_pos)
            
            # Only schedule hide if mouse is not over popup
            if not mouse_over_popup:
                self._schedule_volume_popup_hide(delay_ms)

    def _position_volume_popup_onscreen(self, source_btn=None):
        """Position the volume popup so it stays fully on-screen (flip up if needed near bottom edge)."""
        if not hasattr(self, 'volume_popup') or not self.volume_popup:
            return

        try:
            # Choose an anchor button if caller didn't provide one
            btn = source_btn
            if (btn is None) and hasattr(self, 'volume_btn') and self.volume_btn:
                btn = self.volume_btn

            # Ensure the popup has an up-to-date size hint before positioning
            try:
                self.volume_popup.adjustSize()
            except Exception:
                pass

            popup_hint = self.volume_popup.sizeHint()
            popup_w = max(int(self.volume_popup.width()), int(popup_hint.width()))
            popup_h = max(int(self.volume_popup.height()), int(popup_hint.height()))

            # Even with fixed width, height can be 0 before first show; keep a sensible fallback
            if popup_w <= 0:
                popup_w = 60
            if popup_h <= 0:
                popup_h = 180

            # Determine desired position (default: below button)
            x_offset = -20
            gap = 5

            if btn and hasattr(btn, 'mapToGlobal'):
                below_anchor = btn.mapToGlobal(btn.rect().bottomLeft())
                above_anchor = btn.mapToGlobal(btn.rect().topLeft())
                desired_x = below_anchor.x() + x_offset
                desired_y_below = below_anchor.y() + gap
                desired_y_above = above_anchor.y() - popup_h - gap
                anchor_for_screen = below_anchor
            else:
                # Fallback: near top-right of the main window
                anchor_for_screen = self.mapToGlobal(QPoint(self.width(), 0))
                desired_x = anchor_for_screen.x() - popup_w - 20
                desired_y_below = anchor_for_screen.y() + 50
                desired_y_above = desired_y_below

            # Pick the screen that contains the anchor point (multi-monitor safe)
            screen = None
            try:
                screen = QApplication.screenAt(anchor_for_screen)
            except Exception:
                screen = None
            if not screen:
                try:
                    screen = self.screen()
                except Exception:
                    screen = None
            if not screen:
                screen = QApplication.primaryScreen()

            if not screen:
                # As a last resort, just move to the desired position
                self.volume_popup.move(desired_x, desired_y_below)
                return

            avail = screen.availableGeometry()

            # If there isn't enough room below, open upward instead
            if desired_y_below + popup_h > avail.bottom():
                desired_y = desired_y_above
            else:
                desired_y = desired_y_below

            # Clamp fully on-screen
            min_x = avail.left()
            min_y = avail.top()
            max_x = avail.right() - popup_w
            max_y = avail.bottom() - popup_h
            if max_x < min_x:
                max_x = min_x
            if max_y < min_y:
                max_y = min_y

            final_x = max(min_x, min(int(desired_x), int(max_x)))
            final_y = max(min_y, min(int(desired_y), int(max_y)))

            self.volume_popup.move(final_x, final_y)
        except Exception:
            # Never let positioning logic crash the app or block the popup
            try:
                self.volume_popup.move(self.width() - 80, 50)
            except Exception:
                pass
    
    def _schedule_volume_popup_hide(self, delay_ms=1200):
        """Schedule volume popup to hide after delay"""
        # Cancel existing timer if any
        if self.volume_hide_timer:
            self.volume_hide_timer.stop()
        
        # Create new timer
        self.volume_hide_timer = QTimer(self)
        self.volume_hide_timer.setSingleShot(True)
        self.volume_hide_timer.timeout.connect(self._hide_volume_popup)
        self.volume_hide_timer.start(delay_ms)
    
    def _start_fade_in_animation(self):
        """Start the fade in animation (called after widget is shown)"""
        if not self.volume_popup or not self.volume_popup.isVisible():
            return
        
        # Ensure initial opacity is 0
        self.volume_popup.setWindowOpacity(0.0)
        
        # Create fade in animation using window opacity
        fade_in = QPropertyAnimation(self.volume_popup, b"windowOpacity")
        fade_in.setDuration(150)  # 150ms fade in
        fade_in.setStartValue(0.0)
        fade_in.setEndValue(1.0)
        fade_in.setEasingCurve(QEasingCurve.Type.OutQuad)
        
        # Store animation reference
        self.volume_popup_fade_animation = fade_in
        fade_in.start()
    
    def _hide_volume_popup(self):
        """Hide volume popup with fade out animation"""
        if not self.volume_popup or not self.volume_popup.isVisible():
            return
        
        # Cancel any ongoing fade in animation
        if self.volume_popup_fade_animation:
            self.volume_popup_fade_animation.stop()
        
        # Get current opacity (should be 1.0 if fully visible)
        current_opacity = self.volume_popup.windowOpacity()
        if current_opacity < 0.1:
            # Already mostly transparent, just hide immediately
            self.volume_popup.hide()
            self.volume_popup.setWindowOpacity(1.0)  # Reset for next show
            self.volume_popup_fade_animation = None
            
            # Clear JavaScript flag after a delay to handle any queued click events
            def clear_volume_flag():
                if self.web_view and self.web_view.page():
                    self.web_view.page().runJavaScript("""
                        window._bandcampPlayerVolumePopupOpen = false;
                        if (typeof window._updateCoverArtCursor === 'function') {
                            window._updateCoverArtCursor();
                        }
                    """)
            
            # Clear flag after a short delay to catch any queued click events
            QTimer.singleShot(200, clear_volume_flag)
            return
        
        # Create fade out animation using window opacity
        fade_out = QPropertyAnimation(self.volume_popup, b"windowOpacity")
        fade_out.setDuration(150)  # 150ms fade out
        fade_out.setStartValue(current_opacity)
        fade_out.setEndValue(0.0)
        fade_out.setEasingCurve(QEasingCurve.Type.InQuad)
        
        # Store animation reference
        self.volume_popup_fade_animation = fade_out
        
        # Hide popup after animation completes
        def hide_after_fade():
            if self.volume_popup:
                self.volume_popup.hide()
                # Reset opacity for next show
                self.volume_popup.setWindowOpacity(1.0)
            self.volume_popup_fade_animation = None
            
            # Clear JavaScript flag after a delay to handle any queued click events
            def clear_volume_flag():
                if self.web_view and self.web_view.page():
                    self.web_view.page().runJavaScript("""
                        window._bandcampPlayerVolumePopupOpen = false;
                        if (typeof window._updateCoverArtCursor === 'function') {
                            window._updateCoverArtCursor();
                        }
                    """)
            
            # Clear flag after a short delay to catch any queued click events
            QTimer.singleShot(200, clear_volume_flag)
        
        fade_out.finished.connect(hide_after_fade)
        fade_out.start()
    
    def _apply_rounded_mask(self):
        """Apply rounded corner mask to volume popup"""
        if self.volume_popup and self.volume_popup.isVisible():
            path = QPainterPath()
            path.addRoundedRect(0, 0, self.volume_popup.width(), self.volume_popup.height(), 20, 20)
            region = QRegion(path.toFillPolygon().toPolygon())
            self.volume_popup.setMask(region)
    
    def on_volume_changed(self, value):
        """Handle volume slider change"""
        self.volume_level = value
        # Update label if popup exists
        if hasattr(self, 'volume_label') and self.volume_label:
            self.volume_label.setText(f"{value}%")
        
        # Update mute button checked state
        if hasattr(self, 'mute_btn') and self.mute_btn:
            self.mute_btn.setChecked(value == 0)
        
        # Update volume in JavaScript using standard volume control
        # Note: Boost (100-200%) is disabled due to Web Audio API compatibility issues
        volume_js = f"""
        (function() {{
            var audio = document.querySelector('audio');
            if (audio) {{
                // Clamp volume to 0.0-1.0 (0-100%)
                var volume = Math.max(0.0, Math.min(1.0, {value / 100.0}));
                audio.volume = volume;
            }}
        }})();
        """
        if self.web_view and self.web_view.page():
            self.web_view.page().runJavaScript(volume_js)
        
        # Save to settings
        self.settings['volume_level'] = value
        self.save_settings()
        
        # Reset hide timer when volume is changed manually (user interaction)
        if self.volume_popup and self.volume_popup.isVisible():
            self._schedule_volume_popup_hide(delay_ms=1200)
    
    def toggle_mute(self):
        """Toggle mute (set to 0% or restore previous volume)"""
        if self.volume_level > 0:
            # Store current volume and mute
            self._previous_volume = self.volume_level
            new_volume = 0
        else:
            # Restore previous volume (cap at 100%)
            previous = getattr(self, '_previous_volume', 100)
            new_volume = min(100, previous)  # Cap at 100%
        
        # Update volume immediately (don't go through slider to avoid delays)
        self.volume_level = new_volume
        self.on_volume_changed(new_volume)
        
        # Update slider if it exists (but don't wait for its signal)
        if hasattr(self, 'volume_slider') and self.volume_slider:
            # Temporarily block signals to avoid triggering valueChanged
            self.volume_slider.blockSignals(True)
            self.volume_slider.setValue(new_volume)
            self.volume_slider.blockSignals(False)
        
        # Update mute button checked state
        if hasattr(self, 'mute_btn') and self.mute_btn:
            self.mute_btn.setChecked(self.volume_level == 0)
        
        # Show volume popup if not visible, or reset timer if already visible
        if not (hasattr(self, 'volume_popup') and self.volume_popup and self.volume_popup.isVisible()):
            self.show_volume_control(auto_hide=True, delay_ms=1200)
        else:
            # Popup is already visible, just reset the timer
            self._schedule_volume_popup_hide(delay_ms=1200)
    
    def volume_up(self):
        """Increase volume by 10%"""
        new_volume = min(100, self.volume_level + 10)  # Cap at 100%
        # Update volume immediately (don't go through slider to avoid delays)
        self.volume_level = new_volume
        self.on_volume_changed(new_volume)
        
        # Update slider if it exists (but don't wait for its signal)
        if hasattr(self, 'volume_slider') and self.volume_slider:
            # Temporarily disconnect to avoid triggering valueChanged signal
            self.volume_slider.blockSignals(True)
            self.volume_slider.setValue(new_volume)
            self.volume_slider.blockSignals(False)
        
        # Show volume popup and reset hide timer (this allows rapid volume changes)
        # The timer will be reset on each call, allowing continuous adjustments
        self.show_volume_control(auto_hide=True, delay_ms=1200)
    
    def volume_down(self):
        """Decrease volume by 10%"""
        new_volume = max(0, self.volume_level - 10)
        # Update volume immediately (don't go through slider to avoid delays)
        self.volume_level = new_volume
        self.on_volume_changed(new_volume)
        
        # Update slider if it exists (but don't wait for its signal)
        if hasattr(self, 'volume_slider') and self.volume_slider:
            # Temporarily disconnect to avoid triggering valueChanged signal
            self.volume_slider.blockSignals(True)
            self.volume_slider.setValue(new_volume)
            self.volume_slider.blockSignals(False)
        
        # Show volume popup and reset hide timer (this allows rapid volume changes)
        # The timer will be reset on each call, allowing continuous adjustments
        self.show_volume_control(auto_hide=True, delay_ms=1200)
    
    def apply_volume(self):
        """Apply saved volume level to audio element"""
        # Use the same volume change logic
        self.on_volume_changed(self.volume_level)
        # Update slider value
        if hasattr(self, 'volume_slider') and self.volume_slider:
            self.volume_slider.setValue(self.volume_level)
    
    def on_paste_url(self):
        """Paste URL from clipboard and auto-load"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        if text:
            # Take first URL only (player can only handle one at a time)
            # Split by newlines and take first line
            lines = [line.strip() for line in text.split('\n') if line.strip()]
            url = lines[0] if lines else text
            
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Auto-add to playlist and switch if it's a Bandcamp URL
            if 'bandcamp.com' in url.lower():
                # Add to playlist if not already there
                playlist = self.playlist_manager.get_playlist()
                if url not in playlist:
                    self.playlist_manager.add_url(url)
                    self.update_playlist_display()
                # Switch to this URL automatically
            self.load_url(url)
    
    def changeEvent(self, event):
        """Handle window state changes (minimize/restore) to sync detached playlist and nano mode."""
        if event.type() == QEvent.Type.WindowStateChange:
            # Skip nano mode activation if we're doing a quick sync cycle
            if self._doing_quick_sync:
                return
            
            # Check if main window is minimized
            if self.isMinimized():
                # If minimize button was clicked, don't trigger nano mode (regular minimize)
                if self._minimize_button_clicked:
                    self._minimize_button_clicked = False  # Reset flag
                    # Regular minimize - minimize detached playlist if it exists and isn't already minimized
                    if (self.playlist_detached and 
                        hasattr(self, 'detached_playlist_window') and 
                        self.detached_playlist_window and 
                        not self.detached_playlist_window.isMinimized()):
                        try:
                            # Set flag BEFORE minimizing to avoid race condition with eventFilter
                            self._detached_playlist_minimized_by_main = True
                            self.detached_playlist_window.showMinimized()
                        except Exception:
                            self._detached_playlist_minimized_by_main = False
                # Check if nano mode is enabled (only if minimize button wasn't clicked)
                elif self.nano_mode_on_minimize:
                    # Hide main window and detached playlist, show nano player
                    self._enter_nano_mode()
                else:
                    # Regular minimize - minimize detached playlist if it exists and isn't already minimized
                    if (self.playlist_detached and 
                        hasattr(self, 'detached_playlist_window') and 
                        self.detached_playlist_window and 
                        not self.detached_playlist_window.isMinimized()):
                        try:
                            # Set flag BEFORE minimizing to avoid race condition with eventFilter
                            self._detached_playlist_minimized_by_main = True
                            self.detached_playlist_window.showMinimized()
                        except Exception:
                            self._detached_playlist_minimized_by_main = False
            else:
                # Main window was restored
                self._minimize_button_clicked = False  # Reset flag on restore
                if self._main_window_hidden_for_nano:
                    # Restore from nano mode
                    self._exit_nano_mode()
                else:
                    # Regular restore - restore detached playlist if we minimized it
                    if (self._detached_playlist_minimized_by_main and 
                        self.playlist_detached and 
                        hasattr(self, 'detached_playlist_window') and 
                        self.detached_playlist_window):
                        try:
                            if self.detached_playlist_window.isMinimized():
                                self.detached_playlist_window.showNormal()
                            self._detached_playlist_minimized_by_main = False
                        except Exception:
                            self._detached_playlist_minimized_by_main = False
        
        # Call parent's changeEvent
        super().changeEvent(event)
    
    def eventFilter(self, obj, event):
        """Event filter to detect paste events in URL input and handle drag/drop on central widget"""
        # Handle interactions with volume popup
        if obj == self.volume_popup and self.volume_popup and self.volume_popup.isVisible():
            # Cancel hide timer when mouse enters popup - keep it visible while hovering
            if event.type() == QEvent.Type.Enter:
                if self.volume_hide_timer:
                    self.volume_hide_timer.stop()
            # Restart hide timer when mouse leaves popup
            elif event.type() == QEvent.Type.Leave:
                self._schedule_volume_popup_hide(delay_ms=1200)
            # Handle mouse wheel to adjust volume
            elif event.type() == QEvent.Type.Wheel:
                # Cancel any hide timer since user is interacting
                if self.volume_hide_timer:
                    self.volume_hide_timer.stop()
                # Get wheel delta (positive = scroll up, negative = scroll down)
                delta = event.angleDelta().y()
                if delta > 0:
                    # Scroll up = increase volume
                    self.volume_up()
                elif delta < 0:
                    # Scroll down = decrease volume
                    self.volume_down()
                # Don't restart timer - keep visible while hovering
                return True  # Event handled
            # Reset timer on any mouse interaction with the popup (except wheel, handled above)
            elif event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.MouseMove):
                # Cancel timer on interaction, but don't restart - keep visible while hovering
                if self.volume_hide_timer:
                    self.volume_hide_timer.stop()
        
        # Handle clicks outside volume popup to close it with fade out
        if self.volume_popup and self.volume_popup.isVisible():
            if event.type() == QEvent.Type.MouseButtonPress:
                # Check if click is outside the popup
                click_pos = event.globalPosition().toPoint() if hasattr(event, 'globalPosition') else QCursor.pos()
                popup_rect = QRect(
                    self.volume_popup.mapToGlobal(QPoint(0, 0)),
                    self.volume_popup.size()
                )
                if not popup_rect.contains(click_pos):
                    # Also check if click is on the volume button (which should toggle)
                    if obj != self.volume_btn:
                        # Fade out when clicking away
                        self._hide_volume_popup()
        
        # Handle mouse events in controls bar to keep address bar visible
        if obj == self.controls_bar_widget:
            # In all modes (including regular), don't show address bar on mouse events - only show on trigger button hover
            if event.type() == QEvent.Type.MouseMove:
                # Mouse is moving within address bar
                if self.autohide_address_bar:
                    # In all modes, don't show on mouse move - only show on trigger button hover
                    return False
            elif event.type() == QEvent.Type.Enter:
                # Mouse entered address bar
                if self.autohide_address_bar:
                    # In all modes, don't show on enter - only show on trigger button hover
                    return False
            elif event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.MouseButtonRelease, QEvent.Type.Wheel):
                # Reset failsafe timer on any mouse interaction
                if self.autohide_address_bar:
                    self._reset_address_bar_failsafe_timer()
        
        # Handle drag and drop on central widget
        if obj == self.centralWidget():
            if event.type() == event.Type.DragEnter:
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                    return True
            elif event.type() == event.Type.Drop:
                url = None
                if event.mimeData().hasUrls():
                    urls = event.mimeData().urls()
                    if urls:
                        url = urls[0].toString()
                elif event.mimeData().hasText():
                    # Get text and take first URL only (player can only handle one at a time)
                    text = event.mimeData().text().strip()
                    if text:
                        # Split by newlines and take first line
                        lines = [line.strip() for line in text.split('\n') if line.strip()]
                        if lines:
                            url = lines[0]
                
                if url:
                    self._handle_global_drop(url)
                    event.acceptProposedAction()
                    return True
        
        # Handle keyboard events to reset failsafe timer when typing
        if self.autohide_address_bar and hasattr(self, 'controls_bar_widget'):
            if obj == self.controls_bar_widget or (hasattr(self, 'url_input') and obj == self.url_input):
                if event.type() in (QEvent.Type.KeyPress, QEvent.Type.KeyRelease, QEvent.Type.FocusIn):
                    # Reset failsafe timer on keyboard input or focus
                    self._reset_address_bar_failsafe_timer()
        
        # Handle detached playlist window move/resize events
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and obj == self.detached_playlist_window:
            # Handle window state changes (independent minimize/restore)
            if event.type() == QEvent.Type.WindowStateChange:
                # If the detached playlist window state changed independently (not by main window),
                # clear the flag so we don't try to restore it when main window restores
                # We detect this by checking if the change wasn't triggered by our changeEvent
                # (which would have set the flag). If the flag is not set, this is an independent change.
                if not self._detached_playlist_minimized_by_main:
                    # Independent state change - clear any pending restore
                    self._detached_playlist_minimized_by_main = False
                # If flag is set but window was independently restored, clear the flag
                elif self._detached_playlist_minimized_by_main and not self.detached_playlist_window.isMinimized():
                    # User independently restored it, so clear our flag
                    self._detached_playlist_minimized_by_main = False
            
            if event.type() == QEvent.Type.Move or event.type() == QEvent.Type.Resize:
                # If this Move is from our own link-mode programmatic move, use it to clear the guard
                if event.type() == QEvent.Type.Move and self._moving_detached_playlist_programmatically:
                    try:
                        if self._last_programmatic_detached_pos:
                            target_x, target_y = self._last_programmatic_detached_pos
                            cur_x = self.detached_playlist_window.x()
                            cur_y = self.detached_playlist_window.y()
                            if cur_x == target_x and cur_y == target_y:
                                # Only clear the guard if we're not actively moving via link-mode throttle
                                if not (hasattr(self, '_linked_move_timer') and self._linked_move_timer and self._linked_move_timer.isActive()):
                                    self._moving_detached_playlist_programmatically = False
                                    self._last_programmatic_detached_pos = None
                    except Exception:
                        if not (hasattr(self, '_linked_move_timer') and self._linked_move_timer and self._linked_move_timer.isActive()):
                            self._moving_detached_playlist_programmatically = False
                            self._last_programmatic_detached_pos = None

                # Check for automatic docking at screen edges
                if event.type() == QEvent.Type.Move:
                    if hasattr(self, '_check_windows_dock_to_screen_edge'):
                        self._check_windows_dock_to_screen_edge()
                
                # Handle window snapping when moving (only while dragging, not in release window, and not broken away)
                # Don't snap while link mode is enabled (snapping fights the link motion)
                # Release window gives a brief grace period after unlinking to allow easy breakaway
                if event.type() == QEvent.Type.Move and (not self.playlist_window_linked) and not self._moving_detached_playlist_programmatically and self._is_dragging_playlist_window and not self._playlist_release_window_active and not self._playlist_breakaway_activated:
                    # Check breakaway: if playlist is moving away from main window, disable snapping
                    current_pos = self.detached_playlist_window.pos()
                    current_dist = self._calculate_distance_to_main_window(current_pos)
                    breakaway_threshold = 10  # Fixed 10px threshold for breakaway
                    
                    if self._playlist_drag_start_pos:
                        start_dist = self._calculate_distance_to_main_window(self._playlist_drag_start_pos)
                        
                        # If distance increased by breakaway threshold, activate breakaway
                        if current_dist > start_dist + breakaway_threshold:
                            self._playlist_breakaway_activated = True
                        # If distance decreased (dragging back toward main window), reset breakaway
                        elif current_dist < start_dist:
                            self._playlist_breakaway_activated = False
                            # Update start position to current position for new reference
                            self._playlist_drag_start_pos = current_pos
                    
                    # Enable snapping if not linked, not in release window, and (not broken away OR windows are close enough to snap)
                    # Release window gives a brief grace period after unlinking to allow easy breakaway
                    # This allows snapping to re-engage if user drags back toward main window
                    can_snap = (not self.playlist_window_linked and 
                               not self._playlist_release_window_active and
                               (not self._playlist_breakaway_activated or current_dist <= self._snap_threshold))
                    if can_snap:
                        # Snap immediately while dragging (more forceful, like nano player)
                        if self._handle_playlist_window_snapping():
                            self._snapped_during_drag = True
                            # Reset breakaway if we snap (user is dragging toward main window)
                            self._playlist_breakaway_activated = False
                            # Reset drag start position since we snapped (new reference point)
                            self._playlist_drag_start_pos = current_pos
                
                # Handle window linking if enabled
                if self.playlist_window_linked and event.type() == QEvent.Type.Move:
                    self._handle_detached_playlist_window_movement(event)
                
                # Update bottom resize handle position on resize
                if event.type() == QEvent.Type.Resize:
                    if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                        QTimer.singleShot(10, self._update_detached_bottom_resize_handle_position)
                    # Update rounded corners on resize
                    if hasattr(self, '_apply_detached_rounded_corners'):
                        QTimer.singleShot(10, self._apply_detached_rounded_corners)
                
                # Save position/size when window is moved or resized (debounced)
                try:
                    pos = self.detached_playlist_window.pos()
                    size = self.detached_playlist_window.size()
                    # Save absolute position
                    self.playlist_detached_position = (pos.x(), pos.y())
                    # Also save relative offset for backward compatibility
                    main_pos = self.pos()
                    self.playlist_detached_offset = (pos.x() - main_pos.x(), pos.y() - main_pos.y())
                    self.playlist_detached_size = f"{size.width()}x{size.height()}"
                    # Debounce saves to avoid too many writes
                    if not hasattr(self, '_playlist_detach_save_timer'):
                        self._playlist_detach_save_timer = QTimer()
                        self._playlist_detach_save_timer.setSingleShot(True)
                        self._playlist_detach_save_timer.timeout.connect(self._save_playlist_detach_state)
                    self._playlist_detach_save_timer.stop()
                    self._playlist_detach_save_timer.start(500)  # Save after 500ms of no changes
                except Exception as e:
                    logger.debug(f"Error saving detached playlist position: {e}")
        
        # Handle main window move events for link mode (handled in moveEvent override instead)
        
        return super().eventFilter(obj, event)
    
    def setup_keyboard_shortcuts(self):
        """Setup customizable keyboard shortcuts"""
        # Load shortcuts from settings or use defaults
        shortcuts = self.settings.get("keyboard_shortcuts", {})
        default_shortcuts = KeyboardShortcutsDialog.DEFAULT_SHORTCUTS
        
        # Merge defaults with saved shortcuts
        all_shortcuts = {**default_shortcuts, **shortcuts}
        
        # Store shortcuts for later use
        self.keyboard_shortcuts = {}
        
        # Action mapping
        action_map = {
            "play_pause": self._trigger_play_pause,
            "next_track": self._trigger_next_track,
            "previous_track": self._trigger_previous_track,
            "next_album": lambda: self.playlist_sidebar.load_next_album() if hasattr(self, 'playlist_sidebar') else None,
            "previous_album": lambda: self.playlist_sidebar.load_previous_album() if hasattr(self, 'playlist_sidebar') else None,
            "volume_up": self.volume_up,
            "volume_down": self.volume_down,
            "mute": self.toggle_mute,
            "toggle_playlist": self.toggle_playlist,
            "toggle_playlist_expand": self.toggle_playlist_expand,
            "cycle_app_mode": self.toggle_mini_mode,  # toggle_mini_mode already cycles through modes
            "save_playlist": self.save_current_playlist_shortcut,
        }
        
        # Create shortcuts
        for key, action in action_map.items():
            shortcut_str = all_shortcuts.get(key)
            if shortcut_str:
                try:
                    shortcut = QShortcut(QKeySequence(shortcut_str), self)
                    shortcut.setContext(Qt.ShortcutContext.WindowShortcut)  # Make shortcuts work when window has focus
                    shortcut.activated.connect(action)
                    self.keyboard_shortcuts[key] = shortcut
                    logger.debug(f"Keyboard shortcut set: {shortcut_str} for {key}")
                except Exception as e:
                    logger.warning(f"Could not set shortcut {shortcut_str} for {key}: {e}")
                    # Only log full traceback in debug mode
                    if os.environ.get('DEBUG'):
                        import traceback
                        logger.warning(traceback.format_exc())
        
        logger.debug(f"Keyboard shortcuts loaded: {len(self.keyboard_shortcuts)} shortcuts active")
    
    def save_current_playlist_shortcut(self):
        """Save current playlist (called from keyboard shortcut)"""
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            self.playlist_sidebar.save_current_playlist()
        else:
            # If playlist sidebar doesn't exist, try to save directly
            if hasattr(self, 'playlist_manager') and self.playlist_manager:
                if self.playlist_manager.save_playlist():
                    self.save_settings()
                    # Show tooltip feedback
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        global_pos = self.playlist_sidebar.list_widget.mapToGlobal(self.playlist_sidebar.list_widget.rect().center())
                        playlist_name = self.playlist_manager.get_current_playlist_name()
                        QToolTip.showText(global_pos, f"Saved: {playlist_name}", self.playlist_sidebar.list_widget, QRect(), 1500)
    
    def show_keyboard_shortcuts_dialog(self):
        """Show keyboard shortcuts configuration dialog"""
        current_shortcuts = self.settings.get("keyboard_shortcuts", {})
        dialog = KeyboardShortcutsDialog(self, current_shortcuts)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Save new shortcuts
            new_shortcuts = dialog.get_shortcuts()
            self.settings["keyboard_shortcuts"] = new_shortcuts
            self.save_settings()
            
            # Recreate shortcuts with new values
            # First, remove old shortcuts
            for shortcut in self.keyboard_shortcuts.values():
                shortcut.setParent(None)
            self.keyboard_shortcuts.clear()
            
            # Create new shortcuts
            self.setup_keyboard_shortcuts()
            
            logger.debug("Keyboard shortcuts updated")
    
    def setup_media_key_listener(self):
        """Legacy method name - now calls setup_keyboard_shortcuts"""
        self.setup_keyboard_shortcuts()
    
    def setup_ipc_server(self):
        """Setup named pipe server for AutoHotkey communication"""
        if sys.platform != 'win32':
            return
        
        try:
            # Create local server (named pipe on Windows)
            self.ipc_server = QLocalServer(self)
            server_name = "BandcampPlayerIPC"
            
            # Remove any existing server with the same name
            QLocalServer.removeServer(server_name)
            
            # Start listening
            if self.ipc_server.listen(server_name):
                self.ipc_server.newConnection.connect(self._handle_ipc_connection)
                # On Windows, QLocalServer creates a pipe at \\.\pipe\ServerName
                # Log the full pipe path for debugging
                full_pipe_name = f"\\\\.\\pipe\\{server_name}"
                logger.info(f"IPC server started: {server_name} (pipe: {full_pipe_name})")
            else:
                error_msg = self.ipc_server.errorString()
                logger.warning(f"Failed to start IPC server: {error_msg}")
        except Exception as e:
            logger.warning(f"Error setting up IPC server: {e}")
            import traceback
            logger.debug(traceback.format_exc())
    
    def _handle_ipc_connection(self):
        """Handle new IPC connection from AutoHotkey"""
        try:
            socket = self.ipc_server.nextPendingConnection()
            if socket:
                logger.info("IPC client connected from AutoHotkey")
                # Connect readyRead signal - use a lambda that captures the socket
                def read_command():
                    self._read_ipc_command(socket)
                socket.readyRead.connect(read_command)
                socket.disconnected.connect(socket.deleteLater)
        except Exception as e:
            logger.warning(f"Error handling IPC connection: {e}")
            import traceback
            logger.debug(traceback.format_exc())
    
    def _read_ipc_command(self, socket):
        """Read command from IPC socket"""
        try:
            # Read all available data
            while socket.bytesAvailable() > 0:
                data = socket.readAll().data()
                command = data.decode('utf-8').strip()
                
                logger.info(f"IPC command received: {command}")
                
                # Process commands
                if command == "next":
                    QTimer.singleShot(0, self._trigger_next_track)
                elif command == "prev":
                    QTimer.singleShot(0, self._trigger_previous_track)
                elif command == "playpause":
                    QTimer.singleShot(0, self._trigger_play_pause)
                elif command == "next_album":
                    QTimer.singleShot(0, lambda: self.playlist_sidebar.load_next_album() if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else None)
                elif command == "prev_album":
                    QTimer.singleShot(0, lambda: self.playlist_sidebar.load_previous_album() if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else None)
                elif command == "volume_up":
                    QTimer.singleShot(0, self.volume_up)
                elif command == "volume_down":
                    QTimer.singleShot(0, self.volume_down)
                elif command == "mute":
                    QTimer.singleShot(0, self.toggle_mute)
                elif command == "toggle_playlist":
                    QTimer.singleShot(0, self.toggle_playlist)
                elif command == "toggle_playlist_expand":
                    QTimer.singleShot(0, self.toggle_playlist_expand)
                elif command == "cycle_app_mode":
                    QTimer.singleShot(0, self.toggle_mini_mode)
        except Exception as e:
            logger.warning(f"Error reading IPC command: {e}")
            import traceback
            logger.debug(traceback.format_exc())
    
    def _trigger_next_track(self):
        """Trigger next track via JavaScript"""
        logger.debug("_trigger_next_track called")
        if not self.web_view or not self.web_view.page():
            logger.warning("_trigger_next_track: web_view or page not available")
            return
        
        js_code = """
        (function() {
            console.log('Bandcamp Player: Attempting to trigger next track...');
            
            // Try multiple methods to trigger next track
            // Method 1: Click the next button directly
            var nextBtn = document.querySelector('button[aria-label="Skip to next song"]');
            if (nextBtn) {
                var isDisabled = nextBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found next button, disabled:', isDisabled);
                if (!isDisabled) {
                    nextBtn.click();
                    console.log('Bandcamp Player: Clicked next button');
                    return;
                }
            } else {
                console.log('Bandcamp Player: Next button not found with aria-label="Skip to next song"');
            }
            
            // Method 2: Try alternative selectors for next button
            var altNextBtn = document.querySelector('.next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
            if (altNextBtn) {
                var isDisabled = altNextBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found alternative next button, disabled:', isDisabled);
                if (!isDisabled) {
                    altNextBtn.click();
                    console.log('Bandcamp Player: Clicked alternative next button');
                    return;
                }
            }
            
            // Method 3: Try to access Knockout.js view model and call player.next()
            try {
                // Bandcamp uses Knockout.js - try to find the player view model
                var playerElement = document.querySelector('#player');
                if (playerElement) {
                    // Try ko.contextFor
                    if (typeof ko !== 'undefined' && ko.contextFor) {
                        var context = ko.contextFor(playerElement);
                        if (context && context.$data && context.$data.player && typeof context.$data.player.next === 'function') {
                            context.$data.player.next();
                            console.log('Bandcamp Player: Called player.next() via Knockout context');
                            return;
                        }
                    }
                    
                    // Try __ko__ property
                    if (playerElement.__ko__) {
                        var context = playerElement.__ko__;
                        if (context && context.$data && context.$data.player && typeof context.$data.player.next === 'function') {
                            context.$data.player.next();
                            console.log('Bandcamp Player: Called player.next() via __ko__');
                            return;
                        }
                    }
                }
                
                // Try global player object
                if (typeof window.player !== 'undefined' && typeof window.player.next === 'function') {
                    window.player.next();
                    console.log('Bandcamp Player: Called window.player.next()');
                    return;
                }
            } catch (e) {
                console.log('Bandcamp Player: Could not access player.next() via view model:', e);
            }
            
            console.log('Bandcamp Player: Could not find next track button or method');
        })();
        """
        self.web_view.page().runJavaScript(js_code)
    
    def _trigger_previous_track(self):
        """Trigger previous track via JavaScript"""
        logger.debug("_trigger_previous_track called")
        if not self.web_view or not self.web_view.page():
            logger.warning("_trigger_previous_track: web_view or page not available")
            return
        
        js_code = """
        (function() {
            console.log('Bandcamp Player: Attempting to trigger previous track...');
            
            // Try multiple methods to trigger previous track
            // Method 1: Click the previous button directly
            var prevBtn = document.querySelector('button[aria-label="Skip to previous song"]');
            if (prevBtn) {
                var isDisabled = prevBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found previous button, disabled:', isDisabled);
                if (!isDisabled) {
                    prevBtn.click();
                    console.log('Bandcamp Player: Clicked previous button');
                    return;
                }
            } else {
                console.log('Bandcamp Player: Previous button not found with aria-label="Skip to previous song"');
            }
            
            // Method 2: Try alternative selectors for previous button
            var altPrevBtn = document.querySelector('.next-prev-controls button[aria-label*="previous"], .next-prev-controls button[aria-label*="Previous"], button[aria-label*="Skip to previous"]');
            if (altPrevBtn) {
                var isDisabled = altPrevBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found alternative previous button, disabled:', isDisabled);
                if (!isDisabled) {
                    altPrevBtn.click();
                    console.log('Bandcamp Player: Clicked alternative previous button');
                    return;
                }
            }
            
            // Method 3: Try to access Knockout.js view model and call player.prev()
            try {
                // Bandcamp uses Knockout.js - try to find the player view model
                var playerElement = document.querySelector('#player');
                if (playerElement) {
                    // Try ko.contextFor
                    if (typeof ko !== 'undefined' && ko.contextFor) {
                        var context = ko.contextFor(playerElement);
                        if (context && context.$data && context.$data.player && typeof context.$data.player.prev === 'function') {
                            context.$data.player.prev();
                            console.log('Bandcamp Player: Called player.prev() via Knockout context');
                            return;
                        }
                    }
                    
                    // Try __ko__ property
                    if (playerElement.__ko__) {
                        var context = playerElement.__ko__;
                        if (context && context.$data && context.$data.player && typeof context.$data.player.prev === 'function') {
                            context.$data.player.prev();
                            console.log('Bandcamp Player: Called player.prev() via __ko__');
                            return;
                        }
                    }
                }
                
                // Try global player object
                if (typeof window.player !== 'undefined' && typeof window.player.prev === 'function') {
                    window.player.prev();
                    console.log('Bandcamp Player: Called window.player.prev()');
                    return;
                }
            } catch (e) {
                console.log('Bandcamp Player: Could not access player.prev() via view model:', e);
            }
            
            console.log('Bandcamp Player: Could not find previous track button or method');
        })();
        """
        self.web_view.page().runJavaScript(js_code)
    
    def _trigger_play_pause(self):
        """Trigger play/pause via JavaScript"""
        logger.debug("_trigger_play_pause called")
        if not self.web_view or not self.web_view.page():
            logger.warning("_trigger_play_pause: web_view or page not available")
            return
        
        js_code = """
        (function() {
            console.log('Bandcamp Player: Attempting to trigger play/pause...');
            
            // Try multiple methods to trigger play/pause
            // Method 1: Click the play/pause button directly
            var playPauseBtn = document.querySelector('button[aria-label="Play"], button[aria-label="Pause"], button[aria-label="Play song"], button[aria-label="Pause song"]');
            if (playPauseBtn) {
                var isDisabled = playPauseBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found play/pause button, disabled:', isDisabled);
                if (!isDisabled) {
                    playPauseBtn.click();
                    console.log('Bandcamp Player: Clicked play/pause button');
                    return;
                }
            } else {
                console.log('Bandcamp Player: Play/pause button not found with standard aria-label');
            }
            
            // Method 2: Try alternative selectors for play/pause button
            var altPlayPauseBtn = document.querySelector('.playbutton, .pausebutton, .play-btn, .pause-btn, button[title*="play"], button[title*="Play"], button[title*="pause"], button[title*="Pause"]');
            if (altPlayPauseBtn) {
                var isDisabled = altPlayPauseBtn.getAttribute('aria-disabled') === 'true';
                console.log('Bandcamp Player: Found alternative play/pause button, disabled:', isDisabled);
                if (!isDisabled) {
                    altPlayPauseBtn.click();
                    console.log('Bandcamp Player: Clicked alternative play/pause button');
                    return;
                }
            }
            
            // Method 3: Try to access Knockout.js view model and call player.play() or player.pause()
            try {
                // Bandcamp uses Knockout.js - try to find the player view model
                var playerElement = document.querySelector('#player');
                if (playerElement) {
                    // Try ko.contextFor
                    if (typeof ko !== 'undefined' && ko.contextFor) {
                        var context = ko.contextFor(playerElement);
                        if (context && context.$data && context.$data.player) {
                            // Check if playing and toggle
                            if (context.$data.player.playing && typeof context.$data.player.pause === 'function') {
                                context.$data.player.pause();
                                console.log('Bandcamp Player: Called player.pause() via Knockout context');
                                return;
                            } else if (typeof context.$data.player.play === 'function') {
                                context.$data.player.play();
                                console.log('Bandcamp Player: Called player.play() via Knockout context');
                                return;
                            }
                        }
                    }
                    
                    // Try __ko__ property
                    if (playerElement.__ko__) {
                        var context = playerElement.__ko__;
                        if (context && context.$data && context.$data.player) {
                            // Check if playing and toggle
                            if (context.$data.player.playing && typeof context.$data.player.pause === 'function') {
                                context.$data.player.pause();
                                console.log('Bandcamp Player: Called player.pause() via __ko__');
                                return;
                            } else if (typeof context.$data.player.play === 'function') {
                                context.$data.player.play();
                                console.log('Bandcamp Player: Called player.play() via __ko__');
                                return;
                            }
                        }
                    }
                }
                
                // Try global player object
                if (typeof window.player !== 'undefined') {
                    if (window.player.playing && typeof window.player.pause === 'function') {
                        window.player.pause();
                        console.log('Bandcamp Player: Called window.player.pause()');
                        return;
                    } else if (typeof window.player.play === 'function') {
                        window.player.play();
                        console.log('Bandcamp Player: Called window.player.play()');
                        return;
                    }
                }
            } catch (e) {
                console.log('Bandcamp Player: Could not access player.play()/pause() via view model:', e);
            }
            
            console.log('Bandcamp Player: Could not find play/pause button or method');
        })();
        """
        self.web_view.page().runJavaScript(js_code)
    
    def resolve_url_redirects(self, url):
        """Resolve URL redirects to get final destination.
        
        Only resolves URLs that don't already contain 'bandcamp.com'.
        If the URL already contains 'bandcamp.com', returns it unchanged.
        If resolution succeeds and final URL contains 'bandcamp.com', returns the final URL.
        If resolution fails or final URL doesn't contain 'bandcamp.com', returns None.
        
        Args:
            url: URL string to resolve
            
        Returns:
            Final URL after redirects (if it resolves to Bandcamp), original URL (if already Bandcamp),
            or None (if resolution fails or doesn't resolve to Bandcamp)
        """
        if not url or not isinstance(url, str):
            return None
        
        url = url.strip()
        url_lower = url.lower()
        
        # If URL already contains bandcamp.com, no need to resolve
        if 'bandcamp.com' in url_lower:
            return url
        
        # Only resolve URLs that start with http:// or https://
        if not (url_lower.startswith('http://') or url_lower.startswith('https://')):
            return None
        
        try:
            # Create a request with a timeout and follow redirects
            # Use HEAD request first (faster, doesn't download body)
            req = urllib.request.Request(url, method='HEAD')
            req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
            
            # Open with redirect handling and timeout
            with urllib.request.urlopen(req, timeout=5) as response:
                # Get the final URL after redirects
                final_url = response.geturl()
                
                # Check if final URL contains bandcamp.com
                if 'bandcamp.com' in final_url.lower():
                    return final_url
                else:
                    # Resolved but not to Bandcamp - reject
                    return None
                    
        except urllib.error.HTTPError as e:
            # HTTP error (404, 500, etc.) - try GET request as fallback
            # Some servers don't respond to HEAD requests
            try:
                req = urllib.request.Request(url)
                req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
                with urllib.request.urlopen(req, timeout=5) as response:
                    final_url = response.geturl()
                    if 'bandcamp.com' in final_url.lower():
                        return final_url
                    return None
            except Exception as e:
                logger.debug(f"URL resolution fallback failed: {e}")
                return None
        except (urllib.error.URLError, TimeoutError, OSError) as e:
            # Network error, timeout, or connection refused
            logger.debug(f"URL resolution failed (network error): {e}")
            return None
        except Exception as e:
            # Any other error
            logger.warning(f"URL resolution failed (unexpected error): {e}")
            return None
    
    def handle_paste(self):
        """Handle paste event - auto-add to playlist and switch (only first URL)"""
        clipboard = QApplication.clipboard()
        text = clipboard.text().strip()
        if text:
            # Take first URL only (player can only handle one at a time)
            # Split by newlines and take first line
            lines = [line.strip() for line in text.split('\n') if line.strip()]
            url = lines[0] if lines else text
            
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Check if it's a Bandcamp URL (either original or resolved)
            if 'bandcamp.com' in url.lower():
                # Add to playlist if not already there
                playlist = self.playlist_manager.get_playlist()
                if url not in playlist:
                    self.playlist_manager.add_url(url)
                    self.update_playlist_display()
                # Switch to this URL automatically
                self.load_url(url)
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event for the entire window"""
        # Check if the event is coming from a child widget
        source = event.source()
        if source and source != self:
            # If it's from a child widget, accept it here
            if event.mimeData().hasUrls() or event.mimeData().hasText():
                event.acceptProposedAction()
                return
        
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def dropEvent(self, event: QDropEvent):
        """Handle drop event anywhere on the window - route to paste handler"""
        # Check if the drop target is the playlist sidebar - if so, let it handle it
        # Get position relative to this widget
        try:
            pos = event.position().toPoint()
        except AttributeError:
            # Fallback for older PyQt6 versions
            pos = event.pos()
        
        widget_at_pos = self.childAt(pos)
        
        # Walk up the widget hierarchy to check if we're dropping on the playlist sidebar
        current_widget = widget_at_pos
        while current_widget:
            if isinstance(current_widget, PlaylistSidebar):
                # Let the playlist sidebar handle the drop (it will add to playlist)
                event.ignore()
                return
            current_widget = current_widget.parentWidget()
        
        # Also check if playlist sidebar is visible and position is within its bounds
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar.isVisible() and not self.playlist_detached:
            global_pos = self.mapToGlobal(pos)
            sidebar_global_rect = QRect(
                self.playlist_sidebar.mapToGlobal(QPoint(0, 0)),
                self.playlist_sidebar.size()
            )
            if sidebar_global_rect.contains(global_pos):
                # Drop is on the playlist sidebar, let it handle it
                event.ignore()
                return
        
        url = None
        
        # Try to get URL from dropped data
        if event.mimeData().hasUrls():
            # Get first URL from dropped files/links
            urls = event.mimeData().urls()
            if urls:
                url = urls[0].toString()
        elif event.mimeData().hasText():
            # Get text and take first URL only (player can only handle one at a time)
            text = event.mimeData().text().strip()
            if text:
                # Split by newlines and take first line
                lines = [line.strip() for line in text.split('\n') if line.strip()]
                if lines:
                    url = lines[0]
        
        if url:
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Auto-load if it's a Bandcamp URL
            if 'bandcamp.com' in url.lower():
                # Add to playlist if not already there
                playlist = self.playlist_manager.get_playlist()
                if url not in playlist:
                    self.playlist_manager.add_url(url)
                    self.update_playlist_display()
                # Load the URL
                self.load_url(url)
        
        event.acceptProposedAction()
    
    def _handle_global_drop(self, url):
        """Helper method to handle dropped URLs from anywhere"""
        if url:
            # Try to resolve redirects if it's not already a Bandcamp URL
            resolved_url = self.resolve_url_redirects(url)
            if resolved_url:
                url = resolved_url
            
            # Auto-load if it's a Bandcamp URL
            if 'bandcamp.com' in url.lower():
                # Add to playlist if not already there
                playlist = self.playlist_manager.get_playlist()
                if url not in playlist:
                    self.playlist_manager.add_url(url)
                    self.update_playlist_display()
                # Load the URL
                self.load_url(url)
            else:
                # Not a Bandcamp URL, just set it in the field
                self.url_input.setFocus()
    
    def load_url(self, url, is_startup_load=None):
        """Load a URL in the web view
        
        Args:
            url: The URL to load
            is_startup_load: Optional flag to explicitly mark this as a startup load.
                           If None, will check if _is_startup_load is already set.
        """
        # If is_startup_load is explicitly provided, use it
        # Otherwise, if _is_startup_load is already True, preserve it (it was set in deferred_init)
        # Only reset to False if it's not a startup load and wasn't already set
        if is_startup_load is not None:
            self._is_startup_load = is_startup_load
        elif not hasattr(self, '_is_startup_load') or not self._is_startup_load:
            # Not a startup load - ensure flag is False
            self._is_startup_load = False
        
        # Clear Super Shuffle flag if this is not a Super Shuffle load
        # (Super Shuffle sets this flag before calling load_url)
        if not hasattr(self, '_is_super_shuffle_load') or not self._is_super_shuffle_load:
            self._is_super_shuffle_load = False
            self._super_shuffle_album_url = None
        
        # If in mini or micro mode, minimize playlist if it's expanded
        # BUT: never auto-minimize when the playlist is detached (it breaks detached UX).
        if (self.mini_mode_state == 1 or self.mini_mode_state == 2):
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                try:
                    if getattr(self, 'playlist_detached', False):
                        # Detached playlist should stay usable/expanded.
                        # If it somehow is minimized, un-minimize it (safe no-op otherwise).
                        if getattr(self.playlist_sidebar, 'is_minimized', False):
                            self.playlist_sidebar._toggle_minimize_state()
                    else:
                        if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized:
                            # Minimize the attached playlist
                            self.playlist_sidebar._toggle_minimize_state()
                except Exception:
                    # Never let playlist minimize logic interfere with loading a URL
                    pass
        
        # Reset first playback detection flag for new URL load
        self._first_playback_detected = False
        # Stop any existing first playback check timer
        if hasattr(self, '_first_playback_check_timer') and self._first_playback_check_timer:
            self._first_playback_check_timer.stop()
        # Reset JavaScript flag for new URL load
        if self.web_view:
            self.web_view.page().runJavaScript("window.bandcampFirstPlaybackDetected = false; window.bandcampFirstPlaybackSetup = false;")
        
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url
        
        # Try to resolve redirects if it's not already a Bandcamp URL
        resolved_url = self.resolve_url_redirects(url)
        if resolved_url:
            url = resolved_url
        
        # Ensure it's a Bandcamp URL
        if 'bandcamp.com' not in url.lower():
            QMessageBox.warning(self, "Invalid URL", "Please enter a Bandcamp URL")
            return
        
        # Hide welcome widget if it's visible (URL is being loaded)
        if self.welcome_widget and self.welcome_widget.isVisible():
            self.welcome_widget.hide()
            self._has_url_loaded = True
            # Re-enable mode switching now that URL is loaded
            self.update_mini_mode_button()
            self.update_mini_mode_menu_text()
        
        # Set loading state to prevent overlay flicker
        self.is_loading = True
        
        # Disable context menu on web view during loading to prevent crashes
        if self.web_view:
            # Store original context menu policy if not already stored
            if self._original_context_menu_policy is None:
                self._original_context_menu_policy = self.web_view.contextMenuPolicy()
            # Disable context menu during loading
            self.web_view.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)
            self.web_view.hide()  # Hide completely, not just transparent
            self.web_view.setWindowOpacity(0.0)
        
        # Show loading overlay covering entire web view area (playlist will sit on top)
        if self.loading_overlay:
            # Position overlay to cover full height (playlist can be raised above it)
            # This will set the correct geometry based on current window size
            self.update_loading_overlay_geometry()
            # Show overlay and raise it above web view (but playlist container can be raised above overlay)
            # Restore opacity when showing (in case it was set to 0 when hidden)
            self.loading_overlay.setWindowOpacity(1.0)
            self.loading_overlay.show()
            self.loading_overlay.raise_()
            # Ensure playlist stays above overlay if it's visible
            if hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible():
                self.playlist_container.raise_()
            # Clear any existing graphics effects first
            self.loading_overlay.setGraphicsEffect(None)
            # Apply transparency based on setting
            self.apply_overlay_transparency()
        
        # Now load the new URL (web view is hidden, overlay is showing)
        self.web_view.setUrl(QUrl(url))
        # Set placeholder title from URL
        placeholder_title = self.extract_artist_album_from_url(url)
        if not placeholder_title:
            placeholder_title = url
        # Always append "- Bandcamp Player" to the title for reliable window detection
        full_title = f"{placeholder_title} - Bandcamp Player"
        QMainWindow.setWindowTitle(self, full_title)
        if self.window_title_label:
            self.window_title_label.setText(placeholder_title)
        
        # Update playlist sidebar to highlight current item
        # This must happen after URL is resolved and validated
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            # Use a small delay to ensure playlist is ready (in case it's being created)
            QTimer.singleShot(50, lambda: self.playlist_sidebar.update_current_item(url) if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else None)
        
        # Save last played URL to settings
        self.settings['last_played_url'] = url
        self.save_settings()
    
    def on_page_load_started(self):
        """Handle page load start - ensure loading overlay is visible and covering everything"""
        # Set loading state
        self.is_loading = True
        
        # Reset JavaScript injection flag - new page is loading, JavaScript needs to be injected again
        self._js_injected_on_current_page = False
        
        # Disable context menu on web view during loading to prevent crashes
        if self.web_view:
            # Store original context menu policy if not already stored
            if self._original_context_menu_policy is None:
                self._original_context_menu_policy = self.web_view.contextMenuPolicy()
            # Disable context menu during loading
            self.web_view.setContextMenuPolicy(Qt.ContextMenuPolicy.NoContextMenu)
            self.web_view.hide()
            self.web_view.setWindowOpacity(0.0)
        
        # Ensure loading overlay is visible and covering entire web view area
        if self.loading_overlay:
            # Stop any existing animations first to prevent overlay from getting stuck
            if self.loading_overlay.graphicsEffect():
                effect = self.loading_overlay.graphicsEffect()
                if isinstance(effect, QPropertyAnimation):
                    effect.stop()
                # Clear the effect so we can start fresh
                self.loading_overlay.setGraphicsEffect(None)
            # Position overlay to cover full height (playlist can be raised above it)
            self.update_loading_overlay_geometry()
            # Show and raise overlay above web view (but playlist container can be raised above overlay)
            if not self.loading_overlay.isVisible():
                self.loading_overlay.show()
            self.loading_overlay.raise_()
            # Ensure playlist stays above overlay if it's visible
            if hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible():
                self.playlist_container.raise_()
            # Apply transparency based on setting (after clearing old effects)
            self.apply_overlay_transparency()
    
    def on_page_load_progress(self, progress):
        """Handle page load progress - show page early for faster perceived loading"""
        # Show the page when it's 30% loaded (much faster perceived loading)
        if progress >= 30 and self.web_view and not self.web_view.isVisible():
            # Show web view early so user sees content loading
            self.web_view.show()
            self.web_view.raise_()
            # Start with low opacity, will fade in fully after CSS injection
            self.web_view.setWindowOpacity(0.3)
            # Inject CSS early (at 30% load) for faster styling
            if progress == 30:  # Only inject once at 30%
                self.inject_css_with_callback()
    
    def on_page_loaded(self, success):
        """Handle page load completion"""
        # Keep loading state until fade-in completes
        if success:
            # Mark that page has loaded at least once
            self._page_loaded_at_least_once = True
            
            # Reset JavaScript injection flag - new page means we need to inject again
            self._js_injected_on_current_page = False
            
            # Inject CSS if not already injected (fallback)
            if self.web_view and self.web_view.isVisible() and self.web_view.windowOpacity() < 0.5:
                # CSS wasn't injected at 30%, inject now
                self.inject_css_with_callback()
            else:
                # CSS already injected, just ensure it's applied and fade in
                # Always re-inject on page load to ensure image viewer and mini mode JavaScript is set up
                # Use inject_css_with_callback to wait for CSS injection before fading in
                # This prevents showing unstyled content (especially important for fast-loading Super Shuffle)
                self.inject_css_with_callback()
            
            # CRITICAL: Re-inject JavaScript after delays to ensure DOM elements are ready
            # This fixes issues where image viewer and mini mode player don't initialize on startup
            # The delays allow the page to fully render before setting up event handlers
            # Use longer delays for startup to ensure everything is ready
            # On first launch, use even longer delays to ensure everything is properly initialized
            def ensure_js_setup():
                if hasattr(self, 'web_view') and self.web_view and self.web_view.page():
                    # Re-inject to ensure all JavaScript is properly set up
                    # This is especially important on startup when DOM might not be ready yet
                    self.inject_css()
            
            # Check if this is a startup load - use longer delays if so
            is_startup = getattr(self, '_is_startup_load', False)
            # Check if this is first launch (settings file didn't exist) - use even longer delays
            # This works for both startup loads and manually loaded URLs on first launch
            is_first_launch = not self.settings.get('mini_mode_js_fixed', False)
            
            if is_startup or is_first_launch:
                # Startup or first launch: use longer delays to ensure page is fully ready
                # First launch needs even more time as everything is being initialized for the first time
                # This applies to both startup loads AND manually loaded URLs on first launch
                if is_first_launch:
                    # First launch: use very long delays to ensure everything is ready
                    # This is critical for manually loaded URLs on first launch where DOM elements
                    # might not be ready as quickly as on subsequent launches
                    QTimer.singleShot(2000, ensure_js_setup)   # After initial load
                    QTimer.singleShot(4000, ensure_js_setup)   # After more elements load
                    QTimer.singleShot(6000, ensure_js_setup)   # After even more elements load
                    QTimer.singleShot(8000, ensure_js_setup)   # Final catch-all for first launch
                    # Mark that we've done this fix so it doesn't happen again (persists in settings)
                    # Only set the flag after the first successful injection to ensure it works
                    def mark_fixed():
                        self.settings['mini_mode_js_fixed'] = True
                        self.save_settings()
                    QTimer.singleShot(9000, mark_fixed)  # Set flag after all injections complete
                else:
                    # Regular startup: use longer delays to ensure page is fully ready
                    QTimer.singleShot(1000, ensure_js_setup)   # After initial load
                    QTimer.singleShot(2000, ensure_js_setup)   # After more elements load
                    QTimer.singleShot(3500, ensure_js_setup)   # After even more elements load
                    QTimer.singleShot(5000, ensure_js_setup)   # Final catch-all for startup
            else:
                # Regular load: shorter delays (page is usually ready faster)
                QTimer.singleShot(500, ensure_js_setup)   # After initial load
                QTimer.singleShot(1000, ensure_js_setup)   # After more elements load
                QTimer.singleShot(2000, ensure_js_setup)   # Final catch-all
            
            # Force light page detection after page load with multiple retries
            # This ensures light-page class is applied even if detection ran too early
            def trigger_light_page_detection():
                if self.web_view and self.web_view.page():
                    # Call the global function we created in JavaScript
                    self.web_view.page().runJavaScript("""
                        if (typeof window._runLightPageDetection === 'function') {
                            window._runLightPageDetection();
                        }
                    """)
            
            # Run detection multiple times with increasing delays to catch styles as they load
            QTimer.singleShot(300, trigger_light_page_detection)  # After CSS injection
            QTimer.singleShot(600, trigger_light_page_detection)  # After styles compute
            QTimer.singleShot(1000, trigger_light_page_detection)  # Final check
            
            # Check for updates after page has loaded (only once, and only if auto-check is enabled)
            # Delay to ensure JavaScript injection is complete and won't be interfered with
            if not self._update_check_done:
                auto_check_enabled = self.settings.get("auto_check_updates", True)
                if auto_check_enabled:
                    # Determine delay based on whether this is first launch
                    is_first_launch = not self.settings.get('mini_mode_js_fixed', False)
                    if is_first_launch:
                        # First launch: wait until after all JavaScript injections complete (9s)
                        delay = 10000
                    else:
                        # Regular load: wait until after JavaScript injections complete (5s for startup, 2s for regular)
                        if is_startup:
                            delay = 6000
                        else:
                            delay = 3000
                    
                    def check_updates_after_load():
                        if not self._update_check_done:
                            self._update_check_done = True
                            self._check_for_updates_background()
                    
                    QTimer.singleShot(delay, check_updates_after_load)
            
            # Extract title from page and update title bar
            self.update_title_from_page()
            
            # Extract metadata from page DOM and update playlist item
            # Small delay to ensure DOM is fully ready
            QTimer.singleShot(500, self.extract_metadata_from_page)
            
            # Create shuffled track list if Shuffle Tracks mode is active
            if (hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and 
                self.playlist_sidebar.shuffle_mode == 1):
                current_url = self.web_view.url().toString()
                # Delay to ensure tracklist is loaded
                QTimer.singleShot(1000, lambda: self._create_shuffled_track_list(current_url))
            
            # Pick random track for Super Shuffle mode when page is ready
            if hasattr(self, '_is_super_shuffle_load') and self._is_super_shuffle_load:
                # Small delay to ensure tracklist DOM is ready
                QTimer.singleShot(500, self._pick_super_shuffle_track)
            
            # Check if we should activate nano mode after page load (startup)
            if hasattr(self, '_activate_nano_after_page_load') and self._activate_nano_after_page_load:
                # Wait a bit more for CSS injection and mini mode resizing to complete
                # Also ensure playlist is created and restored before entering nano mode
                def activate_nano_after_load():
                    # Ensure playlist is created and restored before entering nano mode
                    # This ensures shuffle/repeat buttons can sync correctly
                    playlist_visible = self.settings.get("playlist_visible", True)  # Default to visible
                    playlist_was_closed = not playlist_visible
                    
                    if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
                        # Playlist doesn't exist - create it to initialize shuffle/repeat states
                        # This is needed even if playlist is closed, so nano player can sync buttons
                        self.toggle_playlist()
                        # If playlist was supposed to be closed, hide it again after initialization
                        if playlist_was_closed:
                            # Small delay to ensure playlist is fully initialized, then hide it
                            def hide_playlist_and_enter_nano():
                                self.toggle_playlist()  # Hide playlist
                                # Now enter nano mode and sync buttons
                                if self.nano_mode_on_minimize and not self._main_window_hidden_for_nano:
                                    QApplication.processEvents()
                                    self._enter_nano_mode()
                                    # Mark that we started in nano mode (for first restore workaround)
                                    self._first_restore_from_nano = True
                                    logger.debug(f"Set _first_restore_from_nano=True after entering nano mode on startup")
                                    # Sync buttons after nano player is created
                                    if hasattr(self, 'nano_player_window') and self.nano_player_window:
                                        QTimer.singleShot(100, self.nano_player_window._sync_shuffle_repeat_buttons)
                                self._activate_nano_after_page_load = False
                            QTimer.singleShot(100, hide_playlist_and_enter_nano)
                        else:
                            # Playlist should be visible - enter nano mode normally
                            if self.nano_mode_on_minimize and not self._main_window_hidden_for_nano:
                                QApplication.processEvents()
                                self._enter_nano_mode()
                                # Mark that we started in nano mode (for first restore workaround)
                                self._first_restore_from_nano = True
                                logger.debug(f"Set _first_restore_from_nano=True after entering nano mode on startup")
                            self._activate_nano_after_page_load = False
                    elif hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        # Playlist exists - ensure state is restored
                        if hasattr(self, '_restore_playlist_state_pending') and self._restore_playlist_state_pending:
                            self._restore_playlist_state()
                            self._restore_playlist_state_pending = False
                        
                        if self.nano_mode_on_minimize and not self._main_window_hidden_for_nano:
                            QApplication.processEvents()
                            self._enter_nano_mode()
                            # Mark that we started in nano mode (for first restore workaround)
                            self._first_restore_from_nano = True
                            logger.debug(f"Set _first_restore_from_nano=True after entering nano mode on startup")
                        self._activate_nano_after_page_load = False
                    else:
                        # No playlist and shouldn't create it (shouldn't happen, but handle gracefully)
                        if self.nano_mode_on_minimize and not self._main_window_hidden_for_nano:
                            QApplication.processEvents()
                            self._enter_nano_mode()
                        self._first_restore_from_nano = True
                        logger.debug(f"Set _first_restore_from_nano=True after entering nano mode on startup")
                    self._activate_nano_after_page_load = False
                QTimer.singleShot(500, activate_nano_after_load)
            
            # Update playlist current item selection after page is loaded
            # This ensures the playlist item is selected on startup when loading last played URL
            # Use a delay to ensure playlist is fully loaded and ready
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                # Get the current URL from the web view
                current_url = self.web_view.url().toString() if self.web_view else None
                if current_url:
                    # Delay to ensure playlist is ready (especially on startup)
                    QTimer.singleShot(200, lambda: self.playlist_sidebar.update_current_item(current_url) if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar else None)
            
            # Apply mini/micro mode resize now that page is loaded
            # This ensures dimensions are available for accurate resizing
            if hasattr(self, 'mini_mode_state'):
                # Ensure original size is set before resizing
                # IMPORTANT: Only set original size if we're actually in mini/micro mode
                # and if the current size is NOT micro mode size (to avoid saving micro size as original)
                # Only resize if we're still in the same mode (don't resize if user switched modes)
                if self.mini_mode_state == 1:
                    # Mini mode: wait a bit for carousel to be ready, then resize
                    QTimer.singleShot(200, self.resize_to_mini_mode)
                elif self.mini_mode_state == 2:
                    # Micro mode: resize to player size
                    # Only resize if we're still in micro mode (user hasn't switched)
                    QTimer.singleShot(100, self.resize_to_micro_mode)
            
            # Apply volume setting
            QTimer.singleShot(500, self.apply_volume)
            
            # Set up playback monitoring for repeat functionality
            QTimer.singleShot(1000, self.setup_playback_monitoring)
            
            # Set up first playback detection for micro mode layout refresh
            if self.mini_mode_state == 2:
                QTimer.singleShot(1000, self.setup_first_playback_detection)
            # Auto-play first track if loaded via repeat - trigger when overlay is hidden
            if hasattr(self, '_auto_play_next_album') and self._auto_play_next_album:
                # Don't set a timer here - we'll trigger it when the overlay is hidden
                # This ensures the page is fully loaded and ready
                pass
            # Safety fallback: force hide after 1 second (reduced from 2 seconds)
            QTimer.singleShot(1000, self.force_hide_overlay)
        else:
            # If load failed, still show the page
            # Clear Super Shuffle flags if they were set (page load failed)
            if hasattr(self, '_is_super_shuffle_load') and self._is_super_shuffle_load:
                logger.debug("Page load failed, clearing Super Shuffle flags")
                self._is_super_shuffle_load = False
                self._super_shuffle_album_url = None
            if self.web_view:
                self.web_view.show()
                self.web_view.setWindowOpacity(1.0)
            QTimer.singleShot(100, self.fade_in_page)
            QTimer.singleShot(1000, self.force_hide_overlay)
    
    def force_hide_overlay(self):
        """Force hide the loading overlay (safety fallback)"""
        # Clear loading state
        self.is_loading = False
        # Restore context menu policy on web view
        if self.web_view and self._original_context_menu_policy is not None:
            self.web_view.setContextMenuPolicy(self._original_context_menu_policy)
            self._original_context_menu_policy = None
        if self.loading_overlay:
            # Stop any animations
            if self.loading_overlay.graphicsEffect():
                effect = self.loading_overlay.graphicsEffect()
                if isinstance(effect, QPropertyAnimation):
                    effect.stop()
            # Hide completely
            self.loading_overlay.hide()
            self.loading_overlay.setVisible(False)
            self.loading_overlay.setGraphicsEffect(None)
            self.loading_overlay.lower()  # Move behind other widgets
            # Ensure it's not taking up space
            self.loading_overlay.setGeometry(0, 0, 0, 0)
        if self.web_view:
            self.web_view.show()
            self.web_view.setWindowOpacity(1.0)
            self.web_view.raise_()
            if self.web_view.graphicsEffect():
                effect = self.web_view.graphicsEffect()
                if isinstance(effect, QGraphicsOpacityEffect):
                    effect.setOpacity(1.0)
        
        # Auto-play specific track if set (for Repeat 1 Track, Super Shuffle, Shuffle Tracks)
        if hasattr(self, '_auto_play_track_number') and self._auto_play_track_number is not None:
            track_num = self._auto_play_track_number
            self._auto_play_track_number = None  # Reset flag
            logger.debug(f"Auto-playing specific track: {track_num}")
            self.auto_play_first_track(track_number=track_num)
        # Auto-play first track if loaded via repeat (now that overlay is hidden and page is ready)
        elif hasattr(self, '_auto_play_next_album') and self._auto_play_next_album:
            self._auto_play_next_album = False  # Reset flag
            # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
            self.auto_play_first_track()
        # Auto-play logic: check startup autoplay first if it's a startup load, otherwise check regular autoplay
        elif hasattr(self, '_is_startup_load') and self._is_startup_load:
            # This is a startup load - only check autoplay_on_startup (independent of regular autoplay)
            if self.autoplay_on_startup:
                # Get saved track number from settings (if available)
                saved_track_number = self.settings.get("last_played_track_number")
                logger.debug(f"force_hide_overlay autoplay: Retrieved saved_track_number from settings: {saved_track_number}")
                # Ensure it's an integer if it exists
                if saved_track_number is not None:
                    try:
                        saved_track_number = int(saved_track_number)
                        logger.debug(f"force_hide_overlay autoplay: Converted to integer: {saved_track_number}")
                    except (ValueError, TypeError):
                        logger.debug(f"force_hide_overlay autoplay: Failed to convert to integer, using None")
                        saved_track_number = None
                else:
                    logger.debug(f"force_hide_overlay autoplay: No saved track number found, will play first track")
                # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
                # Scroll prevention is now handled inside auto_play_first_track() to prevent jitter
                logger.debug(f"force_hide_overlay autoplay: Calling auto_play_first_track with track_number={saved_track_number}")
                self.auto_play_first_track(track_number=saved_track_number)
            # Reset startup flag after checking (regardless of whether autoplay happened)
            self._is_startup_load = False
        # Regular autoplay (for non-startup loads)
        elif self.autoplay:
            # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
            self.auto_play_first_track()
    
    def fade_in_page(self):
        """Fade in the web view and hide loading overlay"""
        if not self.web_view or not self.loading_overlay:
            # Fallback: just hide overlay if something is wrong
            if self.loading_overlay:
                self.loading_overlay.hide()
            if self.web_view:
                self.web_view.show()
            return
        
        # Show web view (was hidden during load)
        self.web_view.show()
        self.web_view.raise_()
        
        # Set initial opacity for fade-in
        self.web_view.setWindowOpacity(0.0)
        
        try:
            # Create graphics opacity effects for smooth animation
            web_view_effect = QGraphicsOpacityEffect(self.web_view)
            self.web_view.setGraphicsEffect(web_view_effect)
            web_view_effect.setOpacity(0.0)
            
            # Ensure overlay is visible and raised above web view before applying fade effect
            # (playlist container can be raised above overlay separately)
            # Update geometry before showing to ensure it's correct
            if self.is_loading:
                self.update_loading_overlay_geometry()
            if not self.loading_overlay.isVisible():
                self.loading_overlay.show()
            self.loading_overlay.raise_()
            # Ensure playlist stays above overlay if it's visible
            if hasattr(self, 'playlist_container') and self.playlist_container and self.playlist_container.isVisible():
                self.playlist_container.raise_()
            
            overlay_effect = QGraphicsOpacityEffect(self.loading_overlay)
            self.loading_overlay.setGraphicsEffect(overlay_effect)
            # Use the transparency setting to determine initial opacity
            initial_opacity = 0.7 if self.transparent_overlay else 1.0
            overlay_effect.setOpacity(initial_opacity)
            
            # Create fade animation for web view
            fade_animation = QPropertyAnimation(web_view_effect, b"opacity")
            fade_animation.setDuration(150)  # Faster fade (reduced from 300ms)
            # Start from current opacity (might be 0.3 if shown early)
            current_opacity = web_view_effect.opacity() if web_view_effect else 0.0
            fade_animation.setStartValue(current_opacity)
            fade_animation.setEndValue(1.0)
            fade_animation.setEasingCurve(QEasingCurve.Type.InOutQuad)
            
            # Fade out loading overlay smoothly
            # Use the transparency setting to determine start opacity
            start_opacity = 0.7 if self.transparent_overlay else 1.0
            overlay_fade = QPropertyAnimation(overlay_effect, b"opacity")
            overlay_fade.setDuration(150)  # Faster fade (reduced from 300ms)
            overlay_fade.setStartValue(start_opacity)
            overlay_fade.setEndValue(0.0)
            overlay_fade.setEasingCurve(QEasingCurve.Type.InOutQuad)
            
            def hide_overlay():
                # Clear loading state
                self.is_loading = False
                # Restore context menu policy on web view
                if self.web_view and self._original_context_menu_policy is not None:
                    self.web_view.setContextMenuPolicy(self._original_context_menu_policy)
                    self._original_context_menu_policy = None
                if self.loading_overlay:
                    # Animation finished, now hide it completely
                    self.loading_overlay.hide()
                    self.loading_overlay.setVisible(False)
                    self.loading_overlay.setGraphicsEffect(None)
                    self.loading_overlay.lower()
                    # Ensure it's not taking up space - set geometry to zero
                    self.loading_overlay.setGeometry(0, 0, 0, 0)
                if self.web_view:
                    web_view_effect.setOpacity(1.0)
                    self.web_view.setWindowOpacity(1.0)
                    self.web_view.raise_()
                
                # Auto-play first track if loaded via repeat (now that overlay is hidden and page is ready)
                if hasattr(self, '_auto_play_next_album') and self._auto_play_next_album:
                    self._auto_play_next_album = False  # Reset flag
                    # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
                    self.auto_play_first_track()
                # Auto-play logic: check Super Shuffle first (if track was selected), then startup, then regular
                elif hasattr(self, '_auto_play_track_number') and self._auto_play_track_number is not None:
                    # Super Shuffle (or other modes) has selected a specific track - play it immediately
                    track_num = self._auto_play_track_number
                    self._auto_play_track_number = None  # Reset flag
                    logger.debug(f"Super Shuffle autoplay: Playing track {track_num}")
                    self.auto_play_first_track(track_number=track_num)
                # Auto-play logic: check startup autoplay first if it's a startup load, otherwise check regular autoplay
                elif hasattr(self, '_is_startup_load') and self._is_startup_load:
                    # This is a startup load - only check autoplay_on_startup (independent of regular autoplay)
                    if self.autoplay_on_startup:
                        # Get saved track number from settings (if available)
                        saved_track_number = self.settings.get("last_played_track_number")
                        logger.debug(f"Startup autoplay: Retrieved saved_track_number from settings: {saved_track_number}")
                        # Ensure it's an integer if it exists
                        if saved_track_number is not None:
                            try:
                                saved_track_number = int(saved_track_number)
                                logger.debug(f"Startup autoplay: Converted to integer: {saved_track_number}")
                            except (ValueError, TypeError):
                                logger.debug(f"Startup autoplay: Failed to convert to integer, using None")
                                saved_track_number = None
                        else:
                            logger.debug(f"Startup autoplay: No saved track number found, will play first track")
                        # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
                        logger.debug(f"Startup autoplay: Calling auto_play_first_track with track_number={saved_track_number}")
                        self.auto_play_first_track(track_number=saved_track_number)
                        # Scroll to top in regular mode when autoplay happens on startup
                        if self.mini_mode_state == 0:  # Regular mode only
                            scroll_to_top_js = """
                            (function() {
                                window.scrollTo({ top: 0, left: 0, behavior: 'instant' });
                                document.documentElement.scrollTop = 0;
                                document.body.scrollTop = 0;
                            })();
                            """
                            self.web_view.page().runJavaScript(scroll_to_top_js)
                    # Reset startup flag after checking (regardless of whether autoplay happened)
                    self._is_startup_load = False
                # Regular autoplay (for non-startup loads)
                elif self.autoplay:
                    # Trigger immediately - overlay is already hidden and JS has its own delay for player readiness
                    self.auto_play_first_track()
            
            overlay_fade.finished.connect(hide_overlay)
            
            # Fallback timer to force hide overlay if animation doesn't complete
            # Set to longer than animation duration to allow fade to complete
            def force_hide_local():
                # Only force hide if overlay is still visible (animation might have failed)
                if self.loading_overlay and self.loading_overlay.isVisible():
                    # Check if animation is still running by checking opacity
                    current_effect = self.loading_overlay.graphicsEffect()
                    if current_effect and isinstance(current_effect, QGraphicsOpacityEffect):
                        # Animation might still be running, give it a bit more time
                        if current_effect.opacity() > 0.1:
                            QTimer.singleShot(200, force_hide_local)
                            return
                    # Animation finished or failed, hide it
                    self.is_loading = False
                    # Restore context menu policy on web view
                    if self.web_view and self._original_context_menu_policy is not None:
                        self.web_view.setContextMenuPolicy(self._original_context_menu_policy)
                        self._original_context_menu_policy = None
                    self.loading_overlay.hide()
                    self.loading_overlay.setVisible(False)
                    self.loading_overlay.setGraphicsEffect(None)
                    self.loading_overlay.lower()
                    # Ensure it's not taking up space - set geometry to zero
                    self.loading_overlay.setGeometry(0, 0, 0, 0)
                if self.web_view:
                    self.web_view.setWindowOpacity(1.0)
                    self.web_view.raise_()
                    if self.web_view.graphicsEffect():
                        effect = self.web_view.graphicsEffect()
                        if isinstance(effect, QGraphicsOpacityEffect):
                            effect.setOpacity(1.0)
            
            QTimer.singleShot(600, force_hide_local)  # Force hide after 600ms (longer than 300ms animation)
            
            # Start both animations
            fade_animation.start()
            overlay_fade.start()
        except Exception as e:
            # If animation fails, just hide the overlay immediately
            logger.error(f"Fade animation error: {e}", exc_info=True)
            if self.loading_overlay:
                self.loading_overlay.hide()
                self.loading_overlay.setGraphicsEffect(None)
            if self.web_view:
                self.web_view.show()
                self.web_view.setWindowOpacity(1.0)
                self.web_view.setGraphicsEffect(None)
    
    def inject_css_with_callback(self):
        """Inject CSS with callback to know when it's complete, then fade in immediately"""
        # Safety check: ensure web_view and page exist before injecting
        if not hasattr(self, 'web_view') or not self.web_view:
            logger.warning("inject_css_with_callback: web_view not available, skipping injection")
            return
        if not self.web_view.page():
            logger.warning("inject_css_with_callback: web_view.page() not available, skipping injection")
            return
        
        css = self.css_injector.get_css(self.compact_mode, self.bandcamp_mode, self.mini_mode_state, self.webview_scrollbar_visible)
        if css:
            # Get the full JavaScript code (same as inject_css but with callback)
            js = self._get_css_injection_js(css)
            # Inject with callback - when CSS is injected, immediately fade in
            def on_css_injected(result):
                # Mark that JavaScript has been injected (image viewer and mini mode setup)
                self._js_injected_on_current_page = True
                # CSS injection complete, fade in immediately (minimal delay)
                QTimer.singleShot(10, self.fade_in_page)
            
            self.web_view.page().runJavaScript(js, on_css_injected)
    
    def _get_bandcamp_mode_hide_js(self):
        """Get JavaScript code to hide unwanted Bandcamp elements"""
        return """
                    var elementsToHide = [
                        '#sticky-player',
                        '.sticky-player-container',
                        '#sticky-player-marker',
                        'nav#menubar.logged-in',
                        'header#tralbum-header.tralbum-header',
                        'div#tralbum-actions.tralbum-actions-container.desktop-right',
                        'div#tralbum-digital-only.tralbum-digital-only-container.desktop-left',
                        'section#supporters.supporters-container.desktop-right',
                        'section#tags.tags-container.desktop-left',
                        'section#artist-profile.desktop-sidebar.artist-profile-container',
                        'section#recommendations-footer.recommendations-footer-container.desktop-footer',
                        'section#tralbum-credits',
                        'section#purchase-options'
                    ];
                    
                    elementsToHide.forEach(function(selector) {
                        var elements = document.querySelectorAll(selector);
                        elements.forEach(function(el) {
                            el.style.display = 'none';
                            el.style.visibility = 'hidden';
                            el.style.opacity = '0';
                            el.style.pointerEvents = 'none';
                        });
                    });
                """
    
    def _get_mini_mode_class_js(self):
        """Get JavaScript code to apply mini mode classes"""
        return f"""
                // Windows 10 fix: Check if document.body exists before accessing classList
                // This prevents crashes when switching modes during page transitions
                if (document.body) {{
                    // ALWAYS remove deprecated 'mini-mode-player-hidden' class (fully hidden mode removed)
                    // This ensures the player is never stuck in hidden state
                    document.body.classList.remove('mini-mode-player-hidden');
                    
                    if ({self.mini_mode_state} === 1) {{
                        document.body.classList.add('mini-mode');
                        document.body.classList.remove('micro-mode');
                        
                        // Apply mini mode player autohide class if enabled
                        if ({'true' if self.mini_mode_player_autohide else 'false'}) {{
                            document.body.classList.add('mini-mode-autohide');
                            
                            // Setup hover event listeners for autohide
                            // Use a function to setup listeners that can be called multiple times safely
                            function setupAutohideHover() {{
                                var player = document.querySelector('#player');
                                if (!player) return;
                                
                                // If already set up, remove old listeners first to prevent duplicates
                                if (player.hasAttribute('data-autohide-setup')) {{
                                    // Remove old event listeners if they exist
                                    var oldEnterHandler = player._bandcampAutohideEnterHandler;
                                    var oldLeaveHandler = player._bandcampAutohideLeaveHandler;
                                    if (oldEnterHandler) {{
                                        player.removeEventListener('mouseenter', oldEnterHandler);
                                    }}
                                    if (oldLeaveHandler) {{
                                        player.removeEventListener('mouseleave', oldLeaveHandler);
                                    }}
                                }}
                                
                                // Create new event handlers and store references
                                var enterHandler = function() {{
                                    player.classList.add('player-hovered');
                                }};
                                var leaveHandler = function() {{
                                    player.classList.remove('player-hovered');
                                }};
                                
                                // Store handlers so we can remove them later
                                player._bandcampAutohideEnterHandler = enterHandler;
                                player._bandcampAutohideLeaveHandler = leaveHandler;
                                
                                // Add new event listeners
                                player.addEventListener('mouseenter', enterHandler);
                                player.addEventListener('mouseleave', leaveHandler);
                                
                                // Mark as set up
                                player.setAttribute('data-autohide-setup', 'true');
                            }}
                            
                            // Setup with retry logic - player might not exist yet on startup
                            // Use more retries and longer delays for startup scenarios
                            function setupAutohideWithRetry(retryCount) {{
                                retryCount = retryCount || 0;
                                // Increased retries for startup (20 retries = up to 4 seconds)
                                var maxRetries = 20;
                                // Progressive delay: start with 100ms, increase to 300ms for later retries
                                var retryDelay = retryCount < 10 ? 100 : 300;
                                
                                var player = document.querySelector('#player');
                                if (player) {{
                                    // Player exists, set up hover listeners
                                    setupAutohideHover();
                                }} else if (retryCount < maxRetries) {{
                                    // Player doesn't exist yet, retry after delay
                                    setTimeout(function() {{
                                        setupAutohideWithRetry(retryCount + 1);
                                    }}, retryDelay);
                                }}
                            }}
                            
                            // Start setup with retry - also check if page is ready
                            if (document.readyState === 'complete' || document.readyState === 'interactive') {{
                                // Page is ready, start setup immediately
                                setupAutohideWithRetry();
                            }} else {{
                                // Page not ready yet, wait for it
                                document.addEventListener('DOMContentLoaded', function() {{
                                    setupAutohideWithRetry();
                                }});
                                // Also try after a delay in case DOMContentLoaded already fired
                                setTimeout(function() {{
                                    setupAutohideWithRetry();
                                }}, 100);
                            }}
                            
                            // Also setup when player is added dynamically (MutationObserver)
                            // Use a debounced approach to prevent excessive calls
                            if (typeof MutationObserver !== 'undefined') {{
                                var setupTimeout = null;
                                var observer = new MutationObserver(function(mutations) {{
                                    // Debounce: only check after mutations stop for 100ms
                                    if (setupTimeout) {{
                                        clearTimeout(setupTimeout);
                                    }}
                                    setupTimeout = setTimeout(function() {{
                                        var player = document.querySelector('#player');
                                        // Only setup if player exists and isn't already set up
                                        // OR if player was replaced (lost the attribute)
                                        if (player) {{
                                            // Check if setup is needed (player exists but not set up, or was replaced)
                                            var needsSetup = !player.hasAttribute('data-autohide-setup');
                                            if (needsSetup) {{
                                                setupAutohideHover();
                                            }}
                                        }}
                                    }}, 100);
                                }});
                                observer.observe(document.body, {{
                                    childList: true,
                                    subtree: true
                                }});
                            }}
                        }} else {{
                            document.body.classList.remove('mini-mode-autohide');
                            
                            // Remove hover class and event listeners if autohide is disabled
                            var player = document.querySelector('#player');
                            if (player) {{
                                player.classList.remove('player-hovered');
                                
                                // Remove event listeners if they exist
                                var oldEnterHandler = player._bandcampAutohideEnterHandler;
                                var oldLeaveHandler = player._bandcampAutohideLeaveHandler;
                                if (oldEnterHandler) {{
                                    player.removeEventListener('mouseenter', oldEnterHandler);
                                    delete player._bandcampAutohideEnterHandler;
                                }}
                                if (oldLeaveHandler) {{
                                    player.removeEventListener('mouseleave', oldLeaveHandler);
                                    delete player._bandcampAutohideLeaveHandler;
                                }}
                                
                                player.removeAttribute('data-autohide-setup');
                            }}
                        }}
                        
                        // Setup player visibility toggle button in mini mode only (not micro mode)
                        function setupPlayerVisibilityToggleButton() {{
                            var player = document.querySelector('#player');
                            var existingBtn = document.getElementById('bandcamp-player-visibility-toggle');
                            
                            // Check current mode
                            var isMiniMode = document.body.classList.contains('mini-mode');
                            var isMicroMode = document.body.classList.contains('micro-mode');
                            var isRegularMode = !isMiniMode && !isMicroMode;
                            
                            // Hide button if not in mini mode (regular mode or micro mode)
                            if (!player || {self.mini_mode_state} !== 1 || isMicroMode || isRegularMode) {{
                                if (existingBtn) {{
                                    // Hide button instead of removing it (so it can be shown again if needed)
                                    existingBtn.style.display = 'none';
                                    existingBtn.style.visibility = 'hidden';
                                    existingBtn.style.pointerEvents = 'none';
                                }}
                                return;
                            }}
                            
                            // Also check if we're in micro mode (shouldn't happen if state is 1, but double-check)
                            if (isMicroMode) {{
                                if (existingBtn) {{
                                    existingBtn.style.display = 'none';
                                    existingBtn.style.visibility = 'hidden';
                                    existingBtn.style.pointerEvents = 'none';
                                }}
                                return;
                            }}
                            
                            // Button is only visible in mini mode (not regular or micro mode)
                            // Check if button already exists
                            var toggleBtn = existingBtn;
                            if (!toggleBtn) {{
                                // Create toggle button
                                toggleBtn = document.createElement('div');
                                toggleBtn.id = 'bandcamp-player-visibility-toggle';
                                toggleBtn.setAttribute('aria-label', 'Toggle Player Visibility');
                                toggleBtn.title = 'Toggle Player Visibility: Visible  Autohide';
                                
                                // Set icon based on current state
                                var isAutohide = document.body.classList.contains('mini-mode-autohide');
                                if (isAutohide) {{
                                    toggleBtn.textContent = '';
                                }} else {{
                                    toggleBtn.textContent = '';
                                }}
                                
                                // Add click handler
                                toggleBtn.addEventListener('click', function(e) {{
                                    e.preventDefault();
                                    e.stopPropagation();
                                    e.stopImmediatePropagation();
                                    
                                    // Set global variable for Python to poll
                                    window._bandcampPlayerVisibilityToggle = true;
                                }});
                                
                                // Append to body instead of player so it stays visible when player is hidden
                                document.body.appendChild(toggleBtn);
                            }} else {{
                                // Update icon if button exists
                                var isAutohide = document.body.classList.contains('mini-mode-autohide');
                                if (isAutohide) {{
                                    toggleBtn.textContent = '';
                                }} else {{
                                    toggleBtn.textContent = '';
                                }}
                                
                                // Only show button in mini mode (not regular or micro mode)
                                var isMiniMode = document.body.classList.contains('mini-mode');
                                var isMicroMode = document.body.classList.contains('micro-mode');
                                if (isMiniMode && !isMicroMode) {{
                                    toggleBtn.style.display = 'flex';
                                    toggleBtn.style.visibility = 'visible';
                                }} else {{
                                    // Hide button in regular mode or micro mode
                                    toggleBtn.style.display = 'none';
                                    toggleBtn.style.visibility = 'hidden';
                                }}
                            }}
                        }}
                        
                        // Setup button when in mini mode (with retry logic for startup)
                        if ({self.mini_mode_state} === 1) {{
                            // Setup with retry logic - player might not exist yet on startup
                            function setupButtonWithRetry(retryCount) {{
                                retryCount = retryCount || 0;
                                var maxRetries = 20;
                                var retryDelay = retryCount < 10 ? 100 : 300;
                                
                                var player = document.querySelector('#player');
                                if (player) {{
                                    // Player exists, set up button
                                    setupPlayerVisibilityToggleButton();
                                }} else if (retryCount < maxRetries) {{
                                    // Player doesn't exist yet, retry after delay
                                    setTimeout(function() {{
                                        setupButtonWithRetry(retryCount + 1);
                                    }}, retryDelay);
                                }}
                            }}
                            
                            // Start setup with retry - also check if page is ready
                            if (document.readyState === 'complete' || document.readyState === 'interactive') {{
                                // Page is ready, start setup immediately
                                setupButtonWithRetry();
                            }} else {{
                                // Page not ready yet, wait for it
                                document.addEventListener('DOMContentLoaded', function() {{
                                    setupButtonWithRetry();
                                }});
                                // Also try after a delay in case DOMContentLoaded already fired
                                setTimeout(function() {{
                                    setupButtonWithRetry();
                                }}, 100);
                            }}
                            
                            // Also setup when player is added dynamically or when classes change
                            if (typeof MutationObserver !== 'undefined') {{
                                var observer = new MutationObserver(function(mutations) {{
                                    // Only setup if player exists (avoid unnecessary calls)
                                    var player = document.querySelector('#player');
                                    if (player) {{
                                        setupPlayerVisibilityToggleButton();
                                    }}
                                }});
                                observer.observe(document.body, {{
                                    childList: true,
                                    subtree: true,
                                    attributes: true,
                                    attributeFilter: ['class']
                                }});
                            }}
                        }} else {{
                            // Remove button when not in mini mode
                            var toggleBtn = document.getElementById('bandcamp-player-autohide-toggle');
                            if (toggleBtn) {{
                                toggleBtn.remove();
                            }}
                        }}
                        
                        // Restore cover art visibility when switching to mini mode (with retry for startup)
                        function restoreCoverArtVisibility(retryCount) {{
                            retryCount = retryCount || 0;
                            var maxRetries = 20;
                            var retryDelay = retryCount < 10 ? 100 : 300;
                            
                            var coverArt = document.querySelector('#tralbum-art-carousel');
                            if (coverArt) {{
                                coverArt.style.display = '';
                                coverArt.style.visibility = '';
                                coverArt.style.height = '';
                                coverArt.style.maxHeight = '';
                                coverArt.style.width = '';
                                coverArt.style.margin = '';
                                coverArt.style.padding = '';
                            }} else if (retryCount < maxRetries) {{
                                // Cover art doesn't exist yet, retry after delay
                                setTimeout(function() {{
                                    restoreCoverArtVisibility(retryCount + 1);
                                }}, retryDelay);
                            }}
                        }}
                        
                        // Start restoration with retry - also check if page is ready
                        if (document.readyState === 'complete' || document.readyState === 'interactive') {{
                            // Page is ready, start restoration immediately
                            restoreCoverArtVisibility();
                        }} else {{
                            // Page not ready yet, wait for it
                            document.addEventListener('DOMContentLoaded', function() {{
                                restoreCoverArtVisibility();
                            }});
                            // Also try after a delay in case DOMContentLoaded already fired
                            setTimeout(function() {{
                                restoreCoverArtVisibility();
                            }}, 100);
                        }}
                        // Clear CSS custom property for micro mode player height
                        document.documentElement.style.removeProperty('--micro-mode-player-height');
                        
                        // Restore footer visibility when switching to mini mode
                        var footer = document.querySelector('#TralbumPageFooter');
                        if (footer) {{
                            footer.style.display = '';
                            footer.style.visibility = '';
                            footer.style.height = '';
                            footer.style.width = '';
                            footer.style.margin = '';
                            footer.style.padding = '';
                        }}
                        var tralbumFooter = document.querySelector('#tralbum-footer, footer#tralbum-footer');
                        if (tralbumFooter) {{
                            tralbumFooter.style.display = '';
                            tralbumFooter.style.visibility = '';
                            tralbumFooter.style.height = '';
                            tralbumFooter.style.width = '';
                            tralbumFooter.style.margin = '';
                            tralbumFooter.style.padding = '';
                        }}
                        
                        // Restore body/html height when switching to mini mode
                        document.body.style.height = '';
                        document.body.style.minHeight = '';
                        document.body.style.maxHeight = '';
                        document.documentElement.style.height = '';
                        document.documentElement.style.minHeight = '';
                        document.documentElement.style.maxHeight = '';
                        
                        // Also restore page containers
                        var pgBd = document.querySelector('#pgBd');
                        if (pgBd) {{
                            pgBd.style.height = '';
                            pgBd.style.minHeight = '';
                            pgBd.style.maxHeight = '';
                            pgBd.style.paddingBottom = '';
                            pgBd.style.marginBottom = '';
                        }}
                        var pageContainer = document.querySelector('.p-tralbum-page-container');
                        if (pageContainer) {{
                            pageContainer.style.height = '';
                            pageContainer.style.minHeight = '';
                            pageContainer.style.maxHeight = '';
                            pageContainer.style.paddingBottom = '';
                            pageContainer.style.marginBottom = '';
                        }}
                        var mainElement = document.querySelector('main#p-tralbum-page');
                        if (mainElement) {{
                            mainElement.style.height = '';
                            mainElement.style.minHeight = '';
                            mainElement.style.maxHeight = '';
                            mainElement.style.paddingBottom = '';
                            mainElement.style.marginBottom = '';
                        }}
                    }} else if ({self.mini_mode_state} === 2) {{
                        document.body.classList.add('micro-mode');
                        document.body.classList.remove('mini-mode');
                        document.body.classList.remove('mini-mode-autohide'); // Remove autohide class when not in mini mode
                        
                        // Micro mode: hide cover art completely and constrain body height
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            coverArt.style.display = 'none';
                            coverArt.style.visibility = 'hidden';
                            coverArt.style.height = '0';
                            coverArt.style.width = '0';
                            coverArt.style.margin = '0';
                            coverArt.style.padding = '0';
                        }}
                        
                        // Hide footer elements that add space below player
                        var footer = document.querySelector('#TralbumPageFooter');
                        if (footer) {{
                            footer.style.display = 'none';
                            footer.style.visibility = 'hidden';
                            footer.style.height = '0';
                            footer.style.width = '0';
                            footer.style.margin = '0';
                            footer.style.padding = '0';
                        }}
                        var tralbumFooter = document.querySelector('#tralbum-footer, footer#tralbum-footer');
                        if (tralbumFooter) {{
                            tralbumFooter.style.display = 'none';
                            tralbumFooter.style.visibility = 'hidden';
                            tralbumFooter.style.height = '0';
                            tralbumFooter.style.width = '0';
                            tralbumFooter.style.margin = '0';
                            tralbumFooter.style.padding = '0';
                        }}
                        
                        // Constrain body/html height to player height (no extra space)
                        var player = document.querySelector('#player');
                        if (player) {{
                            // Use setTimeout to ensure player is rendered
                            setTimeout(function() {{
                                var playerRect = player.getBoundingClientRect();
                                // Get the exact bottom position of the player element
                                var exactBottom = playerRect.bottom + window.scrollY;
                                // Subtract 44 pixels to account for extra space
                                var adjustedBottom = Math.max(50, exactBottom - 33);
                                
                                // Set body and html height to match adjusted player bottom position
                                document.body.style.height = adjustedBottom + 'px';
                                document.body.style.minHeight = adjustedBottom + 'px';
                                document.body.style.maxHeight = adjustedBottom + 'px';
                                document.documentElement.style.height = adjustedBottom + 'px';
                                document.documentElement.style.minHeight = adjustedBottom + 'px';
                                document.documentElement.style.maxHeight = adjustedBottom + 'px';
                                
                                // Also ensure page containers match exactly
                                var pgBd = document.querySelector('#pgBd');
                                if (pgBd) {{
                                    pgBd.style.height = adjustedBottom + 'px';
                                    pgBd.style.minHeight = adjustedBottom + 'px';
                                    pgBd.style.maxHeight = adjustedBottom + 'px';
                                    pgBd.style.paddingBottom = '0';
                                    pgBd.style.marginBottom = '0';
                                }}
                                var pageContainer = document.querySelector('.p-tralbum-page-container');
                                if (pageContainer) {{
                                    pageContainer.style.height = adjustedBottom + 'px';
                                    pageContainer.style.minHeight = adjustedBottom + 'px';
                                    pageContainer.style.maxHeight = adjustedBottom + 'px';
                                    pageContainer.style.paddingBottom = '0';
                                    pageContainer.style.marginBottom = '0';
                                }}
                                // Also target the main element
                                var mainElement = document.querySelector('main#p-tralbum-page');
                                if (mainElement) {{
                                    mainElement.style.height = adjustedBottom + 'px';
                                    mainElement.style.minHeight = adjustedBottom + 'px';
                                    mainElement.style.maxHeight = adjustedBottom + 'px';
                                    mainElement.style.paddingBottom = '0';
                                    mainElement.style.marginBottom = '0';
                                }}
                            }}, 50);
                        }}
                    }} else {{
                        document.body.classList.remove('mini-mode', 'micro-mode', 'mini-mode-autohide');
                        
                        // Hide visibility toggle button when switching to regular mode (CSS will handle it)
                        // Don't remove it, just let CSS hide it
                        
                        // Restore cover art visibility when switching to regular mode
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            coverArt.style.display = '';
                            coverArt.style.visibility = '';
                            coverArt.style.height = '';
                            coverArt.style.width = '';
                            coverArt.style.margin = '';
                            coverArt.style.padding = '';
                        }}
                        
                        // Restore footer visibility when switching to regular mode
                        var footer = document.querySelector('#TralbumPageFooter');
                        if (footer) {{
                            footer.style.display = '';
                            footer.style.visibility = '';
                            footer.style.height = '';
                            footer.style.width = '';
                            footer.style.margin = '';
                            footer.style.padding = '';
                        }}
                        var tralbumFooter = document.querySelector('#tralbum-footer, footer#tralbum-footer');
                        if (tralbumFooter) {{
                            tralbumFooter.style.display = '';
                            tralbumFooter.style.visibility = '';
                            tralbumFooter.style.height = '';
                            tralbumFooter.style.width = '';
                            tralbumFooter.style.margin = '';
                            tralbumFooter.style.padding = '';
                        }}
                        
                        // Restore body/html height when switching to regular mode
                        document.body.style.height = '';
                        document.body.style.minHeight = '';
                        document.body.style.maxHeight = '';
                        document.documentElement.style.height = '';
                        document.documentElement.style.minHeight = '';
                        document.documentElement.style.maxHeight = '';
                        
                        // Also restore page containers
                        var pgBd = document.querySelector('#pgBd');
                        if (pgBd) {{
                            pgBd.style.height = '';
                            pgBd.style.minHeight = '';
                            pgBd.style.maxHeight = '';
                            pgBd.style.paddingBottom = '';
                            pgBd.style.marginBottom = '';
                        }}
                        var pageContainer = document.querySelector('.p-tralbum-page-container');
                        if (pageContainer) {{
                            pageContainer.style.height = '';
                            pageContainer.style.minHeight = '';
                            pageContainer.style.maxHeight = '';
                            pageContainer.style.paddingBottom = '';
                            pageContainer.style.marginBottom = '';
                        }}
                        var mainElement = document.querySelector('main#p-tralbum-page');
                        if (mainElement) {{
                            mainElement.style.height = '';
                            mainElement.style.minHeight = '';
                            mainElement.style.maxHeight = '';
                            mainElement.style.paddingBottom = '';
                            mainElement.style.marginBottom = '';
                        }}
                    }}
                }} else {{
                    // Body not ready yet - retry after a short delay
                    setTimeout(function() {{
                        if (document.body) {{
                            if ({self.mini_mode_state} === 1) {{
                                document.body.classList.add('mini-mode');
                                document.body.classList.remove('micro-mode');
                                
                                // Restore cover art visibility when switching to mini mode
                                var coverArt = document.querySelector('#tralbum-art-carousel');
                                if (coverArt) {{
                                    coverArt.style.display = '';
                                    coverArt.style.visibility = '';
                                    coverArt.style.height = '';
                                    coverArt.style.maxHeight = '';
                                    coverArt.style.width = '';
                                    coverArt.style.margin = '';
                                    coverArt.style.padding = '';
                                }}
                                // Clear CSS custom property for micro mode player height
                                document.documentElement.style.removeProperty('--micro-mode-player-height');
                                
                                // Restore body/html height when switching to mini mode
                                document.body.style.height = '';
                                document.body.style.minHeight = '';
                                document.body.style.maxHeight = '';
                                document.documentElement.style.height = '';
                                document.documentElement.style.minHeight = '';
                                document.documentElement.style.maxHeight = '';
                            }} else if ({self.mini_mode_state} === 2) {{
                                document.body.classList.add('micro-mode');
                                document.body.classList.remove('mini-mode', 'mini-mode-autohide');
                                
                                // Micro mode: show cover art behind player (semi-transparent player)
                                var coverArt = document.querySelector('#tralbum-art-carousel');
                                if (coverArt) {{
                                    coverArt.style.display = 'block';
                                    coverArt.style.visibility = 'visible';
                                    coverArt.style.position = 'absolute';
                                    coverArt.style.top = '0';
                                    coverArt.style.left = '0';
                                    coverArt.style.right = '0';
                                    coverArt.style.zIndex = '1';
                                    coverArt.style.width = '100%';
                                    coverArt.style.height = '100%';
                                    coverArt.style.overflow = 'hidden';
                                    coverArt.style.pointerEvents = 'none';
                                    coverArt.style.margin = '0';
                                    coverArt.style.padding = '0';
                                }}
                                
                                // Constrain body/html height to player height (no extra space)
                                var player = document.querySelector('#player');
                                if (player) {{
                                    setTimeout(function() {{
                                        var playerRect = player.getBoundingClientRect();
                                        // Get the exact bottom position of the player element
                                        var exactBottom = playerRect.bottom + window.scrollY;
                                        
                                        // Set body and html height to match player bottom position exactly
                                        document.body.style.height = exactBottom + 'px';
                                        document.body.style.minHeight = exactBottom + 'px';
                                        document.body.style.maxHeight = exactBottom + 'px';
                                        document.documentElement.style.height = exactBottom + 'px';
                                        document.documentElement.style.minHeight = exactBottom + 'px';
                                        document.documentElement.style.maxHeight = exactBottom + 'px';
                                        
                                        // Also ensure page containers match exactly
                                        var pgBd = document.querySelector('#pgBd');
                                        if (pgBd) {{
                                            pgBd.style.height = exactBottom + 'px';
                                            pgBd.style.minHeight = exactBottom + 'px';
                                            pgBd.style.maxHeight = exactBottom + 'px';
                                            pgBd.style.paddingBottom = '0';
                                            pgBd.style.marginBottom = '0';
                                        }}
                                        var pageContainer = document.querySelector('.p-tralbum-page-container');
                                        if (pageContainer) {{
                                            pageContainer.style.height = exactBottom + 'px';
                                            pageContainer.style.minHeight = exactBottom + 'px';
                                            pageContainer.style.maxHeight = exactBottom + 'px';
                                            pageContainer.style.paddingBottom = '0';
                                            pageContainer.style.marginBottom = '0';
                                        }}
                                        var mainElement = document.querySelector('main#p-tralbum-page');
                                        if (mainElement) {{
                                            mainElement.style.height = exactBottom + 'px';
                                            mainElement.style.minHeight = exactBottom + 'px';
                                            mainElement.style.maxHeight = exactBottom + 'px';
                                            mainElement.style.paddingBottom = '0';
                                            mainElement.style.marginBottom = '0';
                                        }}
                                    }}, 50);
                                }}
                            }} else {{
                                document.body.classList.remove('mini-mode', 'micro-mode', 'mini-mode-autohide');
                                
                                // Hide visibility toggle button when switching to regular mode (CSS will handle it)
                                // Don't remove it, just let CSS hide it
                                
                                // Restore cover art visibility when switching to regular mode
                                var coverArt = document.querySelector('#tralbum-art-carousel');
                                if (coverArt) {{
                                    coverArt.style.display = '';
                                    coverArt.style.visibility = '';
                                    coverArt.style.height = '';
                                    coverArt.style.width = '';
                                    coverArt.style.margin = '';
                                    coverArt.style.padding = '';
                                }}
                                
                                // Restore body/html height when switching to regular mode
                                document.body.style.height = '';
                                document.body.style.minHeight = '';
                                document.body.style.maxHeight = '';
                                document.documentElement.style.height = '';
                                document.documentElement.style.minHeight = '';
                                document.documentElement.style.maxHeight = '';
                            }}
                        }}
                    }}, 100);
                }}
                """
    
    def _handle_image_viewer_action(self, action, image_url):
        """Handle image viewer context menu actions from JavaScript"""
        from PyQt6.QtCore import QUrl
        from PyQt6.QtGui import QDesktopServices, QClipboard, QGuiApplication
        from PyQt6.QtWidgets import QFileDialog
        from pathlib import Path
        
        if not image_url:
            return
        
        try:
            if action == 'save':
                # Show save dialog
                file_path, _ = QFileDialog.getSaveFileName(
                    self,
                    "Save Image",
                    str(Path.home() / "Downloads" / "bandcamp-cover-art.jpg"),
                    "Image Files (*.jpg *.jpeg *.png *.gif *.webp);;All Files (*)"
                )
                
                if file_path:
                    try:
                        # Download and save the image using urllib (no external dependency)
                        req = urllib.request.Request(image_url)
                        req.add_header('User-Agent', 'Mozilla/5.0')
                        with urllib.request.urlopen(req, timeout=10) as response:
                            image_data = response.read()
                            with open(file_path, 'wb') as f:
                                f.write(image_data)
                        logger.info(f"Image saved to {file_path}")
                    except Exception as e:
                        logger.error(f"Failed to save image: {e}", exc_info=True)
                        from PyQt6.QtWidgets import QMessageBox
                        QMessageBox.warning(self, "Save Failed", f"Failed to save image:\n{str(e)}")
                        
            elif action == 'copy':
                # Copy image to clipboard
                try:
                    # Download image using urllib
                    req = urllib.request.Request(image_url)
                    req.add_header('User-Agent', 'Mozilla/5.0')
                    with urllib.request.urlopen(req, timeout=10) as response:
                        image_data = response.read()
                    
                    # Load into QPixmap and copy to clipboard
                    from PyQt6.QtGui import QPixmap
                    pixmap = QPixmap()
                    if pixmap.loadFromData(image_data):
                        clipboard = QGuiApplication.clipboard()
                        clipboard.setPixmap(pixmap)
                        logger.info("Image copied to clipboard")
                    else:
                        # Fallback: copy URL
                        clipboard = QGuiApplication.clipboard()
                        clipboard.setText(image_url)
                        logger.info("Image URL copied to clipboard (fallback)")
                except Exception as e:
                    logger.error(f"Failed to copy image: {e}", exc_info=True)
                    # Fallback: copy URL
                    clipboard = QGuiApplication.clipboard()
                    clipboard.setText(image_url)
                    logger.info("Image URL copied to clipboard (error fallback)")
                    
            elif action == 'copyUrl':
                # Copy image URL to clipboard
                clipboard = QGuiApplication.clipboard()
                clipboard.setText(image_url)
                logger.info("Image URL copied to clipboard")
                
            elif action == 'open':
                # Open image in default browser
                QDesktopServices.openUrl(QUrl(image_url))
                logger.info(f"Opening image in browser: {image_url}")
                
        except Exception as e:
            logger.error(f"Error handling image viewer action {action}: {e}", exc_info=True)
    
    def _poll_image_viewer_actions(self):
        """Poll for image viewer actions and autohide toggle from JavaScript"""
        # Safety checks: ensure web_view, page, and page is loaded before polling
        if not hasattr(self, 'web_view') or not self.web_view:
            return
        if not self.web_view.page():
            return
        # Check if page has loaded and JavaScript has been injected
        # The JavaScript for image viewer and mini mode is injected in inject_css(),
        # which is called in on_page_loaded(), so we should wait for both
        try:
            url = self.web_view.url()
            if not url or url.toString() == "about:blank":
                # Page hasn't loaded yet, skip polling
                return
            # Also check if JavaScript has been injected on this page
            if not getattr(self, '_js_injected_on_current_page', False):
                # JavaScript hasn't been injected yet, skip polling
                return
        except Exception:
            # If we can't check the URL or flag, skip polling to be safe
            return
        
        js_code = """
        (function() {
            var result = {};
            
            // Check for image viewer actions
            if (window._bandcampImageViewerAction) {
                result.imageViewerAction = window._bandcampImageViewerAction;
                window._bandcampImageViewerAction = null; // Clear it
            }
            
            // Check for player visibility toggle
            if (window._bandcampPlayerVisibilityToggle) {
                result.playerVisibilityToggle = true;
                window._bandcampPlayerVisibilityToggle = null; // Clear it
            }
            
            // Always check if image viewer modal is active (for trigger button visibility)
            var modal = document.getElementById('bandcamp-player-cover-modal');
            if (modal) {
                result.imageViewerActive = modal.classList.contains('active');
            } else {
                result.imageViewerActive = false;
            }
            
            // Always return result (even if empty) so we can track modal state
            return result;
        })();
        """
        
        def handle_action(result):
            if result and isinstance(result, dict):
                # Handle image viewer actions
                if 'imageViewerAction' in result:
                    action_data = result.get('imageViewerAction')
                    if action_data:
                        action = action_data.get('action')
                        image_url = action_data.get('imageUrl')
                        if action and image_url:
                            self._handle_image_viewer_action(action, image_url)
                
                # Handle player visibility toggle (mini mode: Visible  Autohide)
                if result.get('playerVisibilityToggle'):
                    self.toggle_mini_mode_player_autohide()
                
                # Handle image viewer modal state - hide/show trigger button
                # Only update if state changed to prevent flickering
                if 'imageViewerActive' in result:
                    is_active = result.get('imageViewerActive', False)
                    # Only update if state actually changed
                    if is_active != getattr(self, '_image_viewer_active', False):
                        self._image_viewer_active = is_active
                        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn:
                            if is_active:
                                # Modal is active - hide trigger button immediately
                                if self.autohide_trigger_btn.isVisible():
                                    self.hide_trigger_button(animated=True)
                            else:
                                # Modal is closed - show trigger button if address bar is hidden
                                if (hasattr(self, 'autohide_address_bar') and self.autohide_address_bar and 
                                    hasattr(self, 'controls_bar_widget') and 
                                    not self.controls_bar_widget.isVisible() and
                                    not self.autohide_trigger_btn.isVisible()):
                                    self.show_trigger_button(animated=True)
        
        self.web_view.page().runJavaScript(js_code, handle_action)
    
    def _initialize_image_viewer_modal_early(self):
        """Initialize image viewer modal structure early (before any page loads)
        This ensures the modal is ready whenever a URL is loaded, fixing first launch issues"""
        if not hasattr(self, 'web_view') or not self.web_view or not self.web_view.page():
            # Retry if web view isn't ready yet
            QTimer.singleShot(100, self._initialize_image_viewer_modal_early)
            return
        
        # Inject JavaScript to create modal structure early
        # This creates the modal DOM elements and basic event handlers
        # Click handlers for cover art will be attached when pages load
        modal_init_js = """
        (function initializeModalStructure() {
            // Check if body is ready - if not, retry
            if (!document.body) {
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initializeModalStructure);
                } else {
                    setTimeout(initializeModalStructure, 50);
                }
                return;
            }
            
            // Only create modal if it doesn't exist
            if (document.getElementById('bandcamp-player-cover-modal')) {
                return; // Already exists
            }
            
            // Create modal structure
            var modal = document.createElement('div');
            modal.id = 'bandcamp-player-cover-modal';
            
            var closeBtn = document.createElement('div');
            closeBtn.id = 'bandcamp-player-cover-modal-close';
            closeBtn.innerHTML = '';
            closeBtn.setAttribute('aria-label', 'Close');
            
            var img = document.createElement('img');
            img.id = 'bandcamp-player-cover-modal-content';
            
            modal.appendChild(closeBtn);
            modal.appendChild(img);
            
            try {
                document.body.appendChild(modal);
                console.log('Bandcamp Player: Image viewer modal structure initialized early');
            } catch (e) {
                console.error('Bandcamp Player: Error appending modal to body:', e);
                setTimeout(initializeModalStructure, 100);
                return;
            }
            
            // Initialize zoom state (will be used by full setup later)
            if (!window._bandcampModalZoomLevel) {
                window._bandcampModalZoomLevel = 1;
                window._bandcampModalMinZoom = 0.5;
                window._bandcampModalMaxZoom = 5;
                window._bandcampModalZoomStep = 0.1;
            }
            
            // Initialize drag state variables
            if (!window._bandcampModalDragState) {
                window._bandcampModalDragState = {
                    isDragging: false,
                    dragStartX: 0,
                    dragStartY: 0,
                    currentTranslateX: 0,
                    currentTranslateY: 0,
                    mouseDownX: 0,
                    mouseDownY: 0,
                    mouseButtonDown: false,
                    dragThreshold: 5
                };
            }
            
            // Mark that modal structure is ready (handlers will be set up when page loads)
            modal.setAttribute('data-structure-ready', 'true');
        })();
        """
        
        try:
            self.web_view.page().runJavaScript(modal_init_js)
            logger.debug("Initialized image viewer modal structure early")
        except Exception as e:
            logger.warning(f"Could not initialize image viewer modal early: {e}")
            # Retry after a delay
            QTimer.singleShot(200, self._initialize_image_viewer_modal_early)
    
    def _get_cover_art_modal_js(self):
        """Get JavaScript code to handle cover art modal functionality"""
        # Get reference to self for Python callbacks
        import weakref
        self_ref = weakref.ref(self)
        
        return """
            (function setupCoverArtModal() {
                // Image viewer modal setup - works on both light and dark pages
                // Check if body is ready - if not, retry
                if (!document.body) {
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', setupCoverArtModal);
                    } else {
                        // Document loaded but body not ready - retry after delay
                        setTimeout(setupCoverArtModal, 50);
                    }
                    return;
                }
                
                // Zoom state (shared across modal instances)
                // Use global state if available (from early initialization), otherwise create new
                var zoomLevel = window._bandcampModalZoomLevel || 1;
                var minZoom = window._bandcampModalMinZoom || 0.5;
                var maxZoom = window._bandcampModalMaxZoom || 5;
                var zoomStep = window._bandcampModalZoomStep || 0.1;
                
                // Get or create modal - check if it was already created by early initialization
                var modal = document.getElementById('bandcamp-player-cover-modal');
                var closeBtn = null;
                var img = null;
                
                if (!modal) {
                    // Modal doesn't exist - create it (fallback for cases where early init didn't run)
                    modal = document.createElement('div');
                    modal.id = 'bandcamp-player-cover-modal';
                    
                    closeBtn = document.createElement('div');
                    closeBtn.id = 'bandcamp-player-cover-modal-close';
                    closeBtn.innerHTML = '';
                    closeBtn.setAttribute('aria-label', 'Close');
                    
                    img = document.createElement('img');
                    img.id = 'bandcamp-player-cover-modal-content';
                    
                    modal.appendChild(closeBtn);
                    modal.appendChild(img);
                    
                    // Ensure body exists before appending
                    if (!document.body) {
                        console.error('Bandcamp Player: document.body is null, cannot append modal');
                        // Retry after a delay
                        setTimeout(setupCoverArtModal, 100);
                        return;
                    }
                    
                    try {
                        document.body.appendChild(modal);
                    } catch (e) {
                        console.error('Bandcamp Player: Error appending modal to body:', e);
                        // Retry after a delay
                        setTimeout(setupCoverArtModal, 100);
                        return;
                    }
                } else {
                    // Modal already exists (from early initialization) - just get references
                    closeBtn = document.getElementById('bandcamp-player-cover-modal-close');
                    img = document.getElementById('bandcamp-player-cover-modal-content');
                }
                
                // Only set up event handlers if they haven't been set up yet
                // Check if modal has data attribute to indicate handlers are already set up
                // If modal was created early, we still need to set up the event handlers
                var handlersNeedSetup = !modal.hasAttribute('data-handlers-setup');
                
                if (handlersNeedSetup) {
                    // Mark as set up to prevent duplicate handlers
                    modal.setAttribute('data-handlers-setup', 'true');
                    
                    // Close modal functions
                    function closeModal() {
                        modal.classList.remove('active');
                        img.src = '';
                        img.alt = '';
                        // Reset zoom and position when closing
                        zoomLevel = 1;
                        currentZoomLevelIndex = 0;
                        currentTranslateX = 0;
                        currentTranslateY = 0;
                        isDragging = false;
                        mouseButtonDown = false;
                        updateTransform();
                        img.style.transformOrigin = 'center center';
                        img.style.cursor = 'zoom-in';
                        
                        // Show visibility toggle button when modal closes (only in mini mode)
                        var visibilityToggle = document.getElementById('bandcamp-player-visibility-toggle');
                        if (visibilityToggle && document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {
                            visibilityToggle.style.display = 'flex';
                        }
                    }
                    
                    // Close on background click
                    modal.addEventListener('click', function(e) {
                        if (e.target === modal || e.target === closeBtn) {
                            closeModal();
                        }
                    });
                    
                    // Close on ESC key
                    document.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape' && modal.classList.contains('active')) {
                            closeModal();
                        }
                    });
                    
                    // Prevent image click from closing modal
                    img.addEventListener('click', function(e) {
                        e.stopPropagation();
                    });
                    
                    // Drag state
                    var isDragging = false;
                    var dragStartX = 0;
                    var dragStartY = 0;
                    var currentTranslateX = 0;
                    var currentTranslateY = 0;
                    var mouseDownX = 0;
                    var mouseDownY = 0;
                    var mouseButtonDown = false;
                    var dragThreshold = 5; // Pixels to move before considering it a drag
                    
                    // Zoom levels for click toggle
                    var zoomLevels = [1, 1.5, 2, 3]; // 1x, 1.5x, 2x, 3x zoom
                    var currentZoomLevelIndex = 0;
                    
                    // Update transform with both zoom and translate
                    function updateTransform() {
                        var transform = 'scale(' + zoomLevel + ') translate(' + currentTranslateX + 'px, ' + currentTranslateY + 'px)';
                        img.style.transform = transform;
                    }
                    
                    // Zoom functionality with mouse wheel
                    function applyZoom(zoom, originX, originY) {
                        zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoom));
                        updateTransform();
                        if (originX !== undefined && originY !== undefined) {
                            // Convert viewport position to percentage relative to image
                            // Get image's current bounding box (before transform)
                            var imgRect = img.getBoundingClientRect();
                            
                            // Calculate where the origin point is relative to the image
                            var relativeX = originX - imgRect.left;
                            var relativeY = originY - imgRect.top;
                            
                            // Convert to percentage of image dimensions
                            var xPercent = (relativeX / imgRect.width) * 100;
                            var yPercent = (relativeY / imgRect.height) * 100;
                            
                            img.style.transformOrigin = xPercent + '% ' + yPercent + '%';
                        } else {
                            // Default to viewport center
                            img.style.transformOrigin = 'center center';
                        }
                    }
                    
                    // Listen for zoom reset event
                    modal.addEventListener('resetZoom', function() {
                        zoomLevel = 1;
                        currentZoomLevelIndex = 0;
                        currentTranslateX = 0;
                        currentTranslateY = 0;
                        updateTransform();
                        img.style.transformOrigin = 'center center';
                    });
                    
                    // Handle mouse wheel for zoom
                    modal.addEventListener('wheel', function(e) {
                        if (!modal.classList.contains('active')) return;
                        
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Determine zoom direction
                        var delta = e.deltaY > 0 ? -zoomStep : zoomStep;
                        var newZoom = zoomLevel + delta;
                        
                        // Get mouse position relative to image for zoom origin
                        var mouseX = e.clientX;
                        var mouseY = e.clientY;
                        
                        applyZoom(newZoom, mouseX, mouseY);
                    }, { passive: false });
                    
                    // Document-level handler to catch middle-click on modal/image
                    // This must run in capture phase to handle events early
                    document.addEventListener('mousedown', function(e) {
                        if ((e.button === 0 || e.button === 1) && modal.classList.contains('active')) {
                            // Check if click is on the modal or image
                            var target = e.target;
                            if (target === img || target === modal || modal.contains(target)) {
                                // Handle middle-click for image dragging
                                e.preventDefault();
                                e.stopPropagation();
                                e.stopImmediatePropagation();
                                // Store initial mouse position to detect click vs drag
                                mouseDownX = e.clientX;
                                mouseDownY = e.clientY;
                                mouseButtonDown = true;
                                isDragging = false; // Will be set to true if mouse moves enough
                                dragStartX = e.clientX - currentTranslateX;
                                dragStartY = e.clientY - currentTranslateY;
                                return false; // Prevent further propagation
                            }
                        }
                    }, { capture: true, passive: false }); // Use capture phase with passive: false to allow preventDefault
                    
                    // Also handle on the image element itself (as backup)
                    img.addEventListener('mousedown', function(e) {
                        if ((e.button === 0 || e.button === 1) && modal.classList.contains('active')) { // Left or middle click
                            // Handle middle-click for image dragging
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            // Store initial mouse position to detect click vs drag
                            mouseDownX = e.clientX;
                            mouseDownY = e.clientY;
                            mouseButtonDown = true;
                            isDragging = false; // Will be set to true if mouse moves enough
                            dragStartX = e.clientX - currentTranslateX;
                            dragStartY = e.clientY - currentTranslateY;
                            return false; // Prevent further propagation
                        }
                    }, { capture: true, passive: false }); // Use capture phase with passive: false to allow preventDefault
                    
                    // Note: Middle-click is enabled in image viewer (works like left-click for dragging)
                    
                    // Handle mouse move for dragging (left click only)
                    document.addEventListener('mousemove', function(e) {
                        if (!modal.classList.contains('active') || !mouseButtonDown) {
                            return;
                        }
                        
                        // Check if mouse moved enough to be considered a drag
                        var moveDistance = Math.sqrt(
                            Math.pow(e.clientX - mouseDownX, 2) + 
                            Math.pow(e.clientY - mouseDownY, 2)
                        );
                        
                        if (moveDistance > dragThreshold) {
                            // It's a drag
                            if (!isDragging) {
                                isDragging = true;
                                img.style.cursor = 'grabbing';
                            }
                            
                            e.preventDefault();
                            e.stopPropagation();
                            
                            currentTranslateX = e.clientX - dragStartX;
                            currentTranslateY = e.clientY - dragStartY;
                            
                            updateTransform();
                        }
                    });
                    
                    // Handle mouse up - toggle zoom if it was a click, stop dragging if it was a drag
                    img.addEventListener('mouseup', function(e) {
                        if ((e.button === 0 || e.button === 1) && modal.classList.contains('active')) {
                            mouseButtonDown = false;
                            
                            // Check if it was a click (didn't move much) or a drag
                            var moveDistance = Math.sqrt(
                                Math.pow(e.clientX - mouseDownX, 2) + 
                                Math.pow(e.clientY - mouseDownY, 2)
                            );
                            
                            if (!isDragging && moveDistance <= dragThreshold) {
                                // It was a click - find next discrete zoom level based on current scroll zoom
                                // Find the closest discrete zoom level to current zoomLevel
                                var closestIndex = 0;
                                var closestDistance = Math.abs(zoomLevel - zoomLevels[0]);
                                for (var i = 1; i < zoomLevels.length; i++) {
                                    var distance = Math.abs(zoomLevel - zoomLevels[i]);
                                    if (distance < closestDistance) {
                                        closestDistance = distance;
                                        closestIndex = i;
                                    }
                                }
                                
                                // If current zoom is very close to a discrete level, go to next one
                                // Otherwise, go to the next level after the closest one
                                var threshold = 0.05; // 5% threshold for "close enough"
                                if (closestDistance < threshold) {
                                    // Current zoom is close to a discrete level, go to next one
                                    currentZoomLevelIndex = (closestIndex + 1) % zoomLevels.length;
                                } else {
                                    // Current zoom is between levels, go to next level after closest
                                    if (zoomLevel > zoomLevels[closestIndex]) {
                                        // Zoomed in past closest level, go to next higher level
                                        currentZoomLevelIndex = Math.min(closestIndex + 1, zoomLevels.length - 1);
                                    } else {
                                        // Zoomed out before closest level, go to closest level
                                        currentZoomLevelIndex = closestIndex;
                                    }
                                }
                                
                                var newZoom = zoomLevels[currentZoomLevelIndex];
                                
                                // Get viewport (modal) center coordinates
                                var modalRect = modal.getBoundingClientRect();
                                var viewportCenterX = modalRect.left + modalRect.width / 2;
                                var viewportCenterY = modalRect.top + modalRect.height / 2;
                                
                                // Reset position first to get base image position
                                var oldTranslateX = currentTranslateX;
                                var oldTranslateY = currentTranslateY;
                                var oldZoom = zoomLevel;
                                
                                // Temporarily reset transform to get base image position
                                currentTranslateX = 0;
                                currentTranslateY = 0;
                                zoomLevel = 1;
                                updateTransform();
                                
                                // Get image's base (untransformed) position
                                var imgRect = img.getBoundingClientRect();
                                
                                // Calculate where viewport center is relative to base image
                                var relativeX = viewportCenterX - imgRect.left;
                                var relativeY = viewportCenterY - imgRect.top;
                                
                                // Convert to percentage relative to image dimensions
                                var xPercent = (relativeX / imgRect.width) * 100;
                                var yPercent = (relativeY / imgRect.height) * 100;
                                
                                // Set transform origin to viewport center (relative to image)
                                img.style.transformOrigin = xPercent + '% ' + yPercent + '%';
                                
                                // Reset position when toggling zoom
                                currentTranslateX = 0;
                                currentTranslateY = 0;
                                
                                // Apply new zoom
                                zoomLevel = newZoom;
                                updateTransform();
                            } else {
                                // It was a drag - just stop dragging
                                isDragging = false;
                                img.style.cursor = 'zoom-in';
                            }
                        }
                    });
                    
                    // Also handle mouseup on document to catch cases where mouse is released outside image
                    document.addEventListener('mouseup', function(e) {
                        if ((e.button === 0 || e.button === 1) && modal.classList.contains('active')) {
                            mouseButtonDown = false;
                            if (isDragging) {
                                isDragging = false;
                                if (modal.classList.contains('active')) {
                                    img.style.cursor = 'zoom-in';
                                }
                            }
                        }
                    });
                    
                    // Custom context menu for image viewer
                    var contextMenu = null;
                    
                    function createContextMenu() {
                        if (contextMenu) {
                            return contextMenu;
                        }
                        
                        var menu = document.createElement('div');
                        menu.id = 'bandcamp-player-image-context-menu';
                        menu.style.cssText = 'display: none; position: fixed; background-color: rgba(30, 30, 30, 0.95); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 4px; padding: 4px 0; z-index: 10002; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); min-width: 180px;';
                        
                        var menuItems = [
                            { text: 'Save Image', action: 'save' },
                            { text: 'Copy Image', action: 'copy' },
                            { text: 'Copy Image URL', action: 'copyUrl' },
                            { text: 'Open Image in Browser', action: 'open' },
                            { text: 'Zoom to Fit', action: 'zoomFit' },
                            { text: 'separator', action: 'separator' },
                            { text: 'Close Menu', action: 'close' },
                            { text: 'Exit Image Viewer', action: 'exit' }
                        ];
                        
                        menuItems.forEach(function(item) {
                            if (item.action === 'separator') {
                                // Add separator line
                                var separator = document.createElement('div');
                                separator.style.cssText = 'height: 1px; background-color: rgba(255, 255, 255, 0.2); margin: 4px 0;';
                                menu.appendChild(separator);
                                return;
                            }
                            
                            var menuItem = document.createElement('div');
                            menuItem.textContent = item.text;
                            menuItem.style.cssText = 'padding: 8px 16px; cursor: pointer; color: #e0e0e0; font-size: 13px; user-select: none;';
                            menuItem.addEventListener('mouseenter', function() {
                                this.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                            });
                            menuItem.addEventListener('mouseleave', function() {
                                this.style.backgroundColor = 'transparent';
                            });
                            menuItem.addEventListener('click', function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                if (item.action === 'close') {
                                    hideContextMenu();
                                } else if (item.action === 'exit') {
                                    closeModal();
                                    hideContextMenu();
                                } else {
                                    handleContextMenuAction(item.action);
                                    hideContextMenu();
                                }
                            });
                            menu.appendChild(menuItem);
                        });
                        
                        // Ensure body exists before appending
                        if (!document.body) {
                            console.error('Bandcamp Player: document.body is null, cannot append context menu');
                            // Return menu anyway - it can be appended later
                            return menu;
                        }
                        
                        try {
                            document.body.appendChild(menu);
                        } catch (e) {
                            console.error('Bandcamp Player: Error appending context menu to body:', e);
                            // Return menu anyway - it can be appended later
                        }
                        
                        return menu;
                    }
                    
                    function showContextMenu(x, y) {
                        if (!contextMenu) {
                            contextMenu = createContextMenu();
                        }
                        contextMenu.style.display = 'block';
                        
                        // Set initial position
                        contextMenu.style.left = x + 'px';
                        contextMenu.style.top = y + 'px';
                        
                        // Get menu dimensions after it's displayed
                        var rect = contextMenu.getBoundingClientRect();
                        var menuWidth = rect.width;
                        var menuHeight = rect.height;
                        var viewportWidth = window.innerWidth;
                        var viewportHeight = window.innerHeight;
                        
                        // Adjust horizontal position to keep menu within viewport
                        var finalX = x;
                        if (x + menuWidth > viewportWidth) {
                            // Menu would go off right edge - position to the left of cursor
                            finalX = x - menuWidth;
                        }
                        if (finalX < 0) {
                            // Menu would go off left edge - position at left edge
                            finalX = 0;
                        }
                        
                        // Adjust vertical position to keep menu within viewport
                        var finalY = y;
                        if (y + menuHeight > viewportHeight) {
                            // Menu would go off bottom edge - position above cursor
                            finalY = y - menuHeight;
                        }
                        if (finalY < 0) {
                            // Menu would go off top edge - position at top edge
                            finalY = 0;
                        }
                        
                        // Apply final position
                        contextMenu.style.left = finalX + 'px';
                        contextMenu.style.top = finalY + 'px';
                    }
                    
                    function hideContextMenu() {
                        if (contextMenu) {
                            contextMenu.style.display = 'none';
                        }
                    }
                    
                    function handleContextMenuAction(action) {
                        var imgSrc = img.src;
                        if (!imgSrc) return;
                        
                        switch(action) {
                            case 'save':
                            case 'copy':
                            case 'copyUrl':
                            case 'open':
                                // Store action in global variable for Python to poll
                                window._bandcampImageViewerAction = {
                                    action: action,
                                    imageUrl: imgSrc,
                                    timestamp: Date.now()
                                };
                                break;
                                
                            case 'zoomFit':
                                // Reset zoom to fit viewport
                                currentZoomLevelIndex = 0;
                                zoomLevel = 1;
                                currentTranslateX = 0;
                                currentTranslateY = 0;
                                img.style.transformOrigin = 'center center';
                                updateTransform();
                                break;
                        }
                    }
                    
                    // Show custom context menu on right click
                    img.addEventListener('contextmenu', function(e) {
                        if (modal.classList.contains('active')) {
                            e.preventDefault();
                            e.stopPropagation();
                            showContextMenu(e.clientX, e.clientY);
                        }
                    });
                    
                    // Hide context menu when clicking elsewhere
                    document.addEventListener('click', function(e) {
                        if (contextMenu && !contextMenu.contains(e.target)) {
                            hideContextMenu();
                        }
                    });
                    
                    // Hide context menu on ESC key
                    document.addEventListener('keydown', function(e) {
                        if (e.key === 'Escape' && contextMenu && contextMenu.style.display !== 'none') {
                            hideContextMenu();
                        }
                    });
                    
                    // Reset zoom and position on background click (before closing)
                    modal.addEventListener('click', function(e) {
                        if (e.target === modal) {
                            zoomLevel = 1;
                            currentZoomLevelIndex = 0;
                            currentTranslateX = 0;
                            currentTranslateY = 0;
                            updateTransform();
                            img.style.transformOrigin = 'center center';
                        }
                    });
                }
                
                // Setup click handlers on cover art
                function setupCoverArtClickHandlers() {
                    var coverArtContainer = document.querySelector('#tralbum-art-carousel');
                    if (!coverArtContainer) return;
                    
                    // Remove existing handlers to prevent duplicates
                    if (coverArtContainer.hasAttribute('data-modal-handler-attached')) {
                        return;
                    }
                    coverArtContainer.setAttribute('data-modal-handler-attached', 'true');
                    
                    // Update cursor when cover art is set up
                    if (typeof window._updateCoverArtCursor === 'function') {
                        window._updateCoverArtCursor();
                    }
                    
                    coverArtContainer.addEventListener('click', function(e) {
                        // Don't trigger if settings menu is open (check flag first)
                        if (window._bandcampPlayerMenuOpen === true) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            return false;
                        }
                        
                        // Don't trigger if volume popup is open (check flag)
                        // This prevents image viewer from opening when volume control is visible
                        if (window._bandcampPlayerVolumePopupOpen === true || (typeof window._checkVolumePopupVisible === 'function' && window._checkVolumePopupVisible())) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            return false;
                        }
                        
                        // Don't trigger if clicking on carousel controls
                        if (e.target.closest('.carousel-control-prev, .carousel-control-next, .carousel-indicators')) {
                            return;
                        }
                        
                        // Find the visible/active image
                        var visibleImg = null;
                        
                        // Method 1: Look for active carousel item
                        var activeItem = coverArtContainer.querySelector('.carousel-item.active, [class*="active"]');
                        if (activeItem) {
                            visibleImg = activeItem.querySelector('img');
                        }
                        
                        // Method 2: Find visible image
                        if (!visibleImg) {
                            var allImgs = coverArtContainer.querySelectorAll('img');
                            for (var i = 0; i < allImgs.length; i++) {
                                var img = allImgs[i];
                                var style = window.getComputedStyle(img);
                                if (style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
                                    var rect = img.getBoundingClientRect();
                                    if (rect && rect.width > 0 && rect.height > 0) {
                                        visibleImg = img;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Method 3: Fallback to first image
                        if (!visibleImg) {
                            visibleImg = coverArtContainer.querySelector('img');
                        }
                        
                        if (visibleImg) {
                            // Get image URL - try multiple sources in order of preference
                            var imgSrc = null;
                            
                            // Method 1: Try data-src (lazy loading) or data-lazy-src
                            imgSrc = visibleImg.getAttribute('data-src') || visibleImg.getAttribute('data-lazy-src');
                            
                            // Method 2: Try srcset for higher resolution
                            if (!imgSrc) {
                                var srcset = visibleImg.getAttribute('srcset');
                                if (srcset) {
                                    // Get the largest image from srcset (last one is usually largest)
                                    var srcsetParts = srcset.split(',').map(function(s) { return s.trim(); });
                                    if (srcsetParts.length > 0) {
                                        // Get the last entry (usually highest resolution)
                                        var lastEntry = srcsetParts[srcsetParts.length - 1];
                                        // Extract URL (before space or descriptor)
                                        imgSrc = lastEntry.split(/\s+/)[0];
                                    }
                                }
                            }
                            
                            // Method 3: Use current src (most reliable)
                            if (!imgSrc) {
                                imgSrc = visibleImg.src || visibleImg.getAttribute('src');
                            }
                            
                            // Show modal with the image
                            var modal = document.getElementById('bandcamp-player-cover-modal');
                            var modalImg = document.getElementById('bandcamp-player-cover-modal-content');
                            
                            if (modal && modalImg && imgSrc) {
                                // Set image source
                                modalImg.src = imgSrc;
                                modalImg.alt = visibleImg.alt || 'Album cover art';
                                
                                // Handle image load errors - fallback to original src
                                var imageErrorRetryCount = 0;
                                modalImg.onerror = function() {
                                    imageErrorRetryCount++;
                                    if (imageErrorRetryCount === 1) {
                                        // First error - try original src
                                        var originalSrc = visibleImg.src || visibleImg.getAttribute('src');
                                        if (originalSrc && originalSrc !== imgSrc) {
                                            modalImg.src = originalSrc;
                                            return; // Don't log error yet, wait for retry
                                        }
                                    }
                                    // If we've already tried or no fallback available, log once
                                    if (imageErrorRetryCount === 1 || imageErrorRetryCount === 2) {
                                        // Only log if it's a real failure (not just a retry)
                                        // This reduces console noise
                                    }
                                };
                                
                                // Reset zoom and position before showing modal
                                modalImg.style.transform = 'scale(1) translate(0px, 0px)';
                                modalImg.style.transformOrigin = 'center center';
                                
                                // Reset zoom level by dispatching a custom event
                                var zoomResetEvent = new CustomEvent('resetZoom');
                                modal.dispatchEvent(zoomResetEvent);
                                
                                // Hide visibility toggle button when modal opens
                                var visibilityToggle = document.getElementById('bandcamp-player-visibility-toggle');
                                if (visibilityToggle) {
                                    visibilityToggle.style.display = 'none';
                                }
                                
                                // Show modal
                                modal.classList.add('active');
                                
                                // Prevent body scroll when modal is open
                                document.body.style.overflow = 'hidden';
                                
                                // Restore body scroll when modal closes
                                var restoreScroll = function() {
                                    document.body.style.overflow = '';
                                };
                                
                                modal.addEventListener('transitionend', function() {
                                    if (!modal.classList.contains('active')) {
                                        restoreScroll();
                                    }
                                }, { once: true });
                            }
                        }
                    });
                }
                
                // Setup handlers with retry logic - elements might not exist yet on startup
                // Use more retries and longer delays for startup scenarios
                function setupWithRetry(retryCount) {
                    retryCount = retryCount || 0;
                    // Increased retries for startup (20 retries = up to 4 seconds)
                    var maxRetries = 20;
                    // Progressive delay: start with 100ms, increase to 300ms for later retries
                    var retryDelay = retryCount < 10 ? 100 : 300;
                    
                    var coverArtContainer = document.querySelector('#tralbum-art-carousel');
                    if (coverArtContainer) {
                        // Element exists, set up handlers
                        setupCoverArtClickHandlers();
                    } else if (retryCount < maxRetries) {
                        // Element doesn't exist yet, retry after delay
                        setTimeout(function() {
                            setupWithRetry(retryCount + 1);
                        }, retryDelay);
                    }
                }
                
                // Start setup with retry - also check if page is ready
                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    // Page is ready, start setup immediately
                    setupWithRetry();
                } else {
                    // Page not ready yet, wait for it
                    document.addEventListener('DOMContentLoaded', function() {
                        setupWithRetry();
                    });
                    // Also try after a delay in case DOMContentLoaded already fired
                    setTimeout(function() {
                        setupWithRetry();
                    }, 100);
                }
                
                // Also setup when cover art is added dynamically
                if (typeof MutationObserver !== 'undefined') {
                    var observer = new MutationObserver(function(mutations) {
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt && !coverArt.hasAttribute('data-modal-handler-attached')) {
                            setupCoverArtClickHandlers();
                        }
                    });
                    
                    observer.observe(document.body, {
                        childList: true,
                        subtree: true
                    });
                }
            })();
                """
    
    def _get_css_injection_js(self, css):
        """Get the JavaScript code for CSS injection (shared by both methods)"""
        mini_mode_js = self._get_mini_mode_class_js()
        bandcamp_hide_js = self._get_bandcamp_mode_hide_js() if self.bandcamp_mode else ""
        cover_art_modal_js = self._get_cover_art_modal_js()
        
        return f"""
            (function injectCSS() {{
                try {{
                    // CRITICAL: Always remove deprecated 'mini-mode-player-hidden' class on every CSS injection
                    // This prevents the player from getting stuck in hidden state (fully hidden mode was removed)
                    if (document.body) {{
                        document.body.classList.remove('mini-mode-player-hidden');
                    }}
                    
                    // Initialize menu state flag (prevents image viewer from opening when menu is open)
                    if (typeof window._bandcampPlayerMenuOpen === 'undefined') {{
                        window._bandcampPlayerMenuOpen = false;
                    }}
                    
                    // Initialize volume popup state flag (prevents image viewer from opening when volume popup is open)
                    if (typeof window._bandcampPlayerVolumePopupOpen === 'undefined') {{
                        window._bandcampPlayerVolumePopupOpen = false;
                    }}
                    
                    // Helper function to check if volume popup is actually visible
                    // This provides a fallback check in case the flag gets out of sync
                    window._checkVolumePopupVisible = function() {{
                        // The flag should be the source of truth, but we can add additional checks if needed
                        return window._bandcampPlayerVolumePopupOpen === true;
                    }};
                    
                    // Function to update cover art cursor based on menu/volume popup state
                    window._updateCoverArtCursor = function() {{
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            var menuOpen = window._bandcampPlayerMenuOpen === true;
                            var volumeOpen = window._bandcampPlayerVolumePopupOpen === true;
                            
                            if (menuOpen || volumeOpen) {{
                                coverArt.classList.add('cursor-disabled');
                            }} else {{
                                coverArt.classList.remove('cursor-disabled');
                            }}
                        }}
                    }};
                    
                    // Update cursor on initial load
                    if (document.readyState === 'loading') {{
                        document.addEventListener('DOMContentLoaded', window._updateCoverArtCursor);
                    }} else {{
                        window._updateCoverArtCursor();
                    }}
                    
                    // Detect light-colored pages and add class to body for CSS targeting
                    // Made more robust with retry logic and better error handling
                    function detectLightPage() {{
                        try {{
                            var body = document.body;
                            if (!body) {{
                                // Retry if body isn't ready yet
                                if (document.readyState === 'loading') {{
                                    setTimeout(detectLightPage, 50);
                                }}
                                return;
                            }}
                            
                            // Check multiple elements for background color (in order of preference)
                            var elements = [];
                            
                            // First, try to get the main content container (most reliable)
                            try {{
                                var mainContainer = document.querySelector('.p-tralbum-page-container, #pgBd, .leftColumn');
                                if (mainContainer) {{
                                    elements.push(mainContainer);
                                }}
                            }} catch (e) {{
                                // Ignore errors
                            }}
                            
                            // Then try body and documentElement
                            elements.push(body);
                            elements.push(document.documentElement);
                            
                            // Try to get carousel element, but don't fail if it doesn't exist
                            try {{
                                var carousel = document.querySelector('#tralbum-art-carousel');
                                if (carousel) {{
                                    elements.push(carousel);
                                }}
                            }} catch (e) {{
                                // Ignore errors getting carousel
                            }}
                            
                            var foundValidBackground = false;
                            var isLight = false;
                            
                            for (var i = 0; i < elements.length; i++) {{
                                try {{
                                    var element = elements[i];
                                    if (!element) continue;
                                    
                                    // Check if getComputedStyle is available
                                    if (typeof window.getComputedStyle === 'undefined') {{
                                        continue;
                                    }}
                                    
                                    var computedStyle = window.getComputedStyle(element);
                                    if (!computedStyle) continue;
                                    
                                    var backgroundColor = computedStyle.backgroundColor;
                                    if (!backgroundColor) continue;
                                    
                                    // Parse RGB values (handle both rgb() and rgba() formats)
                                    var rgbMatch = backgroundColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*[\\d.]+)?\\)/);
                                    if (rgbMatch) {{
                                        var r = parseInt(rgbMatch[1]);
                                        var g = parseInt(rgbMatch[2]);
                                        var b = parseInt(rgbMatch[3]);
                                        
                                        // Validate RGB values
                                        if (isNaN(r) || isNaN(g) || isNaN(b)) continue;
                                        
                                        // Calculate luminance to determine if background is light or dark
                                        var luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                                        
                                        // If we find a meaningful background (not transparent), use it
                                        if (backgroundColor !== 'rgba(0, 0, 0, 0)' && backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)') {{
                                            foundValidBackground = true;
                                            if (luminance > 0.6) {{
                                                isLight = true;
                                                break; // Found light background, stop checking
                                            }} else if (luminance < 0.4) {{
                                                // Definitely dark, can stop checking
                                                isLight = false;
                                                break;
                                            }}
                                            // If luminance is between 0.4 and 0.6, continue checking other elements
                                        }}
                                    }}
                                }} catch (e) {{
                                    // Continue to next element if this one fails
                                    continue;
                                }}
                            }}
                            
                            // Apply or remove light-page class based on detection
                            // Also add dark-page class for dark pages to ensure consistent styling
                            if (foundValidBackground) {{
                                if (isLight) {{
                                    body.classList.add('light-page');
                                    body.classList.remove('dark-page');
                                }} else {{
                                    body.classList.remove('light-page');
                                    body.classList.add('dark-page');
                                }}
                            }} else {{
                                // If no valid background found, default to dark-page
                                body.classList.remove('light-page');
                                body.classList.add('dark-page');
                            }}
                        }} catch (e) {{
                            // Log error but don't let it break other initialization
                            console.error('Bandcamp Player: Error detecting light page:', e);
                        }}
                    }}
                    
                    // Run detection with retry logic - don't block other initialization
                    function runLightPageDetection(retryCount) {{
                        retryCount = retryCount || 0;
                        var maxRetries = 10;
                        var baseDelay = 50;
                        
                        try {{
                            detectLightPage();
                            
                            // If detection didn't find a valid background, retry after styles load
                            // This handles cases where styles aren't computed yet
                            if (retryCount < maxRetries) {{
                                var body = document.body;
                                if (body) {{
                                    var hasLightClass = body.classList.contains('light-page');
                                    // If we haven't determined light/dark yet, retry
                                    // Check if we got a valid computed style
                                    var computedStyle = window.getComputedStyle(body);
                                    var bgColor = computedStyle.backgroundColor;
                                    
                                    // If background is still transparent/unset, retry
                                    if (bgColor === 'rgba(0, 0, 0, 0)' || bgColor === 'transparent' || !bgColor) {{
                                        var delay = baseDelay * Math.pow(1.5, retryCount);
                                        setTimeout(function() {{
                                            runLightPageDetection(retryCount + 1);
                                        }}, delay);
                                    }}
                                }}
                            }}
                        }} catch (e) {{
                            // Don't let light page detection errors break anything
                            console.error('Bandcamp Player: Error in light page detection wrapper:', e);
                            // Retry on error if we haven't exceeded max retries
                            if (retryCount < maxRetries) {{
                                var delay = baseDelay * Math.pow(1.5, retryCount);
                                setTimeout(function() {{
                                    runLightPageDetection(retryCount + 1);
                                }}, delay);
                            }}
                        }}
                    }}
                    
                    // Run detection immediately if body is ready, otherwise wait
                    if (document.body) {{
                        // Use setTimeout to avoid blocking other initialization
                        // Start with a small delay to let styles begin loading
                        setTimeout(function() {{
                            runLightPageDetection(0);
                        }}, 50);
                    }} else {{
                        // Wait for body to be available
                        if (document.readyState === 'loading') {{
                            document.addEventListener('DOMContentLoaded', function() {{
                                setTimeout(function() {{
                                    runLightPageDetection(0);
                                }}, 50);
                            }});
                        }} else {{
                            // If document is already loaded but body isn't ready, retry
                            setTimeout(function() {{
                                runLightPageDetection(0);
                            }}, 50);
                        }}
                    }}
                    
                    // Also run detection after window load (when all styles are definitely loaded)
                    if (document.readyState !== 'complete') {{
                        window.addEventListener('load', function() {{
                            setTimeout(function() {{
                                runLightPageDetection(0);
                            }}, 100);
                        }});
                    }} else {{
                        // Already loaded, run after a short delay
                        setTimeout(function() {{
                            runLightPageDetection(0);
                        }}, 100);
                    }}
                    
                    // Re-run detection when body classes change (e.g., when switching modes)
                    // This ensures light-page treatments apply reliably in all modes
                    // Made more robust with error handling
                    if (typeof MutationObserver !== 'undefined') {{
                        try {{
                            var lastModeState = null;
                            var lightPageObserver = null;
                            
                            var setupObserver = function() {{
                                try {{
                                    var body = document.body;
                                    if (!body) {{
                                        // Retry if body isn't ready
                                        if (document.readyState === 'loading') {{
                                            document.addEventListener('DOMContentLoaded', setupObserver);
                                        }} else {{
                                            setTimeout(setupObserver, 50);
                                        }}
                                        return;
                                    }}
                                    
                                    if (lightPageObserver) {{
                                        // Observer already set up
                                        return;
                                    }}
                                    
                                    lightPageObserver = new MutationObserver(function(mutations) {{
                                        try {{
                                            var body = document.body;
                                            if (!body) return;
                                            
                                            // Check if mode classes changed (mini-mode, micro-mode, or regular mode)
                                            var currentModeState = body.classList.contains('mini-mode') ? 'mini' : 
                                                                  body.classList.contains('micro-mode') ? 'micro' : 'regular';
                                            
                                            // Only re-run if mode actually changed
                                            if (lastModeState !== null && lastModeState !== currentModeState) {{
                                                // Small delay to ensure CSS has been applied
                                                setTimeout(detectLightPage, 150);
                                            }}
                                            
                                            lastModeState = currentModeState;
                                        }} catch (e) {{
                                            // Don't let observer errors break anything
                                            console.error('Bandcamp Player: Error in light page observer:', e);
                                        }}
                                    }});
                                    
                                    // Initialize mode state
                                    lastModeState = body.classList.contains('mini-mode') ? 'mini' : 
                                                   body.classList.contains('micro-mode') ? 'micro' : 'regular';
                                    
                                    lightPageObserver.observe(body, {{
                                        attributes: true,
                                        attributeFilter: ['class']
                                    }});
                                }} catch (e) {{
                                    console.error('Bandcamp Player: Error setting up light page observer:', e);
                                }}
                            }};
                            
                            setupObserver();
                        }} catch (e) {{
                            // Don't let observer setup errors break anything
                            console.error('Bandcamp Player: Error initializing light page observer:', e);
                        }}
                    }}
                    
                    // Windows 10 fix: Check if document is ready before manipulating DOM
                    // This is critical - if head isn't ready, we can't inject CSS
                    if (!document.head) {{
                        console.log('Bandcamp Player: document.head not ready, retrying...');
                        setTimeout(injectCSS, 50);
                        return;
                    }}
                    
                    // Remove existing injected styles (with error handling)
                    try {{
                        var existingStyle = document.getElementById('bandcamp-player-style');
                        if (existingStyle) {{
                            existingStyle.remove();
                        }}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error removing existing style:', e);
                        // Continue anyway - might not exist
                    }}
                    
                    // Inject CSS (critical - must not fail)
                    function reRunLightPageDetectionAfterCSS() {{
                    // Make runLightPageDetection globally accessible so it can be called from Python
                    window._runLightPageDetection = function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }};
                    
                    // Re-run light page detection after CSS is injected
                    // This ensures light-page class is applied after our styles are loaded
                    // Use longer delay to ensure styles are computed
                    setTimeout(function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }}, 200);
                    
                    // Also run again after a longer delay to catch late-loading styles
                    setTimeout(function() {{
                        if (typeof runLightPageDetection === 'function') {{
                            runLightPageDetection(0);
                        }}
                    }}, 500);
                    }}
                    
                    try {{
                        var style = document.createElement('style');
                        style.id = 'bandcamp-player-style';
                        style.textContent = {repr(css)};
                        document.head.appendChild(style);
                        // Re-run light page detection after CSS injection
                        reRunLightPageDetectionAfterCSS();
                    }} catch (e) {{
                        console.error('Bandcamp Player: Critical error injecting CSS:', e);
                        // This is critical - retry if it fails
                        setTimeout(function() {{
                            try {{
                                var style = document.createElement('style');
                                style.id = 'bandcamp-player-style';
                                style.textContent = {repr(css)};
                                document.head.appendChild(style);
                                // Re-run light page detection after retry CSS injection
                                reRunLightPageDetectionAfterCSS();
                            }} catch (e2) {{
                                console.error('Bandcamp Player: Retry CSS injection also failed:', e2);
                            }}
                        }}, 100);
                    }}
                    
                    // Apply mini mode classes if active (with null check in mini_mode_js)
                    // Wrap in try-catch to prevent errors from blocking other initialization
                    try {{
                        {mini_mode_js}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error applying mini mode classes:', e);
                    }}
                    
                    // If Bandcamp mode is active, ensure elements are properly hidden
                    // Wrap in try-catch to prevent errors from blocking other initialization
                    try {{
                        if ({str(self.bandcamp_mode).lower()}) {{
                            {bandcamp_hide_js}
                        }}
                    }} catch (e) {{
                        console.error('Bandcamp Player: Error applying bandcamp mode:', e);
                    }}
                    
                    // Setup cover art modal functionality (CRITICAL - image viewer)
                    // Wrap in try-catch but log errors - this is important
                    // The function itself now has retry logic, but we'll also retry here if it fails
                    function setupCoverArtModalWithRetry(retryCount) {{
                        retryCount = retryCount || 0;
                        var maxRetries = 5;
                        var retryDelay = 100;
                        
                        try {{
                            {cover_art_modal_js}
                        }} catch (e) {{
                            console.error('Bandcamp Player: Critical error setting up cover art modal:', e);
                            if (retryCount < maxRetries) {{
                                // Retry with exponential backoff
                                var delay = retryDelay * Math.pow(2, retryCount);
                                setTimeout(function() {{
                                    setupCoverArtModalWithRetry(retryCount + 1);
                                }}, delay);
                            }} else {{
                                console.error('Bandcamp Player: Max retries reached for cover art modal setup');
                            }}
                        }}
                    }}
                    
                    // Start setup - check if body is ready first
                    if (document.body) {{
                        setupCoverArtModalWithRetry();
                    }} else {{
                        // Wait for body to be ready
                        if (document.readyState === 'loading') {{
                            document.addEventListener('DOMContentLoaded', setupCoverArtModalWithRetry);
                        }} else {{
                            // Document loaded but body not ready - retry after delay
                            setTimeout(function() {{
                                setupCoverArtModalWithRetry();
                            }}, 50);
                        }}
                    }}
                    
                    // Force body styles to persist - apply directly to body element
                    function applyBodyStyles() {{
                        try {{
                            var body = document.body;
                            if (body) {{
                                // Remove pointer cursor and ensure default cursor
                                body.style.setProperty('cursor', 'default', 'important');
                                
                                // Remove opacity and filter on hover by adding event listeners
                                body.addEventListener('mouseenter', function(e) {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}, true);
                                
                                body.addEventListener('mouseleave', function(e) {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}, true);
                                
                                // Also set initial values
                                body.style.setProperty('opacity', '1', 'important');
                                body.style.setProperty('filter', 'brightness(1)', 'important');
                            }}
                        }} catch (e) {{
                            console.error('Bandcamp Player: Error applying body styles:', e);
                        }}
                    }}
                    
                    // Apply body styles immediately
                    applyBodyStyles();
                    
                    // Re-apply on DOM ready if body wasn't ready yet
                    if (document.readyState === 'loading') {{
                        document.addEventListener('DOMContentLoaded', applyBodyStyles);
                    }}
                    
                    // Use MutationObserver to ensure body styles persist even if page tries to change them
                    if (typeof MutationObserver !== 'undefined') {{
                        var bodyStyleObserver = new MutationObserver(function(mutations) {{
                            var body = document.body;
                            if (body) {{
                                // Re-apply cursor if it was changed
                                var currentCursor = window.getComputedStyle(body).cursor;
                                if (currentCursor === 'pointer') {{
                                    body.style.setProperty('cursor', 'default', 'important');
                                }}
                                
                                // Re-apply opacity and filter if they were changed
                                var currentOpacity = window.getComputedStyle(body).opacity;
                                var currentFilter = window.getComputedStyle(body).filter;
                                if (currentOpacity !== '1' || currentFilter !== 'none') {{
                                    body.style.setProperty('opacity', '1', 'important');
                                    body.style.setProperty('filter', 'brightness(1)', 'important');
                                }}
                            }}
                        }});
                        
                        // Observe body for style attribute changes
                        var body = document.body;
                        if (body) {{
                            bodyStyleObserver.observe(body, {{
                                attributes: true,
                                attributeFilter: ['style', 'class'],
                                subtree: false
                            }});
                        }} else {{
                            // Wait for body to be available
                            if (document.readyState === 'loading') {{
                                document.addEventListener('DOMContentLoaded', function() {{
                                    var body = document.body;
                                    if (body) {{
                                        bodyStyleObserver.observe(body, {{
                                            attributes: true,
                                            attributeFilter: ['style', 'class'],
                                            subtree: false
                                        }});
                                    }}
                                }});
                            }}
                        }}
                    }}
                }} catch (e) {{
                    console.error('Bandcamp Player: Error in CSS injection:', e);
                    // Don't crash - just log the error
                }}
            }})();
            """
    
    def inject_css(self):
        """Inject CSS for compact/dark/bandcamp/mini modes"""
        # Safety check: ensure web_view and page exist before injecting
        if not hasattr(self, 'web_view') or not self.web_view:
            logger.warning("inject_css: web_view not available, skipping injection")
            return
        if not self.web_view.page():
            logger.warning("inject_css: web_view.page() not available, skipping injection")
            return
        
        # Only use print statements if DEBUG environment variable is set
        debug_mode = os.environ.get('DEBUG')
        if debug_mode:
            print(f"[DEBUG] inject_css: START - compact={self.compact_mode}, bandcamp={self.bandcamp_mode}, mini_state={getattr(self, 'mini_mode_state', 'N/A')}")
            sys.stdout.flush()
        logger.debug(f"inject_css: Starting (compact={self.compact_mode}, bandcamp={self.bandcamp_mode}, mini_mode_state={getattr(self, 'mini_mode_state', 'N/A')})")
        try:
            css = self.css_injector.get_css(self.compact_mode, self.bandcamp_mode, self.mini_mode_state, self.webview_scrollbar_visible)
            if css:
                if debug_mode:
                    print(f"[DEBUG] inject_css: CSS generated, length={len(css)} chars")
                    sys.stdout.flush()
                logger.debug(f"inject_css: CSS generated, length={len(css)} chars")
                js = self._get_css_injection_js(css)
                if debug_mode:
                    print(f"[DEBUG] inject_css: JavaScript generated, executing...")
                    sys.stdout.flush()
                logger.debug(f"inject_css: JavaScript generated, executing...")
                self.web_view.page().runJavaScript(js)
                # Mark that JavaScript has been injected (image viewer and mini mode setup)
                self._js_injected_on_current_page = True
                if debug_mode:
                    print(f"[DEBUG] inject_css: JavaScript execution scheduled")
                    sys.stdout.flush()
                logger.debug(f"inject_css: JavaScript execution scheduled")
            else:
                if debug_mode:
                    print("[WARNING] inject_css: No CSS generated")
                    sys.stdout.flush()
                logger.warning("inject_css: No CSS generated")
        except Exception as e:
            print(f"[ERROR] inject_css: Error injecting CSS: {e}")
            if debug_mode:
                import traceback
                traceback.print_exc()
                sys.stdout.flush()
            logger.error(f"inject_css: Error injecting CSS: {e}", exc_info=True)
    
    def toggle_bandcamp_mode(self):
        """Toggle Bandcamp mode (hides unwanted elements, shows only player content)"""
        self.bandcamp_mode = not self.bandcamp_mode
        self.bandcamp_action.setChecked(self.bandcamp_mode)
        self.inject_css()
        # Update mini mode button visibility
        self.update_mini_mode_button()
        # If bandcamp mode is disabled and mini mode is active, reset mini mode
        if not self.bandcamp_mode and self.mini_mode_state != 0:
            self.mini_mode_state = 0
            # Always use default regular mode size
            self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            self.inject_css()
            self.update_mini_mode_button()
            self.update_mini_mode_menu_text()
        self.save_settings()
    
    def toggle_compact_mode(self):
        """Toggle compact mode"""
        self.compact_mode = not self.compact_mode
        self.compact_action.setChecked(self.compact_mode)
        self.inject_css()
        self.save_settings()
    
    def toggle_mini_mode(self):
        """Toggle mini mode (cycles through: Regular -> Mini -> Micro -> Regular)"""
        # Disable mode switching if welcome message is visible (no URLs loaded, empty playlist)
        if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
            playlist = self.playlist_manager.get_playlist()
            if not playlist or len(playlist) == 0:
                # Welcome message is visible and playlist is empty - disable mode switching
                return
        
        # Only allow mini mode when bandcamp mode is active
        if not self.bandcamp_mode and self.mini_mode_state == 0:
            QMessageBox.information(self, "Mini Mode", "Bandcamp Mode must be enabled to use Mini Mode.")
            return
        
        # Cycle through states: 0 -> 1 -> 2 -> 0
        self.mini_mode_state = (self.mini_mode_state + 1) % 3
        
        # Apply mini mode (no need to store original size - always use defaults)
        self.apply_mini_mode()
        
        # If windows are docked together (linked), reposition playlist to maintain docked relationship
        if (self.playlist_detached and self.playlist_window_linked and self._windows_docked and
            hasattr(self, 'detached_playlist_window') and self.detached_playlist_window):
            # Get current link offset to determine docking relationship
            if hasattr(self, '_playlist_window_link_offset') and self._playlist_window_link_offset:
                offset_x, offset_y = self._playlist_window_link_offset
                # Calculate new position based on offset
                new_playlist_x = self.x() + offset_x
                new_playlist_y = self.y() + offset_y
                
                # Check if playlist is at bottom of main window
                main_bottom = self.y() + self.height()
                playlist_top = self.detached_playlist_window.y()
                is_at_bottom = abs(playlist_top - main_bottom) <= self._snap_threshold
                
                # If at bottom or offset indicates bottom docking, reposition to maintain it
                if is_at_bottom or offset_y > self.height() * 0.8:  # Playlist is at or near bottom
                    new_playlist_y = self.y() + self.height()
                    self._moving_detached_playlist_programmatically = True
                    self.detached_playlist_window.move(new_playlist_x, new_playlist_y)
                    # Update link offset
                    self._playlist_window_link_offset = (offset_x, new_playlist_y - self.y())
                    QTimer.singleShot(50, lambda: setattr(self, '_moving_detached_playlist_programmatically', False))
                else:
                    # For other docking positions (top, left, right), maintain the offset
                    self._moving_detached_playlist_programmatically = True
                    self.detached_playlist_window.move(new_playlist_x, new_playlist_y)
                    QTimer.singleShot(50, lambda: setattr(self, '_moving_detached_playlist_programmatically', False))
        
        # Update UI
        self.update_mini_mode_button()
        self.update_mini_mode_menu_text()
        
        # Update hover area position for micro mode changes
        if hasattr(self, 'update_hover_area_position') and self.autohide_address_bar:
            QTimer.singleShot(100, self.update_hover_area_position)
        
        # Update trigger button position (moves to top right in micro mode)
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
            self.update_autohide_trigger_position()
        
        # Save settings
        self.save_settings()
    
    def _ensure_window_on_screen(self):
        """Ensure the window is fully visible on screen, adjusting position if needed"""
        try:
            # Get the screen that contains the window
            screen = self.screen()
            if not screen:
                # Fallback to primary screen
                screen = QApplication.primaryScreen()
            
            if not screen:
                return  # Can't determine screen, skip adjustment
            
            # Get available screen geometry (excluding taskbar, etc.)
            available_geometry = screen.availableGeometry()
            
            # Get current window geometry
            window_geometry = self.geometry()
            window_bottom = window_geometry.y() + window_geometry.height()
            screen_bottom = available_geometry.y() + available_geometry.height()
            
            # Check if window would go off the bottom of the screen
            if window_bottom > screen_bottom:
                # Calculate how much we need to move up
                offset = window_bottom - screen_bottom
                new_y = window_geometry.y() - offset
                
                # Ensure we don't move above the top of the screen
                if new_y < available_geometry.y():
                    new_y = available_geometry.y()
                
                # Move window up to keep it on screen
                self.move(window_geometry.x(), new_y)
                logger.debug(f"Adjusted window position from ({window_geometry.x()}, {window_geometry.y()}) to ({window_geometry.x()}, {new_y}) to keep on screen")
        except Exception as e:
            logger.warning(f"Error ensuring window on screen: {e}")
    
    def apply_mini_mode(self):
        """Apply mini mode state (resize window and inject CSS)"""
        logger.debug(f"apply_mini_mode: state={self.mini_mode_state}")
        
        # Close image viewer modal when switching modes
        if self.web_view and self.web_view.page():
            close_modal_js = """
            (function() {
                var modal = document.getElementById('bandcamp-player-cover-modal');
                if (modal && modal.classList.contains('active')) {
                    modal.classList.remove('active');
                    var img = document.getElementById('bandcamp-player-cover-modal-content');
                    if (img) {
                        img.src = '';
                        img.alt = '';
                    }
                    document.body.style.overflow = '';
                }
            })();
            """
            self.web_view.page().runJavaScript(close_modal_js)
        
        if not self.web_view:
            logger.warning("apply_mini_mode: web_view not available")
            return
        
        # Always inject CSS first - no delays needed since we're not using display:none
        self.inject_css()

        # Keep playlist quick button in sync when switching modes
        try:
            QTimer.singleShot(0, self.update_playlist_quick_btn_visibility)
        except Exception:
            pass
        
        if self.mini_mode_state == 0:
            # Regular mode: always use fixed default size (not resizable)
            # Clear micro mode cover art height constraints after CSS injection
            # Use a small delay to ensure CSS injection JavaScript has run
            QTimer.singleShot(50, self._clear_micro_mode_cover_art_height)
            
            # Clear any stored constraint attributes (no longer needed)
            if hasattr(self, '_mini_mode_original_min_size'):
                delattr(self, '_mini_mode_original_min_size')
            if hasattr(self, '_mini_mode_original_max_size'):
                delattr(self, '_mini_mode_original_max_size')
            if hasattr(self, '_micro_mode_original_min_size'):
                delattr(self, '_micro_mode_original_min_size')
            if hasattr(self, '_micro_mode_original_max_size'):
                delattr(self, '_micro_mode_original_max_size')
            
            # Regular mode: fixed size, not resizable
            # Always use default size - no need to store/restore
            self.setMinimumSize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            self.setMaximumSize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            
            # Restore playlist height if we're leaving micro mode
            # Try to restore from _playlist_height_before_micro first, then from playlist_height_regular
            restored_height = None
            if hasattr(self, '_playlist_height_before_micro') and self._playlist_height_before_micro is not None:
                restored_height = self._playlist_height_before_micro
            elif self.settings.get('playlist_height_regular'):
                restored_height = self.settings.get('playlist_height_regular')
                logger.debug(f"Using playlist_height_regular for restoration: {restored_height}")
            
            if restored_height is not None and restored_height != 135:  # Don't restore micro mode height
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    # Only restore height if playlist is expanded (not minimized)
                    if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                        restored_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, restored_height)))
                        self.playlist_sidebar.setFixedHeight(restored_height)
                        if hasattr(self.playlist_sidebar, '_restore_height'):
                            self.playlist_sidebar._restore_height = restored_height
                        # Update settings with restored height
                        self.settings['playlist_height'] = restored_height
                        self.settings['playlist_height_regular'] = restored_height
                        self.settings['playlist_attached_height'] = restored_height
                        self.save_settings()
                        logger.debug(f"Restored playlist height from micro mode: {restored_height}")
                    else:
                        # Playlist is minimized or hidden - just set the restore height for when it's expanded
                        restored_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, restored_height)))
                        if hasattr(self.playlist_sidebar, '_restore_height'):
                            self.playlist_sidebar._restore_height = restored_height
                        # Update settings with restored height (for when expanded)
                        self.settings['playlist_height'] = restored_height
                        self.settings['playlist_height_regular'] = restored_height
                        self.settings['playlist_attached_height'] = restored_height
                        self.save_settings()
                        logger.debug(f"Set playlist restore height from micro mode (will apply when expanded): {restored_height}")
                # Clear the stored height
                if hasattr(self, '_playlist_height_before_micro'):
                    delattr(self, '_playlist_height_before_micro')

            # If we were previously in mini mode and forced a fixed playlist height (300),
            # restore the user's attached regular-mode height now that we're back in regular mode.
            try:
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
                    # Prefer explicit snapshot captured when entering mini mode
                    desired_attached = getattr(self, '_playlist_height_before_mini', None)
                    if desired_attached is None:
                        desired_attached = self.settings.get('playlist_attached_height')

                    if desired_attached:
                        desired_attached = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, int(desired_attached))))

                        # Only apply if playlist is visible+expanded and currently at a fixed mode height
                        if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized:
                            current_h = int(self.playlist_sidebar.height())
                            if current_h in (135, 300) and current_h != desired_attached:
                                self.playlist_sidebar.setFixedHeight(desired_attached)
                                if hasattr(self.playlist_sidebar, '_restore_height'):
                                    self.playlist_sidebar._restore_height = desired_attached
                                # Keep settings consistent
                                self.settings['playlist_height'] = desired_attached
                                self.settings['playlist_height_regular'] = desired_attached
                                self.settings['playlist_attached_height'] = desired_attached
                                self.save_settings()
            except Exception:
                pass
            finally:
                # Clear snapshot if present so it doesn't override future user changes
                try:
                    if hasattr(self, '_playlist_height_before_mini'):
                        delattr(self, '_playlist_height_before_mini')
                except Exception:
                    pass
            
            # Always resize to default regular mode size (fixed, not resizable)
            self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            QApplication.processEvents()  # Force UI update
            # Ensure window stays on screen after resize
            self._ensure_window_on_screen()
            logger.debug(f"Switched to regular mode: {WINDOW_DEFAULT_WIDTH}x{WINDOW_DEFAULT_HEIGHT}")
            
            # Clear micro mode flag
            self._was_micro_mode = False
        elif self.mini_mode_state == 1:
            # Mini mode: resize to cover art size (image height)
            # Clear micro mode cover art height constraints after CSS injection
            # Use a small delay to ensure CSS injection JavaScript has run
            QTimer.singleShot(50, self._clear_micro_mode_cover_art_height)
            
            # Clear any stored constraint attributes (no longer needed)
            if hasattr(self, '_mini_mode_original_min_size'):
                delattr(self, '_mini_mode_original_min_size')
            if hasattr(self, '_mini_mode_original_max_size'):
                delattr(self, '_mini_mode_original_max_size')
            if hasattr(self, '_micro_mode_original_min_size'):
                delattr(self, '_micro_mode_original_min_size')
            if hasattr(self, '_micro_mode_original_max_size'):
                delattr(self, '_micro_mode_original_max_size')
            
            # Mini mode: always use WINDOW_DEFAULT_WIDTH for width
            # Height will be calculated dynamically by resize_to_mini_mode based on cover art + playlist
            
            # Restore playlist height if we're leaving micro mode
            # Try to restore from _playlist_height_before_micro first, then from playlist_height_regular
            restored_height = None
            if hasattr(self, '_playlist_height_before_micro') and self._playlist_height_before_micro is not None:
                restored_height = self._playlist_height_before_micro
            elif self.settings.get('playlist_height_regular'):
                restored_height = self.settings.get('playlist_height_regular')
                logger.debug(f"Using playlist_height_regular for restoration: {restored_height}")
            
            if restored_height is not None and restored_height != 135:  # Don't restore micro mode height
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    # Only restore height if playlist is expanded (not minimized)
                    if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                        restored_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, restored_height)))
                        self.playlist_sidebar.setFixedHeight(restored_height)
                        if hasattr(self.playlist_sidebar, '_restore_height'):
                            self.playlist_sidebar._restore_height = restored_height
                        # Update settings with restored height
                        self.settings['playlist_height'] = restored_height
                        self.settings['playlist_height_regular'] = restored_height
                        self.settings['playlist_attached_height'] = restored_height
                        self.save_settings()
                        logger.debug(f"Restored playlist height from micro mode: {restored_height}")
                    else:
                        # Playlist is minimized or hidden - just set the restore height for when it's expanded
                        restored_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, restored_height)))
                        if hasattr(self.playlist_sidebar, '_restore_height'):
                            self.playlist_sidebar._restore_height = restored_height
                        # Update settings with restored height (for when expanded)
                        self.settings['playlist_height'] = restored_height
                        self.settings['playlist_height_regular'] = restored_height
                        self.settings['playlist_attached_height'] = restored_height
                        self.save_settings()
                        logger.debug(f"Set playlist restore height from micro mode (will apply when expanded): {restored_height}")
                # Clear the stored height
                if hasattr(self, '_playlist_height_before_micro'):
                    delattr(self, '_playlist_height_before_micro')
            
            # If playlist is expanded when entering mini mode, set it to fixed height (300px)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                    # Snapshot attached regular-mode height BEFORE forcing fixed mini-mode height.
                    # This is the height we want to restore when returning to regular mode.
                    try:
                        pre_height = int(self.playlist_sidebar.height())
                        if PLAYLIST_MIN_HEIGHT <= pre_height <= PLAYLIST_MAX_HEIGHT and pre_height != 135:
                            self._playlist_height_before_mini = pre_height
                            self.settings['playlist_attached_height'] = pre_height
                            self.settings['playlist_height_regular'] = pre_height
                            self.settings['playlist_height'] = pre_height
                            self.save_settings()
                    except Exception:
                        pass
                    # Mini mode: always use fixed height of 300px (not resizable)
                    mini_mode_playlist_height = 300
                    self.playlist_sidebar.setFixedHeight(mini_mode_playlist_height)
                    # Don't save this height - it's fixed for mini mode
                    # Set restore height but don't save to settings
                    if hasattr(self.playlist_sidebar, '_restore_height'):
                        self.playlist_sidebar._restore_height = mini_mode_playlist_height
            
            # Resize after a brief delay to ensure CSS is applied
            QTimer.singleShot(100, self.resize_to_mini_mode)
            # Scroll to top of page when entering mini mode
            def scroll_to_top():
                if self.web_view and self.web_view.page():
                    scroll_js = """
                    (function() {
                        window.scrollTo({top: 0, behavior: 'smooth'});
                        // Also try scrolling document and body elements
                        if (document.documentElement) {
                            document.documentElement.scrollTop = 0;
                        }
                        if (document.body) {
                            document.body.scrollTop = 0;
                        }
                    })();
                    """
                    self.web_view.page().runJavaScript(scroll_js)
            QTimer.singleShot(150, scroll_to_top)  # Slight delay after resize to ensure page is ready
            # No longer using track change detection
            self._was_micro_mode = False
        elif self.mini_mode_state == 2:
            # Micro mode: resize to player size
            # Clear any stored constraint attributes (no longer needed)
            if hasattr(self, '_mini_mode_original_min_size'):
                delattr(self, '_mini_mode_original_min_size')
            if hasattr(self, '_mini_mode_original_max_size'):
                delattr(self, '_mini_mode_original_max_size')
            if hasattr(self, '_micro_mode_original_min_size'):
                delattr(self, '_micro_mode_original_min_size')
            if hasattr(self, '_micro_mode_original_max_size'):
                delattr(self, '_micro_mode_original_max_size')
            
            # Reset window minimum/maximum sizes to allow resizing
            # This must happen so the window can actually resize when resize_to_micro_mode is called
            # IMPORTANT: Clear mini mode's fixed size constraints first
            # When coming from mini mode, we need to aggressively clear the fixed size constraints
            current_size = self.size()
            is_coming_from_mini = current_size.height() > 300  # Likely coming from mini mode (mini mode is typically > 300px)
            
            if is_coming_from_mini:
                # Clear any resizing flags that might block the resize
                if hasattr(self, '_mini_mode_resizing'):
                    self._mini_mode_resizing = False
                if hasattr(self, '_micro_mode_resizing'):
                    self._micro_mode_resizing = False
                
                # Aggressively clear fixed size constraints by setting to unlimited first
                # This ensures Qt recognizes the constraints have changed
                self.setMinimumSize(0, 0)  # Temporarily set to 0 to break any fixed constraints
                self.setMaximumSize(QSize(16777215, 16777215))  # Qt's default maximum (effectively unlimited)
                QApplication.processEvents()
                
                # Force a small immediate resize to break the fixed size constraint
                # This ensures Qt actually recognizes the constraints have changed
                # Resize to a size that's definitely different from mini mode
                temp_height = max(200, min(250, current_size.height() // 2))
                self.resize(WINDOW_DEFAULT_WIDTH, temp_height)
                QApplication.processEvents()
                QApplication.processEvents()  # Process twice to ensure resize is applied
                
                # Now set to proper minimums
                self.setMinimumSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT)
                QApplication.processEvents()
                
                # Force geometry update to ensure constraints are fully cleared
                self.updateGeometry()
                QApplication.processEvents()
                logger.debug(f"Cleared mini mode fixed size constraints (was {current_size.width()}x{current_size.height()}, temp resize to {temp_height}px)")
            else:
                # Not coming from mini mode - just set normal constraints
                self.setMinimumSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT)
                self.setMaximumSize(QSize(16777215, 16777215))
                QApplication.processEvents()
            
            # Micro mode: always use WINDOW_DEFAULT_WIDTH for width
            # Height will be calculated dynamically by resize_to_micro_mode based on player + playlist
            
            # Save current playlist height before entering micro mode (if not already saved)
            # Only save if we're coming from mini/regular mode (not already in micro)
            if not hasattr(self, '_playlist_height_before_micro') or self._playlist_height_before_micro is None:
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    # Save the *regular attached* height for restoration later.
                    # IMPORTANT: in mini mode, _restore_height is set to 300 (fixed), so prefer the persisted
                    # attached height from settings when attached.
                    candidate = None
                    try:
                        if not self.playlist_detached:
                            candidate = self.settings.get('playlist_attached_height')
                    except Exception:
                        candidate = None
                    if not candidate:
                        # Fallback to current restore height / actual height
                        if hasattr(self.playlist_sidebar, '_restore_height') and self.playlist_sidebar._restore_height:
                            candidate = self.playlist_sidebar._restore_height
                        else:
                            candidate = self.playlist_sidebar.height()
                    self._playlist_height_before_micro = candidate
                    logger.debug(f"Saving playlist height before micro mode: {self._playlist_height_before_micro}")
                    # Also save to settings as playlist_height_regular for persistence across app restarts
                    if self._playlist_height_before_micro != 135:  # Don't save micro mode height
                        self.settings['playlist_height_regular'] = self._playlist_height_before_micro
                        # Keep attached height stable across mode changes (do not overwrite with fixed heights).
                        # NOTE: If a user legitimately set 300 as their preferred height, we still want to remember it.
                        if not self.playlist_detached:
                            self.settings['playlist_attached_height'] = self._playlist_height_before_micro
                        self.save_settings()
                        logger.debug(f"Saved playlist_height_regular: {self._playlist_height_before_micro}")
            
            # Set playlist height to 135 when entering micro mode (for when expanded in micro mode)
            # Micro mode: always use fixed height of 135px (not resizable)
            # Close and reopen playlist if it's visible to ensure proper state on first launch
            # Only do this the first time entering micro mode (to fix first launch issue)
            # Flag persists in settings so it only happens once ever, unless settings are cleared
            playlist_was_visible = False
            should_fix_playlist = not self.settings.get('micro_mode_playlist_fixed', False)
            if should_fix_playlist and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached:
                playlist_was_visible = True
                # Close the playlist to reset its state
                self.playlist_sidebar.close_playlist()
                # Force layout update after closing
                layout = self.centralWidget().layout()
                if layout:
                    layout.update()
                    layout.activate()
                QApplication.processEvents()
                logger.debug("Closed playlist when entering micro mode (first time) - will reopen after delay")
                # Mark that we've done this fix so it doesn't happen again (persists in settings)
                self.settings['micro_mode_playlist_fixed'] = True
                self.save_settings()
            
            # Set the restore height to 135 (for when expanded in micro mode)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                if hasattr(self.playlist_sidebar, '_restore_height'):
                    self.playlist_sidebar._restore_height = 135
            
            # Resize after a delay to ensure CSS is applied
            # If coming from mini mode, use a longer delay to ensure the temporary resize completes
            # If playlist was visible, reopen it after a delay to ensure proper state restoration
            base_delay = 200 if is_coming_from_mini else 100
            delay = base_delay
            
            if playlist_was_visible:
                # Reopen playlist after a delay to ensure it's properly restored with minimized state
                def reopen_playlist():
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                        # Reopen the playlist - this will restore its state properly
                        self.toggle_playlist()
                        # Ensure it's minimized if it should be
                        if self.playlist_sidebar.isVisible() and not self.playlist_sidebar.is_minimized and not self.playlist_detached:
                            self.playlist_sidebar._toggle_minimize_state()
                        # Force geometry updates
                        self.playlist_sidebar.updateGeometry()
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            self.playlist_container.updateGeometry()
                        layout = self.centralWidget().layout()
                        if layout:
                            layout.update()
                            layout.activate()
                        QApplication.processEvents()
                        logger.debug(f"Reopened playlist in micro mode (minimized: {self.playlist_sidebar.is_minimized if self.playlist_sidebar.isVisible() else 'hidden'})")
                        # Trigger resize after playlist is reopened
                        QTimer.singleShot(100, self.resize_to_micro_mode)
                    else:
                        # Playlist doesn't exist yet, just trigger resize
                        QTimer.singleShot(100, self.resize_to_micro_mode)
                
                QTimer.singleShot(150, reopen_playlist)
            else:
                QTimer.singleShot(delay, self.resize_to_micro_mode)
            self._was_micro_mode = True
    
    def _restore_regular_mode(self):
        """Restore regular mode size (immediate restore)"""
        try:
            # Always use default regular mode size
            self.resize(WINDOW_DEFAULT_WIDTH, WINDOW_DEFAULT_HEIGHT)
            # Restore normal minimum height
            self.setMinimumHeight(WINDOW_MIN_HEIGHT)
        except Exception as e:
            logger.error(f"Error restoring regular mode: {e}", exc_info=True)
    
    def _inject_css_with_log(self, context=""):
        """Inject CSS with logging for debugging"""
        logger.debug(f"_inject_css_with_log: Injecting CSS (context: {context})")
        try:
            self.inject_css()
            logger.debug(f"_inject_css_with_log: CSS injection complete (context: {context})")
        except Exception as e:
            logger.error(f"_inject_css_with_log: Error injecting CSS (context: {context}): {e}", exc_info=True)
    
    def resize_to_mini_mode(self, retry_count=0):
        """Resize window to cover art height only (maintain width, player overlays via CSS)"""
        if not self.web_view:
            return
        # Only resize if actually in mini mode (prevents late timers from resizing after mode switch)
        if getattr(self, 'mini_mode_state', 0) != 1:
            return
        
        # Ensure original size is set (needed for width)
        # Micro mode: always use WINDOW_DEFAULT_WIDTH for width
        # No need to store original size
        
        # Get cover art dimensions via JavaScript
        # Fixed: Handle carousels with multiple images by finding the currently visible image
        # Windows 10 fix: Add extra safety checks and error handling for carousel stability
        js_code = """
        (function() {
            try {
                // Wait a moment for carousel to stabilize (Windows 10 fix for multiple images)
                var albumArt = document.querySelector('#tralbum-art-carousel');
                if (!albumArt) {
                    return null;
                }
                
                // Ensure element is in the DOM and has layout
                if (!albumArt.offsetParent && albumArt.style.display === 'none') {
                    return null;
                }
                
                var albumArtRect = albumArt.getBoundingClientRect();
                if (!albumArtRect || albumArtRect.height === 0 || !isFinite(albumArtRect.height)) {
                    // Retry after a brief delay (carousel might still be loading)
                    return null;
                }
                
                // Find the currently visible/active image in the carousel
                // For carousels with multiple images, we need to find the one that's actually displayed
                var visibleImg = null;
                
                // Method 1: Look for images in active carousel items
                // Windows 10 fix: Add try-catch around DOM queries to prevent crashes
                try {
                var carouselItems = albumArt.querySelectorAll('.carousel-item, [class*="carousel-item"], [class*="active"]');
                for (var i = 0; i < carouselItems.length; i++) {
                        try {
                    var item = carouselItems[i];
                            if (!item || !item.parentNode) continue; // Skip if detached from DOM
                            
                    var style = window.getComputedStyle(item);
                    // Check if item is visible (not hidden)
                            if (style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
                        var img = item.querySelector('img');
                                if (img && img.parentNode) {
                            var imgStyle = window.getComputedStyle(img);
                                    if (imgStyle && imgStyle.display !== 'none' && imgStyle.visibility !== 'hidden') {
                                visibleImg = img;
                                break;
                            }
                        }
                    }
                        } catch (itemError) {
                            // Skip this item if there's an error
                            continue;
                        }
                    }
                } catch (carouselError) {
                    // If carousel query fails, fall back to other methods
                    console.log('Bandcamp Player: Error querying carousel items:', carouselError);
                }
                
                // Method 2: If no active item found, look for images that are actually visible
                // Windows 10 fix: Add safety checks to prevent crashes
                if (!visibleImg) {
                    try {
                    var allImgs = albumArt.querySelectorAll('img');
                    for (var i = 0; i < allImgs.length; i++) {
                            try {
                        var img = allImgs[i];
                                if (!img || !img.parentNode) continue; // Skip if detached
                                
                        var imgStyle = window.getComputedStyle(img);
                                if (!imgStyle) continue;
                                
                        var imgRect = img.getBoundingClientRect();
                                if (!imgRect) continue;
                                
                        // Check if image is visible and has dimensions
                        if (imgStyle.display !== 'none' && 
                            imgStyle.visibility !== 'hidden' && 
                            imgStyle.opacity !== '0' &&
                                    isFinite(imgRect.width) && isFinite(imgRect.height) &&
                            imgRect.width > 0 && imgRect.height > 0) {
                            visibleImg = img;
                            break;
                        }
                            } catch (imgError) {
                                // Skip this image if there's an error
                                continue;
                            }
                        }
                    } catch (allImgsError) {
                        console.log('Bandcamp Player: Error querying all images:', allImgsError);
                    }
                }
                
                // Method 3: Fallback to first image if still not found
                if (!visibleImg) {
                    visibleImg = albumArt.querySelector('img');
                }
                
                // Calculate cover art height safely
                var coverArtHeight = albumArtRect.height; // Default to container height
                
                if (visibleImg) {
                    try {
                        var imgRect = visibleImg.getBoundingClientRect();
                        var imgOffsetHeight = visibleImg.offsetHeight || 0;
                        var imgNaturalHeight = visibleImg.naturalHeight || 0;
                        var imgNaturalWidth = visibleImg.naturalWidth || 0;
                        var albumArtWidth = albumArtRect.width || 1; // Prevent division by zero
                        
                        // Calculate height based on aspect ratio if natural dimensions are available
                        if (imgNaturalWidth > 0 && imgNaturalHeight > 0 && albumArtWidth > 0) {
                            var aspectRatioHeight = imgNaturalHeight * (albumArtWidth / imgNaturalWidth);
                            coverArtHeight = Math.max(imgOffsetHeight, aspectRatioHeight, albumArtRect.height);
                        } else if (imgOffsetHeight > 0) {
                            coverArtHeight = Math.max(imgOffsetHeight, albumArtRect.height);
                        }
                    } catch (e) {
                        // If calculation fails, use container height
                        console.log('Bandcamp Player: Error calculating image height, using container height:', e);
                        coverArtHeight = albumArtRect.height;
                    }
                }
                
                // Ensure we have a valid height
                if (!coverArtHeight || coverArtHeight <= 0 || !isFinite(coverArtHeight)) {
                    coverArtHeight = albumArtRect.height || 400; // Fallback to 400 if all else fails
                }
                
                return {
                    coverArtHeight: coverArtHeight,
                    coverArtRectHeight: albumArtRect.height
                };
            } catch (e) {
                console.log('Bandcamp Player: Error in resize_to_mini_mode JavaScript:', e);
                return null;
            }
        })();
        """
        
        def on_dimensions_received(result):
            try:
                if result and isinstance(result, dict):
                    # Use the actual cover art image height, not the container height
                    cover_art_height = result.get('coverArtHeight')
                    if not cover_art_height:
                        cover_art_height = result.get('coverArtRectHeight', 400)
                    
                    # Ensure we have a valid number
                    try:
                        cover_art_height = int(float(cover_art_height))
                        if cover_art_height <= 0:
                            raise ValueError("Invalid height")
                    except (ValueError, TypeError):
                        # Use fallback if conversion fails
                        if self.mini_mode_cover_art_height:
                            cover_art_height = self.mini_mode_cover_art_height
                        else:
                            cover_art_height = 400
                    
                    # Calculate window padding (title bar + address bar)
                    window_padding = 0
                    if self.title_bar and self.title_bar.isVisible():
                        window_padding += self.title_bar.height()
                    if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                        if hasattr(self, 'controls_bar_in_layout') and self.controls_bar_in_layout:
                            window_padding += self.controls_bar_widget.height()
                    
                    # Account for playlist sidebar title bar if playlist is visible
                    # Treat detached playlist as closed for resizing purposes
                    playlist_title_bar_height = 0
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached:
                        # Always use 40px for playlist title bar height (includes borders)
                        playlist_title_bar_height = 35
                    
                    # Mini mode: window height = cover art height only (tracklist is scrollable below)
                    # Don't add playlist height - window should only be cover art height
                    base_height = cover_art_height + window_padding + playlist_title_bar_height
                    
                    # Store cover art height for future reference (just the cover art, not including padding)
                    self.mini_mode_cover_art_height = cover_art_height
                    
                    # Save to settings for next startup
                    self.settings["mini_mode_saved_height"] = cover_art_height
                    self.save_settings()
                    
                    # Window height is just cover art + padding + playlist title bar (tracklist scrolls below)
                    # Subtract 88px to reduce mini mode height, but never allow an unreasonably small window.
                    total_height = max(200, base_height - 88)
                    original_width = WINDOW_DEFAULT_WIDTH
                    
                    try:
                        # Set flag to allow programmatic resize (prevents resizeEvent from blocking it)
                        self._mini_mode_resizing = True
                        self.resize(original_width, total_height)
                        # Set fixed size to prevent user resizing in mini mode
                        self.setMinimumSize(original_width, total_height)
                        self.setMaximumSize(original_width, total_height)
                        logger.debug(f"Resized to mini mode: {original_width}x{total_height} (cover art: {cover_art_height}, padding: {window_padding})")
                        # Clear flag after resize completes
                        QTimer.singleShot(50, lambda: setattr(self, '_mini_mode_resizing', False))
                    except Exception as e:
                        logger.error(f"Could not resize to mini mode: {e}", exc_info=True)
                        # Clear flag on error too
                        self._mini_mode_resizing = False
                else:
                    # If we couldn't measure yet (common on first startup load), retry a couple times.
                    try:
                        current_retry = int(retry_count) if retry_count is not None else 0
                    except Exception:
                        current_retry = 0
                    if current_retry < 2:
                        QTimer.singleShot(250, lambda: self.resize_to_mini_mode(current_retry + 1))
                        return
                    
                    # Last-resort fallback if dimensions not available after retries
                    base_height = int(getattr(self, 'mini_mode_cover_art_height', 0) or 0)
                    if base_height <= 0:
                        base_height = int(self.settings.get("mini_mode_saved_height") or 0)
                    if base_height <= 0:
                        base_height = 400
                    
                    window_padding = 0
                    if getattr(self, 'title_bar', None) and self.title_bar.isVisible():
                        window_padding += self.title_bar.height()
                    if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                        if hasattr(self, 'controls_bar_in_layout') and self.controls_bar_in_layout:
                            window_padding += self.controls_bar_widget.height()
                    
                    # Account for playlist sidebar title bar if playlist is visible
                    # Treat detached playlist as closed for resizing purposes
                    playlist_title_bar_height = 0
                    if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible() and not self.playlist_detached:
                        playlist_title_bar_height = 35
                    
                    total_height = max(200, base_height + window_padding + playlist_title_bar_height - 88)
                    original_width = WINDOW_DEFAULT_WIDTH
                    try:
                        self._mini_mode_resizing = True
                        self.resize(original_width, total_height)
                        self.setMinimumSize(original_width, total_height)
                        self.setMaximumSize(original_width, total_height)
                        QTimer.singleShot(50, lambda: setattr(self, '_mini_mode_resizing', False))
                    except Exception as e:
                        logger.error(f"Could not resize to mini mode (fallback): {e}", exc_info=True)
                        self._mini_mode_resizing = False
            except Exception as e:
                logger.error(f"Error in resize_to_mini_mode callback: {e}", exc_info=True)
                # Use stored height as last resort
                if self.mini_mode_cover_art_height:
                    try:
                        original_width = WINDOW_DEFAULT_WIDTH
                        self.resize(original_width, self.mini_mode_cover_art_height)
                    except:
                        pass
        
        self.web_view.page().runJavaScript(js_code, on_dimensions_received)
    
    def resize_to_micro_mode(self):
        """Resize window to player size only (maintain width, fit exactly to player)"""
        # Only resize if actually in micro mode
        if self.mini_mode_state != 2:
            logger.debug(f"resize_to_micro_mode: Not in micro mode (state={self.mini_mode_state}), skipping")
            return
        
        if not self.web_view:
            return
        
        # Don't resize if already resizing (prevent cascading)
        if hasattr(self, '_micro_mode_resizing') and self._micro_mode_resizing:
            logger.debug("resize_to_micro_mode: Already resizing, skipping")
            return
        
        # Ensure constraints are properly cleared (in case we're coming from mini mode)
        # Check if min and max are the same (fixed size) - if so, clear them
        current_min = self.minimumSize()
        current_max = self.maximumSize()
        current_size = self.size()
        is_stuck_at_mini_size = current_size.height() > 300  # Still at mini mode size
        
        if (current_min.width() == current_max.width() and current_min.height() == current_max.height()) or is_stuck_at_mini_size:
            # Window has fixed size constraints or is still at mini mode size - clear them aggressively
            logger.debug(f"Window appears stuck at mini mode size ({current_size.width()}x{current_size.height()}) or has fixed constraints - clearing aggressively")
            
            # Aggressively clear constraints
            self.setMinimumSize(0, 0)
            self.setMaximumSize(QSize(16777215, 16777215))
            QApplication.processEvents()
            
            # Force a small resize to break the constraint if still at mini size
            if is_stuck_at_mini_size:
                temp_height = max(200, min(250, current_size.height() // 2))
                self.resize(WINDOW_DEFAULT_WIDTH, temp_height)
                QApplication.processEvents()
                QApplication.processEvents()
                logger.debug(f"Forced temporary resize to {temp_height}px to break mini mode constraint")
            
            # Set proper minimums
            self.setMinimumSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT)
            self.updateGeometry()
            QApplication.processEvents()
            logger.debug(f"Cleared fixed size constraints in resize_to_micro_mode")
        
        # Set flag early to allow programmatic resize (prevents resizeEvent from blocking it)
        # This must be set BEFORE any resize operations, including JavaScript callbacks
        self._micro_mode_resizing = True
        
        # Micro mode: always use WINDOW_DEFAULT_WIDTH for width
        # No need to store original size - always use default width
        
        # Get player dimensions via JavaScript - use multiple methods to find exact bottom
        js_code = """
        (function() {
            var player = document.querySelector('#player');
            if (!player) {
                return null;
            }
            
            // Method 1: getBoundingClientRect (viewport-relative, add scrollY for document-relative)
            var playerRect = player.getBoundingClientRect();
            var method1_bottom = playerRect.bottom + window.scrollY;
            
            // Method 2: offsetTop + offsetHeight (layout-based, includes margins)
            var method2_bottom = player.offsetTop + player.offsetHeight;
            
            // Method 3: getBoundingClientRect with computed margins
            var computedStyle = window.getComputedStyle(player);
            var marginBottom = parseFloat(computedStyle.marginBottom) || 0;
            var marginTop = parseFloat(computedStyle.marginTop) || 0;
            var method3_bottom = playerRect.bottom + window.scrollY + marginBottom;
            
            // Method 4: Use offsetTop + offsetHeight + marginBottom (most reliable for layout)
            var method4_bottom = player.offsetTop + player.offsetHeight + marginBottom;
            
            // Method 5: Check parent container's bottom if player is last child
            var parent = player.parentElement;
            var method5_bottom = method1_bottom;
            if (parent) {
                var parentRect = parent.getBoundingClientRect();
                var parentBottom = parentRect.bottom + window.scrollY;
                // Only use if parent bottom is close to player bottom (within 50px)
                if (Math.abs(parentBottom - method1_bottom) < 50) {
                    method5_bottom = parentBottom;
                }
            }
            
            // Method 6: Use document scrollHeight after hiding elements (should match player bottom)
            var docScrollHeight = Math.max(
                document.documentElement.scrollHeight,
                document.body.scrollHeight
            );
            
            // Take the maximum of reliable methods
            // Prefer methods that include margins (method3, method4)
            var candidates = [
                method1_bottom,
                method2_bottom,
                method3_bottom,
                method4_bottom,
                method5_bottom
            ];
            
            // Only use docScrollHeight if it's reasonable (close to player bottom, not way larger)
            if (docScrollHeight > 0 && docScrollHeight >= method1_bottom && docScrollHeight <= method1_bottom * 1.5) {
                candidates.push(docScrollHeight);
            }
            
            var exactBottom = Math.max.apply(Math, candidates);
            
            // Also get player height for reference
            var playerHeight = Math.max(
                playerRect.height,
                player.offsetHeight,
                player.scrollHeight
            );
            
            return {
                playerHeight: playerHeight,
                playerRectHeight: playerRect.height,
                offsetHeight: player.offsetHeight,
                scrollHeight: player.scrollHeight,
                method1_bottom: method1_bottom,
                method2_bottom: method2_bottom,
                method3_bottom: method3_bottom,
                method4_bottom: method4_bottom,
                method5_bottom: method5_bottom,
                docScrollHeight: docScrollHeight,
                exactBottom: exactBottom,
                marginBottom: marginBottom,
                marginTop: marginTop
            };
        })();
        """
        
        def on_dimensions_received(result):
            if result and isinstance(result, dict):
                # Use exactBottom which is the maximum of all calculation methods
                exact_bottom = result.get('exactBottom', 0)
                
                # Log all methods for debugging
                method1 = result.get('method1_bottom', 0)
                method2 = result.get('method2_bottom', 0)
                method3 = result.get('method3_bottom', 0)
                doc_scroll = result.get('docScrollHeight', 0)
                
                if exact_bottom <= 0:
                    # Fallback: use the maximum of all methods
                    exact_bottom = max(method1, method2, method3)
                    if exact_bottom <= 0:
                        # Last resort: use player height
                        exact_bottom = int(max(
                            result.get('playerHeight', 0),
                            result.get('playerRectHeight', 0),
                            result.get('offsetHeight', 0),
                            result.get('scrollHeight', 0)
                        ))
                
                exact_bottom = int(exact_bottom)
                
                # If playlist was just closed (settings say False but we're measuring after close),
                # use the saved exact_bottom value instead to avoid layout reflow issues
                # Check if playlist is being closed by comparing settings
                if hasattr(self, 'settings') and 'playlist_visible' in self.settings:
                    playlist_just_closed = not self.settings.get('playlist_visible', True)
                    if playlist_just_closed and 'micro_mode_saved_height' in self.settings:
                        saved_exact_bottom = self.settings.get('micro_mode_saved_height', 0)
                        if saved_exact_bottom > 0:
                            # Use saved value if it's reasonable (within 50px of measured value)
                            # This prevents using stale values but avoids reflow issues
                            if abs(exact_bottom - saved_exact_bottom) < 50:
                                print(f"[DEBUG] resize_to_micro_mode: Using saved exact_bottom={saved_exact_bottom} instead of measured {exact_bottom} (playlist just closed)")
                                logger.debug(f"resize_to_micro_mode: Using saved exact_bottom={saved_exact_bottom} instead of measured {exact_bottom} (playlist just closed)")
                                exact_bottom = saved_exact_bottom
                
                # Account for zoom factor (0.75) - JavaScript measurements are in CSS pixels
                # but we need to convert to actual window pixels
                zoom_factor = self.web_view.zoomFactor() if self.web_view else 1.0
                # Actually, the web view handles zoom internally, so we don't need to convert
                # The JavaScript measurements should already be correct
                
                # Calculate window padding dynamically (title bar + address bar)
                window_padding = 0
                if self.title_bar and self.title_bar.isVisible():
                    window_padding += self.title_bar.height()
                # Account for address bar if autohide is disabled (it's in layout)
                if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
                    if hasattr(self, 'controls_bar_in_layout') and self.controls_bar_in_layout:
                        window_padding += self.controls_bar_widget.height()
                    # Also check if autohide is explicitly disabled
                    elif hasattr(self, 'autohide_address_bar') and not self.autohide_address_bar:
                        window_padding += self.controls_bar_widget.height()
                
                # Account for playlist sidebar title bar if playlist is visible
                # Use same approach as mini mode: always use 30px for title bar height
                # Check both isVisible() AND settings - both must be True for playlist to be considered visible
                # This handles the case where settings might not be updated yet after close_playlist
                playlist_title_bar_height = 0
                playlist_visible = False
                settings_visible = False
                widget_visible = False
                
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
                    # Check settings value first (updated immediately in close_playlist/toggle_playlist)
                    if hasattr(self, 'settings') and 'playlist_visible' in self.settings:
                        settings_visible = self.settings.get('playlist_visible', False)
                    
                    # Also check isVisible() - both must be True
                    widget_visible = self.playlist_sidebar.isVisible()
                    
                    # Playlist is only considered visible if BOTH settings and widget say it's visible
                    # This ensures we don't add space if playlist was just closed
                    playlist_visible = settings_visible and widget_visible
                
                # Debug logging for playlist visibility check
                print(f"[DEBUG] resize_to_micro_mode: settings_visible={settings_visible}, widget_visible={widget_visible}, playlist_visible={playlist_visible}, playlist_title_bar_height={playlist_title_bar_height}")
                logger.debug(f"resize_to_micro_mode: settings_visible={settings_visible}, widget_visible={widget_visible}, playlist_visible={playlist_visible}, playlist_title_bar_height={playlist_title_bar_height}")
                
                if playlist_visible:
                    # Always use 30px for playlist title bar height (includes borders)
                    playlist_title_bar_height = 30
                
                # Debug logging after playlist_title_bar_height is set
                print(f"[DEBUG] resize_to_micro_mode: AFTER playlist_visible check - playlist_title_bar_height={playlist_title_bar_height}")
                logger.debug(f"resize_to_micro_mode: AFTER playlist_visible check - playlist_title_bar_height={playlist_title_bar_height}")
                
                # Total height = exact bottom position of player + window chrome + playlist title bar
                # Subtract 33 pixels to account for extra space that's difficult to detect
                total_height = exact_bottom + window_padding + playlist_title_bar_height - 33
                
                # Debug logging for height calculation
                print(f"[DEBUG] resize_to_micro_mode: exact_bottom={exact_bottom}, window_padding={window_padding}, playlist_title_bar_height={playlist_title_bar_height}, total_height={total_height}, current_window_height={self.height()}")
                logger.debug(f"resize_to_micro_mode: exact_bottom={exact_bottom}, window_padding={window_padding}, playlist_title_bar_height={playlist_title_bar_height}, total_height={total_height}, current_window_height={self.height()}")
                original_width = WINDOW_DEFAULT_WIDTH
                
                # Ensure we don't go below minimum
                if total_height < window_padding + 50:
                    total_height = window_padding + 50
                
                # Set very low minimum height in micro mode (just enough for title bar)
                min_height = window_padding + 50  # Title bar + minimal player space
                self.setMinimumHeight(min_height)
                
                # Save player bottom for next startup
                self.settings["micro_mode_saved_height"] = exact_bottom
                self.save_settings()
                
                # Set cover art height to match player height (constrain it to not extend below player)
                # Use JavaScript to set CSS variable and direct style for cover art height
                cover_art_height_js = f"""
                (function() {{
                    var player = document.querySelector('#player');
                    if (player) {{
                        var playerRect = player.getBoundingClientRect();
                        var playerBottom = playerRect.bottom;
                        var coverArt = document.querySelector('#tralbum-art-carousel');
                        if (coverArt) {{
                            // Set CSS custom property for cover art height
                            document.documentElement.style.setProperty('--micro-mode-player-height', playerBottom + 'px');
                            // Also set directly on the element as fallback
                            coverArt.style.height = playerBottom + 'px';
                            coverArt.style.maxHeight = playerBottom + 'px';
                        }}
                    }}
                }})();
                """
                # Set cover art height after a short delay to ensure player is fully rendered
                QTimer.singleShot(50, lambda: self._set_micro_mode_cover_art_height())
                
                try:
                    # Flag was already set at start of function to allow programmatic resize
                    current_size_before = (self.width(), self.height())
                    print(f"[DEBUG] resize_to_micro_mode: About to resize from {current_size_before[0]}x{current_size_before[1]} to {original_width}x{total_height}")
                    logger.debug(f"resize_to_micro_mode: About to resize from {current_size_before[0]}x{current_size_before[1]} to {original_width}x{total_height}")
                    self.resize(original_width, total_height)
                    # Set fixed size to prevent user resizing in micro mode
                    self.setMinimumSize(original_width, total_height)
                    self.setMaximumSize(original_width, total_height)
                    current_size_after = (self.width(), self.height())
                    print(f"[DEBUG] resize_to_micro_mode: After resize, window size is {current_size_after[0]}x{current_size_after[1]} (requested: {original_width}x{total_height})")
                    logger.debug(f"Resized to micro mode: {original_width}x{total_height} (player bottom: {exact_bottom}, padding: {window_padding}, playlist_title_bar: {playlist_title_bar_height}, methods: m1={method1}, m2={method2}, m3={method3}, doc={doc_scroll}), actual size after resize: {current_size_after[0]}x{current_size_after[1]}")
                    # Set cover art height after resize completes
                    QTimer.singleShot(150, lambda: self._set_micro_mode_cover_art_height())
                    # Clear flag after resize completes
                    QTimer.singleShot(50, lambda: setattr(self, '_micro_mode_resizing', False))
                except Exception as e:
                    logger.error(f"Could not resize to micro mode: {e}", exc_info=True)
                    # Clear flag on error too
                    self._micro_mode_resizing = False
        
        self.web_view.page().runJavaScript(js_code, on_dimensions_received)
    
    def _set_micro_mode_cover_art_height(self):
        """Set cover art height to match player height in micro mode"""
        if self.mini_mode_state != 2 or not self.web_view:
            return
        
        # Use JavaScript to set cover art height to match player bottom
        cover_art_height_js = """
        (function() {
            var player = document.querySelector('#player');
            if (player) {
                var playerRect = player.getBoundingClientRect();
                var playerBottom = playerRect.bottom;
                var coverArt = document.querySelector('#tralbum-art-carousel');
                if (coverArt) {
                    // Set CSS custom property for cover art height
                    document.documentElement.style.setProperty('--micro-mode-player-height', playerBottom + 'px');
                    // Also set directly on the element as fallback
                    coverArt.style.height = playerBottom + 'px';
                    coverArt.style.maxHeight = playerBottom + 'px';
                }
            }
        })();
        """
        try:
            self.web_view.page().runJavaScript(cover_art_height_js)
        except Exception as e:
            logger.debug(f"Could not set cover art height: {e}")
    
    def _clear_micro_mode_cover_art_height(self):
        """Clear cover art height constraints when switching from micro mode"""
        if not self.web_view:
            return
        
        # Use JavaScript to clear the cover art height constraints
        clear_cover_art_js = """
        (function() {
            var coverArt = document.querySelector('#tralbum-art-carousel');
            if (coverArt) {
                // Clear inline styles that were set for micro mode
                coverArt.style.height = '';
                coverArt.style.maxHeight = '';
                // Clear CSS custom property
                document.documentElement.style.removeProperty('--micro-mode-player-height');
            }
        })();
        """
        try:
            self.web_view.page().runJavaScript(clear_cover_art_js)
        except Exception as e:
            logger.debug(f"Could not clear cover art height: {e}")
    
    def _resize_to_micro_mode_with_retry(self, retry_count=0):
        """Resize to micro mode with retry logic to ensure accurate measurements"""
        max_retries = 1  # Only retry once if needed
        
        # Force layout update before measuring
        if hasattr(self, 'playlist_container') and self.playlist_container:
            self.playlist_container.updateGeometry()
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            self.playlist_sidebar.updateGeometry()
        layout = self.centralWidget().layout()
        if layout:
            layout.update()
            layout.activate()
        # Process events multiple times to ensure all updates are applied
        QApplication.processEvents()
        QApplication.processEvents()  # Second pass to ensure settings updates are processed
        
        # Call the actual resize function
        self.resize_to_micro_mode()
        
        # If this is the first attempt, do one retry after a short delay to fine-tune
        # This helps catch cases where the layout hasn't fully settled
        if retry_count < max_retries:
            QTimer.singleShot(100, lambda: self._resize_to_micro_mode_with_retry(retry_count + 1))
    
    def setup_micro_mode_track_detection(self):
        """No longer used - kept for compatibility"""
        pass
    
    def remove_micro_mode_track_detection(self):
        """No longer used - kept for compatibility"""
        pass
    
    def check_micro_mode_resize_needed(self):
        """No longer used - kept for compatibility"""
        pass
    
    def _do_micro_mode_resize(self):
        """No longer used - kept for compatibility"""
        pass
    
    def _clear_micro_mode_resizing_flag(self):
        """No longer used - kept for compatibility"""
        pass
    
    def _get_playable_tracks_helper_js(self):
        """Generate JavaScript helper function to get all playable tracks from tracklist"""
        return """
            function getPlayableTracks() {
                var tracklist = document.querySelector('#tracklist');
                if (!tracklist) {
                    return [];
                }
                
                // Get all track elements - use comprehensive selector to match actual Bandcamp structure
                // Tracks can be: li.track, tr.track_row_view, or other variations
                var allTracks = tracklist.querySelectorAll('li.track, tr.track_row_view, .track, .track_row_view, tr[class*="track"], li[class*="track"]');
                var playableTracks = [];
                
                console.log('Bandcamp Player: getPlayableTracks found ' + allTracks.length + ' total tracks');
                
                for (var i = 0; i < allTracks.length; i++) {
                    var track = allTracks[i];
                    
                    // KEY INDICATOR: Check for .play_status.disabled - this marks unavailable tracks
                    // The play_status is inside a <td class="play-col"> which is inside the <tr>
                    var playStatus = track.querySelector('.play_status');
                    
                    // If not found directly, check inside play-col (for table row structure)
                    if (!playStatus) {
                        var playCol = track.querySelector('td.play-col, .play-col');
                        if (playCol) {
                            playStatus = playCol.querySelector('.play_status');
                        }
                    }
                    
                    // If play_status exists, use it as the definitive indicator
                    if (playStatus) {
                        // If play_status has 'disabled' class, track is NOT playable - skip it
                        if (playStatus.classList.contains('disabled')) {
                            console.log('Bandcamp Player: Track ' + (i+1) + ' has play_status.disabled - skipping (not playable)');
                            continue; // Skip this track
                        }
                        // If play_status exists and doesn't have 'disabled', track IS playable
                        console.log('Bandcamp Player: Track ' + (i+1) + ' has play_status without disabled - marking as playable');
                        playableTracks.push(track);
                        continue; // Move to next track
                    }
                    
                    // Fallback: if no play_status element found (mobile/regular albums), use other indicators
                    // Mobile version: playable tracks have 'playable' class AND data-bind="click: playTrack" on .info
                    var isPlayable = false;
                    
                    // Check for explicit 'playable' class (mobile version indicator)
                    if (track.classList.contains('playable')) {
                        // Additional check: .info div should have data-bind="click: playTrack"
                        var infoDiv = track.querySelector('.info');
                        if (infoDiv) {
                            var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                             infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                            if (hasClickBind) {
                                isPlayable = true;
                                console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has playable class and click: playTrack)');
                            } else {
                                console.log('Bandcamp Player: Track ' + (i+1) + ' has playable class but no click: playTrack - not playable');
                            }
                        } else {
                            // If no .info div but has playable class, still consider playable
                            isPlayable = true;
                            console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has playable class)');
                        }
                    } else if (track.classList.contains('has-audio')) {
                        // Track has has-audio but NOT playable class - check if it has click: playTrack
                        var infoDiv = track.querySelector('.info');
                        if (infoDiv) {
                            var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                             infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                            if (hasClickBind) {
                                isPlayable = true;
                                console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has-audio with click: playTrack)');
                            } else {
                                console.log('Bandcamp Player: Track ' + (i+1) + ' has has-audio but no click: playTrack - not playable');
                            }
                        }
                    } else {
                        // Check for .info div with track link (desktop/fallback)
                        var infoDiv = track.querySelector('.info');
                        if (infoDiv) {
                            var trackLink = infoDiv.querySelector('a');
                            if (trackLink) {
                                var href = trackLink.getAttribute('href');
                                if (href && href !== '#' && href.indexOf('/track/') !== -1) {
                                    isPlayable = true;
                                    console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has valid track link)');
                                }
                            }
                        } else {
                            // Check for play button
                            var playBtn = track.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]');
                            if (playBtn && playBtn.offsetParent !== null) {
                                isPlayable = true;
                                console.log('Bandcamp Player: Track ' + (i+1) + ' marked as playable (has play button)');
                            }
                        }
                    }
                    
                    if (isPlayable) {
                        playableTracks.push(track);
                    } else {
                        console.log('Bandcamp Player: Track ' + (i+1) + ' not playable (no indicators found)');
                    }
                }
                
                return playableTracks;
            }
            
            function isTrackPlayable(track) {
                // Helper function to check if a single track is playable
                // KEY INDICATOR: Check for .play_status.disabled - this marks unavailable tracks
                var playStatus = track.querySelector('.play_status');
                
                // If not found directly, check inside play-col (for table row structure)
                if (!playStatus) {
                    var playCol = track.querySelector('td.play-col, .play-col');
                    if (playCol) {
                        playStatus = playCol.querySelector('.play_status');
                    }
                }
                
                // If play_status exists, use it as the definitive indicator
                if (playStatus) {
                    if (playStatus.classList.contains('disabled')) {
                        return false; // Track is disabled/unavailable
                    }
                    // If play_status exists and doesn't have 'disabled', track IS playable
                    return true;
                }
                
                // Fallback: if no play_status, check for mobile version indicators
                // Mobile version: playable tracks have 'playable' class AND data-bind="click: playTrack"
                if (track.classList.contains('playable')) {
                    var infoDiv = track.querySelector('.info');
                    if (infoDiv) {
                        var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                         infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                        if (hasClickBind) {
                            return true;
                        }
                    } else {
                        // If no .info div but has playable class, still consider playable
                        return true;
                    }
                } else if (track.classList.contains('has-audio')) {
                    // Track has has-audio but NOT playable - check if it has click: playTrack
                    var infoDiv = track.querySelector('.info');
                    if (infoDiv) {
                        var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                         infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                        if (hasClickBind) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            """
    
    def _get_is_last_track_js(self):
        """Generate JavaScript function to check if current track is the last playable one"""
        playable_helper = self._get_playable_tracks_helper_js()
        return playable_helper + """
            
            function isLastTrack() {
                try {
                    // First, check if this is a single track page (no tracklist or URL contains /track/)
                    var isSingleTrackPage = false;
                    var url = window.location.href;
                    if (url.indexOf('/track/') !== -1) {
                        isSingleTrackPage = true;
                        console.log('Bandcamp Player: Detected single track page from URL');
                    }
                    
                    // Get tracklist
                    var tracklist = document.querySelector('#tracklist');
                    if (!tracklist) {
                        // No tracklist found - could be a single track page
                        console.log('Bandcamp Player: Tracklist not found - checking if single track page');
                        // If URL indicates single track, or if we have audio playing, treat as single
                        if (isSingleTrackPage || document.querySelector('audio')) {
                            console.log('Bandcamp Player: Single track page detected - this is the last (and only) track');
                            return true;
                        }
                        return false;
                    }
                    
                    // Get all track items - try multiple selectors (for finding current track)
                    var allTracks = tracklist.querySelectorAll('.track, .track_row_view, tr[class*="track"], li[class*="track"], .track_list .track');
                    if (allTracks.length === 0) {
                        // Try alternative: look for numbered tracks
                        allTracks = tracklist.querySelectorAll('[data-track-number], [data-index]');
                    }
                    
                    // Get playable tracks (for determining if current track is last playable)
                    var playableTracks = getPlayableTracks();
                    
                    // If no tracks found in tracklist, check if it's a single track page
                    if (allTracks.length === 0) {
                        console.log('Bandcamp Player: No tracks found in tracklist');
                        // If URL indicates single track or we have audio, treat as single
                        if (isSingleTrackPage || document.querySelector('audio')) {
                            console.log('Bandcamp Player: Single track page detected (empty tracklist) - this is the last track');
                            return true;
                        }
                        return false;
                    }
                    
                    // If only one track total, it's automatically the last track
                    if (allTracks.length === 1) {
                        console.log('Bandcamp Player: Only one track found - this is the last track');
                        return true;
                    }
                    
                    console.log('Bandcamp Player: Found ' + allTracks.length + ' total tracks, ' + playableTracks.length + ' playable tracks');
                    
                    // Get current track title from player
                    var currentTitle = null;
                    var titleElement = player.querySelector('.track-title, .title, [data-bind*="title"]');
                    if (titleElement) {
                        currentTitle = (titleElement.textContent || titleElement.innerText || '').trim();
                    }
                    
                    // Find which track is currently playing by looking for "playing" class or active state
                    var currentTrack = null;
                    var currentTrackIndexInAll = -1;
                    
                    // First, try to find track with "playing" class in all tracks
                    for (var i = 0; i < allTracks.length; i++) {
                        var track = allTracks[i];
                        if (track.classList.contains('playing') || 
                            track.classList.contains('current') ||
                            track.classList.contains('active') ||
                            track.getAttribute('aria-current') === 'true') {
                            currentTrack = track;
                            currentTrackIndexInAll = i;
                            console.log('Bandcamp Player: Found playing track at index ' + i);
                            break;
                        }
                    }
                    
                    // If not found by class, try matching by title
                    if (!currentTrack && currentTitle) {
                        for (var i = 0; i < allTracks.length; i++) {
                            var track = allTracks[i];
                            var trackTitle = (track.textContent || track.innerText || '').trim();
                            // Check if track title matches (be flexible with matching)
                            if (trackTitle && currentTitle && 
                                (trackTitle.includes(currentTitle) || 
                                 currentTitle.includes(trackTitle) ||
                                 trackTitle.toLowerCase() === currentTitle.toLowerCase())) {
                                currentTrack = track;
                                currentTrackIndexInAll = i;
                                console.log('Bandcamp Player: Found track by title match at index ' + i);
                                break;
                            }
                        }
                    }
                    
                    // If we found the current track, check if it's the last playable one
                    if (currentTrack) {
                        // Better approach: check if there are any playable tracks AFTER the current track
                        // This is more reliable than checking array positions
                        var hasPlayableTracksAfter = false;
                        
                        // Start checking from the track after the current one
                        for (var i = currentTrackIndexInAll + 1; i < allTracks.length; i++) {
                            var nextTrack = allTracks[i];
                            // Use the same logic as getPlayableTracks to check if track is playable
                            var nextTrackPlayStatus = nextTrack.querySelector('.play_status');
                            if (!nextTrackPlayStatus) {
                                var playCol = nextTrack.querySelector('td.play-col, .play-col');
                                if (playCol) {
                                    nextTrackPlayStatus = playCol.querySelector('.play_status');
                                }
                            }
                            
                            // If track has play_status.disabled, it's not playable
                            if (nextTrackPlayStatus && nextTrackPlayStatus.classList.contains('disabled')) {
                                console.log('Bandcamp Player: Track at index ' + i + ' has play_status.disabled - not playable');
                                continue; // Skip this track, check next one
                            }
                            
                            // If track has play_status without disabled, it IS playable
                            if (nextTrackPlayStatus && !nextTrackPlayStatus.classList.contains('disabled')) {
                                hasPlayableTracksAfter = true;
                                console.log('Bandcamp Player: Found playable track after current at index ' + i + ' (has play_status without disabled)');
                                break;
                            }
                            
                            // Fallback: if no play_status, check for mobile version indicators
                            if (!nextTrackPlayStatus) {
                                // Mobile version: playable tracks have 'playable' class AND data-bind="click: playTrack"
                                var hasPlayableClass = nextTrack.classList.contains('playable');
                                if (hasPlayableClass) {
                                    var infoDiv = nextTrack.querySelector('.info');
                                    if (infoDiv) {
                                        var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                                         infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                                        if (hasClickBind) {
                                            hasPlayableTracksAfter = true;
                                            console.log('Bandcamp Player: Found playable track after current at index ' + i + ' (has playable class and click: playTrack)');
                                            break;
                                        }
                                    }
                                } else if (nextTrack.classList.contains('has-audio')) {
                                    // Track has has-audio but NOT playable - check if it has click: playTrack
                                    var infoDiv = nextTrack.querySelector('.info');
                                    if (infoDiv) {
                                        var hasClickBind = infoDiv.getAttribute('data-bind') && 
                                                         infoDiv.getAttribute('data-bind').indexOf('click: playTrack') !== -1;
                                        if (hasClickBind) {
                                            hasPlayableTracksAfter = true;
                                            console.log('Bandcamp Player: Found playable track after current at index ' + i + ' (has-audio with click: playTrack)');
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        
                        if (!hasPlayableTracksAfter) {
                            // No playable tracks after current - this is the last playable track
                            console.log('Bandcamp Player: No playable tracks after current track at index ' + currentTrackIndexInAll + ' - this is the last playable track');
                            return true;
                        } else {
                            // There are playable tracks after - not the last one
                            console.log('Bandcamp Player: Found playable tracks after current track - not the last playable');
                            return false;
                        }
                    }
                    
                    // Fallback: if we can't find the current track, assume it might be last if title hasn't changed
                    // OR if it's a single track page
                    console.log('Bandcamp Player: Could not find current track, using fallback check');
                    if (isSingleTrackPage) {
                        console.log('Bandcamp Player: Single track page - treating as last track');
                        return true;
                    }
                    if (lastTrackTitle && currentTitle && lastTrackTitle === currentTitle) {
                        console.log('Bandcamp Player: Track title unchanged, might be last track');
                        return true;
                    }
                    
                    return false;
                } catch (e) {
                    console.log('Bandcamp Player: Error checking last track:', e);
                    return false;
                }
            }
            """
            
    def _get_handle_track_end_js(self):
        """Generate JavaScript function to handle track end"""
        return """
            function handleTrackEnd() {
                console.log('Bandcamp Player: Track ended');
                
                // Store the current track title before checking
                var titleElement = player.querySelector('.track-title, .title, [data-bind*="title"]');
                var endedTrackTitle = null;
                if (titleElement) {
                    endedTrackTitle = (titleElement.textContent || titleElement.innerText || '').trim();
                    if (!lastTrackTitle) {
                        lastTrackTitle = endedTrackTitle;
                    }
                }
                
                console.log('Bandcamp Player: Ended track title: ' + endedTrackTitle);
                
                // Clear any existing timeout
                if (trackEndedTimeout) {
                    clearTimeout(trackEndedTimeout);
                }
                
                // Wait a moment to see if next track starts
                trackEndedTimeout = setTimeout(function() {
                    // Check if a new track started (title changed or audio started playing)
                    var newTitleElement = player.querySelector('.track-title, .title, [data-bind*="title"]');
                    var newTitle = null;
                    if (newTitleElement) {
                        newTitle = (newTitleElement.textContent || newTitleElement.innerText || '').trim();
                    }
                    
                    // Check if audio is playing
                    var isPlaying = false;
                    if (audioElement) {
                        isPlaying = !audioElement.paused && audioElement.currentTime > 0;
                    }
                    
                    // Check if track changed (new track started)
                    var trackChanged = newTitle && newTitle !== endedTrackTitle && newTitle !== lastTrackTitle;
                    
                    console.log('Bandcamp Player: After track end - New title: ' + newTitle + ', Is playing: ' + isPlaying + ', Track changed: ' + trackChanged);
                    
                    // Check if Repeat 1 Track mode is active - if so, don't set flags (JavaScript handles restart)
                    if (window.bandcampRepeatMode === 3) {
                        console.log('Bandcamp Player: Repeat 1 Track mode active - JavaScript should have restarted track, skipping handleTrackEnd logic');
                        // Check if track actually restarted (audio is playing again)
                        if (audioElement && !audioElement.paused && audioElement.currentTime < 5) {
                            console.log('Bandcamp Player: Track restarted successfully in Repeat 1 Track mode');
                            // Track restarted, don't set any flags
                            return;
                        } else {
                            console.log('Bandcamp Player: Track did not restart, might need fallback');
                            // Track didn't restart, but don't set flag yet - let Python handle as fallback
                            return;
                        }
                    }
                    
                    // If no new track started and audio is not playing, track/album might be finished
                    if (!trackChanged && !isPlaying) {
                        // Always set track finished flag (for Super Shuffle, Shuffle Tracks, etc.)
                        window.bandcampTrackFinished = true;
                        console.log('Bandcamp Player: Track finished flag set');
                        
                        // Double-check: is this the last track?
                        var isLast = isLastTrack();
                        console.log('Bandcamp Player: No new track started, is last track: ' + isLast);
                        
                        if (isLast) {
                            console.log('Bandcamp Player: Album finished - last track ended and no new track started');
                            window.bandcampAlbumFinished = true;
                            // Also trigger immediate check by setting a flag that Python can poll
                            console.log('Bandcamp Player: Flag set to true, value is now: ' + window.bandcampAlbumFinished);
                        } else {
                            // Not the last track but no new track started - might still be loading
                            // Wait a bit more and check again
                            setTimeout(function() {
                                var stillNoNewTrack = !audioElement || audioElement.paused;
                                var stillSameTitle = newTitle === endedTrackTitle;
                                if (stillNoNewTrack && stillSameTitle) {
                                    // Check one more time if it's the last track
                                    if (isLastTrack()) {
                                        console.log('Bandcamp Player: Album finished (delayed check)');
                                        window.bandcampAlbumFinished = true;
                                        console.log('Bandcamp Player: Flag set to true (delayed), value is now: ' + window.bandcampAlbumFinished);
                                    }
                                    // Also set track finished if not already set (and not Repeat 1 Track mode)
                                    if (!window.bandcampTrackFinished && window.bandcampRepeatMode !== 3) {
                                        window.bandcampTrackFinished = true;
                                    }
                                }
                            }, 2000);
                        }
                    } else if (trackChanged) {
                        console.log('Bandcamp Player: New track started, album continuing');
                    }
                    
                    // Update last track title
                    if (newTitle) {
                        lastTrackTitle = newTitle;
                    }
                }, 2000); // Wait 2 seconds to see if next track starts
            }
            """
            
    def _get_audio_monitoring_js(self, repeat_mode=0, shuffle_mode=0, shuffled_track_list=None):
        """Generate JavaScript code for audio element monitoring
        
        Args:
            repeat_mode: Current repeat mode (0=off, 1=continuous, 2=album, 3=track)
            shuffle_mode: Current shuffle mode (0=off, 1=tracks, 2=albums, 3=super)
            shuffled_track_list: List of track numbers in shuffled order (for shuffle_mode=1)
        """
        # Inject shuffled track list if provided
        shuffled_list_js = ""
        if shuffled_track_list:
            shuffled_list_js = f"""
            window.bandcampShuffledTrackList = {shuffled_track_list};
            window.bandcampShuffledTrackIndex = 0;
            console.log('Bandcamp Player: Injected shuffled track list:', window.bandcampShuffledTrackList);
            """
        
        return f"""
            {shuffled_list_js}
            // Monitor audio element - most reliable way to detect track end
            var audioElement = document.querySelector('audio');
            if (audioElement) {{
                console.log('Bandcamp Player: Audio element found, setting up monitoring (repeat_mode={repeat_mode}, shuffle_mode={shuffle_mode})');
                
                // Store initial track title
                var titleElement = player.querySelector('.track-title, .title, [data-bind*="title"]');
                if (titleElement) {{
                    lastTrackTitle = titleElement.textContent || titleElement.innerText;
                }}
                
                // Function to restart current track (for Repeat 1 Track mode)
                function restartCurrentTrack() {{
                    if (audioElement && audioElement.duration > 0) {{
                        console.log('Bandcamp Player: Restarting current track (Repeat 1 Track mode)');
                        
                        // Method 1: Seek to beginning and play (most reliable, doesn't trigger Bandcamp's next-track logic)
                        audioElement.currentTime = 0;
                        // Small delay to ensure seek completes, then play
                        setTimeout(function() {{
                            if (audioElement && audioElement.duration > 0) {{
                                var playPromise = audioElement.play();
                                if (playPromise !== undefined) {{
                                    playPromise.then(function() {{
                                        console.log('Bandcamp Player: Track restarted successfully via seek+play');
                                    }}).catch(function(error) {{
                                        console.log('Bandcamp Player: Error restarting track via seek+play:', error);
                                        // Fallback: try clicking the current track in tracklist
                                        var tracklist = document.querySelector('#tracklist');
                                        if (tracklist) {{
                                            var currentTrack = tracklist.querySelector('li.track.playing, li.track.current');
                                            if (currentTrack) {{
                                                console.log('Bandcamp Player: Fallback - clicking current track in tracklist');
                                                var infoDiv = currentTrack.querySelector('.info');
                                                if (infoDiv) {{
                                                    infoDiv.click();
                                                }} else {{
                                                    currentTrack.click();
                                                }}
                                                // Also ensure we're at the beginning
                                                setTimeout(function() {{
                                                    if (audioElement && audioElement.duration > 0) {{
                                                        audioElement.currentTime = 0;
                                                    }}
                                                }}, 300);
                                            }}
                                        }}
                                    }});
                                }} else {{
                                    // No promise returned, assume it worked
                                    console.log('Bandcamp Player: Track play() called (no promise)');
                                }}
                            }}
                        }}, 50); // Shorter delay for faster restart
                    }}
                }}
                
                // Flag to prevent multiple restarts in Repeat 1 Track mode
                var isRestartingTrack = false;
                var lastRestartTime = 0;
                // Flag to prevent multiple album loops in Repeat Album mode
                var isLoopingAlbum = false;
                var lastLoopTime = 0;
                // Flag to prevent multiple track switches in Shuffle Tracks mode
                var isSwitchingShuffledTrack = false;
                var lastSwitchTime = 0;
                
                // Monitor timeupdate to detect when last track is near the end (switch sooner!)
                var timeUpdateHandler = function() {{
                    if (audioElement.currentTime > 0 && 
                        audioElement.duration > 0) {{
                        var timeRemaining = audioElement.duration - audioElement.currentTime;
                        var now = Date.now();
                        
                        // Super Shuffle mode: trigger next random album/track before track ends
                        if (window.bandcampShuffleMode === 3 && 
                            timeRemaining <= 0.3 && 
                            timeRemaining > 0 && 
                            !isSwitchingShuffledTrack &&
                            (now - lastSwitchTime) > 1000) {{  // At least 1 second between switches
                            isSwitchingShuffledTrack = true;
                            lastSwitchTime = now;
                            
                            console.log('Bandcamp Player: Super Shuffle mode - track ending, triggering next random selection');
                            // Set track finished flag to trigger Python handler for Super Shuffle
                            window.bandcampTrackFinished = true;
                            
                            // Reset flag after a short delay
                            setTimeout(function() {{
                                isSwitchingShuffledTrack = false;
                            }}, 1000);
                            return; // Exit early, let Python handle next random selection
                        }}
                        
                        // Shuffle Tracks mode: jump to next track in shuffled list before track ends
                        if (window.bandcampShuffleMode === 1 && 
                            window.bandcampShuffledTrackList && 
                            window.bandcampShuffledTrackList.length > 0 &&
                            timeRemaining <= 0.3 && 
                            timeRemaining > 0 && 
                            !isSwitchingShuffledTrack &&
                            (now - lastSwitchTime) > 1000) {{  // At least 1 second between switches
                            isSwitchingShuffledTrack = true;
                            lastSwitchTime = now;
                            
                            // Move to next track in shuffled list
                            if (window.bandcampShuffledTrackIndex === undefined) {{
                                window.bandcampShuffledTrackIndex = 0;
                            }}
                            var currentIndex = window.bandcampShuffledTrackIndex;
                            var nextIndex = (currentIndex + 1) % window.bandcampShuffledTrackList.length;
                            
                            // Check if we've reached the end of the shuffled list (wrapped back to 0)
                            var reachedEndOfShuffledList = (nextIndex === 0 && currentIndex === window.bandcampShuffledTrackList.length - 1);
                            
                            // If we've reached the end, check Repeat mode
                            if (reachedEndOfShuffledList) {{
                                // If Repeat mode is Continuous (1) or Off (0), move to next album
                                if (window.bandcampRepeatMode === 0 || window.bandcampRepeatMode === 1) {{
                                    console.log('Bandcamp Player: Shuffle Tracks mode - reached end of shuffled list, moving to next album (Repeat mode: ' + window.bandcampRepeatMode + ')');
                                    window.bandcampAlbumFinished = true;
                                    isSwitchingShuffledTrack = false;
                                    return; // Exit early, let Python handle next album
                                }}
                                // If Repeat Album mode (2) is active, reshuffle and continue
                                else if (window.bandcampRepeatMode === 2) {{
                                    console.log('Bandcamp Player: Shuffle Tracks mode - reached end of shuffled list, reshuffling (Repeat Album mode)');
                                    // Reshuffle the list (just reset index to 0, Python will reshuffle if needed)
                                    window.bandcampShuffledTrackIndex = 0;
                                    // Continue to play first track in reshuffled list
                                }}
                                // If Repeat 1 Track mode (3), just continue (shouldn't happen in shuffle mode, but handle it)
                                else {{
                                    window.bandcampShuffledTrackIndex = nextIndex;
                                }}
                            }} else {{
                                // Normal case: move to next track in list
                                window.bandcampShuffledTrackIndex = nextIndex;
                            }}
                            
                            var nextTrackNum = window.bandcampShuffledTrackList[window.bandcampShuffledTrackIndex];
                            console.log('Bandcamp Player: Shuffle Tracks mode - jumping to track ' + nextTrackNum + ' before end (' + timeRemaining.toFixed(2) + 's remaining)');
                            
                            // Find and click the next track
                            var tracklist = document.querySelector('#tracklist');
                            if (tracklist) {{
                                // Find track by data-num attribute
                                var targetTrack = tracklist.querySelector('li.track[data-num="' + nextTrackNum + '"]');
                                if (!targetTrack) {{
                                    // Fallback: find by index (0-based, so subtract 1)
                                    var allTracks = tracklist.querySelectorAll('li.track');
                                    if (allTracks.length >= nextTrackNum) {{
                                        targetTrack = allTracks[nextTrackNum - 1];
                                    }}
                                }}
                                
                                if (targetTrack) {{
                                    var infoDiv = targetTrack.querySelector('.info');
                                    if (infoDiv) {{
                                        try {{
                                            var clickEvent = new MouseEvent('click', {{
                                                bubbles: true,
                                                cancelable: true,
                                                view: window
                                            }});
                                            infoDiv.dispatchEvent(clickEvent);
                                            console.log('Bandcamp Player: Dispatched click event on shuffled track ' + nextTrackNum);
                                        }} catch (e) {{
                                            try {{
                                                infoDiv.click();
                                                console.log('Bandcamp Player: Called .click() on shuffled track ' + nextTrackNum);
                                            }} catch (e2) {{
                                                try {{
                                                    targetTrack.click();
                                                }} catch (e3) {{
                                                    console.log('Bandcamp Player: Error clicking shuffled track: ' + e3);
                                                }}
                                            }}
                                        }}
                                    }} else {{
                                        try {{
                                            targetTrack.click();
                                            console.log('Bandcamp Player: Clicked shuffled track ' + nextTrackNum + ' element directly');
                                        }} catch (e) {{
                                            console.log('Bandcamp Player: Error clicking shuffled track: ' + e);
                                        }}
                                    }}
                                }} else {{
                                    console.log('Bandcamp Player: Track ' + nextTrackNum + ' not found in tracklist');
                                }}
                            }} else {{
                                console.log('Bandcamp Player: Tracklist not found for shuffle track switch');
                            }}
                            
                            // Reset flag after a short delay
                            setTimeout(function() {{
                                isSwitchingShuffledTrack = false;
                            }}, 1000);
                            return; // Exit early, don't check for album end
                        }}
                        
                        // Repeat 1 Track mode: restart earlier (0.3s) to beat Bandcamp's handler
                        // Also check that we haven't restarted too recently (prevent rapid restarts)
                        if (window.bandcampRepeatMode === 3 && 
                            timeRemaining <= 0.3 && 
                            timeRemaining > 0 && 
                            !isRestartingTrack &&
                            (now - lastRestartTime) > 1000) {{  // At least 1 second between restarts
                            isRestartingTrack = true;
                            lastRestartTime = now;
                            console.log('Bandcamp Player: Repeat 1 Track mode - restarting track before end (' + timeRemaining.toFixed(2) + 's remaining)');
                            // Restart immediately by seeking to beginning and playing
                            audioElement.currentTime = 0;
                            // Ensure it keeps playing
                            if (audioElement.paused) {{
                                audioElement.play().catch(function(err) {{
                                    console.log('Bandcamp Player: Error playing after restart:', err);
                                }});
                            }}
                            // Reset flag after a short delay to allow next restart
                            setTimeout(function() {{
                                isRestartingTrack = false;
                            }}, 1000);
                            return; // Exit early, don't check for album end
                        }}
                        
                        // Repeat Album mode: jump to track 1 when last track is near the end
                        if (window.bandcampRepeatMode === 2 && 
                            isLastTrack() &&
                            timeRemaining <= 0.3 && 
                            timeRemaining > 0 && 
                            !isLoopingAlbum &&
                            (now - lastLoopTime) > 1000) {{  // At least 1 second between loops
                            isLoopingAlbum = true;
                            lastLoopTime = now;
                            console.log('Bandcamp Player: Repeat Album mode - jumping to track 1 before end (' + timeRemaining.toFixed(2) + 's remaining)');
                            
                            // Find track 1 (first playable track) and click it
                            var tracklist = document.querySelector('#tracklist');
                            if (tracklist) {{
                                var playableTracks = getPlayableTracks();
                                if (playableTracks.length > 0) {{
                                    var firstTrack = playableTracks[0];
                                    var infoDiv = firstTrack.querySelector('.info');
                                    if (infoDiv) {{
                                        try {{
                                            // Try mouse event first (more reliable)
                                            var clickEvent = new MouseEvent('click', {{
                                                bubbles: true,
                                                cancelable: true,
                                                view: window
                                            }});
                                            infoDiv.dispatchEvent(clickEvent);
                                            console.log('Bandcamp Player: Dispatched click event on track 1 .info div');
                                        }} catch (e) {{
                                            try {{
                                                infoDiv.click();
                                                console.log('Bandcamp Player: Called .click() on track 1 .info div');
                                            }} catch (e2) {{
                                                console.log('Bandcamp Player: Error clicking track 1: ' + e2);
                                                // Fallback: click the track element itself
                                                try {{
                                                    firstTrack.click();
                                                }} catch (e3) {{
                                                    console.log('Bandcamp Player: Error clicking track 1 element: ' + e3);
                                                }}
                                            }}
                                        }}
                                    }} else {{
                                        // No .info div, try clicking track element directly
                                        try {{
                                            firstTrack.click();
                                            console.log('Bandcamp Player: Clicked track 1 element directly');
                                        }} catch (e) {{
                                            console.log('Bandcamp Player: Error clicking track 1: ' + e);
                                        }}
                                    }}
                                }} else {{
                                    console.log('Bandcamp Player: No playable tracks found for album loop');
                                }}
                            }} else {{
                                console.log('Bandcamp Player: Tracklist not found for album loop');
                            }}
                            
                            // Reset flag after a short delay
                            setTimeout(function() {{
                                isLoopingAlbum = false;
                            }}, 1000);
                            return; // Exit early, don't check for album end
                        }}
                        
                        // If we're within the last 2 seconds of the last track, switch to next album
                        // (unless Repeat modes are active)
                        if (timeRemaining <= 2.0 && isLastTrack() && window.bandcampRepeatMode !== 3 && window.bandcampRepeatMode !== 2) {{
                            console.log('Bandcamp Player: Last track near end (' + timeRemaining.toFixed(1) + 's remaining) - switching to next album');
                            window.bandcampAlbumFinished = true;
                            // Remove listener to prevent multiple triggers
                            audioElement.removeEventListener('timeupdate', timeUpdateHandler);
                        }}
                    }}
                }};
                
                // Listen for time updates (fires frequently during playback)
                audioElement.addEventListener('timeupdate', timeUpdateHandler);
                
                // Listen for track end (fallback in case timeupdate didn't catch it)
                // Use capture phase with high priority to intercept before Bandcamp's handlers
                audioElement.addEventListener('ended', function(event) {{
                    console.log('Bandcamp Player: Audio ended event fired');
                    
                    // Check if Repeat 1 Track mode is active FIRST, before removing listeners
                    if (window.bandcampRepeatMode === 3) {{
                        // Try to prevent Bandcamp's default behavior immediately
                        if (event) {{
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                        }}
                        
                        // If we already restarted via timeupdate, ignore this event
                        if (isRestartingTrack || (audioElement.currentTime < 1.0 && audioElement.currentTime > 0)) {{
                            console.log('Bandcamp Player: Repeat 1 Track mode - already restarted, ignoring ended event');
                            return;
                        }}
                        
                        console.log('Bandcamp Player: Repeat 1 Track mode - ended event fired, restarting track (fallback)');
                        var now = Date.now();
                        if ((now - lastRestartTime) < 1000) {{
                            console.log('Bandcamp Player: Repeat 1 Track mode - restart too recent, ignoring');
                            return;
                        }}
                        
                        isRestartingTrack = true;
                        lastRestartTime = now;
                        // Restart the track immediately - don't wait
                        audioElement.currentTime = 0;
                        if (audioElement.paused) {{
                            audioElement.play().catch(function(err) {{
                                console.log('Bandcamp Player: Error playing after restart:', err);
                            }});
                        }}
                        setTimeout(function() {{
                            isRestartingTrack = false;
                        }}, 1000);
                        // DO NOT set window.bandcampTrackFinished - we're handling it in JavaScript
                        // This prevents Python from reloading the URL
                        return; // Exit early, don't call handleTrackEnd()
                    }}
                    
                    // Check if Shuffle Tracks mode is active
                    if (window.bandcampShuffleMode === 1 && 
                        window.bandcampShuffledTrackList && 
                        window.bandcampShuffledTrackList.length > 0) {{
                        // Try to prevent Bandcamp's default behavior immediately
                        if (event) {{
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                        }}
                        
                        // If we already switched via timeupdate, ignore this event
                        if (isSwitchingShuffledTrack) {{
                            console.log('Bandcamp Player: Shuffle Tracks mode - already switched, ignoring ended event');
                            return;
                        }}
                        
                        console.log('Bandcamp Player: Shuffle Tracks mode - ended event fired, jumping to next shuffled track (fallback)');
                        var now = Date.now();
                        if ((now - lastSwitchTime) < 1000) {{
                            console.log('Bandcamp Player: Shuffle Tracks mode - switch too recent, ignoring');
                            return;
                        }}
                        
                        isSwitchingShuffledTrack = true;
                        lastSwitchTime = now;
                        
                        // Move to next track in shuffled list
                        if (window.bandcampShuffledTrackIndex === undefined) {{
                            window.bandcampShuffledTrackIndex = 0;
                        }}
                        var currentIndex = window.bandcampShuffledTrackIndex;
                        var nextIndex = (currentIndex + 1) % window.bandcampShuffledTrackList.length;
                        
                        // Check if we've reached the end of the shuffled list
                        var reachedEndOfShuffledList = (nextIndex === 0 && currentIndex === window.bandcampShuffledTrackList.length - 1);
                        
                        // If we've reached the end, check Repeat mode
                        if (reachedEndOfShuffledList) {{
                            // If Repeat mode is Continuous (1) or Off (0), move to next album
                            if (window.bandcampRepeatMode === 0 || window.bandcampRepeatMode === 1) {{
                                console.log('Bandcamp Player: Shuffle Tracks mode - reached end of shuffled list, moving to next album (Repeat mode: ' + window.bandcampRepeatMode + ')');
                                window.bandcampAlbumFinished = true;
                                isSwitchingShuffledTrack = false;
                                return; // Exit early, let Python handle next album
                            }}
                            // If Repeat Album mode (2) is active, reshuffle and continue
                            else if (window.bandcampRepeatMode === 2) {{
                                console.log('Bandcamp Player: Shuffle Tracks mode - reached end of shuffled list, reshuffling (Repeat Album mode)');
                                window.bandcampShuffledTrackIndex = 0;
                            }}
                            else {{
                                window.bandcampShuffledTrackIndex = nextIndex;
                            }}
                        }} else {{
                            window.bandcampShuffledTrackIndex = nextIndex;
                        }}
                        
                        var nextTrackNum = window.bandcampShuffledTrackList[window.bandcampShuffledTrackIndex];
                        
                        // Find and click the next track
                        var tracklist = document.querySelector('#tracklist');
                        if (tracklist) {{
                            var targetTrack = tracklist.querySelector('li.track[data-num="' + nextTrackNum + '"]');
                            if (!targetTrack) {{
                                var allTracks = tracklist.querySelectorAll('li.track');
                                if (allTracks.length >= nextTrackNum) {{
                                    targetTrack = allTracks[nextTrackNum - 1];
                                }}
                            }}
                            
                            if (targetTrack) {{
                                var infoDiv = targetTrack.querySelector('.info');
                                if (infoDiv) {{
                                    try {{
                                        var clickEvent = new MouseEvent('click', {{
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        }});
                                        infoDiv.dispatchEvent(clickEvent);
                                        console.log('Bandcamp Player: Dispatched click event on shuffled track ' + nextTrackNum + ' (fallback)');
                                    }} catch (e) {{
                                        try {{
                                            infoDiv.click();
                                        }} catch (e2) {{
                                            try {{
                                                targetTrack.click();
                                            }} catch (e3) {{
                                                console.log('Bandcamp Player: Error clicking shuffled track: ' + e3);
                                            }}
                                        }}
                                    }}
                                }} else {{
                                    try {{
                                        targetTrack.click();
                                    }} catch (e) {{
                                        console.log('Bandcamp Player: Error clicking shuffled track: ' + e);
                                    }}
                                }}
                            }}
                        }}
                        
                        setTimeout(function() {{
                            isSwitchingShuffledTrack = false;
                        }}, 1000);
                        // DO NOT set window.bandcampTrackFinished - we're handling it in JavaScript
                        return; // Exit early, don't call handleTrackEnd()
                    }}
                    
                    // Check if Repeat Album mode is active
                    if (window.bandcampRepeatMode === 2 && isLastTrack()) {{
                        // Try to prevent Bandcamp's default behavior immediately
                        if (event) {{
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                        }}
                        
                        // If we already looped via timeupdate, ignore this event
                        if (isLoopingAlbum) {{
                            console.log('Bandcamp Player: Repeat Album mode - already looped, ignoring ended event');
                            return;
                        }}
                        
                        console.log('Bandcamp Player: Repeat Album mode - ended event fired, jumping to track 1 (fallback)');
                        var now = Date.now();
                        if ((now - lastLoopTime) < 1000) {{
                            console.log('Bandcamp Player: Repeat Album mode - loop too recent, ignoring');
                            return;
                        }}
                        
                        isLoopingAlbum = true;
                        lastLoopTime = now;
                        
                        // Find track 1 (first playable track) and click it
                        var tracklist = document.querySelector('#tracklist');
                        if (tracklist) {{
                            var playableTracks = getPlayableTracks();
                            if (playableTracks.length > 0) {{
                                var firstTrack = playableTracks[0];
                                var infoDiv = firstTrack.querySelector('.info');
                                if (infoDiv) {{
                                    try {{
                                        var clickEvent = new MouseEvent('click', {{
                                            bubbles: true,
                                            cancelable: true,
                                            view: window
                                        }});
                                        infoDiv.dispatchEvent(clickEvent);
                                        console.log('Bandcamp Player: Dispatched click event on track 1 .info div (fallback)');
                                    }} catch (e) {{
                                        try {{
                                            infoDiv.click();
                                        }} catch (e2) {{
                                            try {{
                                                firstTrack.click();
                                            }} catch (e3) {{
                                                console.log('Bandcamp Player: Error clicking track 1: ' + e3);
                                            }}
                                        }}
                                    }}
                                }} else {{
                                    try {{
                                        firstTrack.click();
                                    }} catch (e) {{
                                        console.log('Bandcamp Player: Error clicking track 1: ' + e);
                                    }}
                                }}
                            }}
                        }}
                        
                        setTimeout(function() {{
                            isLoopingAlbum = false;
                        }}, 1000);
                        // DO NOT set window.bandcampAlbumFinished - we're handling it in JavaScript
                        return; // Exit early, don't call handleTrackEnd()
                    }}
                    
                    // Normal behavior - handle track end
                    // Remove timeupdate listener since track ended
                    audioElement.removeEventListener('timeupdate', timeUpdateHandler);
                    handleTrackEnd();
                }}, true); // Use capture phase to intercept before Bandcamp's handlers
                
                // Also monitor for when audio stops (in case ended event doesn't fire)
                audioElement.addEventListener('pause', function(event) {{
                    // Only trigger if we're near the end of the track
                    if (audioElement.currentTime > 0 && 
                        audioElement.duration > 0 &&
                        audioElement.currentTime >= audioElement.duration - 0.5) {{
                        console.log('Bandcamp Player: Audio paused near end');
                        
                        // Check if Repeat 1 Track mode is active
                        if (window.bandcampRepeatMode === 3) {{
                            // Try to prevent Bandcamp's default behavior
                            if (event) {{
                                event.preventDefault();
                                event.stopPropagation();
                            }}
                            
                            var now = Date.now();
                            if (isRestartingTrack || (now - lastRestartTime) < 1000) {{
                                console.log('Bandcamp Player: Repeat 1 Track mode - restart too recent or already restarting, ignoring pause');
                                return;
                            }}
                            
                            console.log('Bandcamp Player: Repeat 1 Track mode - restarting track (paused near end, NOT setting trackFinished flag)');
                            isRestartingTrack = true;
                            lastRestartTime = now;
                            // Restart immediately
                            audioElement.currentTime = 0;
                            audioElement.play().catch(function(err) {{
                                console.log('Bandcamp Player: Error playing after restart:', err);
                            }});
                            setTimeout(function() {{
                                isRestartingTrack = false;
                            }}, 1000);
                            // DO NOT set window.bandcampTrackFinished - we're handling it in JavaScript
                            return; // Exit early, don't call handleTrackEnd()
                        }} else {{
                            audioElement.removeEventListener('timeupdate', timeUpdateHandler);
                            handleTrackEnd();
                        }}
                    }}
                }}, true); // Use capture phase
            }} else {{
                console.log('Bandcamp Player: Audio element not found, using fallback monitoring');
                """
                
    def _get_fallback_monitoring_js(self):
        """Generate JavaScript code for fallback MutationObserver monitoring"""
        return """
                // Fallback: monitor player for changes
                var observer = new MutationObserver(function(mutations) {
                    // Check if play button appeared (player stopped)
                    var playBtn = player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]');
                    var pauseBtn = player.querySelector('.pausebutton, .pause-button, button[title*="pause"], button[title*="Pause"]');
                    
                    if (playBtn && playBtn.offsetParent !== null && 
                        (!pauseBtn || pauseBtn.offsetParent === null)) {
                        // Player stopped - might be end of album
                        setTimeout(function() {
                            if (isLastTrack()) {
                                window.bandcampAlbumFinished = true;
                                console.log('Bandcamp Player: Album finished (fallback detection)');
                            }
                        }, 2000);
                    }
                });
                
                observer.observe(player, {
                    childList: true,
                    subtree: true,
                    characterData: true,
                    attributes: true
                });
                
                window.bandcampPlaybackObserver = observer;
            }
            """
    
    def setup_playback_monitoring(self):
        """Set up JavaScript monitoring to detect when album finishes playing"""
        if not self.web_view:
            return
        
        # Get current repeat mode and shuffle mode to pass to JavaScript
        repeat_mode = 0
        shuffle_mode = 0
        shuffled_track_list = None
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            repeat_mode = self.playlist_sidebar.repeat_mode
            shuffle_mode = self.playlist_sidebar.shuffle_mode
            # Get shuffled track list if Shuffle Tracks mode is active
            if shuffle_mode == 1 and hasattr(self, '_shuffled_track_list') and self._shuffled_track_list:
                shuffled_track_list = self._shuffled_track_list
        
        # Build JavaScript code from helper methods
        is_last_track_js = self._get_is_last_track_js()
        handle_track_end_js = self._get_handle_track_end_js()
        audio_monitoring_js = self._get_audio_monitoring_js(repeat_mode, shuffle_mode, shuffled_track_list)
        fallback_monitoring_js = self._get_fallback_monitoring_js()
        
        js_code = f"""
        (function() {{
            // Remove existing observer if any
            if (window.bandcampPlaybackObserver) {{
                window.bandcampPlaybackObserver.disconnect();
                window.bandcampPlaybackObserver = null;
            }}
            
            // Initialize flags
            window.bandcampAlbumFinished = false;
            window.bandcampTrackFinished = false;
            
            // Store repeat mode and shuffle mode for JavaScript
            window.bandcampRepeatMode = {repeat_mode};
            window.bandcampShuffleMode = {shuffle_mode};
            
            var player = document.querySelector('#player');
            if (!player) {{
                console.log('Bandcamp Player: Player element not found');
                return;
            }}
            
            var trackEndedTimeout = null;
            var lastTrackTitle = null;
            
            // Function to check if this is the last track
            {is_last_track_js}
            
            // Function to handle track end
            {handle_track_end_js}
            
            {audio_monitoring_js}
            {fallback_monitoring_js}
            
            console.log('Bandcamp Player: Playback monitoring setup complete (repeat_mode={repeat_mode})');
        }})();
        """
        
        self.web_view.page().runJavaScript(js_code)
        
        # Set up next/previous button interception for Shuffle Tracks mode
        self._setup_next_prev_button_interception()
        
        # Also update repeat mode in case it changed (for dynamic updates)
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            QTimer.singleShot(100, self.playlist_sidebar._update_javascript_repeat_mode)
            QTimer.singleShot(100, self.playlist_sidebar._update_javascript_shuffle_mode)
        
        # Set up periodic check to see if album/track finished
        if not hasattr(self, '_playback_check_timer'):
            self._playback_check_timer = QTimer(self)
            self._playback_check_timer.timeout.connect(self.check_playback_finished)
            self._playback_check_timer.start(PLAYBACK_CHECK_INTERVAL)
            logger.debug(f"Playback check timer started (checking every {PLAYBACK_CHECK_INTERVAL}ms)")
        
        # Set up periodic check to update current track number
        if not hasattr(self, '_track_number_check_timer'):
            self._track_number_check_timer = QTimer(self)
            self._track_number_check_timer.timeout.connect(self._update_current_track_number)
            self._track_number_check_timer.start(PLAYBACK_CHECK_INTERVAL)  # Check every second
            logger.debug(f"Track number check timer started (checking every {PLAYBACK_CHECK_INTERVAL}ms)")
        
        # Also re-inject after a delay to ensure it's set up (in case page wasn't ready)
        QTimer.singleShot(3000, lambda: self.web_view.page().runJavaScript(js_code) if self.web_view else None)
    
    def _setup_next_prev_button_interception(self):
        """Set up JavaScript to intercept next/previous button clicks for Shuffle Tracks mode"""
        if not self.web_view or not self.web_view.page():
            return
        
        js_code = """
        (function() {
            // Function to handle Super Shuffle mode (random album & track)
            function handleSuperShuffle(direction) {
                if (window.bandcampShuffleMode !== 3) {
                    return false; // Not in Super Shuffle mode
                }
                
                console.log('Bandcamp Player: Super Shuffle - ' + direction + ' button clicked, triggering random selection');
                // Set track finished flag to trigger Python handler for Super Shuffle
                window.bandcampTrackFinished = true;
                return true; // Handled
            }
            
            // Function to navigate to next/previous track in shuffled list
            function navigateShuffledTrack(direction) {
                if (window.bandcampShuffleMode !== 1 || 
                    !window.bandcampShuffledTrackList || 
                    window.bandcampShuffledTrackList.length === 0) {
                    return false; // Not in shuffle tracks mode or no shuffled list
                }
                
                if (window.bandcampShuffledTrackIndex === undefined) {
                    window.bandcampShuffledTrackIndex = 0;
                }
                
                var currentIndex = window.bandcampShuffledTrackIndex;
                var newIndex;
                
                if (direction === 'next') {
                    newIndex = (currentIndex + 1) % window.bandcampShuffledTrackList.length;
                    
                    // Check if we've reached the end
                    var reachedEnd = (newIndex === 0 && currentIndex === window.bandcampShuffledTrackList.length - 1);
                    if (reachedEnd) {
                        // If Repeat mode is Continuous (1) or Off (0), move to next album
                        if (window.bandcampRepeatMode === 0 || window.bandcampRepeatMode === 1) {
                            console.log('Bandcamp Player: Shuffle Tracks - reached end, moving to next album');
                            window.bandcampAlbumFinished = true;
                            return true; // Handled
                        }
                        // If Repeat Album mode (2), reshuffle and continue
                        else if (window.bandcampRepeatMode === 2) {
                            console.log('Bandcamp Player: Shuffle Tracks - reached end, reshuffling');
                            newIndex = 0;
                        }
                    }
                } else { // previous
                    newIndex = (currentIndex - 1 + window.bandcampShuffledTrackList.length) % window.bandcampShuffledTrackList.length;
                }
                
                window.bandcampShuffledTrackIndex = newIndex;
                var targetTrackNum = window.bandcampShuffledTrackList[newIndex];
                
                console.log('Bandcamp Player: Shuffle Tracks - navigating to track ' + targetTrackNum + ' (direction: ' + direction + ')');
                
                // Find and click the target track
                var tracklist = document.querySelector('#tracklist');
                if (tracklist) {
                    var targetTrack = tracklist.querySelector('li.track[data-num="' + targetTrackNum + '"]');
                    if (!targetTrack) {
                        var allTracks = tracklist.querySelectorAll('li.track');
                        if (allTracks.length >= targetTrackNum) {
                            targetTrack = allTracks[targetTrackNum - 1];
                        }
                    }
                    
                    if (targetTrack) {
                        var infoDiv = targetTrack.querySelector('.info');
                        if (infoDiv) {
                            try {
                                var clickEvent = new MouseEvent('click', {
                                    bubbles: true,
                                    cancelable: true,
                                    view: window
                                });
                                infoDiv.dispatchEvent(clickEvent);
                                console.log('Bandcamp Player: Clicked shuffled track ' + targetTrackNum + ' via ' + direction + ' button');
                                return true; // Handled
                            } catch (e) {
                                try {
                                    infoDiv.click();
                                    return true;
                                } catch (e2) {
                                    try {
                                        targetTrack.click();
                                        return true;
                                    } catch (e3) {
                                        console.log('Bandcamp Player: Error clicking shuffled track: ' + e3);
                                    }
                                }
                            }
                        } else {
                            try {
                                targetTrack.click();
                                return true;
                            } catch (e) {
                                console.log('Bandcamp Player: Error clicking shuffled track: ' + e);
                            }
                        }
                    }
                }
                
                return false; // Not handled
            }
            
            // Function to set up button interception
            function setupButtonInterception() {
                // Find next button
                var nextBtn = document.querySelector('button[aria-label="Skip to next song"], .next-prev-controls button[aria-label*="next"], .next-prev-controls button[aria-label*="Next"], button[aria-label*="Skip to next"]');
                if (nextBtn) {
                    // Remove old listener if exists
                    if (nextBtn._bandcampPlayerClickHandler) {
                        nextBtn.removeEventListener('click', nextBtn._bandcampPlayerClickHandler, true);
                    }
                    
                    // Create new handler
                    nextBtn._bandcampPlayerClickHandler = function(event) {
                        // Always check current mode at click time (in case mode changed)
                        var currentMode = window.bandcampShuffleMode || 0;
                        
                        // Check Super Shuffle mode first
                        if (currentMode === 3 && handleSuperShuffle('next')) {
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                            console.log('Bandcamp Player: Intercepted next button click for Super Shuffle mode (mode: ' + currentMode + ')');
                            return false;
                        }
                        // Check Shuffle Tracks mode
                        if (currentMode === 1 && navigateShuffledTrack('next')) {
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                            console.log('Bandcamp Player: Intercepted next button click for Shuffle Tracks mode (mode: ' + currentMode + ')');
                            return false;
                        }
                        // Otherwise, let normal behavior proceed (mode 0 or 2)
                        console.log('Bandcamp Player: Next button - normal behavior (mode: ' + currentMode + ')');
                    };
                    
                    // Add new listener
                    nextBtn.addEventListener('click', nextBtn._bandcampPlayerClickHandler, true);
                    nextBtn.setAttribute('data-bandcamp-player-intercepted', 'true');
                    console.log('Bandcamp Player: Next button interception set up (mode: ' + (window.bandcampShuffleMode || 0) + ')');
                }
                
                // Find previous button
                var prevBtn = document.querySelector('button[aria-label="Skip to previous song"], .next-prev-controls button[aria-label*="previous"], .next-prev-controls button[aria-label*="Previous"], button[aria-label*="Skip to previous"]');
                if (prevBtn) {
                    // Remove old listener if exists
                    if (prevBtn._bandcampPlayerClickHandler) {
                        prevBtn.removeEventListener('click', prevBtn._bandcampPlayerClickHandler, true);
                    }
                    
                    // Create new handler
                    prevBtn._bandcampPlayerClickHandler = function(event) {
                        // Always check current mode at click time (in case mode changed)
                        var currentMode = window.bandcampShuffleMode || 0;
                        
                        // Check Super Shuffle mode first
                        if (currentMode === 3 && handleSuperShuffle('previous')) {
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                            console.log('Bandcamp Player: Intercepted previous button click for Super Shuffle mode (mode: ' + currentMode + ')');
                            return false;
                        }
                        // Check Shuffle Tracks mode
                        if (currentMode === 1 && navigateShuffledTrack('previous')) {
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                            console.log('Bandcamp Player: Intercepted previous button click for Shuffle Tracks mode (mode: ' + currentMode + ')');
                            return false;
                        }
                        // Otherwise, let normal behavior proceed (mode 0 or 2)
                        console.log('Bandcamp Player: Previous button - normal behavior (mode: ' + currentMode + ')');
                    };
                    
                    // Add new listener
                    prevBtn.addEventListener('click', prevBtn._bandcampPlayerClickHandler, true);
                    prevBtn.setAttribute('data-bandcamp-player-intercepted', 'true');
                    console.log('Bandcamp Player: Previous button interception set up (mode: ' + (window.bandcampShuffleMode || 0) + ')');
                }
            }
            
            // Set up immediately
            setupButtonInterception();
            
            // Also set up after delays in case buttons aren't ready yet
            setTimeout(setupButtonInterception, 500);
            setTimeout(setupButtonInterception, 1000);
            setTimeout(setupButtonInterception, 2000);
            
            // Watch for dynamically added buttons (if page updates)
            if (document.body) {
                var observer = new MutationObserver(function(mutations) {
                    setupButtonInterception();
                });
                observer.observe(document.body, { childList: true, subtree: true });
                
                // Store observer so we can disconnect it later if needed
                window.bandcampButtonObserver = observer;
            }
        })();
        """
        
        self.web_view.page().runJavaScript(js_code)
    
    def setup_first_playback_detection(self):
        """Set up JavaScript monitoring to detect first playback after URL load in micro mode"""
        if not self.web_view or self.mini_mode_state != 2:
            return
        
        # Stop any existing timer first
        if hasattr(self, '_first_playback_check_timer') and self._first_playback_check_timer:
            self._first_playback_check_timer.stop()
        
        # Reset the detection flag for this new URL load
        self._first_playback_detected = False
        
        js_code = """
        (function() {
            // Reset any previous setup
            window.bandcampFirstPlaybackSetup = false;
            window.bandcampFirstPlaybackDetected = false;
            
            // Set up fresh detection
            window.bandcampFirstPlaybackSetup = true;
            
            var audioElement = document.querySelector('audio');
            var hasTriggered = false;
            
            function detectFirstPlayback() {
                if (hasTriggered) {
                    return;
                }
                
                if (audioElement) {
                    var isPlaying = !audioElement.paused && audioElement.currentTime > 0;
                    if (isPlaying) {
                        hasTriggered = true;
                        console.log('Bandcamp Player: First playback detected - signaling layout refresh');
                        window.bandcampFirstPlaybackDetected = true;
                    }
                }
            }
            
            // Monitor audio element for first playback
            if (audioElement) {
                audioElement.addEventListener('play', function() {
                    if (!hasTriggered) {
                        hasTriggered = true;
                        console.log('Bandcamp Player: First play event - signaling layout refresh');
                        window.bandcampFirstPlaybackDetected = true;
                    }
                });
                
                audioElement.addEventListener('playing', function() {
                    if (!hasTriggered) {
                        hasTriggered = true;
                        console.log('Bandcamp Player: First playing event - signaling layout refresh');
                        window.bandcampFirstPlaybackDetected = true;
                    }
                });
            }
            
            // Also poll for audio state (fallback)
            var checkInterval = setInterval(function() {
                detectFirstPlayback();
                if (hasTriggered) {
                    clearInterval(checkInterval);
                }
            }, 200);
            
            // Stop checking after 5 seconds
            setTimeout(function() {
                clearInterval(checkInterval);
            }, 5000);
        })();
        """
        
        self.web_view.page().runJavaScript(js_code)
        
        # Set up periodic check to see if first playback was detected
        # Always create/restart the timer for each new URL load
        if hasattr(self, '_first_playback_check_timer') and self._first_playback_check_timer:
            self._first_playback_check_timer.stop()
        else:
            self._first_playback_check_timer = QTimer(self)
            self._first_playback_check_timer.timeout.connect(self._check_first_playback)
        
        self._first_playback_check_timer.start(200)  # Check every 200ms
        # Stop checking after 5 seconds
        QTimer.singleShot(5000, lambda: self._first_playback_check_timer.stop() if hasattr(self, '_first_playback_check_timer') and self._first_playback_check_timer else None)
    
    def _check_first_playback(self):
        """Check if first playback was detected and refresh layout in micro mode"""
        if not self.web_view or self.mini_mode_state != 2:
            # Not in micro mode anymore, stop checking
            if hasattr(self, '_first_playback_check_timer'):
                self._first_playback_check_timer.stop()
            return
        
        def on_check_result(result):
            if result is True or result == True or (isinstance(result, str) and result.lower() == 'true'):
                # First playback detected - refresh layout
                self._first_playback_detected = True
                # Stop the timer
                if hasattr(self, '_first_playback_check_timer'):
                    self._first_playback_check_timer.stop()
                # Reset JavaScript flag
                self.web_view.page().runJavaScript("window.bandcampFirstPlaybackDetected = false; window.bandcampFirstPlaybackSetup = false;")
                # Refresh layout by resizing to micro mode
                # Use a small delay to ensure player has fully expanded
                QTimer.singleShot(300, self._resize_to_micro_mode_with_retry)
                logger.debug("First playback detected in micro mode - refreshing layout")
        
        check_js = """
        (function() {
            if (typeof window.bandcampFirstPlaybackDetected === 'undefined') {
                return false;
            }
            return window.bandcampFirstPlaybackDetected === true;
        })();
        """
        
        self.web_view.page().runJavaScript(check_js, on_check_result)
    
    def check_playback_finished(self):
        """Check if track or album has finished playing and handle based on shuffle/repeat modes"""
        if not self.web_view:
            return
        
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # Check both track and album finish flags
        def on_check_result(result):
            try:
                track_finished = result.get('track_finished', False)
                album_finished = result.get('album_finished', False)
                
                # Handle track finish (for Repeat 1 Track, Super Shuffle, Shuffle Tracks)
                if track_finished:
                    self._handle_track_finished()
                
                # Handle album finish (for Repeat Album, Continuous, etc.)
                if album_finished:
                    self._handle_album_finished()
            except (AttributeError, TypeError, KeyError) as e:
                logger.debug(f"Error parsing playback check result: {e}")
        
        # Check JavaScript flags
        check_js = """
        (function() {
            return {
                track_finished: window.bandcampTrackFinished || false,
                album_finished: window.bandcampAlbumFinished || false
            };
        })();
        """
        self.web_view.page().runJavaScript(check_js, on_check_result)
    
    def check_album_finished(self):
        """Legacy method - redirects to check_playback_finished"""
        self.check_playback_finished()
    
    def _handle_track_finished(self):
        """Handle when a track finishes playing"""
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # Reset flag FIRST to prevent multiple triggers
        self.web_view.page().runJavaScript("window.bandcampTrackFinished = false;")
        
        shuffle_mode = self.playlist_sidebar.shuffle_mode
        repeat_mode = self.playlist_sidebar.repeat_mode
        
        # Repeat 1 Track mode: JavaScript handles restarting, but we can fallback to reload if needed
        if repeat_mode == 3:
            # Check if JavaScript actually restarted the track by checking if audio is playing
            def check_if_restarted():
                js_code = """
                (function() {
                    var audioElement = document.querySelector('audio');
                    if (audioElement) {
                        var isPlaying = !audioElement.paused && audioElement.currentTime > 0;
                        var currentTime = audioElement.currentTime || 0;
                        // If playing and near the beginning (< 5 seconds), JavaScript likely restarted it
                        return {
                            isPlaying: isPlaying,
                            currentTime: currentTime,
                            restarted: isPlaying && currentTime < 5
                        };
                    }
                    return {isPlaying: false, currentTime: 0, restarted: false};
                })();
                """
                
                def on_check_result(result):
                    try:
                        if result and result.get('restarted', False):
                            logger.debug("Repeat 1 Track: JavaScript successfully restarted track, skipping Python handler")
                            return  # JavaScript handled it, don't reload
                        else:
                            # JavaScript didn't restart, use fallback
                            logger.info("Repeat 1 Track: JavaScript restart failed, using fallback reload")
                            current_url = self.web_view.url().toString()
                            current_track = getattr(self, '_current_track_number', None)
                            if current_url and current_track:
                                # Load URL and then play the specific track
                                self.load_url(current_url)
                                # Set flag to auto-play the specific track after page loads
                                self._auto_play_track_number = current_track
                                # Also set _current_track_number so it's saved
                                self._current_track_number = current_track
                    except (AttributeError, TypeError, KeyError) as e:
                        logger.debug(f"Error checking restart status: {e}, using fallback")
                        # On error, use fallback
                        current_url = self.web_view.url().toString()
                        current_track = getattr(self, '_current_track_number', None)
                        if current_url and current_track:
                            self.load_url(current_url)
                            self._auto_play_track_number = current_track
                            self._current_track_number = current_track
                
                self.web_view.page().runJavaScript(js_code, on_check_result)
            
            # Wait a bit for JavaScript to restart, then check
            QTimer.singleShot(500, check_if_restarted)
            return
        
        # Super Shuffle mode: pick random album and random track
        if shuffle_mode == 3:
            # Check if this is a pending load from when Super Shuffle was toggled on
            pending_load = getattr(self, '_pending_super_shuffle_load', False)
            if pending_load:
                # Clear the flag
                self._pending_super_shuffle_load = False
                logger.info("Super Shuffle: Track finished, loading random album and random track (was pending)")
            else:
                logger.info("Super Shuffle: Track finished, loading random album and random track")
            self._load_super_shuffle_track()
            return
        
        # Shuffle Tracks mode: JavaScript should have already jumped to next track
        # Skip reload - JavaScript handles the seamless switch
        if shuffle_mode == 1:
            logger.info("Shuffle Tracks: JavaScript should have switched to next track, skipping reload")
            # Note: If JavaScript fails to switch, we could add a fallback here,
            # but for now we trust the JavaScript implementation
            return
    
    def _handle_album_finished(self):
        """Handle when an album finishes playing"""
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # Reset flag FIRST to prevent multiple triggers
        self.web_view.page().runJavaScript("window.bandcampAlbumFinished = false;")
        
        repeat_mode = self.playlist_sidebar.repeat_mode
        
        # Repeat Album mode: JavaScript should have already jumped to track 1
        # Skip reload - JavaScript handles the seamless loop
        if repeat_mode == 2:
            logger.info("Repeat Album: JavaScript should have looped to track 1, skipping reload")
            # Note: If JavaScript fails to loop, we could add a fallback here,
            # but for now we trust the JavaScript implementation
            return
        
        # Continuous mode (or default): load next album
        if repeat_mode == 1 or repeat_mode == 0:
            logger.info("Continuous/Off: Loading next album")
            QTimer.singleShot(50, lambda: self._load_next_album_safe())
            return
    
    def _update_current_track_number(self):
        """Periodically update the current track number from the page"""
        if not self.web_view or not self.web_view.page():
            return
        
        js_code = """
            (function() {
            var currentTrack = document.querySelector('.current-track');
            if (currentTrack) {
                var trackNumEl = currentTrack.querySelector('.track-number, .track-num');
                if (trackNumEl) {
                    var trackNumber = trackNumEl.textContent.trim().replace(/[^\\d]/g, '');
                    if (trackNumber) {
                        return parseInt(trackNumber);
                    }
                }
                // Fallback: try to find number in spans
                var spans = currentTrack.querySelectorAll('span');
                for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    var text = span.textContent.trim();
                    if (/^\\d+$/.test(text)) {
                        return parseInt(text);
                }
                }
            }
            // Also try to get from data-num attribute of playing track
            var tracklist = document.querySelector('#tracklist');
            if (tracklist) {
                var playingTrack = tracklist.querySelector('li.track.playing, li.track.current');
                if (playingTrack) {
                    var dataNum = playingTrack.getAttribute('data-num');
                    if (dataNum) {
                        return parseInt(dataNum);
                    }
                }
            }
            return null;
            })();
        """
        
        def on_track_number_received(result):
            if result is not None:
                try:
                    track_num = int(result)
                    if track_num != self._current_track_number:
                        self._current_track_number = track_num
                        logger.debug(f"Updated current track number: {track_num}")
                        
                        # Update shuffled track index if Shuffle Tracks mode is active
                        if (hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and
                            self.playlist_sidebar.shuffle_mode == 1 and
                            hasattr(self, '_shuffled_track_list') and self._shuffled_track_list and
                            track_num in self._shuffled_track_list):
                            # Find the index of the current track in the shuffled list
                            new_index = self._shuffled_track_list.index(track_num)
                            if new_index != getattr(self, '_shuffled_track_index', -1):
                                self._shuffled_track_index = new_index
                                # Update JavaScript index
                                js_update = f"""
                                (function() {{
                                    window.bandcampShuffledTrackIndex = {new_index};
                                    console.log('Bandcamp Player: Updated shuffled track index to {new_index} (track {track_num})');
                                }})();
                                """
                                self.web_view.page().runJavaScript(js_update)
                                logger.debug(f"Updated shuffled track index to {new_index} for track {track_num}")
                        
                        # Track manual track selection in Super Shuffle mode (continue from there)
                        if (hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and
                            self.playlist_sidebar.shuffle_mode == 3):
                            current_url = self.web_view.url().toString()
                            if current_url and current_url.startswith('http'):
                                combo = (current_url, track_num)
                                self._add_to_super_shuffle_history(combo)
                                logger.debug(f"Super Shuffle: Tracked manual track selection: {combo}")
                        
                        # Save settings immediately when track number changes (regardless of autoplay settings)
                        self.save_settings()
                except (ValueError, TypeError):
                    pass
        
        self.web_view.page().runJavaScript(js_code, on_track_number_received)
    
    def _load_next_album_safe(self):
        """Safely load next album with error handling"""
        try:
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                # Mark that we're loading via repeat (so we can auto-play)
                self._auto_play_next_album = True
                success = self.playlist_sidebar.load_next_album()
                if success:
                    logger.info("Next album loaded successfully, will auto-play first track")
                else:
                    logger.info("Failed to load next album (no more albums?)")
                    self._auto_play_next_album = False
        except Exception as e:
            logger.error(f"Error loading next album: {e}", exc_info=True)
            self._auto_play_next_album = False
    
    def _create_shuffled_track_list(self, album_url):
        """Create a shuffled list of track numbers for the current album (for Shuffle Tracks mode)"""
        if not self.web_view or not self.web_view.page():
            return
        
        # Get all track numbers from the album
        js_code = """
        (function() {
            var tracks = [];
            var tracklist = document.querySelector('#tracklist');
            if (tracklist) {
                var trackElements = tracklist.querySelectorAll('li.track');
                trackElements.forEach(function(trackEl) {
                    var dataNum = trackEl.getAttribute('data-num');
                    if (dataNum) {
                        tracks.push(parseInt(dataNum));
                    } else {
                        // Fallback: use index + 1
                        var index = Array.from(tracklist.querySelectorAll('li.track')).indexOf(trackEl);
                        tracks.push(index + 1);
                    }
                });
            }
            return tracks;
        })();
        """
        
        def on_tracks_received(result):
            if result and isinstance(result, list) and len(result) > 0:
                # Remove duplicates to ensure each track plays only once
                # Convert to set to remove duplicates, then back to list to preserve order
                unique_tracks = list(dict.fromkeys(result))  # Preserves order while removing duplicates
                
                if len(unique_tracks) < len(result):
                    logger.debug(f"Removed {len(result) - len(unique_tracks)} duplicate track(s) from shuffled list")
                
                # Shuffle the track list
                shuffled = unique_tracks.copy()
                random.shuffle(shuffled)
                self._shuffled_track_list = shuffled
                self._shuffled_track_index = 0
                self._shuffled_track_album_url = album_url
                logger.debug(f"Created shuffled track list for album: {shuffled}")
            else:
                # No tracks found or single track - create list with just track 1
                self._shuffled_track_list = [1]
                self._shuffled_track_index = 0
                self._shuffled_track_album_url = album_url
                logger.debug("Single track album - shuffled list contains only track 1")
            
            # Inject shuffled list into JavaScript for seamless track switching
            if self._shuffled_track_list:
                # Find current track index in shuffled list
                current_track = getattr(self, '_current_track_number', None)
                if current_track and current_track in self._shuffled_track_list:
                    # Set index to current track's position in shuffled list
                    self._shuffled_track_index = self._shuffled_track_list.index(current_track)
                else:
                    # Start from beginning if current track not found
                    self._shuffled_track_index = 0
                
                shuffled_js = f"""
                (function() {{
                    window.bandcampShuffledTrackList = {self._shuffled_track_list};
                    window.bandcampShuffledTrackIndex = {self._shuffled_track_index};
                    console.log('Bandcamp Player: Injected shuffled track list:', window.bandcampShuffledTrackList, 'starting at index', window.bandcampShuffledTrackIndex);
                }})();
                """
                self.web_view.page().runJavaScript(shuffled_js)
                
                # Re-setup button interception after shuffled list is created to ensure it's active
                if hasattr(self, '_setup_next_prev_button_interception'):
                    QTimer.singleShot(200, self._setup_next_prev_button_interception)
        
        self.web_view.page().runJavaScript(js_code, on_tracks_received)
    
    def _load_next_shuffled_track(self):
        """Load the next track in the shuffled list (for Shuffle Tracks mode)"""
        current_url = self.web_view.url().toString()
        
        # If album changed or no shuffled list exists, create one
        if (not self._shuffled_track_list or 
            self._shuffled_track_album_url != current_url):
            self._create_shuffled_track_list(current_url)
            # Wait a bit for the list to be created, then try again
            QTimer.singleShot(500, self._load_next_shuffled_track)
            return
        
        # Move to next track in shuffled list
        self._shuffled_track_index += 1
        
        # If we've played all tracks, check Repeat mode
        if self._shuffled_track_index >= len(self._shuffled_track_list):
            repeat_mode = 0
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                repeat_mode = self.playlist_sidebar.repeat_mode
            
            # If Repeat Album mode (2) is active, reshuffle and continue
            if repeat_mode == 2:
                random.shuffle(self._shuffled_track_list)
                self._shuffled_track_index = 0
                # Update JavaScript with reshuffled list
                if self._shuffled_track_list:
                    shuffled_js = f"""
                    (function() {{
                        window.bandcampShuffledTrackList = {self._shuffled_track_list};
                        window.bandcampShuffledTrackIndex = 0;
                        console.log('Bandcamp Player: Reshuffled track list:', window.bandcampShuffledTrackList);
                    }})();
                    """
                    self.web_view.page().runJavaScript(shuffled_js)
            # Otherwise (Continuous/Off), let album finished handler move to next album
            else:
                # Don't reshuffle - let the album finished handler take over
                logger.info("Shuffle Tracks: Reached end of shuffled list, moving to next album (Repeat mode: {})".format(repeat_mode))
                return
        
        # Get the track number to play
        track_number = self._shuffled_track_list[self._shuffled_track_index]
        logger.info(f"Shuffle Tracks: Loading track {track_number} from shuffled list")
        
        # Load URL and set track to play
        self.load_url(current_url)
        self._auto_play_track_number = track_number
        self._current_track_number = track_number
    
    def _load_super_shuffle_track(self):
        """Load a random album and random track (for Super Shuffle mode)
        
        Avoids the last 3 played (album_url, track_number) combinations.
        Works dynamically with playlist changes.
        """
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        # Get all albums from playlist (dynamic - gets current playlist state)
        valid_items = []
        for i in range(self.playlist_sidebar.list_widget.count()):
            item = self.playlist_sidebar.list_widget.item(i)
            if item and item.data(Qt.ItemDataRole.UserRole):  # Has URL
                valid_items.append((i, item))
        
        if len(valid_items) == 0:
            logger.warning("Super Shuffle: No albums in playlist")
            return
        
        # Get history of last played combinations (avoid last 3)
        history = getattr(self.playlist_sidebar, '_super_shuffle_history', [])
        max_history = getattr(self.playlist_sidebar, '_super_shuffle_max_history', 3)
        
        # Pick a random album, avoiding albums from recent history if possible
        available_albums = valid_items.copy()
        
        # If we have history, try to avoid albums that were recently played
        if history and len(valid_items) > 1:
            recent_albums = {combo[0] for combo in history[-max_history:]}
            # Only filter if we have enough albums to choose from
            if len(available_albums) > len(recent_albums):
                available_albums = [item for item in valid_items if item[1].data(Qt.ItemDataRole.UserRole) not in recent_albums]
                if len(available_albums) == 0:
                    available_albums = valid_items.copy()  # Fallback to all albums
        
        # Pick a random album
        random_album_index, random_item = random.choice(available_albums)
        random_album_url = random_item.data(Qt.ItemDataRole.UserRole)
        
        # Set Super Shuffle flag and store album URL before loading
        # This allows track selection to happen immediately when page is ready
        self._is_super_shuffle_load = True
        self._super_shuffle_album_url = random_album_url
        
        # Load the album - track selection will happen in on_page_loaded() when page is ready
        logger.info(f"Super Shuffle: Loading random album: {random_album_url}")
        self.load_url(random_album_url)
    
    def _pick_super_shuffle_track(self):
        """Pick a random track for Super Shuffle mode when page is ready
        
        This is called from on_page_loaded() when _is_super_shuffle_load is True.
        It selects a random track and sets _auto_play_track_number for immediate autoplay.
        """
        # Safety check: ensure Super Shuffle flag is set
        if not hasattr(self, '_is_super_shuffle_load') or not self._is_super_shuffle_load:
            return
        
        # Safety check: ensure Super Shuffle is still enabled (user might have toggled it off)
        if (not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar or 
            self.playlist_sidebar.shuffle_mode != 3):
            # Super Shuffle was disabled - clear flags and return
            logger.debug("Super Shuffle was disabled, clearing flags")
            self._is_super_shuffle_load = False
            self._super_shuffle_album_url = None
            return
        
        if not hasattr(self, '_super_shuffle_album_url') or not self._super_shuffle_album_url:
            # Clear flag and return if no album URL stored
            self._is_super_shuffle_load = False
            return
        
        if not self.web_view or not self.web_view.page():
            # Fallback to track 1 if page not ready
            combo = (self._super_shuffle_album_url, 1)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                self._add_to_super_shuffle_history(combo)
            self._auto_play_track_number = 1
            self._current_track_number = 1
            self._is_super_shuffle_load = False
            self._super_shuffle_album_url = None
            return
        
        random_album_url = self._super_shuffle_album_url
        history = []
        max_history = 3
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            history = getattr(self.playlist_sidebar, '_super_shuffle_history', [])
            max_history = getattr(self.playlist_sidebar, '_super_shuffle_max_history', 3)
        
        js_code = """
        (function() {
            var tracks = [];
            var tracklist = document.querySelector('#tracklist');
            if (tracklist) {
                var trackElements = tracklist.querySelectorAll('li.track');
                trackElements.forEach(function(trackEl) {
                    var dataNum = trackEl.getAttribute('data-num');
                    if (dataNum) {
                        tracks.push(parseInt(dataNum));
                    } else {
                        var index = Array.from(tracklist.querySelectorAll('li.track')).indexOf(trackEl);
                        tracks.push(index + 1);
                    }
                });
            }
            // Remove duplicates
            var uniqueTracks = [];
            var seen = {};
            tracks.forEach(function(track) {
                if (!seen[track]) {
                    seen[track] = true;
                    uniqueTracks.push(track);
                }
            });
            return uniqueTracks.length > 0 ? uniqueTracks : [1];
        })();
        """
        
        def on_tracks_received(result):
            if result and isinstance(result, list) and len(result) > 0:
                # Remove duplicates
                unique_tracks = list(dict.fromkeys(result))
                
                # Pick a random track, avoiding recent combinations
                available_tracks = unique_tracks.copy()
                
                # Filter out tracks that match recent history for this album
                if history and len(unique_tracks) > 1:
                    recent_combos_for_album = [
                        combo[1] for combo in history[-max_history:] 
                        if combo[0] == random_album_url
                    ]
                    if recent_combos_for_album:
                        available_tracks = [t for t in unique_tracks if t not in recent_combos_for_album]
                        if len(available_tracks) == 0:
                            available_tracks = unique_tracks.copy()  # Fallback to all tracks
                
                random_track = random.choice(available_tracks)
                combo = (random_album_url, random_track)
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    self._add_to_super_shuffle_history(combo)
                logger.info(f"Super Shuffle: Selected track {random_track} from random album")
                # Set track to play - autoplay will happen in hide_overlay()
                self._auto_play_track_number = random_track
                self._current_track_number = random_track
            else:
                # Fallback to track 1
                combo = (random_album_url, 1)
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    self._add_to_super_shuffle_history(combo)
                self._auto_play_track_number = 1
                self._current_track_number = 1
            
            # Clear flags after track selection
            self._is_super_shuffle_load = False
            self._super_shuffle_album_url = None
        
        self.web_view.page().runJavaScript(js_code, on_tracks_received)
    
    def _add_to_super_shuffle_history(self, combo):
        """Add a (album_url, track_number) combination to Super Shuffle history"""
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        history = getattr(self.playlist_sidebar, '_super_shuffle_history', [])
        max_history = getattr(self.playlist_sidebar, '_super_shuffle_max_history', 3)
        
        # Add to history
        history.append(combo)
        
        # Keep only last max_history items
        if len(history) > max_history:
            history = history[-max_history:]
        
        self.playlist_sidebar._super_shuffle_history = history
        logger.debug(f"Super Shuffle history updated: {history}")
    
    def _get_single_track_play_js(self):
        """Generate JavaScript code to play single track page"""
        return """
                // For singles, try to find and click the play button directly
                if (isSingleTrackPage) {{
                    console.log('Bandcamp Player: Detected single track page - trying direct play button');
                    var playBtn = player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"], button[aria-label*="play"], button[aria-label*="Play"]');
                    if (playBtn && playBtn.offsetParent !== null) {{
                        console.log('Bandcamp Player: Single track - clicking play button');
                        playBtn.click();
                        // Immediately restore scroll position after click
                        setTimeout(function() {{
                            window.scrollTo(savedScrollLeft, savedScrollTop);
                        }}, 0);
                        
                        // Also try direct audio.play() after a short delay
                        setTimeout(function() {{
                            var audioElement = document.querySelector('audio');
                            if (audioElement) {{
                                console.log('Bandcamp Player: Single track - attempting direct audio.play()');
                                var playPromise = audioElement.play();
                                if (playPromise !== undefined) {{
                                    playPromise.then(function() {{
                                        console.log('Bandcamp Player:  Single track audio.play() succeeded!');
                                    }}).catch(function(error) {{
                                        console.log('Bandcamp Player: Single track audio.play() failed: ' + error);
                                    }});
                                }}
                            }}
                        }}, 500);
                        return;
                    }}
                }}
                """
                
    def _get_album_track_play_js(self, track_number=None):
        """Generate JavaScript code to play specified track (or first playable track) from album tracklist
        
        Args:
            track_number: Optional track number to play (1-based). If None, plays first playable track.
        """
        # If track_number is None, we'll find the first playable track in JS
        # Otherwise, try to play the specified track (will fall back to first playable if not available)
        target_track_num = track_number if track_number is not None else 1
        use_first_playable = (track_number is None)
        logger.debug(f"_get_album_track_play_js: track_number={track_number}, target_track_num={target_track_num}, use_first_playable={use_first_playable}")
        playable_helper = self._get_playable_tracks_helper_js()
        # Convert boolean to JavaScript boolean string
        use_first_playable_js = 'true' if use_first_playable else 'false'
        return playable_helper + f"""
                
                // For albums, try clicking the specified track (or first track) in the tracklist to load it
                console.log('Bandcamp Player: Auto-play starting - looking for track number {target_track_num}, useFirstPlayable should be {use_first_playable_js}');
                var tracklist = document.querySelector('#tracklist');
                if (!tracklist) {{
                    console.log('Bandcamp Player: Tracklist not found yet, waiting...');
                    // Wait for tracklist to appear (retry up to 5 times with 200ms delay)
                    var retries = 0;
                    var maxRetries = 5;
                    var checkTracklist = setInterval(function() {{
                        retries++;
                        tracklist = document.querySelector('#tracklist');
                        if (tracklist || retries >= maxRetries) {{
                            clearInterval(checkTracklist);
                            if (tracklist) {{
                                console.log('Bandcamp Player: Tracklist found after ' + (retries * 200) + 'ms');
                                // Continue with track selection
                                selectAndPlayTrack();
                            }} else {{
                                console.log('Bandcamp Player: Tracklist not found after ' + (maxRetries * 200) + 'ms, using fallback');
                                // Fallback to play button
                                var player = document.querySelector('#player');
                                var playBtn = player ? player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]') : null;
                                if (playBtn && playBtn.offsetParent !== null) {{
                                    playBtn.click();
                                }}
                            }}
                        }}
                    }}, 200);
                }} else {{
                    selectAndPlayTrack();
                }}
                
                function selectAndPlayTrack() {{
                    var tracklist = document.querySelector('#tracklist');
                    if (!tracklist) {{
                        console.log('Bandcamp Player: Tracklist still not available in selectAndPlayTrack');
                        return;
                    }}
                    
                    // Get all playable tracks first
                    var playableTracks = getPlayableTracks();
                    console.log('Bandcamp Player: Found ' + playableTracks.length + ' playable tracks out of all tracks');
                    
                    if (playableTracks.length === 0) {{
                        console.log('Bandcamp Player: No playable tracks found, cannot autoplay');
                        // Log all tracks for debugging
                        var allTracks = tracklist.querySelectorAll('li.track');
                        console.log('Bandcamp Player: Total tracks in tracklist: ' + allTracks.length);
                        for (var i = 0; i < Math.min(allTracks.length, 5); i++) {{
                            var t = allTracks[i];
                            console.log('Bandcamp Player: Track ' + (i+1) + ' - classes: ' + t.className + ', has .info: ' + (t.querySelector('.info') ? 'YES' : 'NO'));
                        }}
                        return;
                    }}
                    
                    var targetTrack = null;
                    var actualTrackNum = null;
                    
                    // If track_number was None (target_track_num is 1 as default), always use first playable track
                    // Otherwise, try to find the requested track first
                    var useFirstPlayable = {use_first_playable_js};
                    console.log('Bandcamp Player: useFirstPlayable = ' + useFirstPlayable + ' (boolean), target_track_num = {target_track_num}');
                    
                    if (!useFirstPlayable) {{
                        // First, try to find the requested track by data-num attribute
                        var requestedTrack = tracklist.querySelector('li.track[data-num="{target_track_num}"]');
                        if (requestedTrack) {{
                            // Check if the requested track is actually playable
                            var isPlayable = false;
                            for (var i = 0; i < playableTracks.length; i++) {{
                                if (playableTracks[i] === requestedTrack) {{
                                    isPlayable = true;
                                    break;
                                }}
                            }}
                            
                            if (isPlayable) {{
                                targetTrack = requestedTrack;
                                actualTrackNum = {target_track_num};
                                console.log('Bandcamp Player: Found playable track with data-num="{target_track_num}"');
                            }} else {{
                                console.log('Bandcamp Player: Track {target_track_num} exists but is not playable, finding first playable track');
                                useFirstPlayable = true;
                            }}
                        }} else {{
                            console.log('Bandcamp Player: Track {target_track_num} not found, finding first playable track');
                            useFirstPlayable = true;
                        }}
                    }}
                    
                    // If requested track not found or not playable, or if track_number was None, find first playable track
                    if (useFirstPlayable || !targetTrack) {{
                        if (playableTracks.length === 0) {{
                            console.log('Bandcamp Player: ERROR - No playable tracks available!');
                            return;
                        }}
                        targetTrack = playableTracks[0];
                        // Get the actual track number from data-num attribute
                        actualTrackNum = targetTrack.getAttribute('data-num');
                        if (actualTrackNum) {{
                            actualTrackNum = parseInt(actualTrackNum);
                        }} else {{
                            // Fallback: find the track's position in the original tracklist
                            var allTracks = tracklist.querySelectorAll('li.track');
                            for (var i = 0; i < allTracks.length; i++) {{
                                if (allTracks[i] === targetTrack) {{
                                    actualTrackNum = i + 1; // 1-based
                                    break;
                                }}
                            }}
                            // If still not found, use index in playable tracks array (1-based)
                            if (!actualTrackNum) {{
                                for (var i = 0; i < playableTracks.length; i++) {{
                                    if (playableTracks[i] === targetTrack) {{
                                        actualTrackNum = i + 1;
                                        break;
                                    }}
                                }}
                            }}
                        }}
                        // Verify the track is actually in the playable tracks array
                        var isActuallyPlayable = false;
                        for (var i = 0; i < playableTracks.length; i++) {{
                            if (playableTracks[i] === targetTrack) {{
                                isActuallyPlayable = true;
                                break;
                            }}
                        }}
                        if (!isActuallyPlayable) {{
                            console.log('Bandcamp Player: ERROR - Selected track is not in playable tracks array!');
                            return;
                        }}
                        if (useFirstPlayable) {{
                            console.log('Bandcamp Player: Using first playable track (track number ' + actualTrackNum + ', index 0 in playable tracks)');
                        }} else {{
                            console.log('Bandcamp Player: Using first playable track (track number ' + actualTrackNum + ') instead of requested track {target_track_num}');
                        }}
                    }}
                    
                    if (targetTrack && playableTracks.length > 0) {{
                        // Double-check that targetTrack is actually playable
                        var isInPlayableArray = false;
                        for (var i = 0; i < playableTracks.length; i++) {{
                            if (playableTracks[i] === targetTrack) {{
                                isInPlayableArray = true;
                                break;
                            }}
                        }}
                        if (!isInPlayableArray) {{
                            console.log('Bandcamp Player: ERROR - Target track is not in playable tracks array, cannot play');
                            return;
                        }}
                        
                        var infoDiv = targetTrack.querySelector('.info');
                        if (!infoDiv) {{
                            console.log('Bandcamp Player: WARNING - Target track has no .info div, trying to click track element directly');
                        }}
                        
                        console.log('Bandcamp Player: Auto-playing track ' + actualTrackNum + ' (requested: {target_track_num}, autoplay restriction disabled)');
                        console.log('Bandcamp Player: Target track classes: ' + targetTrack.className);
                        console.log('Bandcamp Player: Target track has .info div: ' + (infoDiv ? 'YES' : 'NO'));
                        
                        // Step 1: Click target track to load it (scroll is locked, so it won't scroll)
                        // Try multiple methods to ensure the track loads
                        var clicked = false;
                        if (infoDiv) {{
                            console.log('Bandcamp Player: Step 1 - Clicking track ' + actualTrackNum + ' .info div to load track');
                            try {{
                                // Try mouse event first (more reliable)
                                var clickEvent = new MouseEvent('click', {{
                                    bubbles: true,
                                    cancelable: true,
                                    view: window
                                }});
                                infoDiv.dispatchEvent(clickEvent);
                                clicked = true;
                                console.log('Bandcamp Player: Dispatched click event on .info div');
                            }} catch (e) {{
                                console.log('Bandcamp Player: Error dispatching click on .info div: ' + e);
                                try {{
                            infoDiv.click();
                                    clicked = true;
                                    console.log('Bandcamp Player: Called .click() on .info div');
                                }} catch (e2) {{
                                    console.log('Bandcamp Player: Error calling .click() on .info div: ' + e2);
                                }}
                            }}
                        }}
                        
                        // Fallback: try clicking the track element directly
                        if (!clicked) {{
                            console.log('Bandcamp Player: Step 1 (fallback) - Clicking track ' + actualTrackNum + ' element to load track');
                            try {{
                                var clickEvent = new MouseEvent('click', {{
                                    bubbles: true,
                                    cancelable: true,
                                    view: window
                                }});
                                targetTrack.dispatchEvent(clickEvent);
                                clicked = true;
                                console.log('Bandcamp Player: Dispatched click event on track element');
                            }} catch (e) {{
                                console.log('Bandcamp Player: Error dispatching click on track element: ' + e);
                                try {{
                                    targetTrack.click();
                                    clicked = true;
                                    console.log('Bandcamp Player: Called .click() on track element');
                                }} catch (e2) {{
                                    console.log('Bandcamp Player: Error calling .click() on track element: ' + e2);
                                }}
                            }}
                        }}
                        
                        if (!clicked) {{
                            console.log('Bandcamp Player: ERROR - Failed to click track, cannot load');
                            return;
                        }}
                        
                        // Step 2: Wait for track to load, then try to play
                        // Use a longer delay and check multiple times to ensure track loads
                        var playAttempts = 0;
                        var maxPlayAttempts = 5;
                        var playInterval = setInterval(function() {{
                            playAttempts++;
                            var audioElement = document.querySelector('audio');
                            var player = document.querySelector('#player');
                            var playBtn = player ? player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]') : null;
                            
                            if (audioElement && audioElement.src) {{
                                console.log('Bandcamp Player: Step 2 (attempt ' + playAttempts + ') - Audio element found with src, attempting direct audio.play()');
                                clearInterval(playInterval);
                                var playPromise = audioElement.play();
                                if (playPromise !== undefined) {{
                                    playPromise.then(function() {{
                                        console.log('Bandcamp Player:  Direct audio.play() succeeded!');
                                    }}).catch(function(error) {{
                                        console.log('Bandcamp Player: Direct audio.play() failed: ' + error);
                                        // Fallback: try play button
                                        if (playBtn && playBtn.offsetParent !== null) {{
                                            console.log('Bandcamp Player: Fallback - Clicking play button');
                                            playBtn.click();
                                        }}
                                    }});
                                }}
                            }} else if (playBtn && playBtn.offsetParent !== null) {{
                                // Play button is visible, try clicking it
                                console.log('Bandcamp Player: Step 2 (attempt ' + playAttempts + ') - Play button found, clicking it');
                                clearInterval(playInterval);
                                playBtn.click();
                            }} else if (playAttempts >= maxPlayAttempts) {{
                                console.log('Bandcamp Player: Step 2 - Max attempts reached, audio/play button not found');
                                clearInterval(playInterval);
                            }} else {{
                                console.log('Bandcamp Player: Step 2 (attempt ' + playAttempts + ') - Waiting for audio/play button...');
                            }}
                        }}, 500); // Check every 500ms, up to 5 times (2.5 seconds total)
                        
                        return;
                    }} else {{
                        console.log('Bandcamp Player: ERROR - No target track found and no playable tracks available!');
                    }}
                }}
                """
                
    def _get_fallback_play_js(self):
        """Generate JavaScript code for fallback play button click"""
        return """
                // Fallback: if no tracklist found, try play button (for singles or edge cases)
                if (!tracklist || isSingleTrackPage) {{
                    console.log('Bandcamp Player: No tracklist found - trying play button fallback');
                    var playBtn = player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"], button[aria-label*="play"], button[aria-label*="Play"]');
                    if (playBtn && playBtn.offsetParent !== null) {{
                        console.log('Bandcamp Player: Fallback - Clicking play button');
                        playBtn.click();
                        // Scroll restoration will be handled by the interval, which stops when playback starts
                        
                        // Also try direct audio.play() after a short delay
                        setTimeout(function() {{
                            // Ensure scroll position is maintained
                            window.scrollTo(savedScrollLeft, savedScrollTop);
                            var audioElement = document.querySelector('audio');
                            if (audioElement) {{
                                console.log('Bandcamp Player: Fallback - attempting direct audio.play()');
                                var playPromise = audioElement.play();
                                if (playPromise !== undefined) {{
                                    playPromise.then(function() {{
                                        console.log('Bandcamp Player:  Fallback audio.play() succeeded!');
                                    }}).catch(function(error) {{
                                        console.log('Bandcamp Player: Fallback audio.play() failed: ' + error);
                                    }});
                                }}
                            }}
                        }}, 500);
                        return;
                    }}
                }}
                """
    
    def auto_play_first_track(self, track_number=None):
        """Automatically start playing the specified track (or first track) of the loaded album
        
        Args:
            track_number: Optional track number to play (1-based). If None, plays first track.
        """
        if not self.web_view:
            return
        
        # Ensure overlay is hidden before autoplay
        if self.loading_overlay and self.loading_overlay.isVisible():
            self.is_loading = False
            # Restore context menu policy on web view
            if self.web_view and self._original_context_menu_policy is not None:
                self.web_view.setContextMenuPolicy(self._original_context_menu_policy)
                self._original_context_menu_policy = None
            self.loading_overlay.hide()
            self.loading_overlay.setVisible(False)
            self.loading_overlay.setGraphicsEffect(None)
            self.loading_overlay.lower()
            self.loading_overlay.setGeometry(0, 0, 0, 0)
        
        # Build JavaScript code from helper methods
        logger.debug(f"auto_play_first_track: Building JS with track_number={track_number} (type: {type(track_number)})")
        # For regular autoplay (track_number=None), we want to find first playable track
        # For startup autoplay with saved track, we want to try that track first, then fall back
        single_track_js = self._get_single_track_play_js()
        album_track_js = self._get_album_track_play_js(track_number=track_number)
        fallback_js = self._get_fallback_play_js()
        
        js_code = f"""
        (function() {{
            // Save current scroll position to prevent scrolling during autoplay
            var savedScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
            var savedScrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft;
            
            // Set up scroll prevention IMMEDIATELY (before waiting for player) to catch fast-loading pages
            // Use multiple prevention methods to completely prevent scrolling without jitter
            var originalScrollIntoView = Element.prototype.scrollIntoView;
            var scrollPreventionActive = true;
            
            // Method 1: Override scrollIntoView to prevent browser's automatic scroll-to-view
            Element.prototype.scrollIntoView = function() {{
                if (scrollPreventionActive) {{
                    return; // Prevent scrolling
                }}
                return originalScrollIntoView.apply(this, arguments);
            }};
            
            // Method 2: Prevent scrolling via scroll event listeners (more direct, no jitter)
            var scrollPreventHandler = function(e) {{
                if (scrollPreventionActive) {{
                    window.scrollTo(savedScrollLeft, savedScrollTop);
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }}
            }};
            
            // Add scroll prevention listeners with capture to catch early
            window.addEventListener('scroll', scrollPreventHandler, {{ passive: false, capture: true }});
            document.addEventListener('scroll', scrollPreventHandler, {{ passive: false, capture: true }});
            
            // Method 3: Lock scroll position via CSS (prevents any scrolling)
            var originalOverflow = document.documentElement.style.overflow;
            var originalBodyOverflow = document.body.style.overflow;
            document.documentElement.style.overflow = 'hidden';
            document.body.style.overflow = 'hidden';
            
            // Stop scroll prevention after 1 second - restore everything
            setTimeout(function() {{
                scrollPreventionActive = false;
                // Restore original scrollIntoView
                Element.prototype.scrollIntoView = originalScrollIntoView;
                // Remove scroll event listeners
                window.removeEventListener('scroll', scrollPreventHandler, true);
                document.removeEventListener('scroll', scrollPreventHandler, true);
                // Restore overflow styles
                document.documentElement.style.overflow = originalOverflow;
                document.body.style.overflow = originalBodyOverflow;
                console.log('Bandcamp Player: Scroll prevention stopped after 1 second');
            }}, 1000); // 1 second
            
            // Wait a bit for player to be ready
            setTimeout(function() {{
                var player = document.querySelector('#player');
                if (!player) {{
                    console.log('Bandcamp Player: Player not found for auto-play');
                    return;
                }}
                
                // Cleanup: Ensure body classes are correct (remove mini/micro mode if not active)
                if (document.body) {{
                    var miniModeState = {self.mini_mode_state};
                    if (miniModeState === 0) {{
                        // Not in mini mode - ensure classes are removed
                        document.body.classList.remove('mini-mode', 'micro-mode', 'mini-mode-autohide');
                        // Force reset player positioning
                        var playerStyle = window.getComputedStyle(player);
                        if (playerStyle.position === 'absolute' && !document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {{
                            player.style.position = 'relative';
                            player.style.bottom = 'auto';
                            player.style.left = 'auto';
                            player.style.right = 'auto';
                        }}
                    }}
                }}
                
                // Check if this is a single track page
                var isSingleTrackPage = window.location.href.indexOf('/track/') !== -1;
                
                {single_track_js}
                {album_track_js}
                {fallback_js}
                
                console.log('Bandcamp Player: Could not find first track or play button');
            }}, 300); // Wait 300ms for player to be ready (reduced from 1500ms for faster autoplay)
        }})();
        """
        
        self.web_view.page().runJavaScript(js_code)
        
        # Add aggressive cleanup after autoplay - run multiple times to catch any timing issues
        # This ensures the player positioning is reset even if it gets set incorrectly
        def cleanup_player_positioning():
            """Force cleanup of player positioning to prevent dark block"""
            cleanup_js = f"""
            (function() {{
                if (document.body) {{
                    var miniModeState = {self.mini_mode_state};
                    if (miniModeState === 0) {{
                        // Not in mini mode - ensure classes are removed
                        document.body.classList.remove('mini-mode', 'micro-mode', 'mini-mode-autohide');
                        
                        // Force reset player positioning - check multiple times
                        var player = document.querySelector('#player');
                        if (player) {{
                            var playerStyle = window.getComputedStyle(player);
                            if (playerStyle.position === 'absolute' && !document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {{
                                player.style.position = 'relative';
                                player.style.bottom = 'auto';
                                player.style.left = 'auto';
                                player.style.right = 'auto';
                                player.style.zIndex = 'auto';
                                console.log('Bandcamp Player: Cleaned up player positioning');
                            }}
                        }}
                        
                        // CRITICAL: Prevent dark block at bottom by ensuring body/html don't have extra height
                        // This happens when player is temporarily positioned absolutely during autoplay
                        var html = document.documentElement;
                        var body = document.body;
                        
                        // Reset any absolute positioning on player container
                        var playerContainer = document.querySelector('.player-container');
                        if (playerContainer) {{
                            var containerStyle = window.getComputedStyle(playerContainer);
                            if (containerStyle.position === 'absolute' && !document.body.classList.contains('mini-mode') && !document.body.classList.contains('micro-mode')) {{
                                playerContainer.style.position = 'relative';
                                playerContainer.style.bottom = 'auto';
                                console.log('Bandcamp Player: Cleaned up player container positioning');
                            }}
                        }}
                        
                        // Ensure body doesn't have extra padding/margin at bottom that could show dark background
                        // Check if body height is larger than content (which would show #212121 background)
                        var bodyHeight = body.scrollHeight;
                        var windowHeight = window.innerHeight;
                        
                        // If body is taller than window and there's no visible content at bottom, 
                        // it might be showing the dark background - force min-height to content height
                        if (bodyHeight > windowHeight) {{
                            // Check if last visible element is near bottom
                            var lastElement = body.lastElementChild;
                            if (lastElement) {{
                                var lastElementRect = lastElement.getBoundingClientRect();
                                var lastElementBottom = lastElementRect.bottom;
                                
                                // If last element is well above bottom of viewport, there might be extra space
                                if (lastElementBottom < windowHeight - 50) {{
                                    // Force body to fit content exactly - prevent extra dark space
                                    body.style.minHeight = 'auto';
                                    body.style.height = 'auto';
                                    html.style.height = 'auto';
                                    html.style.minHeight = 'auto';
                                    console.log('Bandcamp Player: Fixed body height to prevent dark block');
                                }}
                            }}
                        }}
                        
                        // Additional safeguard: ensure body/html height matches content to prevent dark block
                        // Check if there's a significant gap at bottom (more than 50px of dark space)
                        var scrollHeight = Math.max(body.scrollHeight, html.scrollHeight, document.documentElement.scrollHeight);
                        var clientHeight = Math.max(body.clientHeight, html.clientHeight, window.innerHeight);
                        
                        // If body is taller than viewport and there's extra space, it might show dark background
                        if (scrollHeight > clientHeight + 50) {{
                            // Check the last visible element to see if there's actually content or just empty space
                            var lastVisibleElement = null;
                            var allElements = body.querySelectorAll('*');
                            for (var i = allElements.length - 1; i >= 0; i--) {{
                                var el = allElements[i];
                                var rect = el.getBoundingClientRect();
                                if (rect.height > 0 && rect.width > 0 && rect.bottom > 0) {{
                                    lastVisibleElement = el;
                                    break;
                                }}
                            }}
                            
                            if (lastVisibleElement) {{
                                var lastElementBottom = lastVisibleElement.getBoundingClientRect().bottom;
                                // If last element is well above bottom, there's extra dark space
                                if (lastElementBottom < clientHeight - 50) {{
                                    // Force body to fit content exactly - prevent extra dark space
                                    body.style.minHeight = 'auto';
                                    body.style.height = 'auto';
                                    html.style.minHeight = 'auto';
                                    html.style.height = 'auto';
                                    console.log('Bandcamp Player: Fixed body height to prevent dark block (last element at ' + lastElementBottom + ', viewport ' + clientHeight + ')');
                                }}
                            }}
                        }}
                    }}
                }}
            }})();
            """
            self.web_view.page().runJavaScript(cleanup_js)
        
        # Run cleanup immediately, then after delays to catch any timing issues
        QTimer.singleShot(2000, cleanup_player_positioning)  # After autoplay delay
        QTimer.singleShot(3000, cleanup_player_positioning)  # Extra safety check
        QTimer.singleShot(4000, cleanup_player_positioning)  # Final check
        QTimer.singleShot(5000, cleanup_player_positioning)  # Additional check for slower page updates
    
    def update_mini_mode_button(self):
        """Update mini mode button icon and tooltip to show NEXT mode"""
        if not hasattr(self, 'mini_mode_btn'):
            return
        
        # Disable button if welcome message is visible and playlist is empty
        if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
            playlist = self.playlist_manager.get_playlist()
            if not playlist or len(playlist) == 0:
                self.mini_mode_btn.setEnabled(False)
                self.mini_mode_btn.setToolTip("Load a Bandcamp URL to Enable Mode Switching")
            return
        
        # Show/hide button based on bandcamp mode
        if self.bandcamp_mode:
            self.mini_mode_btn.setEnabled(True)
            self.mini_mode_btn.setVisible(True)
            # Icons for each mode: Regular = fa5s.square, Mini = ph.triangle-fill, Micro = msc.triangle-up
            if HAS_QT_AWESOME:
                state_icons = ['fa5s.square', 'ph.triangle-fill', 'msc.triangle-up']
            else:
                state_icons = ['', '', '']
            state_names = ['Regular', 'Mini', 'Micro']
            
            # Show NEXT mode (current + 1, wrapping around)
            next_state = (self.mini_mode_state + 1) % 3
            current_state_name = state_names[self.mini_mode_state]
            next_state_name = state_names[next_state]
            
            if HAS_QT_AWESOME:
                icon = get_icon(state_icons[next_state], color='#e0e0e0')
                if icon:
                    self.mini_mode_btn.setIcon(icon)
                else:
                    self.mini_mode_btn.setText(state_icons[next_state] if isinstance(state_icons[next_state], str) and len(state_icons[next_state]) == 1 else "")
            else:
                self.mini_mode_btn.setText(state_icons[next_state])
            self.mini_mode_btn.setToolTip(f"{current_state_name} Mode > {next_state_name} Mode")
        else:
            self.mini_mode_btn.setVisible(False)
    
    def update_mini_mode_menu_text(self):
        """Update mini mode menu item text to show NEXT mode"""
        if hasattr(self, 'mini_mode_action'):
            # Disable menu action if welcome message is visible and playlist is empty
            if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
                playlist = self.playlist_manager.get_playlist()
                if not playlist or len(playlist) == 0:
                    self.mini_mode_action.setEnabled(False)
                    return
            
            self.mini_mode_action.setEnabled(True)
            state_names = ['Regular Mode', 'Mini Mode', 'Micro Mode']
            # Show NEXT mode (current + 1, wrapping around)
            next_state = (self.mini_mode_state + 1) % 3
            self.mini_mode_action.setText(state_names[next_state])
        
        # Update mini mode player autohide menu item visibility
        if hasattr(self, 'mini_mode_player_autohide_action'):
            self.mini_mode_player_autohide_action.setVisible(self.mini_mode_state == 1)
    
    def toggle_always_on_top(self):
        """Toggle always on top"""
        self.always_on_top = not self.always_on_top
        # Update button state if it exists
        if hasattr(self, 'always_on_top_btn'):
            self.always_on_top_btn.setChecked(self.always_on_top)
            # Update icon color based on checked state (light when off, blue when on)
            if HAS_QT_AWESOME:
                icon_color = '#4a90e2' if self.always_on_top else '#a0a0a0'
                icon = get_icon('thumbtack', color=icon_color)
                if icon:
                    self.always_on_top_btn.setIcon(icon)
        self.apply_always_on_top()
        self.save_settings()
    
    def apply_always_on_top(self):
        """Apply always on top setting"""
        flags = self.windowFlags()
        
        # Preserve frameless mode if enabled
        if self.frameless_mode:
            flags |= Qt.WindowType.FramelessWindowHint
        
        # Apply always on top
        if self.always_on_top:
            flags |= Qt.WindowType.WindowStaysOnTopHint
        else:
            flags &= ~Qt.WindowType.WindowStaysOnTopHint
        
        self.setWindowFlags(flags)
        self.show()  # Required to apply flag changes
    
    def toggle_frameless_mode(self):
        """Toggle frameless window mode"""
        self.frameless_mode = not self.frameless_mode
        self.frameless_action.setChecked(self.frameless_mode)
        self.apply_frameless_mode()
        self.save_settings()
    
    def toggle_webview_scrollbar(self):
        """Toggle webview scrollbar visibility"""
        self.webview_scrollbar_visible = not self.webview_scrollbar_visible
        self.settings['webview_scrollbar_visible'] = self.webview_scrollbar_visible
        self.save_settings()
        
        # Update menu action state
        if hasattr(self, 'webview_scrollbar_action'):
            self.webview_scrollbar_action.setChecked(self.webview_scrollbar_visible)
        
        # Re-inject CSS to apply scrollbar changes
        self.inject_css()
    
    def toggle_transparent_overlay(self):
        """Toggle transparent loading overlay"""
        self.transparent_overlay = not self.transparent_overlay
        self.transparent_overlay_action.setChecked(self.transparent_overlay)
        self.save_settings()
        # Apply transparency immediately if overlay is visible
        if self.loading_overlay and self.loading_overlay.isVisible():
            self.apply_overlay_transparency()
    
    def apply_overlay_transparency(self):
        """Apply transparency to loading overlay based on setting"""
        if not self.loading_overlay:
            return
        
        # Use QGraphicsOpacityEffect for proper transparency
        current_effect = self.loading_overlay.graphicsEffect()
        
        if self.transparent_overlay:
            # Make overlay semi-transparent (70% opacity)
            if not current_effect or not isinstance(current_effect, QGraphicsOpacityEffect):
                # Create new effect if one doesn't exist
                overlay_effect = QGraphicsOpacityEffect(self.loading_overlay)
                self.loading_overlay.setGraphicsEffect(overlay_effect)
                overlay_effect.setOpacity(0.7)
            else:
                # Update existing effect
                current_effect.setOpacity(0.7)
        else:
            # Make overlay fully opaque
            if not current_effect or not isinstance(current_effect, QGraphicsOpacityEffect):
                # Create new effect if one doesn't exist
                overlay_effect = QGraphicsOpacityEffect(self.loading_overlay)
                self.loading_overlay.setGraphicsEffect(overlay_effect)
                overlay_effect.setOpacity(1.0)
            else:
                # Update existing effect
                current_effect.setOpacity(1.0)
    
    def apply_frameless_mode(self):
        """Apply frameless window mode"""
        flags = self.windowFlags()
        
        if self.frameless_mode:
            # Remove native title bar
            flags |= Qt.WindowType.FramelessWindowHint
            # Keep always on top if enabled
            if self.always_on_top:
                flags |= Qt.WindowType.WindowStaysOnTopHint
            self.setWindowFlags(flags)
            # Enable rounded corners
            self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
            self.create_custom_title_bar()
            # Create bottom resize handle
            self.create_bottom_resize_handle()
            # Apply rounded corners after window is shown
            QTimer.singleShot(50, self.apply_rounded_corners)
        else:
            # Restore native title bar
            flags &= ~Qt.WindowType.FramelessWindowHint
            # Disable rounded corners (translucent background)
            self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, False)
            # Keep always on top if enabled
            if self.always_on_top:
                flags |= Qt.WindowType.WindowStaysOnTopHint
            self.setWindowFlags(flags)
            self.remove_custom_title_bar()
            # Remove bottom resize handle
            self.remove_bottom_resize_handle()
            # Clear mask
            self.clearMask()
        
        self.show()  # Required to apply flag changes
    
    def apply_rounded_corners(self):
        """Apply rounded corners to the window"""
        if not self.frameless_mode:
            return
        
        radius = 10  # Corner radius in pixels
        size = self.size()
        
        # Create a path with rounded corners
        path = QPainterPath()
        path.addRoundedRect(0, 0, size.width(), size.height(), radius, radius)
        
        # Convert path to polygon and create region
        polygon = path.toFillPolygon()
        rounded_region = QRegion(polygon.toPolygon())
        
        self.setMask(rounded_region)
    
    def update_loading_overlay_geometry(self):
        """Update loading overlay geometry to cover entire web view area (playlist will sit on top)"""
        if not self.loading_overlay:
            return
        
        # Only update geometry if overlay should be visible (is loading)
        # If not loading, ensure overlay is hidden and reset geometry
        if not self.is_loading:
            if self.loading_overlay.isVisible():
                self.loading_overlay.hide()
                self.loading_overlay.setVisible(False)
            # Always reset geometry when not loading to prevent taking up space
            self.loading_overlay.setGeometry(0, 0, 0, 0)
            return
        
        # Calculate top offset (title bar + controls bar)
        top_offset = 0
        
        # Add title bar height if it exists (frameless mode)
        if self.title_bar and self.title_bar.isVisible():
            top_offset += self.title_bar.height()
        
        # Add controls bar height only if it's in the layout (not in overlay mode)
        if hasattr(self, 'controls_bar_widget') and self.controls_bar_widget:
            # Only add height if controls bar is in layout (not overlay mode)
            if hasattr(self, 'controls_bar_in_layout') and self.controls_bar_in_layout:
                top_offset += self.controls_bar_widget.height()
            # If autohide is enabled and controls bar is overlay, don't add to offset
            # (it will overlay the content, so overlay should cover everything)
        
        # Calculate overlay geometry - cover full height (playlist will be on top with higher z-order)
        overlay_x = 0
        overlay_y = top_offset
        overlay_width = self.width()
        overlay_height = self.height() - top_offset  # Full height, no bottom offset
        
        # Ensure minimum height
        if overlay_height < 0:
            overlay_height = 0
        
        self.loading_overlay.setGeometry(overlay_x, overlay_y, overlay_width, overlay_height)
    
    def resizeEvent(self, event):
        """Handle window resize to update rounded corners and overlay"""
        # In micro or mini mode, prevent user-initiated resizing but allow programmatic resizes
        if self.mini_mode_state == 2 or self.mini_mode_state == 1:
            # Check if this is a programmatic resize (from resize_to_mini_mode or resize_to_micro_mode)
            is_programmatic = (
                (hasattr(self, '_micro_mode_resizing') and self._micro_mode_resizing) or
                (hasattr(self, '_mini_mode_resizing') and self._mini_mode_resizing)
            )
            
            if not is_programmatic:
                # User tried to resize - restore fixed size
                current_size = self.size()
                if event.size() != current_size:
                    self.setGeometry(self.x(), self.y(), current_size.width(), current_size.height())
                    event.ignore()
                    return
        
        # Constrain width to 260px (fixed width) - only allow height changes
        new_size = event.size()
        if new_size.width() != 260:
            # Force width to 260, keep the requested height
            new_size.setWidth(260)
            # Use setGeometry to apply the constrained size
            self.setGeometry(self.x(), self.y(), 260, new_size.height())
        
        super().resizeEvent(event)
        
        # Update autohide trigger button position on resize
        if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
            self.update_autohide_trigger_position()
        # Update playlist quick button position on resize
        if hasattr(self, 'playlist_quick_btn') and self.playlist_quick_btn and self.playlist_quick_btn.isVisible():
            self.update_playlist_quick_btn_position()
        
        if self.frameless_mode:
            # Update rounded corners after resize
            QTimer.singleShot(10, self.apply_rounded_corners)
        # Update overlay geometry only if it should be visible (is loading)
        if self.loading_overlay:
            if self.is_loading and self.loading_overlay.isVisible():
                self.update_loading_overlay_geometry()
                self.loading_overlay.raise_()
            elif not self.is_loading:
                # Ensure overlay is hidden when not loading and reset geometry
                if self.loading_overlay.isVisible():
                    self.loading_overlay.hide()
                    self.loading_overlay.setVisible(False)
                # Always reset geometry when not loading to prevent taking up space
                self.loading_overlay.setGeometry(0, 0, 0, 0)
        
        # Update bottom resize handle position if it exists
        if hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle:
            self.update_bottom_resize_handle_position()
        
        # Update address bar hover area position if it exists
        if hasattr(self, 'update_hover_area_position'):
            self.update_hover_area_position()
        
        # Update address bar overlay position if in overlay mode
        if self.autohide_address_bar and hasattr(self, 'update_address_bar_overlay_position'):
            self.update_address_bar_overlay_position()
    
    def create_custom_title_bar(self):
        """Create custom title bar for frameless mode"""
        if self.title_bar:
            return  # Already exists
        
        # Create title bar widget
        self.title_bar = QWidget(self)
        self.title_bar.setFixedHeight(30)
        self.title_bar.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border-bottom: 1px solid #1a1a1a;
            }
        """)
        
        title_layout = QHBoxLayout(self.title_bar)
        title_layout.setContentsMargins(8, 0, 0, 0)
        title_layout.setSpacing(0)
        
        # Icon
        if self.app_icon:
            icon_label = QLabel()
            icon_label.setPixmap(self.app_icon.pixmap(16, 16))
            title_layout.addWidget(icon_label)
            title_layout.addSpacing(8)
        
        # Title
        current_title = self.windowTitle() or "Bandcamp Player"
        self.window_title_label = QLabel(current_title)
        self.window_title_label.setStyleSheet("""
            QLabel {
                color: #e0e0e0;
                font-size: 11px;
            }
        """)
        title_layout.addWidget(self.window_title_label)
        
        title_layout.addStretch()
        
        # Window controls
        controls_layout = QHBoxLayout()
        controls_layout.setContentsMargins(0, 0, 0, 0)
        controls_layout.setSpacing(0)
        
        # Minimize button (actual minimize, not nano mode)
        minimize_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('minus', color='#e0e0e0')
            if icon:
                minimize_btn.setIcon(icon)
            else:
                minimize_btn.setText("")
        else:
            minimize_btn.setText("")
        minimize_btn.setFixedSize(22, 22)  # Match playlist buttons
        minimize_btn.setToolTip("Minimize")
        minimize_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        def on_minimize_clicked():
            self._minimize_button_clicked = True
            self.showMinimized()
        minimize_btn.clicked.connect(on_minimize_clicked)
        controls_layout.addWidget(minimize_btn)
        
        # Nano mode button (hide main window and show nano player)
        nano_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.chevron-down', color='#e0e0e0')
            if icon:
                nano_btn.setIcon(icon)
            else:
                nano_btn.setText("")
        else:
            nano_btn.setText("")
        nano_btn.setFixedSize(22, 22)  # Match playlist buttons
        nano_btn.setToolTip("Nano Mode")
        nano_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        nano_btn.clicked.connect(self._enter_nano_mode)
        controls_layout.addWidget(nano_btn)
        
        # Mini Mode button (between minimize and close)
        if hasattr(self, 'mini_mode_btn') and self.mini_mode_btn:
            # Remove from any previous parent/layout before adding to title bar
            if self.mini_mode_btn.parent():
                old_parent = self.mini_mode_btn.parent()
                if hasattr(old_parent, 'layout'):
                    layout = old_parent.layout()
                    if layout:
                        layout.removeWidget(self.mini_mode_btn)
            # Ensure correct size and style for title bar
            self.mini_mode_btn.setFixedSize(22, 22)  # Match playlist buttons
            # Update style to match
            self.mini_mode_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            controls_layout.addWidget(self.mini_mode_btn)
        else:
            # Create mini mode button if it doesn't exist yet
            self.mini_mode_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('square', color='#e0e0e0')
                if icon:
                    self.mini_mode_btn.setIcon(icon)
                else:
                    self.mini_mode_btn.setText("")  # Default icon (will be updated by update_mini_mode_button)
            else:
                self.mini_mode_btn.setText("")  # Default icon (will be updated by update_mini_mode_button)
            self.mini_mode_btn.setFixedSize(22, 22)  # Match playlist buttons
            self.mini_mode_btn.setToolTip("Mini Mode")
            self.mini_mode_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            self.mini_mode_btn.clicked.connect(self.toggle_mini_mode)
            controls_layout.addWidget(self.mini_mode_btn)
        
        # Update button state after adding to title bar
        if hasattr(self, 'update_mini_mode_button'):
            self.update_mini_mode_button()
        
        # Close button
        close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_btn.setIcon(icon)
            else:
                close_btn.setText("")
        else:
            close_btn.setText("")
        close_btn.setFixedSize(22, 22)  # Match playlist buttons
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #e81123;
                color: white;
            }
        """)
        close_btn.clicked.connect(self.close)
        controls_layout.addWidget(close_btn)
        
        title_layout.addLayout(controls_layout)
        
        # Add title bar to layout (at the top)
        layout = self.centralWidget().layout()
        layout.insertWidget(0, self.title_bar)
        
        # Enable window dragging on title bar
        self.title_bar.mousePressEvent = self.title_bar_mouse_press
        self.title_bar.mouseMoveEvent = self.title_bar_mouse_move
        self.title_bar.mouseReleaseEvent = self.title_bar_mouse_release
        
        # Update bottom resize handle if it exists
        if hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle:
            QTimer.singleShot(50, self.update_bottom_resize_handle_position)
    
    def remove_custom_title_bar(self):
        """Remove custom title bar"""
        if self.title_bar:
            layout = self.centralWidget().layout()
            layout.removeWidget(self.title_bar)
            self.title_bar.deleteLater()
            self.title_bar = None
    
    def mousePressEvent(self, event):
        """Handle mouse press events - hide address bar if clicking outside it when autohide is enabled"""
        super().mousePressEvent(event)
        
        # Debug: Right-click to inspect widget at position (Ctrl+Right-click for more details)
        # Only if debug methods exist (they may not be implemented)
        if event.button() == Qt.MouseButton.RightButton:
            modifiers = event.modifiers()
            if modifiers & Qt.KeyboardModifier.ShiftModifier:
                # Inspect HTML element at position (since dark block shows HTML context menu)
                if hasattr(self, 'inspect_html_element_at_position'):
                    self.inspect_html_element_at_position(event.position().toPoint())
                    return  # Don't process further if inspecting
            elif modifiers & Qt.KeyboardModifier.ControlModifier:
                if hasattr(self, 'inspect_widget_at_position'):
                    self.inspect_widget_at_position(event.globalPosition().toPoint())
                    return  # Don't process further if inspecting
            else:
                # Simple right-click: just show basic info
                if hasattr(self, 'quick_inspect_widget'):
                    self.quick_inspect_widget(event.position().toPoint())
                    return  # Don't process further if inspecting
                # If debug methods don't exist, allow normal right-click behavior to proceed
        
        # Don't handle address bar hiding if we're dragging the playlist resize handle
        if hasattr(self, 'playlist_start_resize_y') and self.playlist_start_resize_y is not None:
            return
        
        if self.autohide_address_bar and hasattr(self, 'controls_bar_widget'):
            # Check if click is outside the address bar
            click_pos = event.pos()
            
            # In mini/micro mode, only show address bar when clicking on the trigger button
            # Don't show it when clicking anywhere else at the top
            is_mini_or_micro = hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2)
            
            # Check if click is on the trigger icon (which should show the address bar)
            if hasattr(self, 'autohide_trigger_btn') and self.autohide_trigger_btn and self.autohide_trigger_btn.isVisible():
                if self.autohide_trigger_btn.geometry().contains(click_pos):
                    # Click is on trigger icon, show address bar
                    self.show_address_bar_immediate()
                    return
            
            # Check if click is within address bar geometry
            if self.controls_bar_widget.geometry().contains(click_pos):
                # Click is on address bar
                # In all modes (including regular), don't show on click - only show on trigger button hover/click
                # Schedule hide instead
                self.schedule_address_bar_hide()
            else:
                # Click is outside address bar
                # Schedule hide
                self.schedule_address_bar_hide()
    
    def moveEvent(self, event):
        """Handle window move event - update linked detached playlist window if link mode is enabled, and handle snapping."""
        super().moveEvent(event)
        if self.playlist_detached and self.playlist_window_linked:
            self._handle_main_window_movement_for_linking(event)
        
        # Check for automatic docking at screen edges (similar to nano player)
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            self._check_windows_dock_to_screen_edge()
        
        # Handle snapping main window to detached playlist window (only while dragging)
        # Only snap if link mode is NOT enabled and we're dragging
        if (
            self.playlist_detached
            and hasattr(self, 'detached_playlist_window')
            and self.detached_playlist_window
            and not self.playlist_window_linked
            and not self._moving_main_window_programmatically
            and self._is_dragging_main_window
        ):
            # Snap immediately while dragging (more forceful, like nano player)
            if self._handle_main_window_snapping():
                self._snapped_during_drag = True
    
    def showEvent(self, event):
        """Handle window show event"""
        super().showEvent(event)
        # Update bottom resize handle position when window is shown
        if self.frameless_mode and hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle:
            QTimer.singleShot(50, self.update_bottom_resize_handle_position)
    
    def title_bar_mouse_press(self, event):
        """Handle mouse press on title bar for window dragging"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
            self._is_dragging_main_window = True
            self._snapped_during_drag = False
            event.accept()
    
    def title_bar_mouse_move(self, event):
        """Handle mouse move on title bar for window dragging"""
        if event.buttons() == Qt.MouseButton.LeftButton and hasattr(self, 'drag_position'):
            self.move(event.globalPosition().toPoint() - self.drag_position)
            # Only enable snapping while dragging main window (and not linked)
            if self.playlist_detached and not self.playlist_window_linked:
                # Check if snapping occurred
                if self._handle_main_window_snapping():
                    self._snapped_during_drag = True
            event.accept()
    
    def title_bar_mouse_release(self, event):
        """Handle mouse release on title bar"""
        if event.button() == Qt.MouseButton.LeftButton:
            self._is_dragging_main_window = False
            # If windows snapped during drag, link them now (on release) - but only if still close
            if self._snapped_during_drag and self.playlist_detached:
                # Check if windows are still close (within snap threshold)
                main_rect = self.geometry()
                detached_rect = self.detached_playlist_window.geometry()
                
                main_left = main_rect.x()
                main_right = main_rect.x() + main_rect.width()
                main_top = main_rect.y()
                main_bottom = main_rect.y() + main_rect.height()
                
                detached_left = detached_rect.x()
                detached_right = detached_rect.x() + detached_rect.width()
                detached_top = detached_rect.y()
                detached_bottom = detached_rect.y() + detached_rect.height()
                
                # Check if windows are within snap threshold
                h_dist = 0
                v_dist = 0
                if detached_right < main_left:
                    h_dist = main_left - detached_right
                elif detached_left > main_right:
                    h_dist = detached_left - main_right
                
                if detached_bottom < main_top:
                    v_dist = main_top - detached_bottom
                elif detached_top > main_bottom:
                    v_dist = detached_top - main_bottom
                
                total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5
                if total_dist <= self._snap_threshold:
                    # Windows are still close - link them
                    self._toggle_playlist_window_linking(True)
                    self._windows_docked = True
                    # Update link offset
                    main_x = self.x()
                    main_y = self.y()
                    detached_x = self.detached_playlist_window.x()
                    detached_y = self.detached_playlist_window.y()
                    self._playlist_window_link_offset = (detached_x - main_x, detached_y - main_y)
            self._snapped_during_drag = False
            if hasattr(self, 'drag_position'):
                self.drag_position = None
    
    def create_bottom_resize_handle(self):
        """Create bottom resize handle for frameless mode"""
        if self.bottom_resize_handle:
            return  # Already exists
        
        # Create resize handle widget
        self.bottom_resize_handle = QWidget(self)
        self.bottom_resize_handle.setFixedHeight(6)  # 6px tall resize area
        self.bottom_resize_handle.setStyleSheet("""
            QWidget {
                background-color: transparent;
            }
            QWidget:hover {
                background-color: rgba(100, 100, 100, 0.3);
            }
        """)
        self.bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)  # Vertical resize cursor
        self.bottom_resize_handle.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        
        # Mouse event handlers for resizing
        def handle_mouse_press(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.resize_start_y = event.globalPosition().y()
                self.resize_start_height = self.height()
                event.accept()
        
        def handle_mouse_move(event):
            if self.resize_start_y is not None and event.buttons() & Qt.MouseButton.LeftButton:
                delta_y = event.globalPosition().y() - self.resize_start_y
                new_height = max(150, self.resize_start_height + int(delta_y))  # Min 150px
                # Keep width fixed at 260px
                self.resize(WINDOW_DEFAULT_WIDTH, new_height)
                event.accept()
        
        def handle_mouse_release(event):
            self.resize_start_y = None
            self.resize_start_height = None
            event.accept()
        
        self.bottom_resize_handle.mousePressEvent = handle_mouse_press
        self.bottom_resize_handle.mouseMoveEvent = handle_mouse_move
        self.bottom_resize_handle.mouseReleaseEvent = handle_mouse_release
        
        # Position at bottom of window
        self.update_bottom_resize_handle_position()
        self.bottom_resize_handle.show()
        self.bottom_resize_handle.raise_()  # Keep on top
    
    def update_bottom_resize_handle_position(self):
        """Update bottom resize handle position"""
        if not self.bottom_resize_handle:
            return
        
        # Position at bottom of window, full width
        handle_height = 6
        self.bottom_resize_handle.setGeometry(0, self.height() - handle_height, self.width(), handle_height)
        self.bottom_resize_handle.raise_()  # Keep on top
    
    def remove_bottom_resize_handle(self):
        """Remove bottom resize handle"""
        if self.bottom_resize_handle:
            self.bottom_resize_handle.deleteLater()
            self.bottom_resize_handle = None
        self.resize_start_y = None
        self.resize_start_height = None
    
    def toggle_playlist_expand(self):
        """Toggle playlist expand/collapse (minimize/restore)"""
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and self.playlist_sidebar.isVisible():
            self.playlist_sidebar._toggle_minimize_state()
    
    def _update_playlist_button_icon(self, is_visible):
        """Update playlist button icon color based on visibility state"""
        if hasattr(self, 'playlist_btn') and HAS_QT_AWESOME:
            icon_color = '#4a90e2' if is_visible else '#a0a0a0'
            icon = get_icon('mdi6.list-box', color=icon_color)
            if icon:
                self.playlist_btn.setIcon(icon)
    
    def toggle_playlist(self):
        """Toggle playlist sidebar visibility"""
        # If playlist is detached, toggle detached window visibility instead
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            is_visible = self.detached_playlist_window.isVisible()
            if is_visible:
                self.detached_playlist_window.hide()
                new_visible = False
            else:
                self.detached_playlist_window.show()
                self.detached_playlist_window.raise_()
                self.detached_playlist_window.activateWindow()
                new_visible = True
            # Update button states and icon color
            if hasattr(self, 'playlist_btn'):
                self.playlist_btn.setChecked(new_visible)
                self._update_playlist_button_icon(new_visible)
            if hasattr(self, 'show_playlist_action'):
                self.show_playlist_action.setChecked(new_visible)
            # Save state
            self.settings['playlist_visible'] = new_visible
            self.save_settings()
            # Keep quick button in sync (should be hidden while detached)
            try:
                self.update_playlist_quick_btn_visibility()
            except Exception:
                pass
            return
        
        # Lazy-load playlist sidebar on first use
        if self.playlist_sidebar is None:
            layout = self.centralWidget().layout()
            
            # Create container widget for playlist and resize handle
            playlist_container = QWidget()
            # Set size policy to prevent container from expanding vertically
            # Expanding horizontally (fills window width), Preferred vertically (only takes space it needs)
            playlist_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            # Set minimum height to 0 so container can collapse completely when playlist is hidden
            playlist_container.setMinimumHeight(0)
            playlist_container_layout = QVBoxLayout(playlist_container)
            playlist_container_layout.setContentsMargins(0, 0, 0, 0)
            playlist_container_layout.setSpacing(0)
            
            # Resize handle (horizontal bar at top of playlist)
            resize_handle = QWidget()
            resize_handle.setFixedHeight(0)  # Start with 0 height since it's hidden
            resize_handle.setStyleSheet("""
                QWidget {
                    background-color: transparent;
                }
                QWidget:hover {
                    background-color: transparent;
                }
            """)
            resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)  # Vertical resize cursor
            resize_handle.hide()  # Hidden by default, shown when playlist is visible
            # Set size policy to prevent taking space when hidden
            resize_handle.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
            playlist_container_layout.addWidget(resize_handle)
            
            self.playlist_sidebar = PlaylistSidebar(
                self,
                self.playlist_manager,
                self.resolve_url_redirects,
                self.load_url
            )
            # Set size policy - expand horizontally to fill container, preferred height
            self.playlist_sidebar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            # Set initial height and allow resizing between min and max
            self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
            self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
            # Restore height from settings or use default
            saved_height = self.settings.get("playlist_height", 250)
            saved_height = int(max(100, min(600, saved_height)))  # Clamp between min and max
            self.playlist_sidebar.setFixedHeight(saved_height)
            if hasattr(self.playlist_sidebar, '_restore_height'):
                self.playlist_sidebar._restore_height = saved_height
            # Always hide by default - the restore function will set the correct visibility
            self.playlist_sidebar.hide()
            playlist_container_layout.addWidget(self.playlist_sidebar, 1)
            
            # Store references for resize functionality
            self.playlist_container = playlist_container
            self.playlist_resize_handle = resize_handle
            self.playlist_start_resize_y = None
            self.playlist_start_height = None
            
            # Setup resize handle mouse events
            def resize_handle_mouse_press(event):
                # Don't allow resizing when playlist is minimized
                if self.playlist_sidebar.is_minimized:
                    return
                # Don't allow resizing in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    return
                # Don't allow resizing if playlist is detached (detached playlist has its own resize handle)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    return
                if event.button() == Qt.MouseButton.LeftButton:
                    self.playlist_start_resize_y = event.globalPosition().y()
                    self.playlist_start_height = self.playlist_sidebar.height()
            
            def resize_handle_mouse_move(event):
                # Don't allow resizing when playlist is minimized
                if self.playlist_sidebar.is_minimized:
                    return
                # Don't allow resizing in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    return
                # Don't allow resizing if playlist is detached (detached playlist has its own resize handle)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    return
                if self.playlist_start_resize_y is not None and event.buttons() & Qt.MouseButton.LeftButton:
                    delta_y = self.playlist_start_resize_y - event.globalPosition().y()  # Inverted: drag up = increase height
                    new_height = self.playlist_start_height + delta_y
                    # Clamp between minimum and maximum and convert to int
                    new_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, new_height)))
                    self.playlist_sidebar.setFixedHeight(new_height)
                    # Ensure playlist stays above loading overlay during resize
                    if hasattr(self, 'playlist_container') and self.playlist_container:
                        self.playlist_container.raise_()
            
            def resize_handle_mouse_release(event):
                # Don't save height if in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    self.playlist_start_resize_y = None
                    self.playlist_start_height = None
                    return
                # Don't save height if playlist is detached (detached playlist handles its own saving)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    self.playlist_start_resize_y = None
                    self.playlist_start_height = None
                    return
                
                # Store the new height for restore after minimize (only in regular mode)
                if self.playlist_sidebar:
                    new_height = self.playlist_sidebar.height()
                    self.playlist_sidebar._restore_height = new_height
                    # Save playlist height to settings (only in regular mode)
                    self.settings['playlist_height'] = new_height
                    # Also save to playlist_height_regular for regular mode
                    self.settings['playlist_height_regular'] = new_height
                    # CRITICAL: keep attached height in sync so detach/reattach + mode cycling restores correctly
                    self.settings['playlist_attached_height'] = new_height
                    self.save_settings()
                
                self.playlist_start_resize_y = None
                self.playlist_start_height = None
                
                # After drag ends, check if mouse is outside address bar and hide if autohide is enabled
                if self.autohide_address_bar and hasattr(self, 'controls_bar_widget'):
                    # Use a small delay to allow mouse position to settle
                    QTimer.singleShot(50, self.check_and_hide_address_bar_after_drag)
            
            resize_handle.mousePressEvent = resize_handle_mouse_press
            resize_handle.mouseMoveEvent = resize_handle_mouse_move
            resize_handle.mouseReleaseEvent = resize_handle_mouse_release
            
            # Add container to layout, aligned to bottom
            layout.addWidget(playlist_container, 0, Qt.AlignmentFlag.AlignBottom)  # Align to bottom
            # Ensure playlist is above loading overlay (higher z-order)
            playlist_container.raise_()
            
            # Force layout update after adding new widget to ensure it's properly positioned
            layout.update()
            layout.activate()
            QApplication.processEvents()
            
            # If playlist was just created and we need to restore state, do it now
            if hasattr(self, '_restore_playlist_state_pending') and self._restore_playlist_state_pending:
                # Check if this is a user-initiated toggle (button is checked = user wants it visible)
                # If button is checked, user just clicked to show it, so don't restore hidden state
                user_wants_visible = hasattr(self, 'playlist_btn') and self.playlist_btn.isChecked()
                
                if not user_wants_visible:
                    # Not a user click, or user wants it hidden - restore saved state
                    self._restore_playlist_state()
                else:
                    # User clicked to show it - show it and update button state
                    self.playlist_sidebar.setVisible(True)
                    if hasattr(self, 'playlist_resize_handle'):
                        handle = self.playlist_resize_handle
                        handle.setVisible(True)
                        handle.setFixedHeight(4)  # Restore height when shown
                    # Restore other state (height, minimized) but keep visible
                    playlist_minimized = self.settings.get("playlist_minimized", True)  # Default to minimized
                    playlist_height = self.settings.get("playlist_height", 250)
                    playlist_height = int(max(100, min(600, playlist_height)))
                    self.playlist_sidebar.setFixedHeight(playlist_height)
                    if hasattr(self.playlist_sidebar, '_restore_height'):
                        self.playlist_sidebar._restore_height = playlist_height
                    if playlist_minimized != self.playlist_sidebar.is_minimized:
                        self.playlist_sidebar._toggle_minimize_state()
                    # Update button state and icon color
                    if hasattr(self, 'playlist_btn'):
                        self.playlist_btn.setChecked(True)
                        self._update_playlist_button_icon(True)
                    if hasattr(self, 'show_playlist_action'):
                        self.show_playlist_action.setChecked(True)
                    # Update settings
                    self.settings['playlist_visible'] = True
                    self.save_settings()
                
                self._restore_playlist_state_pending = False
                return  # Don't continue with normal toggle logic
        
        visible = self.playlist_sidebar.isVisible()
        new_visible = not visible
        self.playlist_sidebar.setVisible(new_visible)
        # Show/hide resize handle when playlist is shown/hidden
        if hasattr(self, 'playlist_resize_handle'):
            handle = self.playlist_resize_handle
            handle.setVisible(new_visible)
            # Set height to 0 when hidden to prevent taking up space
            if new_visible:
                handle.setFixedHeight(4)
            else:
                handle.setFixedHeight(0)
        # Ensure playlist is above loading overlay (higher z-order) when shown
        if new_visible and hasattr(self, 'playlist_container') and self.playlist_container:
            self.playlist_container.raise_()
        
        # If playlist was just shown, force layout update before resizing
        # This ensures the playlist is properly positioned in the layout before we measure/resize
        # This is especially important on first open when playlist is lazy-loaded
        if new_visible:
            # Force layout update to ensure playlist is properly positioned
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.updateGeometry()
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                self.playlist_sidebar.updateGeometry()
            layout = self.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            QApplication.processEvents()
        
        # Update loading overlay geometry only if it should be visible (is loading)
        if self.loading_overlay:
            if self.is_loading and self.loading_overlay.isVisible():
                self.update_loading_overlay_geometry()
            elif not self.is_loading:
                # Ensure overlay is hidden when not loading and reset geometry
                if self.loading_overlay.isVisible():
                    self.loading_overlay.hide()
                    self.loading_overlay.setVisible(False)
                # Always reset geometry when not loading to prevent taking up space
                self.loading_overlay.setGeometry(0, 0, 0, 0)
        # Update button state and icon color
        if hasattr(self, 'playlist_btn'):
            self.playlist_btn.setChecked(new_visible)
            self._update_playlist_button_icon(new_visible)
        if hasattr(self, 'show_playlist_action'):
            self.show_playlist_action.setChecked(new_visible)
        
        # Save playlist state to settings
        self.settings['playlist_visible'] = new_visible
        if hasattr(self.playlist_sidebar, 'is_minimized'):
            self.settings['playlist_minimized'] = self.playlist_sidebar.is_minimized
            # Keep attached-specific minimized state in sync (only when attached)
            try:
                if not self.playlist_detached:
                    self.settings['playlist_attached_minimized'] = self.playlist_sidebar.is_minimized
            except Exception:
                pass
        # Don't save playlist height in mini or micro mode - it has fixed heights
        if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
            # In mini/micro mode, don't save height changes - use fixed heights
            self.save_settings()

        # Keep quick button in sync with playlist visibility
        try:
            self.update_playlist_quick_btn_visibility()
        except Exception:
            pass
        else:
            # Only save height in regular mode or detached mode
            if hasattr(self.playlist_sidebar, '_restore_height'):
                self.settings['playlist_height'] = self.playlist_sidebar._restore_height
            elif self.playlist_sidebar:
                self.settings['playlist_height'] = self.playlist_sidebar.height()
            self.save_settings()
        
        # If in mini mode, resize to account for playlist visibility change
        if self.mini_mode_state == 1:
            QTimer.singleShot(100, self.resize_to_mini_mode)
        
        # If in micro mode, resize immediately to account for playlist visibility change
        # Force layout update first to ensure accurate measurements
        if self.mini_mode_state == 2:
            # Force layout update to ensure visibility changes are fully applied
            if hasattr(self, 'playlist_container') and self.playlist_container:
                self.playlist_container.updateGeometry()
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                self.playlist_sidebar.updateGeometry()
            # Force the main layout to recalculate
            layout = self.centralWidget().layout()
            if layout:
                layout.update()
                layout.activate()
            # Process events to ensure all updates are applied
            QApplication.processEvents()
            # Use a small delay to allow layout to fully settle, then resize
            # This ensures accurate measurements on first toggle
            QTimer.singleShot(50, self._resize_to_micro_mode_with_retry)
    
    def _toggle_detach_playlist(self):
        """Toggle between attached and detached playlist window."""
        if self.playlist_detached:
            self._reattach_playlist()
        else:
            self._detach_playlist()
    
    def _detach_playlist(self):
        """Detach playlist to separate window."""
        if not self.playlist_sidebar:
            return
        # If already detached and window exists, don't recreate (unless window doesn't exist)
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            # Window already exists, just ensure it's shown
            self.detached_playlist_window.show()
            self.detached_playlist_window.raise_()
            # Update overlay when window is shown (in case mode changed while hidden)
            if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                repeat_mode = getattr(self.playlist_sidebar, 'repeat_mode', 0)
                if hasattr(self, '_update_detached_repeat_overlay'):
                    QTimer.singleShot(100, lambda: self._update_detached_repeat_overlay(repeat_mode))
            return
        
        # Ensure playlist is visible before detaching
        if not self.playlist_sidebar.isVisible():
            self.playlist_sidebar.setVisible(True)
            if hasattr(self, 'playlist_resize_handle'):
                self.playlist_resize_handle.setVisible(True)

        # Snapshot the ATTACHED regular-mode expanded playlist height BEFORE reparenting.
        # Once we move the widget into the detached window, Qt will re-layout it and the height can change
        # (often to a smaller default like ~230), which would clobber the user's custom attached height.
        try:
            if getattr(self, 'mini_mode_state', 0) == 0 and not getattr(self, 'playlist_detached', False):
                if hasattr(self.playlist_sidebar, 'is_minimized') and self.playlist_sidebar.is_minimized:
                    # If minimized, don't overwrite attached height  keep the last expanded value.
                    pass
                else:
                    candidate = int(self.playlist_sidebar.height())
                    if candidate and candidate != 135:
                        candidate = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, candidate)))
                        self.settings['playlist_attached_height'] = candidate
                        # Keep regular-mode keys in sync so all restoration paths agree
                        self.settings['playlist_height_regular'] = candidate
                        self.settings['playlist_height'] = candidate
                        self.save_settings()
        except Exception:
            pass

        # Remember attached minimized state before detaching (detached will always show expanded content)
        try:
            if hasattr(self.playlist_sidebar, 'is_minimized'):
                attached_minimized = bool(self.playlist_sidebar.is_minimized)
                self.settings['playlist_attached_minimized'] = attached_minimized
                # Keep legacy key in sync while attached so attached startup restores correctly
                self.settings['playlist_minimized'] = attached_minimized
                self.save_settings()
        except Exception:
            pass
        
        # Expand playlist if minimized (auto-expand when detaching)
        if hasattr(self.playlist_sidebar, 'is_minimized') and self.playlist_sidebar.is_minimized:
            self.playlist_sidebar._toggle_minimize_state()
        
        # Hide playlist title bar when detached (buttons moved to window title bar)
        if hasattr(self.playlist_sidebar, 'title_bar_widget'):
            self.playlist_sidebar.title_bar_widget.hide()
        
        # Hide minimize button when detached
        if hasattr(self.playlist_sidebar, 'minimize_btn'):
            self.playlist_sidebar.minimize_btn.hide()
        
        # Hide close button when detached (detached window has its own close button)
        if hasattr(self.playlist_sidebar, 'close_btn'):
            self.playlist_sidebar.close_btn.hide()
        
        # Remove size constraints from playlist sidebar to allow window resizing
        if self.playlist_sidebar:
            # Remove fixed width constraint
            self.playlist_sidebar.setMaximumWidth(16777215)  # Qt's maximum
            # Ensure playlist can expand horizontally
            self.playlist_sidebar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        # Create detached window
        self._create_detached_playlist_window()
        
        # Initialize window linking if enabled (with a small delay to ensure window is positioned)
        if self.playlist_window_linked:
            # Use a small delay to ensure the detached window is fully created and positioned
            def init_linking_after_window_ready():
                if hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
                    self._initialize_playlist_window_linking()
            QTimer.singleShot(50, init_linking_after_window_ready)
        
        # Move playlist sidebar to detached window
        layout = self.detached_playlist_window.layout()
        self.playlist_sidebar.setParent(self.detached_playlist_window)
        layout.addWidget(self.playlist_sidebar)
        
        # Make playlist expand to fill detached window
        self.playlist_sidebar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        # NOTE: We intentionally do not save attached height here anymore (after reparenting),
        # because the detach layout can change the widget's height and would overwrite the user's
        # custom attached regular-mode height.
        
        # Remove fixed height constraints - clear any fixed height that might have been set
        # On Windows 10, we need to be careful with size constraints to avoid negative size errors
        # Don't use setFixedHeight(-1) as it can cause Qt to interpret sizes incorrectly
        # Instead, just set min/max and let size policy handle expansion
        # First ensure we have a valid size before changing constraints
        if self.playlist_sidebar.height() <= 0:
            self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
        
        self.playlist_sidebar.setMaximumHeight(16777215)  # Qt's maximum value
        # Use a small positive minimum instead of 0 to avoid Qt's negative size detection on Windows 10
        self.playlist_sidebar.setMinimumHeight(1)  # Minimum of 1px instead of 0 to avoid negative size errors
        
        # Force layout update to ensure playlist fills the window immediately
        layout.update()
        layout.activate()
        self.playlist_sidebar.updateGeometry()
        QApplication.processEvents()
        
        # Trigger a resize to force layout recalculation (fixes initial sizing issue on Windows 10)
        def force_layout_update():
            if hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
                current_size = self.detached_playlist_window.size()
                # Trigger resize by setting size to itself (forces layout recalculation)
                self.detached_playlist_window.resize(current_size.width(), current_size.height() + 1)
                QApplication.processEvents()
                self.detached_playlist_window.resize(current_size.width(), current_size.height())
        QTimer.singleShot(10, force_layout_update)
        
        # Create resize handle if it doesn't exist yet (it will be created after window is shown)
        # But if it exists, ensure it's on top after playlist is added
        if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
            QTimer.singleShot(50, lambda: (
                self._update_detached_bottom_resize_handle_position() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None,
                self.detached_bottom_resize_handle.raise_() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None
            ))
        
        # Hide playlist container in main window
        if hasattr(self, 'playlist_container'):
            self.playlist_container.hide()
        if hasattr(self, 'playlist_resize_handle'):
            self.playlist_resize_handle.hide()
        
        # Update detach button icon to "attach" icon
        if hasattr(self.playlist_sidebar, 'detach_btn') and self.playlist_sidebar.detach_btn:
            if HAS_QT_AWESOME:
                # Try multiple icon options for attach
                icon = None
                for icon_name in ['fa5s.window-maximize', 'fa5.window-maximize', 'ei.arrow-down', 'fa5s.compress']:
                    try:
                        icon = get_icon(icon_name, color='#e0e0e0')
                        if icon:
                            break
                    except:
                        continue
                if icon:
                    self.playlist_sidebar.detach_btn.setIcon(icon)
                else:
                    self.playlist_sidebar.detach_btn.setText("")
            else:
                self.playlist_sidebar.detach_btn.setText("")
            self.playlist_sidebar.detach_btn.setToolTip("Attach Playlist to Main Window")
        
        # Update state
        self.playlist_detached = True

        # Hide playlist quick button when detached
        try:
            self.update_playlist_quick_btn_visibility()
        except Exception:
            pass
        
        # Resize modes as if playlist is closed
        if self.mini_mode_state == 1:
            QTimer.singleShot(100, self.resize_to_mini_mode)
        elif self.mini_mode_state == 2:
            QTimer.singleShot(50, self._resize_to_micro_mode_with_retry)
        
        # Save settings
        self._save_playlist_detach_state()
    
    def _update_detached_repeat_overlay(self, repeat_mode):
        """Update overlay on detached playlist repeat button based on mode:
        - Mode 3 (Track): "1" overlay (white)
        - Other modes: no overlay
        """
        if not hasattr(self, '_detached_repeat_btn') or not self._detached_repeat_btn:
            return
        
        # Remove existing overlay if it exists
        if hasattr(self, '_detached_repeat_overlay_label') and self._detached_repeat_overlay_label is not None:
            try:
                self._detached_repeat_overlay_label.deleteLater()
            except (AttributeError, RuntimeError):
                pass  # Label might already be deleted
            self._detached_repeat_overlay_label = None
        
        # Show overlay only for mode 3 ("1")
        if repeat_mode == 3:
            # Create overlay label
            from PyQt6.QtWidgets import QLabel
            from PyQt6.QtCore import Qt
            
            # Set overlay text to "1" for mode 3
            overlay_text = "1"
            
            # Set overlay color: white for mode 3 (track)
            overlay_color = 'white'
            
            # Create overlay as child of button's parent widget to ensure it's on top
            # Get the button's parent widget (the container)
            button_parent = self._detached_repeat_btn.parent()
            if button_parent:
                self._detached_repeat_overlay_label = QLabel(overlay_text, button_parent)
            else:
                # Fallback to button itself if no parent
                self._detached_repeat_overlay_label = QLabel(overlay_text, self._detached_repeat_btn)
            
            self._detached_repeat_overlay_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            # Make overlay transparent to mouse events so clicks pass through to button
            self._detached_repeat_overlay_label.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._detached_repeat_overlay_label.setStyleSheet(f"""
                QLabel {{
                    background-color: transparent;
                    color: {overlay_color};
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                }}
            """)
            # Position will be updated when button is shown/resized
            # Use a method to update position
            def update_overlay_position():
                if hasattr(self, '_detached_repeat_overlay_label') and self._detached_repeat_overlay_label and self._detached_repeat_btn:
                    try:
                        # Get button position relative to its parent widget
                        btn_pos = self._detached_repeat_btn.pos()
                        btn_size = self._detached_repeat_btn.size()
                        overlay_size = 12  # Smaller overlay to ensure it stays within button bounds
                        # Calculate position relative to button's parent, centered on button
                        x = btn_pos.x() + (btn_size.width() - overlay_size) // 2
                        y = btn_pos.y() + (btn_size.height() - overlay_size) // 2
                        # Ensure overlay stays within button bounds
                        x = max(btn_pos.x(), min(x, btn_pos.x() + btn_size.width() - overlay_size))
                        y = max(btn_pos.y(), min(y, btn_pos.y() + btn_size.height() - overlay_size))
                        self._detached_repeat_overlay_label.setGeometry(x, y, overlay_size, overlay_size)
                        self._detached_repeat_overlay_label.show()
                        self._detached_repeat_overlay_label.raise_()
                    except (RuntimeError, AttributeError):
                        pass  # Button or overlay might have been deleted
            
            # Update position immediately and on button resize
            QTimer.singleShot(0, update_overlay_position)
            # Use multiple delays to ensure button is fully rendered and positioned
            QTimer.singleShot(50, update_overlay_position)
            QTimer.singleShot(100, update_overlay_position)
            QTimer.singleShot(200, update_overlay_position)
        else:
            # Ensure overlay is removed for other modes
            if hasattr(self, '_detached_repeat_overlay_label') and self._detached_repeat_overlay_label:
                self._detached_repeat_overlay_label.hide()
    
    def _update_detached_shuffle_button_icon(self):
        """Update the detached shuffle button icon based on current mode."""
        if not hasattr(self, '_detached_shuffle_btn') or not self._detached_shuffle_btn:
            return
        
        try:
            # Check if button is still valid
            _ = self._detached_shuffle_btn.isVisible()
        except (RuntimeError, AttributeError):
            return
        
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        try:
            shuffle_mode = getattr(self.playlist_sidebar, 'shuffle_mode', 0)
            self._detached_shuffle_btn.blockSignals(True)
            
            # Update checked state
            is_active = shuffle_mode > 0
            self._detached_shuffle_btn.setChecked(is_active)
            
            # Update icon based on mode
            if HAS_QT_AWESOME:
                if shuffle_mode == 0:
                    icon_color = '#a0a0a0'
                    icon = get_icon('random', color=icon_color)
                    tooltip = "Shuffle: Off"
                elif shuffle_mode == 1:
                    icon_color = '#4a90e2'
                    icon = get_icon('random', color=icon_color)
                    tooltip = "Shuffle: Tracks (shuffle tracks in album)"
                elif shuffle_mode == 2:
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.question', color=icon_color)
                    tooltip = "Shuffle: Albums (randomize album order)"
                else:  # mode 3
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.asl', color=icon_color)
                    tooltip = "Super Shuffle (random album & track)"
                
                if icon:
                    # Clear and set icon to force refresh
                    self._detached_shuffle_btn.setIcon(QIcon())
                    QApplication.processEvents()
                    self._detached_shuffle_btn.setIcon(icon)
                    self._detached_shuffle_btn.setToolTip(tooltip)
                    # Force update
                    self._detached_shuffle_btn.update()
                    self._detached_shuffle_btn.repaint()
                    if self._detached_shuffle_btn.parent():
                        self._detached_shuffle_btn.parent().update()
                    # Process events to ensure visual update
                    QApplication.processEvents()
            
            self._detached_shuffle_btn.blockSignals(False)
        except (RuntimeError, AttributeError):
            pass
    
    def _update_detached_repeat_button_icon(self):
        """Update the detached repeat button icon based on current mode."""
        if not hasattr(self, '_detached_repeat_btn') or not self._detached_repeat_btn:
            return
        
        try:
            # Check if button is still valid
            _ = self._detached_repeat_btn.isVisible()
        except (RuntimeError, AttributeError):
            return
        
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            return
        
        try:
            repeat_mode = getattr(self.playlist_sidebar, 'repeat_mode', 0)
            self._detached_repeat_btn.blockSignals(True)
            
            # Update checked state
            is_active = repeat_mode > 0
            self._detached_repeat_btn.setChecked(is_active)
            
            # Update icon based on mode
            if HAS_QT_AWESOME:
                if repeat_mode == 0:
                    icon_color = '#a0a0a0'
                    icon = get_icon('ei.repeat', color=icon_color)
                    tooltip = "Repeat: Off"
                elif repeat_mode == 1:
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.repeat', color=icon_color)
                    tooltip = "Repeat: Continuous (play next album)"
                elif repeat_mode == 2:
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.heart', color=icon_color)
                    tooltip = "Repeat: Album (loop current album)"
                else:  # mode 3
                    icon_color = '#4a90e2'
                    icon = get_icon('ei.heart', color=icon_color)
                    tooltip = "Repeat: Track (loop current track)"
                
                if icon:
                    # Clear and set icon to force refresh
                    self._detached_repeat_btn.setIcon(QIcon())
                    QApplication.processEvents()
                    self._detached_repeat_btn.setIcon(icon)
                    self._detached_repeat_btn.setToolTip(tooltip)
                    # Force update
                    self._detached_repeat_btn.update()
                    self._detached_repeat_btn.repaint()
                    if self._detached_repeat_btn.parent():
                        self._detached_repeat_btn.parent().update()
                    # Process events to ensure visual update
                    QApplication.processEvents()
            
            self._detached_repeat_btn.blockSignals(False)
            
            # Update overlay
            if hasattr(self, '_update_detached_repeat_overlay'):
                QTimer.singleShot(0, lambda: self._update_detached_repeat_overlay(repeat_mode))
        except (RuntimeError, AttributeError):
            pass
    
    def _reattach_playlist(self):
        """Reattach playlist to main window."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return
        
        # Save detached window position and size before closing
        try:
            pos = self.detached_playlist_window.pos()
            size = self.detached_playlist_window.size()
            # Save absolute position
            self.playlist_detached_position = (pos.x(), pos.y())
            # Also save relative offset for backward compatibility
            main_pos = self.pos()
            self.playlist_detached_offset = (pos.x() - main_pos.x(), pos.y() - main_pos.y())
            self.playlist_detached_size = f"{size.width()}x{size.height()}"
        except Exception as e:
            logger.debug(f"Error saving detached playlist position: {e}")
        
        # Ensure playlist container and resize handle exist (they might not if playlist started detached)
        if not hasattr(self, 'playlist_container') or not self.playlist_container:
            # Create container and resize handle if they don't exist
            layout = self.centralWidget().layout()
            
            # Create container widget for playlist and resize handle
            playlist_container = QWidget()
            playlist_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
            playlist_container.setMinimumHeight(0)
            playlist_container_layout = QVBoxLayout(playlist_container)
            playlist_container_layout.setContentsMargins(0, 0, 0, 0)
            playlist_container_layout.setSpacing(0)
            
            # Resize handle (horizontal bar at top of playlist)
            resize_handle = QWidget()
            resize_handle.setFixedHeight(0)  # Start with 0 height since it's hidden
            resize_handle.setStyleSheet("""
                QWidget {
                    background-color: transparent;
                }
                QWidget:hover {
                    background-color: transparent;
                }
            """)
            resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)  # Vertical resize cursor
            resize_handle.hide()  # Hidden by default, shown when playlist is visible
            resize_handle.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
            playlist_container_layout.addWidget(resize_handle)
            
            # Store references
            self.playlist_container = playlist_container
            self.playlist_resize_handle = resize_handle
            self.playlist_start_resize_y = None
            self.playlist_start_height = None
            
            # Setup resize handle mouse events
            def resize_handle_mouse_press(event):
                # Don't allow resizing when playlist is minimized
                if self.playlist_sidebar.is_minimized:
                    return
                # Don't allow resizing in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    return
                # Don't allow resizing if playlist is detached (detached playlist has its own resize handle)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    return
                if event.button() == Qt.MouseButton.LeftButton:
                    self.playlist_start_resize_y = event.globalPosition().y()
                    self.playlist_start_height = self.playlist_sidebar.height()
            
            def resize_handle_mouse_move(event):
                # Don't allow resizing when playlist is minimized
                if self.playlist_sidebar.is_minimized:
                    return
                # Don't allow resizing in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    return
                # Don't allow resizing if playlist is detached (detached playlist has its own resize handle)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    return
                if self.playlist_start_resize_y is not None and event.buttons() & Qt.MouseButton.LeftButton:
                    delta_y = self.playlist_start_resize_y - event.globalPosition().y()  # Inverted: drag up = increase height
                    new_height = self.playlist_start_height + delta_y
                    # Clamp between minimum and maximum and convert to int
                    new_height = int(max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, new_height)))
                    self.playlist_sidebar.setFixedHeight(new_height)
                    # Ensure playlist stays above loading overlay during resize
                    if hasattr(self, 'playlist_container') and self.playlist_container:
                        self.playlist_container.raise_()
            
            def resize_handle_mouse_release(event):
                # Don't save height if in mini or micro mode - playlist has fixed height
                if hasattr(self, 'mini_mode_state') and self.mini_mode_state in (1, 2):
                    self.playlist_start_resize_y = None
                    self.playlist_start_height = None
                    return
                # Don't save height if playlist is detached (detached playlist handles its own saving)
                if hasattr(self, 'playlist_detached') and self.playlist_detached:
                    self.playlist_start_resize_y = None
                    self.playlist_start_height = None
                    return
                
                # Store the new height for restore after minimize (only in regular mode)
                if self.playlist_sidebar:
                    new_height = self.playlist_sidebar.height()
                    self.playlist_sidebar._restore_height = new_height
                    # Save playlist height to settings (only in regular mode)
                    self.settings['playlist_height'] = new_height
                    # Also save to playlist_height_regular for regular mode
                    self.settings['playlist_height_regular'] = new_height
                    # CRITICAL: keep attached height in sync so detach/reattach + mode cycling restores correctly
                    self.settings['playlist_attached_height'] = new_height
                    self.save_settings()
                
                self.playlist_start_resize_y = None
                self.playlist_start_height = None
                
                # After drag ends, check if mouse is outside address bar and hide if autohide is enabled
                if self.autohide_address_bar and hasattr(self, 'controls_bar_widget'):
                    # Use a small delay to allow mouse position to settle
                    QTimer.singleShot(50, self.check_and_hide_address_bar_after_drag)
            
            resize_handle.mousePressEvent = resize_handle_mouse_press
            resize_handle.mouseMoveEvent = resize_handle_mouse_move
            resize_handle.mouseReleaseEvent = resize_handle_mouse_release
            
            # Add container to layout, aligned to bottom
            layout.addWidget(playlist_container, 0, Qt.AlignmentFlag.AlignBottom)
            playlist_container.raise_()
            layout.update()
            layout.activate()
        
        # Move playlist sidebar back to main window
        if self.playlist_sidebar:
            layout = self.detached_playlist_window.layout()
            layout.removeWidget(self.playlist_sidebar)
            
            # Add back to main window container
            if hasattr(self, 'playlist_container'):
                playlist_container_layout = self.playlist_container.layout()
                if playlist_container_layout:
                    # Remove any existing widget from the container (shouldn't be any, but just in case)
                    for i in range(playlist_container_layout.count()):
                        item = playlist_container_layout.itemAt(i)
                        if item and item.widget() == self.playlist_sidebar:
                            playlist_container_layout.removeWidget(self.playlist_sidebar)
                    
                    # Add playlist back to container
                    self.playlist_sidebar.setParent(self.playlist_container)
                    playlist_container_layout.addWidget(self.playlist_sidebar, 1)
                    
                    # Show container and resize handle
                    self.playlist_container.show()
                    if hasattr(self, 'playlist_resize_handle'):
                        if self.playlist_sidebar.isVisible():
                            self.playlist_resize_handle.show()
                            self.playlist_resize_handle.setFixedHeight(4)  # Restore height when shown
        
        # Restore playlist title bar visibility
        if hasattr(self.playlist_sidebar, 'title_bar_widget'):
            self.playlist_sidebar.title_bar_widget.show()
        
        # Restore minimize button visibility
        if hasattr(self.playlist_sidebar, 'minimize_btn'):
            self.playlist_sidebar.minimize_btn.show()
        
        # Restore close button visibility
        if hasattr(self.playlist_sidebar, 'close_btn'):
            self.playlist_sidebar.close_btn.show()
        
        # Restore playlist sidebar width constraint
        if self.playlist_sidebar:
            self.playlist_sidebar.setMaximumWidth(260)  # Restore original constraint
        
        # Restore size policy and height constraints
        self.playlist_sidebar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)

        # Restore attached minimized state exactly as it was before detaching
        try:
            desired_minimized = bool(self.settings.get('playlist_attached_minimized', self.settings.get('playlist_minimized', False)))
            if hasattr(self.playlist_sidebar, 'is_minimized'):
                current_minimized = bool(self.playlist_sidebar.is_minimized)
                if desired_minimized != current_minimized:
                    self.playlist_sidebar._toggle_minimize_state()
        except Exception:
            pass
        
        # Restore attached playlist height from settings (independent from detached window size)
        attached_height = self.settings.get('playlist_attached_height')
        if attached_height:
            # Restore the saved attached playlist height
            restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, attached_height))
            self.playlist_sidebar._restore_height = restore_height
            # Apply height deterministically after reparenting.
            # IMPORTANT: right after reparenting, Qt may report isVisible()==False briefly, so don't gate on it.
            try:
                if not self.playlist_sidebar.is_minimized:
                    self.playlist_sidebar.setFixedHeight(restore_height)
            except Exception:
                pass
            # Re-apply on the next event loop tick so the layout has settled (prevents snapping to ~230px)
            def _enforce_attached_height():
                try:
                    if not self.playlist_detached and self.playlist_sidebar and not self.playlist_sidebar.is_minimized:
                        self.playlist_sidebar.setFixedHeight(restore_height)
                        self.playlist_sidebar._restore_height = restore_height
                        # Ensure container isn't artificially constraining height
                        if hasattr(self, 'playlist_container') and self.playlist_container:
                            self.playlist_container.setMaximumHeight(16777215)
                            self.playlist_container.setMinimumHeight(0)
                            self.playlist_container.updateGeometry()
                        layout = self.centralWidget().layout() if self.centralWidget() else None
                        if layout:
                            layout.update()
                            layout.activate()
                except Exception:
                    pass
            QTimer.singleShot(0, _enforce_attached_height)
        else:
            # No saved attached height, use default or current settings
            playlist_height = self.settings.get('playlist_height', PLAYLIST_DEFAULT_HEIGHT)
            if playlist_height == 135:  # Don't use micro mode height
                playlist_height = self.settings.get('playlist_height_regular', PLAYLIST_DEFAULT_HEIGHT)
            restore_height = max(PLAYLIST_MIN_HEIGHT, min(PLAYLIST_MAX_HEIGHT, playlist_height))
            self.playlist_sidebar._restore_height = restore_height
            try:
                if not self.playlist_sidebar.is_minimized:
                    self.playlist_sidebar.setFixedHeight(restore_height)
            except Exception:
                pass
            QTimer.singleShot(0, lambda: (
                self.playlist_sidebar.setFixedHeight(restore_height)
                if (not self.playlist_detached and self.playlist_sidebar and not self.playlist_sidebar.is_minimized)
                else None
            ))
        
        # Restore reasonable max height
        self.playlist_sidebar.setMaximumHeight(PLAYLIST_MAX_HEIGHT)
        self.playlist_sidebar.setMinimumHeight(PLAYLIST_MIN_HEIGHT)
        
        # Restore layout margins (remove bottom margin for resize handle)
        if hasattr(self, 'playlist_container') and self.playlist_container:
            playlist_container_layout = self.playlist_container.layout()
            if playlist_container_layout:
                playlist_container_layout.setContentsMargins(0, 0, 0, 0)
        
        # Update detach button icon back to "detach" icon
        if hasattr(self.playlist_sidebar, 'detach_btn') and self.playlist_sidebar.detach_btn:
            if HAS_QT_AWESOME:
                # Try multiple icon options for detach
                icon = None
                for icon_name in ['fa5s.external-link-alt', 'fa5.external-link', 'ei.external-link', 'fa5s.window-restore']:
                    try:
                        icon = get_icon(icon_name, color='#e0e0e0')
                        if icon:
                            break
                    except:
                        continue
                if icon:
                    self.playlist_sidebar.detach_btn.setIcon(icon)
                else:
                    self.playlist_sidebar.detach_btn.setText("")
            else:
                self.playlist_sidebar.detach_btn.setText("")
            self.playlist_sidebar.detach_btn.setToolTip("Detach Playlist to Separate Window")
        
        # Close detached window
        if hasattr(self, 'detached_playlist_title_bar'):
            self.detached_playlist_title_bar = None
        if hasattr(self, 'detached_bottom_resize_handle'):
            if self.detached_bottom_resize_handle:
                self.detached_bottom_resize_handle.deleteLater()
            self.detached_bottom_resize_handle = None
        if hasattr(self, 'detached_resize_start_y'):
            self.detached_resize_start_y = None
        if hasattr(self, 'detached_resize_start_height'):
            self.detached_resize_start_height = None
        if hasattr(self, 'detached_resize_start_x'):
            self.detached_resize_start_x = None
        if hasattr(self, 'detached_resize_start_width'):
            self.detached_resize_start_width = None
        if hasattr(self, 'detached_resize_start_pos'):
            self.detached_resize_start_pos = None
        self.detached_playlist_window.close()
        self.detached_playlist_window = None
        
        # Update state
        self.playlist_detached = False

        # Re-evaluate playlist quick button after reattach
        try:
            self.update_playlist_quick_btn_visibility()
        except Exception:
            pass
    
    def _enter_nano_mode(self):
        """Enter nano mode: hide main window and detached playlist, show nano player."""
        if self._main_window_hidden_for_nano:
            return  # Already in nano mode
        
        # Ensure playlist is created before entering nano mode (needed for shuffle/repeat button sync)
        playlist_was_closed = False
        if not hasattr(self, 'playlist_sidebar') or not self.playlist_sidebar:
            # Playlist doesn't exist - create it to initialize shuffle/repeat states
            # This is needed so nano player can sync buttons correctly
            playlist_was_closed = True  # Assume it was closed since it doesn't exist
            self.toggle_playlist()  # Create playlist
            # Small delay to ensure playlist is fully initialized
            QApplication.processEvents()
            # Hide it again if it was supposed to be closed
            if playlist_was_closed:
                self.toggle_playlist()  # Hide playlist
                QApplication.processEvents()
        
        # Save playlist visibility state before hiding main window
        # This ensures we can restore it correctly when closing in nano mode
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar and not self.playlist_detached:
            self.settings['playlist_visible'] = self.playlist_sidebar.isVisible()
            if hasattr(self.playlist_sidebar, 'is_minimized'):
                self.settings['playlist_minimized'] = self.playlist_sidebar.is_minimized
                self.settings['playlist_attached_minimized'] = self.playlist_sidebar.is_minimized
            self.save_settings()
        
        self._main_window_hidden_for_nano = True
        
        # Hide main window (not minimize - actually hide it)
        self.hide()
        
        # Hide detached playlist window if it exists
        if (self.playlist_detached and 
            hasattr(self, 'detached_playlist_window') and 
            self.detached_playlist_window):
            self.detached_playlist_window.hide()
        
        # Create and show nano player window
        if not self.nano_player_window:
            self._create_nano_player_window()
        
        if self.nano_player_window:
            self.nano_player_window.show()
            self.nano_player_window.raise_()
            self.nano_player_window.activateWindow()
            # Sync shuffle/repeat buttons after nano player is shown
            # Small delay to ensure playlist_sidebar is fully initialized
            QTimer.singleShot(100, self.nano_player_window._sync_shuffle_repeat_buttons)
            # Note: One-time resize trick is now handled in showEvent() with longer delay
    
    def _exit_nano_mode(self):
        """Exit nano mode: show main window and detached playlist, hide nano player."""
        logger.debug(f"_exit_nano_mode called: _main_window_hidden_for_nano={self._main_window_hidden_for_nano}, _first_restore_from_nano={getattr(self, '_first_restore_from_nano', 'NOT SET')}")
        
        if not self._main_window_hidden_for_nano:
            logger.debug("_exit_nano_mode: Not in nano mode, returning early")
            return  # Not in nano mode
        
        self._main_window_hidden_for_nano = False
        
        # Force hide nano player window immediately and aggressively
        if self.nano_player_window:
            try:
                # Save position before hiding (hideEvent will also save, but save here too for safety)
                if hasattr(self.nano_player_window, '_save_nano_position'):
                    self.nano_player_window._save_nano_position()
                self.nano_player_window.hide()
                self.nano_player_window.setVisible(False)
                # Process events to ensure hide takes effect
                QApplication.processEvents()
            except Exception as e:
                logger.debug(f"Error hiding nano player: {e}")
        
        # Check if this is the first restore from nano after startup
        # If so, do a quick minimize/restore cycle to force proper initialization
        if hasattr(self, '_first_restore_from_nano') and self._first_restore_from_nano:
            logger.debug("First restore from nano - performing quick sync cycle")
            self._first_restore_from_nano = False  # Clear flag so it only happens once
            
            # Show main window first
            self.show()
            self.raise_()
            self.activateWindow()
            QApplication.processEvents()
            
            # Set flag to prevent nano mode from activating during quick sync
            self._doing_quick_sync = True
            
            # Do a quick minimize/restore cycle to force proper sync
            def quick_sync_cycle():
                logger.debug("Quick sync: minimizing")
                # Minimize
                self.showMinimized()
                QApplication.processEvents()
                # Immediately restore
                def restore_after_minimize():
                    logger.debug("Quick sync: restoring")
                    self._doing_quick_sync = False  # Clear flag before restore
                    self._restore_after_quick_sync()
                QTimer.singleShot(100, restore_after_minimize)
            
            QTimer.singleShot(200, quick_sync_cycle)
            return  # Exit early - _restore_after_quick_sync will handle the rest
        
        # Normal restore (not first time)
        # Show main window (restore from hidden/minimized state)
        # Always use showNormal() to ensure it's properly restored regardless of state
        self.showNormal()
        self.raise_()
        self.activateWindow()
        
        # Process events to ensure window is shown
        QApplication.processEvents()
        
        # Double-check window is actually visible (not minimized)
        if self.isMinimized():
            logger.debug("Window still minimized after showNormal(), forcing restore")
            self.showNormal()
            QApplication.processEvents()
        
        # Show detached playlist window immediately if it was detached
        # This must happen before reinitialize to ensure it's visible
        if self.playlist_detached:
            # Check if detached window exists, if not, create it
            if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
                # Detached window doesn't exist - create it now
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    try:
                        self._detach_playlist()
                    except Exception as e:
                        logger.debug(f"Error creating detached playlist on nano exit: {e}")
            
            # Now show it if it exists
            if (hasattr(self, 'detached_playlist_window') and 
                self.detached_playlist_window):
                try:
                    # Ensure it's not minimized (unless main window is minimized)
                    if not self.isMinimized():
                        if self.detached_playlist_window.isMinimized():
                            self.detached_playlist_window.showNormal()
                        self.detached_playlist_window.show()
                        self.detached_playlist_window.raise_()
                        # Process events to ensure show takes effect
                        QApplication.processEvents()
                except Exception as e:
                    logger.debug(f"Error showing detached playlist: {e}")
        
        # Reinitialize things that might not have completed if window was hidden too early
        # This is especially important when starting in nano mode
        def reinitialize_after_nano():
            # Double-check nano player is hidden
            if self.nano_player_window and self.nano_player_window.isVisible():
                self.nano_player_window.hide()
                self.nano_player_window.setVisible(False)
            
            # Ensure window is visible and processed
            if not self.isVisible():
                self.show()
            QApplication.processEvents()
            
            # Re-apply mini/micro mode CSS and resizing if needed
            if self.mini_mode_state != 0 and self.web_view and self.web_view.page():
                # Re-inject CSS to ensure it's applied (critical for mini mode player visibility)
                self.inject_css()
                # Force re-injection of JavaScript for image viewer and mini mode
                if self.web_view.page():
                    # Re-inject all JavaScript that might have been missed
                    js_code = self._get_cover_art_modal_js() + self._get_mini_mode_class_js()
                    self.web_view.page().runJavaScript(js_code)
                # Re-apply mini mode settings
                if self.mini_mode_state == 1:
                    QTimer.singleShot(200, self.resize_to_mini_mode)
                elif self.mini_mode_state == 2:
                    QTimer.singleShot(200, self.resize_to_micro_mode)
            
            # Ensure playlist state is properly restored
            if hasattr(self, '_restore_playlist_state_pending') and self._restore_playlist_state_pending:
                if self.playlist_sidebar:
                    self._restore_playlist_state()
                self._restore_playlist_state_pending = False
            
            # Ensure detached playlist is properly synced and visible
            if (self.playlist_detached and 
                hasattr(self, 'detached_playlist_window') and 
                self.detached_playlist_window):
                # Re-sync window state
                if self.isMinimized() and not self.detached_playlist_window.isMinimized():
                    self.detached_playlist_window.showMinimized()
                elif not self.isMinimized() and self.detached_playlist_window.isMinimized():
                    self.detached_playlist_window.showNormal()
                # Ensure it's visible
                if not self.detached_playlist_window.isVisible():
                    self.detached_playlist_window.show()
                self.detached_playlist_window.raise_()
                # Re-sync minimize state flag
                if self.isMinimized():
                    self._detached_playlist_minimized_by_main = True
                else:
                    self._detached_playlist_minimized_by_main = False
        
        # Reinitialize after a short delay to ensure window is fully shown
        QTimer.singleShot(200, reinitialize_after_nano)
    
    def _restore_after_quick_sync(self):
        """Restore main window after quick minimize/restore cycle (first restore from nano workaround)."""
        # Ensure we're not in nano mode anymore
        self._main_window_hidden_for_nano = False
        
        # Restore main window
        self.showNormal()
        self.raise_()
        self.activateWindow()
        QApplication.processEvents()
        
        # Now do the normal restore logic
        # Show detached playlist window immediately if it was detached
        if self.playlist_detached:
            # Check if detached window exists, if not, create it
            if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
                # Detached window doesn't exist - create it now
                if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                    try:
                        self._detach_playlist()
                    except Exception as e:
                        logger.debug(f"Error creating detached playlist on nano exit: {e}")
            
            # Now show it if it exists
            if (hasattr(self, 'detached_playlist_window') and 
                self.detached_playlist_window):
                try:
                    # Ensure it's not minimized (unless main window is minimized)
                    if not self.isMinimized():
                        if self.detached_playlist_window.isMinimized():
                            self.detached_playlist_window.showNormal()
                        self.detached_playlist_window.show()
                        self.detached_playlist_window.raise_()
                        # Process events to ensure show takes effect
                        QApplication.processEvents()
                except Exception as e:
                    logger.debug(f"Error showing detached playlist: {e}")
        
        # Reinitialize things that might not have completed if window was hidden too early
        def reinitialize_after_nano():
            # Double-check nano player is hidden
            if self.nano_player_window and self.nano_player_window.isVisible():
                self.nano_player_window.hide()
                self.nano_player_window.setVisible(False)
            
            # Ensure window is visible and processed
            if not self.isVisible():
                self.showNormal()  # Use showNormal to ensure proper restore
            QApplication.processEvents()
            
            # Re-apply mini/micro mode CSS and resizing if needed
            # This is critical - the quick sync cycle might have broken JavaScript injection
            # Always re-inject CSS and JavaScript after quick sync cycle (regardless of mode)
            if self.web_view and self.web_view.page():
                # Re-inject CSS to ensure it's applied (critical for mini mode player visibility)
                self.inject_css()
                # Force re-injection of JavaScript for image viewer and mini mode
                js_code = self._get_cover_art_modal_js() + self._get_mini_mode_class_js()
                self.web_view.page().runJavaScript(js_code)
                logger.debug("Re-injected CSS and JavaScript after quick sync cycle")
                
                # Re-apply mini mode settings if in mini/micro mode
                if self.mini_mode_state == 1:
                    QTimer.singleShot(200, self.resize_to_mini_mode)
                elif self.mini_mode_state == 2:
                    QTimer.singleShot(200, self.resize_to_micro_mode)
            
            # Ensure playlist state is properly restored
            if hasattr(self, '_restore_playlist_state_pending') and self._restore_playlist_state_pending:
                if self.playlist_sidebar:
                    self._restore_playlist_state()
                self._restore_playlist_state_pending = False
            
            # Ensure detached playlist is properly synced and visible
            if (self.playlist_detached and 
                hasattr(self, 'detached_playlist_window') and 
                self.detached_playlist_window):
                # Re-sync window state
                if self.isMinimized() and not self.detached_playlist_window.isMinimized():
                    self.detached_playlist_window.showMinimized()
                elif not self.isMinimized() and self.detached_playlist_window.isMinimized():
                    self.detached_playlist_window.showNormal()
                # Ensure it's visible
                if not self.detached_playlist_window.isVisible():
                    self.detached_playlist_window.show()
                self.detached_playlist_window.raise_()
                # Re-sync minimize state flag
                if self.isMinimized():
                    self._detached_playlist_minimized_by_main = True
                else:
                    self._detached_playlist_minimized_by_main = False
        
        # Reinitialize after a short delay to ensure window is fully shown
        QTimer.singleShot(200, reinitialize_after_nano)
    
    def _create_nano_player_window(self):
        """Create the nano player window."""
        if self.nano_player_window:
            return  # Already created
        
        self.nano_player_window = NanoPlayerWindow(self)
        # NOTE: We intentionally do not force-minimize on reattach in mini/micro mode anymore.
        # We restore the user's attached minimized state instead (see above).
        
        # Resize modes to account for reattached playlist
        if self.mini_mode_state == 1:
            QTimer.singleShot(100, self.resize_to_mini_mode)
        elif self.mini_mode_state == 2:
            QTimer.singleShot(50, self._resize_to_micro_mode_with_retry)
        
        # Save settings
        self._save_playlist_detach_state()
    
    def _toggle_playlist_window_linking(self, enabled):
        """Toggle linking between main window and detached playlist window."""
        self.playlist_window_linked = enabled
        # If disabling linking, also clear docked state
        if not enabled:
            self._windows_docked = False
            self._windows_docked_edge = None
        
        if enabled:
            self._initialize_playlist_window_linking()
        else:
            self._deinitialize_playlist_window_linking()
        
        # Update button state if it exists (button is read-only for visual feedback)
        if hasattr(self, '_detached_link_btn') and self._detached_link_btn:
            # Update the checked state
            self._detached_link_btn.blockSignals(True)
            self._detached_link_btn.setChecked(enabled)
            self._detached_link_btn.blockSignals(False)
            
            # Manually call update_link_icon function since signals are blocked
            # Button is now kept enabled (but clicks are blocked via event filter) so icon colors work
            if hasattr(self, '_update_link_icon_func'):
                self._update_link_icon_func(enabled)
            else:
                # Fallback: update icon directly
                if HAS_QT_AWESOME:
                    icon_color = '#4a90e2' if enabled else '#e0e0e0'
                    icon = get_icon('link', color=icon_color)
                    if icon:
                        self._detached_link_btn.setIcon(icon)
            
            # Force repaint to ensure icon change is visible
            self._detached_link_btn.repaint()
            # Update tooltip to reflect current state
            if enabled:
                self._detached_link_btn.setToolTip("Windows are linked (automatic when snapped together)")
            else:
                self._detached_link_btn.setToolTip("Windows are not linked (link automatically when snapped together)")
        
        # Save linking state to settings
        self.settings['playlist_window_linked'] = enabled
        self.save_settings()
    
    def _initialize_playlist_window_linking(self):
        """Initialize window linking - set up event handlers and calculate initial offset."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return
        
        try:
            # Calculate initial offset between windows
            main_x = self.x()
            main_y = self.y()
            detached_x = self.detached_playlist_window.x()
            detached_y = self.detached_playlist_window.y()
            
            self._playlist_window_link_offset = (detached_x - main_x, detached_y - main_y)
            
            # Store initial positions for movement detection
            self._last_main_window_pos = (main_x, main_y)
            self._last_detached_playlist_pos = (detached_x, detached_y)
        except Exception:
            pass
    
    def _deinitialize_playlist_window_linking(self):
        """Deinitialize window linking - remove event handlers."""
        # Stop any in-flight throttle timer and clear state
        try:
            if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                self._linked_move_timer.stop()
        except Exception:
            pass
        self._pending_linked_detached_pos = None
        self._link_move_idle_ticks = 0
        self._moving_detached_playlist_programmatically = False
        self._last_programmatic_detached_pos = None
    
    def _handle_main_window_movement_for_linking(self, event):
        """Handle main window movement - move detached playlist window if linked."""
        # Keep windows linked while main window is moving - only unlink if playlist window is manually moved away
        if not self.playlist_detached or not self.detached_playlist_window or not self.detached_playlist_window.isVisible():
            return
        
        try:
            # Get current main window position
            current_main_x = self.x()
            current_main_y = self.y()
            
            # Check if position actually changed (not just a resize)
            if self._last_main_window_pos:
                old_main_x, old_main_y = self._last_main_window_pos
                if current_main_x == old_main_x and current_main_y == old_main_y:
                    return  # No position change, just a resize
            
            # Calculate new detached window position (always keep it linked while main window moves)
            if self._playlist_window_link_offset:
                offset_x, offset_y = self._playlist_window_link_offset
                new_detached_x = current_main_x + offset_x
                new_detached_y = current_main_y + offset_y

                # Throttle moves (reduces jitter vs moving on every moveEvent, without deferring indefinitely)
                self._pending_linked_detached_pos = (new_detached_x, new_detached_y, current_main_x, current_main_y)
                self._link_move_idle_ticks = 0
                if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                    if not self._linked_move_timer.isActive():
                        # While throttling, keep this guard enabled so detached Move events don't rewrite offsets
                        self._moving_detached_playlist_programmatically = True
                        self._linked_move_timer.start()
        except Exception:
            self._moving_detached_playlist_programmatically = False

    def _apply_pending_linked_detached_move(self):
        """Apply a throttled detached-window move while in link mode."""
        if not self.playlist_detached or not self.playlist_window_linked:
            self._pending_linked_detached_pos = None
            self._link_move_idle_ticks = 0
            if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                self._linked_move_timer.stop()
            self._moving_detached_playlist_programmatically = False
            return
        if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
            self._pending_linked_detached_pos = None
            self._link_move_idle_ticks = 0
            if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                self._linked_move_timer.stop()
            self._moving_detached_playlist_programmatically = False
            return
        if not self._pending_linked_detached_pos:
            # No new target  stop quickly once movement has settled
            self._link_move_idle_ticks += 1
            if self._link_move_idle_ticks >= 2:
                self._link_move_idle_ticks = 0
                if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                    self._linked_move_timer.stop()
                self._moving_detached_playlist_programmatically = False
                self._last_programmatic_detached_pos = None
            return

        try:
            new_detached_x, new_detached_y, current_main_x, current_main_y = self._pending_linked_detached_pos
            self._pending_linked_detached_pos = None
            self._link_move_idle_ticks = 0

            # Mark this as programmatic so the detached window Move event doesn't update offsets
            self._last_programmatic_detached_pos = (new_detached_x, new_detached_y)
            self.detached_playlist_window.move(new_detached_x, new_detached_y)

            # Update stored positions (main position is known here)
            self._last_main_window_pos = (current_main_x, current_main_y)
            self._last_detached_playlist_pos = (new_detached_x, new_detached_y)
        except Exception:
            # If something goes wrong, stop throttling to avoid getting stuck
            self._pending_linked_detached_pos = None
            self._link_move_idle_ticks = 0
            if hasattr(self, '_linked_move_timer') and self._linked_move_timer:
                self._linked_move_timer.stop()
            self._moving_detached_playlist_programmatically = False
            self._last_programmatic_detached_pos = None
    
    def _handle_detached_playlist_window_movement(self, event):
        """Handle detached playlist window movement - recalculate offset if moved manually, or unlink if moved away."""
        if not self.playlist_window_linked or not self.detached_playlist_window:
            return
        
        if self._moving_detached_playlist_programmatically:
            return  # This is a programmatic move, don't recalculate offset
        
        try:
            # Get current positions
            current_main_x = self.x()
            current_main_y = self.y()
            current_detached_x = self.detached_playlist_window.x()
            current_detached_y = self.detached_playlist_window.y()
            
            # Check if position actually changed (not just a resize)
            if self._last_detached_playlist_pos:
                old_detached_x, old_detached_y = self._last_detached_playlist_pos
                if current_detached_x == old_detached_x and current_detached_y == old_detached_y:
                    return  # No position change, just a resize
            
            # Check if windows have moved apart (beyond snap threshold) - if so, unlink
            main_rect = self.geometry()
            detached_rect = self.detached_playlist_window.geometry()
            
            main_left = main_rect.x()
            main_right = main_rect.x() + main_rect.width()
            main_top = main_rect.y()
            main_bottom = main_rect.y() + main_rect.height()
            
            detached_left = detached_rect.x()
            detached_right = detached_rect.x() + detached_rect.width()
            detached_top = detached_rect.y()
            detached_bottom = detached_rect.y() + detached_rect.height()
            
            # Calculate minimum distance between windows
            # Check horizontal distance
            if detached_right < main_left:
                h_dist = main_left - detached_right
            elif detached_left > main_right:
                h_dist = detached_left - main_right
            else:
                h_dist = 0  # Overlapping horizontally
            
            # Check vertical distance
            if detached_bottom < main_top:
                v_dist = main_top - detached_bottom
            elif detached_top > main_bottom:
                v_dist = detached_top - main_bottom
            else:
                v_dist = 0  # Overlapping vertically
            
            # If windows are far apart (beyond snap threshold), unlink
            # Use a more lenient threshold - unlink if either direction is beyond threshold
            total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5  # Euclidean distance
            # Lower threshold to make unlinking easier - unlink if total distance > 1.5x threshold or either direction > threshold
            if total_dist > self._snap_threshold * 1.5 or h_dist > self._snap_threshold or v_dist > self._snap_threshold:
                # Windows have moved apart - unlink them
                self._toggle_playlist_window_linking(False)
                return
            
            # Windows are still close - recalculate offset (user moved detached window manually but kept it close)
            self._playlist_window_link_offset = (current_detached_x - current_main_x, current_detached_y - current_main_y)
            
            # Update stored positions
            self._last_main_window_pos = (current_main_x, current_main_y)
            self._last_detached_playlist_pos = (current_detached_x, current_detached_y)
        except Exception:
            pass
    
    def _calculate_distance_to_main_window(self, playlist_pos):
        """Calculate distance from playlist position to main window."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return float('inf')
        
        main_rect = self.geometry()
        playlist_rect = QRect(playlist_pos, self.detached_playlist_window.size())
        
        main_left = main_rect.x()
        main_right = main_rect.x() + main_rect.width()
        main_top = main_rect.y()
        main_bottom = main_rect.y() + main_rect.height()
        
        playlist_left = playlist_rect.x()
        playlist_right = playlist_rect.x() + playlist_rect.width()
        playlist_top = playlist_rect.y()
        playlist_bottom = playlist_rect.y() + playlist_rect.height()
        
        # Calculate minimum distance
        h_dist = 0
        v_dist = 0
        if playlist_right < main_left:
            h_dist = main_left - playlist_right
        elif playlist_left > main_right:
            h_dist = playlist_left - main_right
        
        if playlist_bottom < main_top:
            v_dist = main_top - playlist_bottom
        elif playlist_top > main_bottom:
            v_dist = playlist_top - main_bottom
        
        return (h_dist ** 2 + v_dist ** 2) ** 0.5
    
    def _handle_playlist_window_snapping(self):
        """Handle window snapping - snap detached playlist window to main window edges when close."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return False
        
        try:
            main_rect = self.geometry()
            detached_rect = self.detached_playlist_window.geometry()
            
            main_left = main_rect.x()
            main_right = main_rect.x() + main_rect.width()
            main_top = main_rect.y()
            main_bottom = main_rect.y() + main_rect.height()
            
            detached_left = detached_rect.x()
            detached_right = detached_rect.x() + detached_rect.width()
            detached_top = detached_rect.y()
            detached_bottom = detached_rect.y() + detached_rect.height()
            
            # First check if windows are reasonably close (within 2x snap threshold) before attempting to snap
            # This prevents snapping when windows are far apart
            h_dist = 0
            v_dist = 0
            if detached_right < main_left:
                h_dist = main_left - detached_right
            elif detached_left > main_right:
                h_dist = detached_left - main_right
            
            if detached_bottom < main_top:
                v_dist = main_top - detached_bottom
            elif detached_top > main_bottom:
                v_dist = detached_top - main_bottom
            
            total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5
            # Only attempt snapping if windows are within reasonable distance (2x snap threshold)
            if total_dist > self._snap_threshold * 2:
                return False  # Windows too far apart, don't snap
            
            new_x = detached_left
            new_y = detached_top
            snapped = False
            
            # Check snapping to right edge of main window
            if abs(detached_left - main_right) <= self._snap_threshold:
                new_x = main_right
                snapped = True
            # Check snapping to left edge of main window
            elif abs(detached_right - main_left) <= self._snap_threshold:
                new_x = main_left - detached_rect.width()
                snapped = True
            # Check snapping to left edge of detached window to right edge of main window
            elif abs(detached_right - main_right) <= self._snap_threshold:
                new_x = main_right - detached_rect.width()
                snapped = True
            
            # Check snapping to bottom edge of main window
            if abs(detached_top - main_bottom) <= self._snap_threshold:
                new_y = main_bottom
                snapped = True
            # Check snapping to top edge of main window
            elif abs(detached_bottom - main_top) <= self._snap_threshold:
                new_y = main_top - detached_rect.height()
                snapped = True
            # Check snapping to top edge of detached window to bottom edge of main window
            elif abs(detached_bottom - main_bottom) <= self._snap_threshold:
                new_y = main_bottom - detached_rect.height()
                snapped = True
            
            # Also check vertical alignment (same top or bottom)
            if abs(detached_top - main_top) <= self._snap_threshold:
                new_y = main_top
                snapped = True
            elif abs(detached_bottom - main_bottom) <= self._snap_threshold:
                new_y = main_bottom - detached_rect.height()
                snapped = True
            
            # Apply snapping if within threshold
            if snapped:
                self._moving_detached_playlist_programmatically = True
                self.detached_playlist_window.move(new_x, new_y)
                # Don't link immediately - wait for mouse release
                # Just mark that snapping occurred
                QTimer.singleShot(50, lambda: setattr(self, '_moving_detached_playlist_programmatically', False))
                return True  # Return True to indicate snapping occurred
        except Exception:
            pass
        return False  # No snapping occurred
    
    def _check_windows_dock_to_screen_edge(self):
        """Check if both main window and playlist window are at a screen edge and should dock together."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        screen_geometry = screen.geometry()
        main_rect = self.frameGeometry()
        detached_rect = self.detached_playlist_window.frameGeometry()
        
        # Calculate distances to screen edges for both windows
        main_dist_to_top = abs(main_rect.top() - screen_geometry.top())
        main_dist_to_bottom = abs(main_rect.bottom() - screen_geometry.bottom())
        main_dist_to_left = abs(main_rect.left() - screen_geometry.left())
        main_dist_to_right = abs(main_rect.right() - screen_geometry.right())
        
        detached_dist_to_top = abs(detached_rect.top() - screen_geometry.top())
        detached_dist_to_bottom = abs(detached_rect.bottom() - screen_geometry.bottom())
        detached_dist_to_left = abs(detached_rect.left() - screen_geometry.left())
        detached_dist_to_right = abs(detached_rect.right() - screen_geometry.right())
        
        # Check if both windows are at the same screen edge (within threshold)
        docked_edge = None
        if main_dist_to_top < self._snap_threshold and detached_dist_to_top < self._snap_threshold:
            docked_edge = 'top'
        elif main_dist_to_bottom < self._snap_threshold and detached_dist_to_bottom < self._snap_threshold:
            docked_edge = 'bottom'
        elif main_dist_to_left < self._snap_threshold and detached_dist_to_left < self._snap_threshold:
            docked_edge = 'left'
        elif main_dist_to_right < self._snap_threshold and detached_dist_to_right < self._snap_threshold:
            docked_edge = 'right'
        
        # If both windows are at an edge and not already docked, dock them
        if docked_edge and not self._windows_docked:
            self._dock_windows_to_edge(docked_edge)
        # If windows are no longer at an edge, undock them
        elif not docked_edge and self._windows_docked:
            self._undock_windows()
    
    def _dock_windows_to_edge(self, edge):
        """Dock both windows to the specified screen edge and enable linking."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        screen_geometry = screen.geometry()
        main_rect = self.frameGeometry()
        detached_rect = self.detached_playlist_window.frameGeometry()
        
        self._windows_docked_edge = edge
        self._windows_docked = True
        
        # Snap both windows to the edge
        if edge == 'top':
            self.move(main_rect.left(), screen_geometry.top())
            self.detached_playlist_window.move(detached_rect.left(), screen_geometry.top())
        elif edge == 'bottom':
            self.move(main_rect.left(), screen_geometry.bottom() - main_rect.height())
            self.detached_playlist_window.move(detached_rect.left(), screen_geometry.bottom() - detached_rect.height())
        elif edge == 'left':
            self.move(screen_geometry.left(), main_rect.top())
            self.detached_playlist_window.move(screen_geometry.left(), detached_rect.top())
        elif edge == 'right':
            self.move(screen_geometry.right() - main_rect.width(), main_rect.top())
            self.detached_playlist_window.move(screen_geometry.right() - detached_rect.width(), detached_rect.top())
        
        # Auto-enable linking when docked
        if not self.playlist_window_linked:
            self._toggle_playlist_window_linking(True)
    
    def _undock_windows(self):
        """Undock windows from screen edge."""
        self._windows_docked_edge = None
        self._windows_docked = False
        # Note: We don't disable linking automatically - user can do that manually if desired
    
    def _handle_main_window_snapping(self):
        """Handle main window snapping - snap main window to detached playlist window edges when close."""
        if not self.playlist_detached or not self.detached_playlist_window:
            return False
        
        try:
            main_rect = self.geometry()
            detached_rect = self.detached_playlist_window.geometry()
            
            main_left = main_rect.x()
            main_right = main_rect.x() + main_rect.width()
            main_top = main_rect.y()
            main_bottom = main_rect.y() + main_rect.height()
            
            detached_left = detached_rect.x()
            detached_right = detached_rect.x() + detached_rect.width()
            detached_top = detached_rect.y()
            detached_bottom = detached_rect.y() + detached_rect.height()
            
            # First check if windows are reasonably close (within 2x snap threshold) before attempting to snap
            # This prevents snapping when windows are far apart
            h_dist = 0
            v_dist = 0
            if detached_right < main_left:
                h_dist = main_left - detached_right
            elif detached_left > main_right:
                h_dist = detached_left - main_right
            
            if detached_bottom < main_top:
                v_dist = main_top - detached_bottom
            elif detached_top > main_bottom:
                v_dist = detached_top - main_bottom
            
            total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5
            # Only attempt snapping if windows are within reasonable distance (2x snap threshold)
            if total_dist > self._snap_threshold * 2:
                return False  # Windows too far apart, don't snap
            
            new_x = main_left
            new_y = main_top
            snapped = False
            
            # Check snapping main window right edge to detached window left edge
            if abs(main_right - detached_left) <= self._snap_threshold:
                new_x = detached_left - main_rect.width()
                snapped = True
            # Check snapping main window left edge to detached window right edge
            elif abs(main_left - detached_right) <= self._snap_threshold:
                new_x = detached_right
                snapped = True
            # Check snapping main window right edge to detached window right edge
            elif abs(main_right - detached_right) <= self._snap_threshold:
                new_x = detached_right - main_rect.width()
                snapped = True
            
            # Check snapping main window bottom edge to detached window top edge
            if abs(main_bottom - detached_top) <= self._snap_threshold:
                new_y = detached_top - main_rect.height()
                snapped = True
            # Check snapping main window top edge to detached window bottom edge
            elif abs(main_top - detached_bottom) <= self._snap_threshold:
                new_y = detached_bottom
                snapped = True
            # Check snapping main window bottom edge to detached window bottom edge
            elif abs(main_bottom - detached_bottom) <= self._snap_threshold:
                new_y = detached_bottom - main_rect.height()
                snapped = True
            
            # Also check vertical alignment (same top or bottom)
            if abs(main_top - detached_top) <= self._snap_threshold:
                new_y = detached_top
                snapped = True
            elif abs(main_bottom - detached_bottom) <= self._snap_threshold:
                new_y = detached_bottom - main_rect.height()
                snapped = True
            
            # Apply snapping if within threshold
            if snapped:
                # Guard against recursive snap scheduling caused by this programmatic move
                self._moving_main_window_programmatically = True
                self.move(new_x, new_y)
                # Don't link immediately - wait for mouse release
                # Just mark that snapping occurred
                QTimer.singleShot(0, lambda: setattr(self, '_moving_main_window_programmatically', False))
                return True  # Return True to indicate snapping occurred
        except Exception:
            pass
        return False  # No snapping occurred
    
    def _create_detached_playlist_window(self):
        """Create a new window for the detached playlist."""
        if self.detached_playlist_window:
            return
        
        # Create dialog window (non-modal) as a separate top-level window for taskbar
        # Use None as parent to make it a top-level window that appears in taskbar
        self.detached_playlist_window = QDialog(None)
        self.detached_playlist_window.setWindowTitle("Playlist")
        self.detached_playlist_window.setModal(False)
        self.detached_playlist_window.setMinimumSize(260, 200)
        # Ensure window is resizable (no maximum size constraint)
        self.detached_playlist_window.setMaximumSize(16777215, 16777215)  # Qt's default maximum (effectively unlimited)
        # Set size policy to allow resizing
        self.detached_playlist_window.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        
        # Make it frameless like the main window, but ensure it appears in taskbar
        # Window flag makes it a separate taskbar item
        flags = Qt.WindowType.FramelessWindowHint | Qt.WindowType.Window
        if self.always_on_top:
            flags |= Qt.WindowType.WindowStaysOnTopHint
        self.detached_playlist_window.setWindowFlags(flags)
        
        # Set window icon if available
        if hasattr(self, 'app_icon') and self.app_icon:
            self.detached_playlist_window.setWindowIcon(self.app_icon)
        
        # Set background color to prevent white border on Windows 10
        # This ensures the window background matches the dark theme
        self.detached_playlist_window.setStyleSheet("""
            QDialog {
                background-color: rgb(21, 21, 21);
            }
        """)
        self.detached_playlist_window.setAutoFillBackground(True)
        # On Windows 10, frameless windows can show white borders without this attribute
        self.detached_playlist_window.setAttribute(Qt.WidgetAttribute.WA_OpaquePaintEvent, True)
        
        # Create layout first (bottom margin will be set when playlist is added)
        layout = QVBoxLayout(self.detached_playlist_window)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create custom title bar for detached window
        self._create_detached_window_title_bar()
        layout.addWidget(self.detached_playlist_title_bar)
        
        # Load saved size from settings
        saved_size = self.settings.get("playlist_detached_size", "260x400")
        try:
            if 'x' in saved_size:
                size_parts = saved_size.split('x')
                if len(size_parts) == 2:
                    width = int(size_parts[0])
                    height = int(size_parts[1])
                    # Validate size - width should always be 260 to match main window
                    if width >= 260 and height >= 200:
                        # Force width to 260 to match main window width
                        self.detached_playlist_window.resize(260, height)
                    else:
                        self.detached_playlist_window.resize(260, 400)
                else:
                    self.detached_playlist_window.resize(260, 400)
            else:
                self.detached_playlist_window.resize(260, 400)
        except Exception:
            self.detached_playlist_window.resize(260, 400)
        
        # Set fixed width to match main window width (260px)
        # This ensures the detached playlist always matches the main window width
        self.detached_playlist_window.setFixedWidth(260)
        
        # Position window relative to main window (always use offset-based positioning)
        screen = QApplication.primaryScreen()
        screen_geometry = screen.availableGeometry() if screen else None
        
        main_pos = self.pos()
        offset_x, offset_y = self.playlist_detached_offset
        
        # Calculate position relative to main window's current position
        # Offset is already the full offset from main window position (like downloader)
        detached_x = main_pos.x() + offset_x
        detached_y = main_pos.y() + offset_y
        
        # Ensure window stays on screen
        if screen_geometry:
            if detached_x + self.detached_playlist_window.width() > screen_geometry.right():
                detached_x = screen_geometry.right() - self.detached_playlist_window.width() - 20
            if detached_y + self.detached_playlist_window.height() > screen_geometry.bottom():
                detached_y = screen_geometry.bottom() - self.detached_playlist_window.height() - 20
            if detached_x < screen_geometry.left():
                detached_x = screen_geometry.left() + 20
            if detached_y < screen_geometry.top():
                detached_y = screen_geometry.top() + 20
        
        self.detached_playlist_window.move(detached_x, detached_y)
        
        # Handle window close - reattach instead of destroying
        self.detached_playlist_window.finished.connect(self._reattach_playlist)
        
        # Install event filter to catch move/resize events
        # The eventFilter method in PlayerWindow will handle Move and Resize events
        self.detached_playlist_window.installEventFilter(self)
        
        # Apply rounded corners after window is shown
        def apply_rounded_corners():
            radius = 10  # Corner radius in pixels (same as main window)
            size = self.detached_playlist_window.size()
            
            # Create a path with rounded corners
            path = QPainterPath()
            path.addRoundedRect(0, 0, size.width(), size.height(), radius, radius)
            
            # Convert path to polygon and create region
            polygon = path.toFillPolygon()
            rounded_region = QRegion(polygon.toPolygon())
            
            self.detached_playlist_window.setMask(rounded_region)
            
            # After setting mask, ensure resize handle is still on top and visible
            if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                QTimer.singleShot(10, lambda: (
                    self._update_detached_bottom_resize_handle_position() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None,
                    self.detached_bottom_resize_handle.raise_() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None
                ))
        
        # Make window resizable (remove fixed size constraints)
        self.detached_playlist_window.setMinimumSize(260, 200)
        # No maximum size - allow resizing
        
        # Store apply_rounded_corners function for event filter
        self._apply_detached_rounded_corners = apply_rounded_corners
        
        # Handle resize events to update bottom resize handle position and rounded corners
        original_resize_event = self.detached_playlist_window.resizeEvent
        
        def on_resize(event):
            # Ensure width is always 260px to match main window
            if self.detached_playlist_window.width() != 260:
                self.detached_playlist_window.setFixedWidth(260)
            # Call original resize event handler
            if original_resize_event:
                original_resize_event(event)
            # Update bottom resize handle position
            if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                self._update_detached_bottom_resize_handle_position()
            # Update rounded corners on resize
            QTimer.singleShot(10, apply_rounded_corners)
        
        self.detached_playlist_window.resizeEvent = on_resize
        
        # Show window (always show on creation, visibility state will be restored from settings)
        # The window should always be shown when created, even if it was minimized before
        self.detached_playlist_window.show()
        
        # Update overlay when window is first shown
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            repeat_mode = getattr(self.playlist_sidebar, 'repeat_mode', 0)
            if hasattr(self, '_update_detached_repeat_overlay'):
                QTimer.singleShot(100, lambda: self._update_detached_repeat_overlay(repeat_mode))
        self.detached_playlist_window.raise_()
        # Don't activate window on startup restoration to avoid stealing focus
        # Only activate if this is a user-initiated detach (not startup restoration)
        if not self.playlist_detached:
            self.detached_playlist_window.activateWindow()
        
        # Create bottom resize handle AFTER window is shown and playlist is added
        # This ensures it's created on top of all content
        QTimer.singleShot(150, lambda: (
            self._create_detached_bottom_resize_handle(),
            self._update_detached_bottom_resize_handle_position() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None,
            self.detached_bottom_resize_handle.raise_() if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle else None
        ))
        
        # Apply rounded corners after showing
        QTimer.singleShot(50, apply_rounded_corners)
    
    def _create_detached_window_title_bar(self):
        """Create custom title bar for detached playlist window with all playlist buttons."""
        # Create title bar widget
        self.detached_playlist_title_bar = QWidget(self.detached_playlist_window)
        self.detached_playlist_title_bar.setFixedHeight(30)
        self.detached_playlist_title_bar.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border-bottom: 1px solid #1a1a1a;
            }
        """)
        
        title_layout = QHBoxLayout(self.detached_playlist_title_bar)
        title_layout.setContentsMargins(10, 2, 10, 2)  # Add padding on left and right sides
        title_layout.setSpacing(2)  # Match playlist title bar spacing
        
        # Title label (no icon to save space)
        title_label = QLabel("Playlist")
        title_label.setMaximumWidth(50)  # Limit label width to make room for buttons
        title_label.setStyleSheet("""
            QLabel {
                font-size: 11px;
                font-weight: normal;
                color: #e0e0e0;
                padding: 0px;
                border: none;
            }
        """)
        title_layout.addWidget(title_label)
        
        # Copy all buttons from playlist sidebar
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            # Playlist menu button
            playlist_menu_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('ph.dots-three-outline-vertical-fill', color='#e0e0e0')
                if icon:
                    playlist_menu_btn.setIcon(icon)
                else:
                    playlist_menu_btn.setText("")
            else:
                playlist_menu_btn.setText("")
            playlist_menu_btn.setToolTip("Playlist Menu")
            playlist_menu_btn.setFixedSize(22, 22)
            playlist_menu_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            playlist_menu_btn.clicked.connect(self.playlist_sidebar.show_playlist_menu)
            title_layout.addWidget(playlist_menu_btn)
            
            title_layout.addStretch()
            
            # Add URL button
            add_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('plus', color='#e0e0e0')
                if icon:
                    add_btn.setIcon(icon)
                else:
                    add_btn.setText("")
            else:
                add_btn.setText("")
            add_btn.setToolTip("Add URL(s) From Clipboard (Supports Multiple URLs, One Per Line)")
            add_btn.setFixedSize(22, 22)
            add_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            add_btn.clicked.connect(self.playlist_sidebar.add_url)
            title_layout.addWidget(add_btn)
            
            # Previous album button
            prev_album_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('step-backward', color='#e0e0e0')
                if icon:
                    prev_album_btn.setIcon(icon)
                else:
                    prev_album_btn.setText("")
            else:
                prev_album_btn.setText("")
            prev_album_btn.setToolTip("Previous Album")
            prev_album_btn.setFixedSize(22, 22)
            prev_album_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            prev_album_btn.clicked.connect(self.playlist_sidebar.load_previous_album)
            title_layout.addWidget(prev_album_btn)
            
            # Next album button
            next_album_btn = QPushButton()
            if HAS_QT_AWESOME:
                icon = get_icon('step-forward', color='#e0e0e0')
                if icon:
                    next_album_btn.setIcon(icon)
                else:
                    next_album_btn.setText("")
            else:
                next_album_btn.setText("")
            next_album_btn.setToolTip("Next Album")
            next_album_btn.setFixedSize(22, 22)
            next_album_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            next_album_btn.clicked.connect(self.playlist_sidebar.load_next_album)
            title_layout.addWidget(next_album_btn)
            
            # Shuffle button (reference the existing one to sync state)
            shuffle_btn = QPushButton()
            shuffle_btn.setFixedSize(22, 22)
            shuffle_btn.setCheckable(True)
            shuffle_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #a0a0a0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
                QPushButton:checked {
                    color: #4a90e2;
                    background-color: #3a3a3a;
                    border: 1px solid #4a90e2;
                    border-radius: 3px;
                }
            """)
            # Sync with existing shuffle button state and mode
            if hasattr(self.playlist_sidebar, 'shuffle_btn') and hasattr(self.playlist_sidebar, 'shuffle_mode'):
                shuffle_mode = self.playlist_sidebar.shuffle_mode
                is_active = shuffle_mode > 0
                shuffle_btn.setChecked(is_active)
                
                # Set initial icon and tooltip based on actual mode
                if HAS_QT_AWESOME:
                    if shuffle_mode == 0:
                        icon_color = '#a0a0a0'
                        icon = get_icon('random', color=icon_color)
                        tooltip = "Shuffle: Off"
                    elif shuffle_mode == 1:
                        icon_color = '#4a90e2'
                        icon = get_icon('random', color=icon_color)
                        tooltip = "Shuffle: Tracks (shuffle tracks in album)"
                    elif shuffle_mode == 2:
                        icon_color = '#4a90e2'
                        icon = get_icon('ei.question', color=icon_color)
                        tooltip = "Shuffle: Albums (randomize album order)"
                    else:  # mode 3
                        icon_color = '#4a90e2'
                        icon = get_icon('ei.asl', color=icon_color)
                        tooltip = "Super Shuffle (random album & track)"
                    
                    if icon:
                        shuffle_btn.setIcon(icon)
                    else:
                        shuffle_btn.setText("")
                else:
                    shuffle_btn.setText("")
                    tooltip = f"Shuffle: {'On' if is_active else 'Off'}"
                
                shuffle_btn.setToolTip(tooltip)
                
                # Connect to toggle function - it will update the button state and icon
                def on_shuffle_clicked():
                    self.playlist_sidebar.toggle_shuffle()
                    # Explicitly update the detached button after toggle
                    # Update immediately and also with a delay to ensure visual refresh
                    if hasattr(self, '_update_detached_shuffle_button_icon'):
                        self._update_detached_shuffle_button_icon()
                        QTimer.singleShot(50, lambda: self._update_detached_shuffle_button_icon())
                shuffle_btn.clicked.connect(on_shuffle_clicked)
            else:
                # Fallback if playlist_sidebar doesn't have shuffle_btn
                if HAS_QT_AWESOME:
                    icon = get_icon('random', color='#a0a0a0')
                    if icon:
                        shuffle_btn.setIcon(icon)
                    else:
                        shuffle_btn.setText("")
                else:
                    shuffle_btn.setText("")
                shuffle_btn.setToolTip("Shuffle: Off")
            title_layout.addWidget(shuffle_btn)
            self._detached_shuffle_btn = shuffle_btn  # Store reference
            
            # Repeat button (reference the existing one to sync state)
            repeat_btn = QPushButton()
            repeat_btn.setFixedSize(22, 22)
            repeat_btn.setCheckable(True)
            repeat_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #a0a0a0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
                QPushButton:checked {
                    color: #4a90e2;
                    background-color: #3a3a3a;
                    border: 1px solid #4a90e2;
                    border-radius: 3px;
                }
            """)
            # Sync with existing repeat button state and mode
            if hasattr(self.playlist_sidebar, 'repeat_btn') and hasattr(self.playlist_sidebar, 'repeat_mode'):
                repeat_mode = self.playlist_sidebar.repeat_mode
                is_active = repeat_mode > 0
                repeat_btn.setChecked(is_active)
                
                # Set initial icon and tooltip based on actual mode
                if HAS_QT_AWESOME:
                    if repeat_mode == 0:
                        icon_color = '#a0a0a0'
                        icon = get_icon('ei.repeat', color=icon_color)
                        tooltip = "Repeat: Off"
                    elif repeat_mode == 1:
                        icon_color = '#4a90e2'
                        icon = get_icon('ei.repeat', color=icon_color)
                        tooltip = "Repeat: Continuous (play next album)"
                    elif repeat_mode == 2:
                        icon_color = '#4a90e2'
                        icon = get_icon('ei.heart', color=icon_color)
                        tooltip = "Repeat: Album (loop current album)"
                    else:  # mode 3
                        icon_color = '#4a90e2'
                        icon = get_icon('ei.heart', color=icon_color)
                        tooltip = "Repeat: Track (loop current track)"
                    
                    if icon:
                        repeat_btn.setIcon(icon)
                    else:
                        repeat_btn.setText("")
                else:
                    repeat_btn.setText("")
                    tooltip = f"Repeat: {'On' if is_active else 'Off'}"
                
                repeat_btn.setToolTip(tooltip)
                
                # Connect to toggle function - it will update the button state and icon
                def on_repeat_clicked():
                    self.playlist_sidebar.toggle_repeat()
                    # Explicitly update the detached button after toggle
                    # Update immediately and also with a delay to ensure visual refresh
                    if hasattr(self, '_update_detached_repeat_button_icon'):
                        self._update_detached_repeat_button_icon()
                        QTimer.singleShot(50, lambda: self._update_detached_repeat_button_icon())
                repeat_btn.clicked.connect(on_repeat_clicked)
            else:
                # Fallback if playlist_sidebar doesn't have repeat_btn
                if HAS_QT_AWESOME:
                    icon = get_icon('ei.repeat', color='#a0a0a0')
                    if icon:
                        repeat_btn.setIcon(icon)
                    else:
                        repeat_btn.setText("")
                else:
                    repeat_btn.setText("")
                repeat_btn.setToolTip("Repeat: Off")
            title_layout.addWidget(repeat_btn)
            self._detached_repeat_btn = repeat_btn  # Store reference
            
            # Detach/Attach button
            detach_btn = QPushButton()
            if HAS_QT_AWESOME:
                # Use attach icon since we're detached
                icon = None
                for icon_name in ['fa5s.window-maximize', 'fa5.window-maximize', 'ei.arrow-down', 'fa5s.compress']:
                    try:
                        icon = get_icon(icon_name, color='#e0e0e0')
                        if icon:
                            break
                    except:
                        continue
                if icon:
                    detach_btn.setIcon(icon)
                else:
                    detach_btn.setText("")
            else:
                detach_btn.setText("")
            detach_btn.setToolTip("Attach Playlist to Main Window")
            detach_btn.setFixedSize(22, 22)
            detach_btn.setStyleSheet("""
                QPushButton {
                    background-color: transparent;
                    color: #e0e0e0;
                    border: none;
                    font-size: 14px;
                    padding: 2px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
            detach_btn.clicked.connect(self._reattach_playlist)
            # Store detach button reference but don't add it yet - we'll add it in the correct order
            self._detached_detach_btn = detach_btn
        
        title_layout.addStretch()
        
        # Link mode toggle button (before window controls)
        link_btn = QPushButton()
        link_btn.setCheckable(True)
        # Block signals when setting initial state to prevent triggering toggle during creation
        link_btn.blockSignals(True)
        link_btn.setChecked(self.playlist_window_linked)
        link_btn.blockSignals(False)
        # Set initial icon color based on linked state (blue if linked, gray if not)
        initial_icon_color = '#4a90e2' if self.playlist_window_linked else '#e0e0e0'
        if HAS_QT_AWESOME:
            icon = get_icon('link', color=initial_icon_color)
            if icon:
                link_btn.setIcon(icon)
            else:
                link_btn.setText("")
        else:
            link_btn.setText("")
        link_btn.setFixedSize(22, 22)  # Match other buttons
        link_btn.setToolTip("Windows are linked (automatic when snapped together)" if self.playlist_window_linked else "Windows are not linked (link automatically when snapped together)")
        # Store initial checked state for stylesheet
        initial_checked = "checked" if self.playlist_window_linked else ""
        link_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }}
            QPushButton:hover {{
                background-color: #3a3a3a;
            }}
            QPushButton:checked {{
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }}
            QPushButton:checked:disabled {{
                color: #4a90e2;
            }}
        """)
        # Update icon color when checked state changes (to match shuffle/repeat buttons)
        def update_link_icon(checked):
            if HAS_QT_AWESOME:
                icon_color = '#4a90e2' if checked else '#e0e0e0'
                icon = get_icon('link', color=icon_color)
                if icon:
                    link_btn.setIcon(icon)
        link_btn.toggled.connect(update_link_icon)
        # Don't connect to toggle function - button is read-only for visual feedback only
        # Linking is now automatic when windows snap together
        # Keep button enabled so icon colors work properly, but use event filter to block clicks
        class ReadOnlyButtonFilter(QObject):
            def __init__(self, parent=None):
                super().__init__(parent)
            
            def eventFilter(self, obj, event):
                # Block all mouse button events to prevent clicking
                if event.type() in (QEvent.Type.MouseButtonPress, QEvent.Type.MouseButtonRelease, 
                                   QEvent.Type.MouseButtonDblClick):
                    # Accept the event to prevent it from being processed by the button
                    event.accept()
                    return True  # Event was handled, don't propagate
                return False  # Let other events through normally
        read_only_filter = ReadOnlyButtonFilter(self)
        link_btn.installEventFilter(read_only_filter)
        # Force initial icon color update
        update_link_icon(self.playlist_window_linked)
        title_layout.addWidget(link_btn)
        self._detached_link_btn = link_btn
        # Store reference to update function so we can call it directly when linking changes programmatically
        self._update_link_icon_func = update_link_icon
        
        # Window controls (minimize and close buttons at the end)
        # Note: Close button reattaches, so attach button is redundant and hidden
        controls_layout = QHBoxLayout()
        controls_layout.setContentsMargins(0, 0, 0, 0)
        controls_layout.setSpacing(2)  # Match title_layout spacing for consistency
        
        # Minimize button (first)
        minimize_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('minus', color='#e0e0e0')
            if icon:
                minimize_btn.setIcon(icon)
            else:
                minimize_btn.setText("")
        else:
            minimize_btn.setText("")
        minimize_btn.setFixedSize(22, 22)  # Match other buttons
        minimize_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
        """)
        minimize_btn.clicked.connect(self.detached_playlist_window.showMinimized)
        controls_layout.addWidget(minimize_btn)
        
        # Attach button is hidden - close button already reattaches, so it's redundant
        
        # Close button (reattaches instead of closing)
        close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_btn.setIcon(icon)
            else:
                close_btn.setText("")
        else:
            close_btn.setText("")
        close_btn.setFixedSize(22, 22)  # Match other buttons
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 14px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #e81123;
                color: white;
            }
        """)
        close_btn.clicked.connect(self._reattach_playlist)
        controls_layout.addWidget(close_btn)
        
        title_layout.addLayout(controls_layout)
        
        # Enable window dragging on title bar
        def title_bar_mouse_press(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self._detached_window_drag_position = event.globalPosition().toPoint()
                # When dragging playlist starts, instantly unlink
                was_linked = self.playlist_window_linked
                if was_linked:
                    self._toggle_playlist_window_linking(False)
                    # Activate release window: brief period where snapping is disabled to allow easy breakaway
                    self._playlist_release_window_active = True
                    self._playlist_release_window_timer.start(150)  # 150ms grace period
                self._is_dragging_playlist_window = True
                self._snapped_during_drag = False
                # Store initial position for breakaway detection
                self._playlist_drag_start_pos = self.detached_playlist_window.pos()
                self._playlist_breakaway_activated = False
                event.accept()
        
        def title_bar_mouse_move(event):
            if event.buttons() == Qt.MouseButton.LeftButton and hasattr(self, '_detached_window_drag_position') and self._detached_window_drag_position is not None:
                delta = event.globalPosition().toPoint() - self._detached_window_drag_position
                new_pos = self.detached_playlist_window.pos() + delta
                self.detached_playlist_window.move(new_pos)
                self._detached_window_drag_position = event.globalPosition().toPoint()
                
                # Check if playlist is being dragged away from main window (breakaway detection)
                current_dist_to_main = self._calculate_distance_to_main_window(new_pos)
                breakaway_threshold = 10  # Fixed 10px threshold for breakaway
                
                if self._playlist_drag_start_pos:
                    start_dist_to_main = self._calculate_distance_to_main_window(self._playlist_drag_start_pos)
                    
                    # If distance increased by breakaway threshold, activate breakaway
                    if current_dist_to_main > start_dist_to_main + breakaway_threshold:
                        self._playlist_breakaway_activated = True
                    # If distance decreased (dragging back toward main window), reset breakaway
                    elif current_dist_to_main < start_dist_to_main:
                        self._playlist_breakaway_activated = False
                        # Update start position to current position for new reference
                        self._playlist_drag_start_pos = new_pos
                
                # Enable snapping if not linked, not in release window, and (not broken away OR windows are close enough to snap)
                # Release window gives a brief grace period after unlinking to allow easy breakaway
                # This allows snapping to re-engage if user drags back toward main window
                can_snap = (not self.playlist_window_linked and 
                           not self._playlist_release_window_active and
                           (not self._playlist_breakaway_activated or current_dist_to_main <= self._snap_threshold))
                if can_snap:
                    # Check if snapping occurred
                    if self._handle_playlist_window_snapping():
                        self._snapped_during_drag = True
                        # Reset breakaway if we snap (user is dragging toward main window)
                        self._playlist_breakaway_activated = False
                        # Reset drag start position since we snapped (new reference point)
                        self._playlist_drag_start_pos = new_pos
                event.accept()
        
        def title_bar_mouse_release(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self._is_dragging_playlist_window = False
                self._playlist_drag_start_pos = None
                self._playlist_breakaway_activated = False
                # Cancel release window timer if still active
                if self._playlist_release_window_timer.isActive():
                    self._playlist_release_window_timer.stop()
                self._playlist_release_window_active = False
                # If windows snapped during drag, link them now (on release) - but only if still close
                if self._snapped_during_drag:
                    # Check if windows are still close (within snap threshold)
                    main_rect = self.geometry()
                    detached_rect = self.detached_playlist_window.geometry()
                    
                    main_left = main_rect.x()
                    main_right = main_rect.x() + main_rect.width()
                    main_top = main_rect.y()
                    main_bottom = main_rect.y() + main_rect.height()
                    
                    detached_left = detached_rect.x()
                    detached_right = detached_rect.x() + detached_rect.width()
                    detached_top = detached_rect.y()
                    detached_bottom = detached_rect.y() + detached_rect.height()
                    
                    # Check if windows are within snap threshold
                    h_dist = 0
                    v_dist = 0
                    if detached_right < main_left:
                        h_dist = main_left - detached_right
                    elif detached_left > main_right:
                        h_dist = detached_left - main_right
                    
                    if detached_bottom < main_top:
                        v_dist = main_top - detached_bottom
                    elif detached_top > main_bottom:
                        v_dist = detached_top - main_bottom
                    
                    total_dist = (h_dist ** 2 + v_dist ** 2) ** 0.5
                    if total_dist <= self._snap_threshold:
                        # Windows are still close - link them
                        self._toggle_playlist_window_linking(True)
                        self._windows_docked = True
                        # Update link offset
                        main_x = self.x()
                        main_y = self.y()
                        detached_x = self.detached_playlist_window.x()
                        detached_y = self.detached_playlist_window.y()
                        self._playlist_window_link_offset = (detached_x - main_x, detached_y - main_y)
                self._snapped_during_drag = False
                if hasattr(self, '_detached_window_drag_position'):
                    self._detached_window_drag_position = None
        
        self.detached_playlist_title_bar.mousePressEvent = title_bar_mouse_press
        self.detached_playlist_title_bar.mouseMoveEvent = title_bar_mouse_move
        self.detached_playlist_title_bar.mouseReleaseEvent = title_bar_mouse_release
    
    def _create_detached_bottom_resize_handle(self):
        """Create bottom resize handle for detached playlist window (like main window)"""
        if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
            return  # Already exists
        
        if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
            return  # Window doesn't exist yet
        
        # Create resize handle widget as a direct child of the window (not in layout)
        # This ensures it can be positioned absolutely and stay on top
        self.detached_bottom_resize_handle = QWidget(self.detached_playlist_window)
        self.detached_bottom_resize_handle.setFixedHeight(6)  # 6px tall resize area
        self.detached_bottom_resize_handle.setStyleSheet("""
            QWidget {
                background-color: transparent;
            }
            QWidget:hover {
                background-color: rgba(100, 100, 100, 0.3);
            }
        """)
        # Use SizeVerCursor for vertical resizing from bottom edge (like main window)
        # The bottom edge allows resizing height, and width from the right side
        self.detached_bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)
        self.detached_bottom_resize_handle.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        
        # Initialize resize state variables
        self.detached_resize_start_y = None
        self.detached_resize_start_height = None
        self.detached_resize_start_x = None
        self.detached_resize_start_width = None
        self.detached_resize_start_pos = None  # Store initial mouse position relative to window
        
        # Mouse event handlers for resizing
        def handle_mouse_press(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.detached_resize_start_y = event.globalPosition().y()
                self.detached_resize_start_height = self.detached_playlist_window.height()
                self.detached_resize_start_x = event.globalPosition().x()
                self.detached_resize_start_width = self.detached_playlist_window.width()
                # Store mouse position relative to window for determining resize direction
                window_pos = self.detached_playlist_window.pos()
                self.detached_resize_start_pos = event.globalPosition().toPoint() - window_pos
                event.accept()
        
        def handle_mouse_move(event):
            if (self.detached_resize_start_y is not None and 
                self.detached_resize_start_x is not None and 
                event.buttons() & Qt.MouseButton.LeftButton):
                delta_y = event.globalPosition().y() - self.detached_resize_start_y
                delta_x = event.globalPosition().x() - self.detached_resize_start_x
                
                # Always resize height from bottom
                new_height = max(200, self.detached_resize_start_height + int(delta_y))  # Min 200px
                
                # Only resize height - width is always fixed to 260px to match main window
                # Dragging from any position only resizes height
                self.detached_playlist_window.resize(260, new_height)  # Always keep width at 260px
                # Update cursor to vertical (only height resizing)
                if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                    self.detached_bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)
                event.accept()
            else:
                # Update cursor on hover - always vertical since we only resize height
                if hasattr(self, 'detached_bottom_resize_handle') and self.detached_bottom_resize_handle:
                    self.detached_bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)
        
        def handle_mouse_release(event):
            self.detached_resize_start_y = None
            self.detached_resize_start_height = None
            self.detached_resize_start_x = None
            self.detached_resize_start_width = None
            self.detached_resize_start_pos = None
            # Reset cursor to vertical
            self.detached_bottom_resize_handle.setCursor(Qt.CursorShape.SizeVerCursor)
            event.accept()
        
        self.detached_bottom_resize_handle.mousePressEvent = handle_mouse_press
        self.detached_bottom_resize_handle.mouseMoveEvent = handle_mouse_move
        self.detached_bottom_resize_handle.mouseReleaseEvent = handle_mouse_release
        
        # Position at bottom of window
        self._update_detached_bottom_resize_handle_position()
        self.detached_bottom_resize_handle.show()
        self.detached_bottom_resize_handle.raise_()  # Keep on top
    
    def _update_detached_bottom_resize_handle_position(self):
        """Update bottom resize handle position for detached window"""
        if not hasattr(self, 'detached_bottom_resize_handle') or not self.detached_bottom_resize_handle:
            return
        if not hasattr(self, 'detached_playlist_window') or not self.detached_playlist_window:
            return
        
        # Position at bottom of window, full width (like main window)
        handle_height = 6
        window_width = self.detached_playlist_window.width()
        window_height = self.detached_playlist_window.height()
        self.detached_bottom_resize_handle.setGeometry(0, window_height - handle_height, window_width, handle_height)
        # Ensure it's always on top and visible
        self.detached_bottom_resize_handle.show()
        self.detached_bottom_resize_handle.raise_()
        # Make sure it can receive mouse events (not transparent)
        self.detached_bottom_resize_handle.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        # Set stacking order to ensure it's above all other widgets
        self.detached_bottom_resize_handle.setAttribute(Qt.WidgetAttribute.WA_NoSystemBackground, True)
        # Force raise again to ensure it's on top
        self.detached_bottom_resize_handle.raise_()
    
    def _save_playlist_detach_state(self):
        """Save playlist detach state to settings."""
        try:
            self.settings['playlist_detached'] = self.playlist_detached
            if self.detached_playlist_window:
                try:
                    pos = self.detached_playlist_window.pos()
                    size = self.detached_playlist_window.size()
                    # Save absolute position
                    self.playlist_detached_position = (pos.x(), pos.y())
                    # Also save relative offset for backward compatibility
                    main_pos = self.pos()
                    self.playlist_detached_offset = (pos.x() - main_pos.x(), pos.y() - main_pos.y())
                    self.playlist_detached_size = f"{size.width()}x{size.height()}"
                except Exception:
                    pass
            self.settings['playlist_detached_offset'] = self.playlist_detached_offset
            self.settings['playlist_detached_position'] = self.playlist_detached_position
            self.settings['playlist_detached_size'] = self.playlist_detached_size
            # Save link mode state
            self.settings['playlist_window_linked'] = self.playlist_window_linked
            self.save_settings()
        except Exception as e:
            logger.debug(f"Error saving playlist detach state: {e}")
    
    def reload_page(self):
        """Reload the current page"""
        self.web_view.reload()
    
    def toggle_dev_tools(self):
        """Toggle developer tools/inspector"""
        dev_tools_opening = self.dev_tools_window is None or not self.dev_tools_window.isVisible()
        
        if dev_tools_opening:
            try:
                # Create developer tools window
                self.dev_tools_window = QWidget()
                self.dev_tools_window.setWindowTitle("Developer Tools - Bandcamp Player")
                self.dev_tools_window.setMinimumSize(800, 600)
                
                # Restore window geometry from settings
                dev_tools_geometry = self.settings.get("dev_tools_geometry")
                if dev_tools_geometry:
                    try:
                        x = dev_tools_geometry.get("x", 100)
                        y = dev_tools_geometry.get("y", 100)
                        width = dev_tools_geometry.get("width", 1000)
                        height = dev_tools_geometry.get("height", 700)
                        self.dev_tools_window.setGeometry(x, y, width, height)
                    except:
                        self.dev_tools_window.resize(1000, 700)
                else:
                    self.dev_tools_window.resize(1000, 700)
                
                # Create a web view for dev tools using the same profile
                # This ensures dev tools settings are persisted
                dev_tools_page = QWebEnginePage(self.webengine_profile, self.dev_tools_window)
                dev_tools_view = QWebEngineView()
                dev_tools_view.setPage(dev_tools_page)
                
                dev_tools_layout = QVBoxLayout(self.dev_tools_window)
                dev_tools_layout.setContentsMargins(0, 0, 0, 0)
                dev_tools_layout.addWidget(dev_tools_view)
                
                # Set the dev tools page - this connects the inspector to the main page
                # Using the same profile ensures settings persistence
                self.web_view.page().setDevToolsPage(dev_tools_page)
                
                # Store dev tools page reference for element inspection
                self.dev_tools_page = dev_tools_page
                
                # Set dev tools theme - use our saved preference or default to dark
                # DevTools may store theme in IndexedDB, so we'll try multiple storage mechanisms
                dev_tools_theme = self.settings.get("dev_tools_theme", "dark")  # Default to dark
                
                def apply_dev_tools_theme(theme):
                    """Apply theme to developer tools using multiple methods including IndexedDB"""
                    theme_js = f"""
                    (function() {{
                        try {{
                            const theme = '{theme}';
                            console.log('DevTools: Applying theme:', theme);
                            
                            // Method 1: Set in localStorage (multiple keys)
                            if (window.localStorage) {{
                                window.localStorage.setItem('theme', theme);
                                window.localStorage.setItem('uiTheme', theme);
                                window.localStorage.setItem('devtools-theme', theme);
                                window.localStorage.setItem('theme-source', 'user');
                            }}
                            
                            // Method 2: Set in IndexedDB (DevTools may use this for persistence)
                            if (window.indexedDB) {{
                                try {{
                                    const request = window.indexedDB.open('DevToolsSettings', 1);
                                    request.onsuccess = function(event) {{
                                        const db = event.target.result;
                                        if (db.objectStoreNames.contains('settings')) {{
                                            const transaction = db.transaction(['settings'], 'readwrite');
                                            const store = transaction.objectStore('settings');
                                            store.put({{ key: 'theme', value: theme }});
                                            store.put({{ key: 'uiTheme', value: theme }});
                                        }}
                                    }};
                                }} catch (e) {{
                                    console.log('IndexedDB access failed:', e);
                                }}
                            }}
                            
                            // Method 3: Try DevTools API
                            if (window.DevToolsAPI) {{
                                if (window.DevToolsAPI.setTheme) {{
                                    window.DevToolsAPI.setTheme(theme);
                                }}
                                if (window.DevToolsAPI.setSetting) {{
                                    window.DevToolsAPI.setSetting('theme', theme);
                                }}
                            }}
                            
                            // Method 4: Try InspectorFrontendHost (most reliable for DevTools)
                            if (window.InspectorFrontendHost) {{
                                if (window.InspectorFrontendHost.setTheme) {{
                                    window.InspectorFrontendHost.setTheme(theme);
                                }}
                                if (window.InspectorFrontendHost.setPreference) {{
                                    window.InspectorFrontendHost.setPreference('theme', theme);
                                }}
                                // Try the actual method that Chrome DevTools uses
                                if (window.InspectorFrontendHost.setPreference) {{
                                    window.InspectorFrontendHost.setPreference('uiTheme', theme);
                                }}
                            }}
                            
                            // Method 5: Try Settings object
                            if (window.Settings && window.Settings.setSetting) {{
                                window.Settings.setSetting('theme', theme);
                                window.Settings.setSetting('uiTheme', theme);
                            }}
                            
                            // Method 6: Try to find and interact with the theme selector UI
                            setTimeout(() => {{
                                try {{
                                    // Look for the actual theme selector in DevTools UI
                                    const selectors = [
                                        'select[aria-label*="theme" i]',
                                        'select[title*="theme" i]',
                                        '.toolbar-select[aria-label*="theme" i]',
                                        '[data-key="ui-theme"]',
                                        'select.toolbar-select'
                                    ];
                                    
                                    for (const selector of selectors) {{
                                        const select = document.querySelector(selector);
                                        if (select && select.options) {{
                                            for (let i = 0; i < select.options.length; i++) {{
                                                const option = select.options[i];
                                                if (option.value === theme || 
                                                    option.text.toLowerCase().includes(theme)) {{
                                                    select.value = option.value;
                                                    select.dispatchEvent(new Event('change', {{ bubbles: true }}));
                                                    console.log('DevTools: Set theme via UI selector');
                                                    break;
                                                }}
                                            }}
                                        }}
                                    }}
                                }} catch (e) {{
                                    // Ignore errors in UI selector search
                                }}
                            }}, 2500);
                            
                            return true;
                        }} catch (e) {{
                            console.error('Error applying dev tools theme:', e);
                            return false;
                        }}
                    }})();
                    """
                    dev_tools_page.runJavaScript(theme_js)
                
                # Also monitor for theme changes to save user's manual preference
                def monitor_theme_changes():
                    """Monitor for theme changes and save to our settings"""
                    monitor_js = """
                    (function() {
                        try {
                            // Monitor localStorage changes
                            const originalSetItem = window.localStorage.setItem;
                            window.localStorage.setItem = function(key, value) {
                                originalSetItem.apply(this, arguments);
                                if (key === 'theme' || key === 'uiTheme' || key === 'devtools-theme') {
                                    // Notify Python about theme change
                                    if (window.qt && window.qt.webChannelTransport) {
                                        // Try to send message back to Python
                                        console.log('DevTools theme changed to:', value);
                                    }
                                }
                            };
                            
                            // Also listen for theme change events
                            window.addEventListener('theme-changed', function(e) {
                                console.log('DevTools theme change event:', e.detail);
                            });
                            
                            return true;
                        } catch (e) {
                            return false;
                        }
                    })();
                    """
                    dev_tools_page.runJavaScript(monitor_js)
                
                # Connect to page load to apply theme when dev tools loads
                def on_dev_tools_load_finished(success):
                    if success:
                        # Apply theme with multiple attempts at different times
                        QTimer.singleShot(500, lambda: apply_dev_tools_theme(dev_tools_theme))
                        QTimer.singleShot(1000, lambda: apply_dev_tools_theme(dev_tools_theme))
                        QTimer.singleShot(2000, lambda: apply_dev_tools_theme(dev_tools_theme))
                        QTimer.singleShot(3000, lambda: apply_dev_tools_theme(dev_tools_theme))
                        # Monitor for changes
                        QTimer.singleShot(2000, monitor_theme_changes)
                
                dev_tools_page.loadFinished.connect(on_dev_tools_load_finished)
                
                # Also try immediately with delays
                QTimer.singleShot(500, lambda: apply_dev_tools_theme(dev_tools_theme))
                QTimer.singleShot(1500, lambda: apply_dev_tools_theme(dev_tools_theme))
                
                # Save geometry when window closes
                def save_geometry_on_close(event):
                    if self.dev_tools_window:
                        geom = self.dev_tools_window.geometry()
                        self.settings["dev_tools_geometry"] = {
                            "x": geom.x(),
                            "y": geom.y(),
                            "width": geom.width(),
                            "height": geom.height()
                        }
                        
                        # Try to read current theme from DevTools before closing
                        def read_theme():
                            read_theme_js = """
                            (function() {
                                try {
                                    const theme = window.localStorage.getItem('theme') || 
                                                 window.localStorage.getItem('uiTheme') || 
                                                 window.localStorage.getItem('devtools-theme') || 
                                                 'dark';
                                    return theme;
                                } catch (e) {
                                    return 'dark';
                                }
                            })();
                            """
                            def on_theme_read(theme):
                                if theme and isinstance(theme, str):
                                    self.settings["dev_tools_theme"] = theme
                                    logger.debug(f"DevTools: Saved theme preference: {theme}")
                                self.save_settings()
                            
                            if self.dev_tools_page:
                                self.dev_tools_page.runJavaScript(read_theme_js, on_theme_read)
                            else:
                                self.save_settings()
                        
                        # Try to read theme, but don't wait too long
                        QTimer.singleShot(100, read_theme)
                        
                        self.save_settings()
                    # Hide developer menu options when dev tools closes
                    self.bandcamp_action.setVisible(False)
                    self.compact_action.setVisible(False)
                    self.frameless_action.setVisible(False)
                    self.transparent_overlay_action.setVisible(False)
                    event.accept()
                
                # Override close event to save geometry
                self.dev_tools_window.closeEvent = save_geometry_on_close
                
                # Show the window
                self.dev_tools_window.show()
                self.dev_tools_window.raise_()
                self.dev_tools_window.activateWindow()
                
                # Show developer menu options when dev tools opens
                self.bandcamp_action.setVisible(True)
                self.compact_action.setVisible(True)
                self.frameless_action.setVisible(True)
                self.transparent_overlay_action.setVisible(True)
            except Exception as e:
                QMessageBox.warning(self, "Developer Tools Error", 
                                  f"Failed to open developer tools:\n\n{str(e)}")
                self.dev_tools_window = None
        else:
            # Save geometry before hiding
            try:
                if self.dev_tools_window:
                    geom = self.dev_tools_window.geometry()
                    self.settings["dev_tools_geometry"] = {
                        "x": geom.x(),
                        "y": geom.y(),
                        "width": geom.width(),
                        "height": geom.height()
                    }
                    self.save_settings()
                # Hide the window
                self.dev_tools_window.hide()
                
                # Hide developer menu options when dev tools closes
                self.bandcamp_action.setVisible(False)
                self.compact_action.setVisible(False)
                self.frameless_action.setVisible(False)
                self.transparent_overlay_action.setVisible(False)
                # Clear dev tools page reference
                self.dev_tools_page = None
            except Exception as e:
                QMessageBox.warning(self, "Developer Tools Error", 
                                  f"Error closing developer tools:\n\n{str(e)}")
                self.dev_tools_window = None
                self.dev_tools_page = None
    
    def _trigger_inspect_at_position(self, position):
        """Trigger inspect at position - ensures dev tools is open first"""
        # Check if dev tools is open, if not wait a bit more
        if not self.dev_tools_window or not self.dev_tools_window.isVisible():
            # Wait a bit more and try again
            QTimer.singleShot(500, lambda: self._trigger_inspect_at_position(position))
            return
        # Dev tools is open, trigger inspect
        self.inspect_element_at_position(position)
    
    def inspect_element_at_position(self, position):
        """Inspect element at the given position in the web view - only works when dev tools are open"""
        # Only proceed if dev tools are open
        if not self.dev_tools_window or not self.dev_tools_window.isVisible():
            return
        
        # Convert widget position to content coordinates (accounting for zoom)
        zoom_factor = self.web_view.zoomFactor()
        content_x = position.x() / zoom_factor
        content_y = position.y() / zoom_factor
        
        # Use Chrome DevTools Protocol to select the element
        # First, get the element and its node ID, then select it in dev tools
        js_code = f"""
        (function() {{
            try {{
                // Get element at the click position
                const element = document.elementFromPoint({content_x}, {content_y});
                if (!element) {{
                    console.log('Bandcamp Player: No element found at position');
                    return null;
                }}
                
                // Store element reference
                window.__elementToInspect = element;
                
                // Try to get a unique identifier for the element
                // We'll use a combination of tag name, class, and position
                const tagName = element.tagName || 'UNKNOWN';
                const className = element.className || '';
                const id = element.id || '';
                
                return {{
                    tagName: tagName,
                    className: className,
                    id: id,
                    x: {content_x},
                    y: {content_y}
                }};
            }} catch (e) {{
                console.error('Bandcamp Player: Error getting element:', e);
                return null;
            }}
        }})();
        """
        
        def on_js_result(result):
            if not result:
                return
            
            # Now select the element in dev tools using Chrome DevTools Protocol
            # We need to inject into the dev tools page to use the protocol
            self._select_element_in_dev_tools(content_x, content_y)
        
        # Run JavaScript to get element info
        self.web_view.page().runJavaScript(js_code, on_js_result)
    
    def _select_element_in_dev_tools(self, x, y):
        """Select element in dev tools Elements panel using Chrome DevTools Protocol"""
        # First, highlight the element in the main page
        js_code = f"""
        (function() {{
            try {{
                // Get element at position (prefer stored reference, fallback to elementFromPoint)
                let element = window.__elementToInspect;
                if (!element) {{
                    element = document.elementFromPoint({x}, {y});
                }}
                
                if (!element) {{
                    console.log('Bandcamp Player: No element found at position for dev tools');
                    return false;
                }}
                
                // Scroll element into view
                element.scrollIntoView({{ behavior: 'smooth', block: 'center' }});
                
                // Highlight the element with a blue outline
                const originalOutline = element.style.outline;
                const originalOutlineOffset = element.style.outlineOffset;
                element.style.outline = '2px solid #4285f4';
                element.style.outlineOffset = '2px';
                
                // Remove highlight after 3 seconds
                setTimeout(() => {{
                    element.style.outline = originalOutline;
                    element.style.outlineOffset = originalOutlineOffset;
                }}, 3000);
                
                return true;
            }} catch (e) {{
                console.error('Bandcamp Player: Error highlighting element:', e);
                return false;
            }}
        }})();
        """
        
        self.web_view.page().runJavaScript(js_code)
        
        # Now try to select the element in dev tools Elements panel
        # We need to use Chrome DevTools Protocol via the dev tools page
        if self.dev_tools_page:
            # Wait a bit for dev tools to be ready, then inject selection command
            QTimer.singleShot(200, lambda: self._inject_element_selection(x, y))
    
    def _inject_element_selection(self, x, y):
        """Inject JavaScript into dev tools page to select element in Elements panel"""
        if not self.dev_tools_page:
            return
        
        # JavaScript to inject into the dev tools page
        # This uses Chrome DevTools Protocol commands
        dev_tools_js = f"""
        (function() {{
            try {{
                // Access the Chrome DevTools Protocol
                if (window.DevToolsAPI && window.DevToolsAPI.inspectElement) {{
                    // Use the inspectElement method if available
                    window.DevToolsAPI.inspectElement({x}, {y});
                    return true;
                }}
                
                // Alternative: Try to use the inspector's selectNodeForLocation method
                if (window.InspectorFrontendHost && window.InspectorFrontendHost.inspect) {{
                    window.InspectorFrontendHost.inspect({x}, {y});
                    return true;
                }}
                
                // Fallback: Try to dispatch a message to the inspector
                if (window.postMessage) {{
                    window.postMessage({{
                        method: 'DOM.getNodeForLocation',
                        params: {{ x: {x}, y: {y} }}
                    }}, '*');
                    return true;
                }}
                
                return false;
            }} catch (e) {{
                console.error('Bandcamp Player: Error selecting element in dev tools:', e);
                return false;
            }}
        }})();
        """
        
        # Inject into the dev tools page
        self.dev_tools_page.runJavaScript(dev_tools_js)
    
    def update_playlist_display(self):
        """Update the playlist display"""
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            self.playlist_sidebar.load_playlist()
    
    def on_playlist_item_clicked(self, item):
        """Handle playlist item double-click (backward compatibility)"""
        # This is now handled by the sidebar
        pass
    
    def apply_settings(self):
        """Apply saved settings"""
        self.apply_always_on_top()
        self.apply_frameless_mode()
        # Apply rounded corners if frameless mode is enabled
        if self.frameless_mode:
            QTimer.singleShot(100, self.apply_rounded_corners)
            # Ensure bottom resize handle is created and positioned
            QTimer.singleShot(150, lambda: self.update_bottom_resize_handle_position() if hasattr(self, 'bottom_resize_handle') and self.bottom_resize_handle else None)
        # Update mini mode button visibility
        if hasattr(self, 'mini_mode_btn'):
            self.update_mini_mode_button()
        # Update always on top button icon color if it exists
        if hasattr(self, 'always_on_top_btn'):
            if HAS_QT_AWESOME:
                icon_color = '#4a9eff' if self.always_on_top else '#e0e0e0'
                icon = get_icon('thumbtack', color=icon_color)
                if icon:
                    self.always_on_top_btn.setIcon(icon)
        if self.web_view:
            # Always inject CSS (for regular mode or as base for mini/micro mode)
            self.inject_css()
            # Note: Mini mode is applied separately in __init__ with minimal delay
            # to prevent flash of regular mode before switching
    
    def load_settings(self):
        """Load settings from file"""
        if self.settings_file.exists():
            try:
                with open(self.settings_file, 'r') as f:
                    settings = json.load(f)
                    # Ensure bandcamp_mode exists (default to True for new installs)
                    if 'bandcamp_mode' not in settings:
                        settings['bandcamp_mode'] = True
                    # Ensure compact_mode exists (default to True for new installs)
                    if 'compact_mode' not in settings:
                        settings['compact_mode'] = True
                    # Ensure autoplay exists (default to True for new installs)
                    if 'autoplay' not in settings:
                        settings['autoplay'] = True
                    # Ensure mini_mode_state exists (default to 0 for new installs)
                    if 'mini_mode_state' not in settings:
                        settings['mini_mode_state'] = 0
                    # Ensure autohide_address_bar exists (default to True for new installs)
                    if 'autohide_address_bar' not in settings:
                        settings['autohide_address_bar'] = True
                    # Ensure mini_mode_player_autohide exists (default to False for new installs)
                    if 'mini_mode_player_autohide' not in settings:
                        settings['mini_mode_player_autohide'] = False
                    # Ensure autoplay_on_startup exists (default to True for new installs)
                    if 'autoplay_on_startup' not in settings:
                        settings['autoplay_on_startup'] = True
                    # Ensure playlist_visible exists (default to True for new installs)
                    if 'playlist_visible' not in settings:
                        settings['playlist_visible'] = True
                    # Ensure playlist_minimized exists (default to True for new installs)
                    if 'playlist_minimized' not in settings:
                        settings['playlist_minimized'] = True
                    # Ensure repeat_mode exists (default to 1 for new installs - continuous)
                    if 'repeat_mode' not in settings:
                        settings['repeat_mode'] = 1
                    # Ensure nano_always_on_top exists (default to True for new installs)
                    if 'nano_always_on_top' not in settings:
                        settings['nano_always_on_top'] = True
                    return settings
            except:
                pass
        return {}
    
    def save_settings(self):
        """Save settings to file"""
        # No longer storing mini_mode_original_size - each mode uses fixed defaults
        
        # Save current playlist file path (relative to Playlists directory)
        current_playlist_file = None
        if hasattr(self, 'playlist_manager') and self.playlist_manager:
            playlist_file = self.playlist_manager.playlist_file
            if playlist_file:
                # Store relative path to Playlists directory for portability
                try:
                    rel_path = playlist_file.relative_to(self.playlist_manager.playlists_dir)
                    current_playlist_file = str(rel_path)
                except ValueError:
                    # If not relative, store the filename only
                    current_playlist_file = playlist_file.name
        
        # Get current track number for saving (from main window - updated continuously)
        current_track_to_save = None
        if hasattr(self, '_current_track_number') and self._current_track_number is not None:
            current_track_to_save = self._current_track_number
        # Fallback: try nano player if main window doesn't have it
        elif hasattr(self, 'nano_player_window') and self.nano_player_window and hasattr(self.nano_player_window, '_current_track_number'):
            current_track_to_save = self.nano_player_window._current_track_number
        # If still None, preserve the existing saved value (don't overwrite with None during startup)
        elif current_track_to_save is None:
            current_track_to_save = self.settings.get("last_played_track_number")
        
        # Update existing settings with current state, preserving other keys
        self.settings.update({
            "compact_mode": self.compact_mode,
            "bandcamp_mode": self.bandcamp_mode,
            "always_on_top": self.always_on_top,
            "frameless_mode": self.frameless_mode,
            "mini_mode_state": self.mini_mode_state,
            "autohide_address_bar": self.autohide_address_bar,
            "mini_mode_player_autohide": self.mini_mode_player_autohide,
            "mini_mode_player_hidden": self.mini_mode_player_hidden,
            "current_playlist_file": current_playlist_file,  # Save current playlist file
            "autoplay": self.autoplay,
            "autoplay_on_startup": self.autoplay_on_startup,
            "last_played_url": self.settings.get("last_played_url"),  # Preserve last played URL
            "last_played_track_number": current_track_to_save,  # Save current track number
            "playlist_visible": self.settings.get("playlist_visible", False),  # Preserve playlist visibility
            "playlist_minimized": self.settings.get("playlist_minimized", False),  # Preserve playlist minimized state
            "playlist_height": self.settings.get("playlist_height", 250),  # Preserve playlist height
            "playlist_detached": self.settings.get("playlist_detached", False),  # Preserve playlist detached state
            "playlist_detached_offset": self.settings.get("playlist_detached_offset", (20, 0)),  # Preserve detached window offset
            "playlist_detached_size": self.settings.get("playlist_detached_size", "260x400"),  # Preserve detached window size
            # These are now explicitly updated from the sidebar in closeEvent
            "shuffle_on": self.settings.get("shuffle_on", False),  # Preserve shuffle state
            "repeat_on": self.settings.get("repeat_on", False),  # Preserve repeat state (default to False)
            "keyboard_shortcuts": self.settings.get("keyboard_shortcuts", {}),  # Preserve keyboard shortcuts
            "auto_check_updates": self.settings.get("auto_check_updates", True),  # Preserve auto-check updates setting
        })
        try:
            with open(self.settings_file, 'w') as f:
                json.dump(self.settings, f, indent=2)
        except:
            pass
    
    def _get_version_string(self):
        """Get formatted version string for display.
        
        Returns:
            "vX.X.X" or "vX.X.X (Launcher vX.X.X)" if launcher mode
        """
        gui_version = __version__
        launcher_version = self._get_launcher_version()
        
        if launcher_version:
            return f"v{gui_version} (Launcher v{launcher_version})"
        else:
            return f"v{gui_version}"
    
    def _get_launcher_version(self):
        """Get launcher version if running in launcher mode."""
        launcher_version = os.environ.get('BANDCAMP_PLAYER_LAUNCHER_VERSION')
        return launcher_version if launcher_version else None
    
    def _show_about_dialog(self):
        """Show About dialog"""
        version_string = self._get_version_string()
        about_text = f"""Bandcamp Player
{version_string}

A standalone mini player for Bandcamp built with PyQt6 and QWebEngineView.

Features:
 Mini, Micro, and Nano player modes
 Playlist management with shuffle and repeat modes
 Keyboard shortcuts and global hotkeys
 Image viewer for album artwork
 Auto-update system
 Customizable UI and settings

GitHub: https://github.com/kameryn1811/Bandcamp-Player

This player provides a lightweight, desktop-friendly interface for streaming music from Bandcamp."""
        
        QMessageBox.about(self, "About Bandcamp Player", about_text)
    
    def on_auto_check_updates_change(self):
        """Handle auto-check for updates checkbox change."""
        auto_check = self.auto_check_updates_action.isChecked()
        self.settings["auto_check_updates"] = auto_check
        self.save_settings()
    
    def check_for_updates(self, show_if_no_update=True):
        """Check for updates by reading version directly from main branch.
        
        Args:
            show_if_no_update: If True, show message even if no update is available (for manual check)
        """
        def check():
            try:
                try:
                    import requests
                    import re
                except ImportError:
                    error_msg = "The 'requests' library is required for update checking.\n\nPlease install it:\npython -m pip install requests"
                    logger.error(error_msg)
                    if show_if_no_update:
                        QTimer.singleShot(0, lambda: QMessageBox.warning(
                            self,
                            "Update Check Failed",
                            error_msg
                        ))
                    return
                
                # GitHub repository info
                repo_owner = "kameryn1811"
                repo_name = "Bandcamp-Player"
                
                # Get version directly from main branch file (not from releases)
                download_url = f"https://raw.githubusercontent.com/{repo_owner}/{repo_name}/main/bandcamp_pl_gui.py"
                logger.debug(f"Checking for updates from: {download_url}")
                
                response = requests.get(download_url, timeout=10)
                response.raise_for_status()
                file_content = response.text
                
                logger.debug(f"Fetched file content, length: {len(file_content)} characters")
                
                # Extract version from the file
                version_match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', file_content)
                if not version_match:
                    error_msg = "Could not find version number in main branch file."
                    logger.error(error_msg)
                    if show_if_no_update:
                        QTimer.singleShot(0, lambda: QMessageBox.warning(
                            self,
                            "Update Check Failed",
                            error_msg
                        ))
                    return
                
                latest_version = version_match.group(1)
                current_version = __version__
                
                logger.info(f"Version check: Current={current_version}, Latest={latest_version}")
                
                # Compare versions
                comparison_result = self._compare_versions(latest_version, current_version)
                logger.debug(f"Version comparison result: {comparison_result} (1=newer, 0=same, -1=older)")
                
                if comparison_result > 0:
                    # Update available - show popup
                    logger.info(f"Update available: v{current_version}  v{latest_version}")
                    
                    # Try to fetch commit message from GitHub API
                    release_notes = self._fetch_commit_message(repo_owner, repo_name, latest_version)
                    
                    # Show update dialog - use QTimer to ensure it runs on main thread
                    # Store values as instance variables to avoid closure issues
                    self._pending_update_info = {
                        'current_version': current_version,
                        'latest_version': latest_version,
                        'download_url': download_url,
                        'release_notes': release_notes
                    }
                    QTimer.singleShot(0, self._show_pending_update_popup)
                elif comparison_result == 0:
                    # Versions are the same - already up to date
                    logger.info(f"Already up to date (current: v{current_version}, latest: v{latest_version})")
                    if show_if_no_update:
                        # User manually checked, show "up to date" message
                        # Store values to avoid closure issues
                        msg_current_version = current_version
                        QTimer.singleShot(0, lambda v=msg_current_version: QMessageBox.information(
                            self,
                            "Update Check",
                            f"You're running the latest version (v{v})\n\nNo updates available."
                        ))
                else:
                    # Current version is newer than latest (shouldn't happen, but handle gracefully)
                    logger.warning(f"Current version ({current_version}) is newer than latest ({latest_version})")
                    if show_if_no_update:
                        msg_current_version = current_version
                        QTimer.singleShot(0, lambda v=msg_current_version: QMessageBox.information(
                            self,
                            "Update Check",
                            f"You're running version v{v}\n\nThis appears to be a development or pre-release version."
                        ))
            except requests.exceptions.RequestException as e:
                error_msg = f"Could not check for updates.\n\nError: {str(e)}\n\nPlease check your internet connection."
                logger.error(f"Update check failed (network error): {e}", exc_info=True)
                if show_if_no_update:
                    QTimer.singleShot(0, lambda: QMessageBox.warning(
                        self,
                        "Update Check Failed",
                        error_msg
                    ))
            except Exception as e:
                error_msg = f"An error occurred while checking for updates.\n\nError: {str(e)}"
                logger.error(f"Update check failed (unexpected error): {e}", exc_info=True)
                if show_if_no_update:
                    QTimer.singleShot(0, lambda: QMessageBox.warning(
                        self,
                        "Update Check Failed",
                        error_msg
                    ))
        
        # Run in background thread to avoid blocking UI
        import threading
        threading.Thread(target=check, daemon=True).start()
    
    def _check_for_updates_background(self):
        """Check for updates in background (non-blocking, no popup if up to date)."""
        self.check_for_updates(show_if_no_update=False)
    
    def _compare_versions(self, version1, version2):
        """Compare two version strings.
        
        Returns:
            -1 if version1 < version2
             0 if version1 == version2
             1 if version1 > version2
        """
        def version_tuple(v):
            parts = []
            for part in v.split('.'):
                try:
                    parts.append(int(part))
                except ValueError:
                    parts.append(0)
            return tuple(parts)
        
        v1_tuple = version_tuple(version1)
        v2_tuple = version_tuple(version2)
        
        max_len = max(len(v1_tuple), len(v2_tuple))
        v1_tuple = v1_tuple + (0,) * (max_len - len(v1_tuple))
        v2_tuple = v2_tuple + (0,) * (max_len - len(v2_tuple))
        
        if v1_tuple < v2_tuple:
            return -1
        elif v1_tuple > v2_tuple:
            return 1
        else:
            return 0
    
    def _fetch_commit_message(self, repo_owner, repo_name, version):
        """Fetch the commit message for the latest commit that modified bandcamp_pl_gui.py."""
        try:
            import requests
            
            # Get the latest commit that modified bandcamp_pl_gui.py on main branch
            api_url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/commits"
            params = {
                'path': 'bandcamp_pl_gui.py',
                'sha': 'main',
                'per_page': 1
            }
            
            response = requests.get(api_url, params=params, timeout=10)
            response.raise_for_status()
            commits = response.json()
            
            if commits and len(commits) > 0:
                commit_message = commits[0].get('commit', {}).get('message', '')
                # Clean up the commit message
                lines = commit_message.strip().split('\n')
                if len(lines) > 1 and (lines[0].startswith('v') or lines[0] == version):
                    commit_message = '\n'.join(lines[1:]).strip()
                return commit_message
            
            return ""
        except Exception as e:
            logger.debug(f"Could not fetch commit message: {str(e)}")
            return ""
    
    def _show_pending_update_popup(self):
        """Show pending update popup (called from main thread via QTimer)."""
        if hasattr(self, '_pending_update_info') and self._pending_update_info:
            info = self._pending_update_info
            self._show_update_popup(
                info.get('current_version'),
                info.get('latest_version'),
                info.get('download_url'),
                info.get('release_notes', '')
            )
            # Clear pending info
            self._pending_update_info = None
    
    def _show_update_popup(self, current_version, latest_version, download_url, release_notes=""):
        """Show update available popup."""
        if not current_version or not latest_version:
            QMessageBox.warning(
                self,
                "Update Error",
                f"Invalid version information detected.\n\n"
                f"Current: {current_version}\n"
                f"Latest: {latest_version}\n\n"
                f"Please check for updates manually."
            )
            return
        
        if not download_url:
            QMessageBox.warning(
                self,
                "Update Error",
                "No download URL available. Please download manually from GitHub."
            )
            return
        
        # Format release notes (first few lines)
        notes_preview = ""
        if release_notes and release_notes.strip():
            cleaned_notes = release_notes.strip()
            lines = [line for line in cleaned_notes.split('\n') if line.strip()]
            if lines:
                preview_lines = lines[:8]
                notes_preview = "\n\n" + "\n".join(preview_lines)
                if len(lines) > 8:
                    notes_preview += "\n..."
        
        # Build message
        message = (
            f"A new version is available!\n\n"
            f"Current version: v{current_version}\n"
            f"Latest version: v{latest_version}"
        )
        
        if notes_preview:
            message += notes_preview
        
        message += (
            f"\n\nWould you like to update now?\n\n"
            f"Note: In launcher mode, the launcher will handle the update automatically."
        )
        
        response = QMessageBox.question(
            self,
            "Update Available",
            message,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if response == QMessageBox.StandardButton.Yes:
            # User approved update - trigger download
            if os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1':
                # In launcher mode, create flag file to trigger launcher download
                try:
                    launcher_dir = Path(__file__).parent
                    flag_file = launcher_dir / "update_download_flag.json"
                    flag_data = {
                        "download": True,
                        "version": latest_version,
                        "download_url": download_url,
                        "timestamp": time.time()
                    }
                    with open(flag_file, 'w', encoding='utf-8') as f:
                        json.dump(flag_data, f)
                    
                    QMessageBox.information(
                        self,
                        "Update",
                        f"Update to v{latest_version} will be downloaded and applied on next restart.\n\n"
                        "Please restart the application to complete the update."
                    )
                except Exception as e:
                    logger.error(f"Failed to trigger update download: {e}")
                    QMessageBox.warning(
                        self,
                        "Update Error",
                        f"Failed to trigger update download:\n{str(e)}\n\n"
                        "Please download manually from GitHub."
                    )
            else:
                QMessageBox.information(
                    self,
                    "Update",
                    "Please download the latest version from GitHub:\n\n"
                    f"https://github.com/kameryn1811/Bandcamp-Player"
                )
        else:
            # User declined update - do nothing
            logger.info(f"User declined update to v{latest_version}")
    
    def extract_artist_album_from_url(self, url):
        """Extract Artist - Album format from Bandcamp URL
        
        Returns:
            String like "Artist - Album" or "Artist" or None
        """
        if not url or 'bandcamp.com' not in url.lower():
            return None
        
        try:
            from urllib.parse import urlparse
            import re
            
            # Clean URL
            url = url.rstrip(' \t,;')
            if not url.startswith(('http://', 'https://')):
                url = 'https://' + url
            
            parsed = urlparse(url)
            hostname = parsed.hostname or ""
            
            # Extract artist from subdomain
            artist = None
            if ".bandcamp.com" in hostname.lower():
                subdomain = hostname.lower().replace(".bandcamp.com", "")
                if "-" in subdomain:
                    artist = " ".join(word.capitalize() for word in subdomain.split("-"))
                else:
                    words = re.findall(r'[a-z]+|[A-Z][a-z]*', subdomain)
                    if len(words) > 1:
                        artist = " ".join(word.capitalize() for word in words)
                    else:
                        # Single word (all lowercase or no camelCase) - try to split on common word endings
                        # Common word endings that might indicate a word boundary
                        common_endings = ['pony', 'ponies', 'music', 'records', 'label', 'band', 'group', 'crew', 'team', 'sound', 'audio', 'tunes', 'tracks']
                        subdomain_lower = subdomain.lower()
                        for ending in common_endings:
                            if subdomain_lower.endswith(ending) and len(subdomain_lower) > len(ending):
                                # Split before the ending
                                prefix = subdomain_lower[:-len(ending)]
                                if len(prefix) > 0:
                                    # Capitalize both parts
                                    artist = f"{prefix.capitalize()} {ending.capitalize()}"
                                    break
                        
                        # Final fallback: just capitalize the first letter
                        if not artist:
                            artist = subdomain.capitalize()
            
            if not artist:
                return None
            
            # Extract path components
            path = parsed.path.strip('/')
            path_parts = [p for p in path.split('/') if p]
            
            # Determine type and extract name
            if not path_parts:
                return artist  # Artist page
            elif len(path_parts) >= 2:
                # URL format: artist.bandcamp.com/album/album-name
                # or: artist.bandcamp.com/track/track-name
                if path_parts[0] in ['album', 'track']:
                    name = path_parts[1]
                    name = " ".join(word.capitalize() for word in name.split("-"))
                    return f"{artist} - {name}"
                else:
                    # Direct format: artist.bandcamp.com/album-name
                    name = path_parts[0]
                    name = " ".join(word.capitalize() for word in name.split("-"))
                    return f"{artist} - {name}"
            elif len(path_parts) == 1:
                # Single path part - could be album or track name
                name = path_parts[0]
                name = " ".join(word.capitalize() for word in name.split("-"))
                return f"{artist} - {name}"
            else:
                return artist  # Unknown format, return artist
            
        except Exception as e:
            logger.debug(f"Error extracting artist/album from URL: {e}")
            return None
    
    def extract_metadata_from_page(self):
        """Extract artist and album metadata from the page DOM and update playlist item"""
        if not self.web_view or not self.web_view.page():
            return
        
        def on_metadata_extracted(result):
            """Callback when metadata is extracted from page DOM"""
            if not result or not isinstance(result, dict):
                return
            
            current_url = self.web_view.url().toString() if self.web_view else None
            if not current_url:
                return
            
            # Extract artist and album from the result
            artist = result.get('artist', '').strip()
            album = result.get('album', '').strip()
            
            # Build display text in "Artist - Album" format
            display_text = None
            if artist and album:
                # Album page: "Artist - Album"
                display_text = f"{artist} - {album}"
            elif artist:
                # Just artist (fallback)
                display_text = artist
            elif album:
                # Just album (fallback)
                display_text = album
            
            if display_text and hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
                # Update the playlist item for this URL
                self.playlist_sidebar.update_item_display(current_url, display_text)
                # Save the metadata to the playlist file so it persists
                if hasattr(self, 'playlist_manager') and self.playlist_manager:
                    self.playlist_manager.update_url_metadata(current_url, display_text)
                logger.debug(f"Updated playlist metadata from page: {current_url} -> {display_text}")
        
        # Extract metadata from page using JavaScript
        # Get album name from .tralbum-name and artist from .tralbum-artist (removing "by " prefix)
        js_code = """
        (function() {
            try {
                var albumElement = document.querySelector('.tralbum-name');
                var artistElement = document.querySelector('.tralbum-artist');
                
                var album = '';
                var artist = '';
                
                if (albumElement) {
                    album = albumElement.textContent.trim();
                }
                
                if (artistElement) {
                    var artistText = artistElement.textContent.trim();
                    // Remove "by " prefix if present
                    if (artistText.toLowerCase().startsWith('by ')) {
                        artist = artistText.substring(3).trim();
                    } else {
                        artist = artistText;
                    }
                }
                
                return {
                    'album': album,
                    'artist': artist
                };
            } catch (e) {
                return {'album': '', 'artist': ''};
            }
        })();
        """
        
        self.web_view.page().runJavaScript(js_code, on_metadata_extracted)
    
    def update_title_from_page(self):
        """Update window title from page title (extract Artist - Album format)"""
        def extract_title(title_text):
            """Extract Artist - Album from page title"""
            if not title_text:
                return None
            
            # Common Bandcamp title formats:
            # "Album Name, by Artist Name | Bandcamp"
            # "Track Name, by Artist Name | Bandcamp"
            # "Artist Name | Bandcamp"
            
            # Remove " | Bandcamp" suffix
            title_text = title_text.replace(" | Bandcamp", "").strip()
            
            # Try to extract "Album/Track, by Artist" format
            if ", by " in title_text:
                parts = title_text.split(", by ")
                if len(parts) == 2:
                    album_or_track = parts[0].strip()
                    artist = parts[1].strip()
                    return f"{artist} - {album_or_track}"
            
            # If no "by" format, try to parse other formats
            # Sometimes it's just "Artist Name" or "Album Name"
            return title_text
        
        def on_title_received(result):
            """Callback when page title is received"""
            if result:
                title_text = result if isinstance(result, str) else str(result)
                extracted_title = extract_title(title_text)
                if extracted_title:
                    # Always append "- Bandcamp Player" to the title for reliable window detection
                    full_title = f"{extracted_title} - Bandcamp Player"
                    QMainWindow.setWindowTitle(self, full_title)
                    if self.window_title_label:
                        # Only show the extracted title (without suffix) in the UI
                        self.window_title_label.setText(extracted_title)
                else:
                    # No valid title extracted - check if welcome widget is visible (empty state)
                    if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
                        QMainWindow.setWindowTitle(self, "Empty - Bandcamp Player")
                        if self.window_title_label:
                            self.window_title_label.setText("Empty")
            else:
                # No result - check if welcome widget is visible (empty state)
                if hasattr(self, 'welcome_widget') and self.welcome_widget and self.welcome_widget.isVisible():
                    QMainWindow.setWindowTitle(self, "Empty - Bandcamp Player")
                    if self.window_title_label:
                        self.window_title_label.setText("Empty")
        
        # Get page title from web view
        if self.web_view and self.web_view.page():
            # Connect to title changed signal
            try:
                self.web_view.page().titleChanged.disconnect()
            except:
                pass
            self.web_view.page().titleChanged.connect(lambda title: on_title_received(title))
            # Also try to get current title immediately
            self.web_view.page().runJavaScript("document.title", on_title_received)
    
    def closeEvent(self, event):
        """Handle window close event"""
        # Keyboard shortcuts are automatically cleaned up by Qt
        # No need to manually remove them
        
        # Close developer tools window if open
        if hasattr(self, 'dev_tools_window') and self.dev_tools_window:
            try:
                # Save geometry before closing
                if self.dev_tools_window.isVisible():
                    geom = self.dev_tools_window.geometry()
                    self.settings["dev_tools_geometry"] = {
                        "x": geom.x(),
                        "y": geom.y(),
                        "width": geom.width(),
                        "height": geom.height()
                    }
                # Close the developer tools window
                self.dev_tools_window.close()
                self.dev_tools_window = None
                self.dev_tools_page = None
            except Exception as e:
                logger.warning(f"Error closing developer tools: {e}")
        
        # Get current track number before closing (if available)
        # Main window should already have it from periodic updates, but sync from nano player as fallback
        if (not hasattr(self, '_current_track_number') or self._current_track_number is None) and \
           hasattr(self, 'nano_player_window') and self.nano_player_window and \
           hasattr(self.nano_player_window, '_current_track_number'):
            self._current_track_number = self.nano_player_window._current_track_number
            logger.debug(f"closeEvent: Got track number from nano player (fallback): {self._current_track_number}")
        else:
            logger.debug(f"closeEvent: Using main window track number: {getattr(self, '_current_track_number', None)}")
        
        # Save window geometry before closing
        try:
            geometry = self.saveGeometry()
            self.settings["window_geometry"] = geometry.toHex().data().decode()
        except Exception as e:
            print(f"Could not save window geometry: {e}")
        
        # Save playlist state before closing
        if hasattr(self, 'playlist_sidebar') and self.playlist_sidebar:
            # Only save visibility if not detached (detached playlist is always "visible" in its own window)
            if not self.playlist_detached:
                # If in nano mode, the main window is hidden so isVisible() will return False
                # even if the playlist was visible. We saved the state when entering nano mode,
                # so use that saved state (it's already in settings from _enter_nano_mode)
                if hasattr(self, '_main_window_hidden_for_nano') and self._main_window_hidden_for_nano:
                    # In nano mode - state was already saved when entering nano mode
                    # Just ensure it's still in settings (it should be)
                    if 'playlist_visible' not in self.settings:
                        # Fallback: if somehow not saved, assume visible if container exists
                        self.settings['playlist_visible'] = hasattr(self, 'playlist_container') and self.playlist_container is not None
                else:
                    # Not in nano mode - use actual visibility
                    self.settings['playlist_visible'] = self.playlist_sidebar.isVisible()
            else:
                # If detached, save as visible (since it's visible in detached window)
                self.settings['playlist_visible'] = True
            if hasattr(self.playlist_sidebar, 'is_minimized'):
                # Only update attached minimized state when playlist is attached.
                # When detached we force-expand, so updating this would lose the user's attached preference.
                if not self.playlist_detached:
                    self.settings['playlist_minimized'] = self.playlist_sidebar.is_minimized
                    self.settings['playlist_attached_minimized'] = self.playlist_sidebar.is_minimized
            if hasattr(self.playlist_sidebar, '_restore_height'):
                playlist_height_to_save = self.playlist_sidebar._restore_height
            else:
                playlist_height_to_save = self.playlist_sidebar.height() if self.playlist_sidebar else self.settings.get('playlist_height', 250)
            
            # Save playlist height
            self.settings['playlist_height'] = playlist_height_to_save
            
            # If not in micro mode, also save to playlist_height_regular
            # This ensures we preserve the regular/mini mode height even if app is closed in micro mode
            if self.mini_mode_state != 2 and playlist_height_to_save != 135:
                self.settings['playlist_height_regular'] = playlist_height_to_save
                logger.debug(f"Saved playlist_height_regular on close: {playlist_height_to_save}")
            
            # Explicitly save shuffle and repeat modes from the sidebar
            self.settings['shuffle_mode'] = self.playlist_sidebar.shuffle_mode
            self.settings['repeat_mode'] = self.playlist_sidebar.repeat_mode
            # Keep old settings for backward compatibility
            self.settings['shuffle_on'] = self.playlist_sidebar.shuffle_mode > 0
            self.settings['repeat_on'] = self.playlist_sidebar.repeat_mode > 0
        else:
            # Playlist doesn't exist yet, save as closed
            self.settings['playlist_visible'] = False
            # Also ensure shuffle/repeat modes are saved even if playlist not created
            # (e.g., if app closed immediately after launch)
            self.settings['shuffle_mode'] = self.settings.get('shuffle_mode', 0)
            self.settings['repeat_mode'] = self.settings.get('repeat_mode', 0)
            # Keep old settings for backward compatibility
            self.settings['shuffle_on'] = self.settings.get('shuffle_mode', 0) > 0
            self.settings['repeat_on'] = self.settings.get('repeat_mode', 0) > 0
        
        # Save nano mode state if active
        if hasattr(self, '_main_window_hidden_for_nano') and self._main_window_hidden_for_nano:
            self.settings['start_in_nano_mode'] = True
        else:
            self.settings['start_in_nano_mode'] = False
        
        # Save detached playlist state before closing
        # Disconnect the finished signal temporarily to prevent reattachment during app close
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            try:
                # Disconnect finished signal to prevent reattachment during app close
                self.detached_playlist_window.finished.disconnect()
            except:
                pass  # Signal might not be connected or already disconnected
            try:
                pos = self.detached_playlist_window.pos()
                size = self.detached_playlist_window.size()
                # Save absolute position
                self.playlist_detached_position = (pos.x(), pos.y())
                # Also save relative offset for backward compatibility
                main_pos = self.pos()
                self.playlist_detached_offset = (pos.x() - main_pos.x(), pos.y() - main_pos.y())
                self.playlist_detached_size = f"{size.width()}x{size.height()}"
            except Exception as e:
                logger.debug(f"Error saving detached playlist position on close: {e}")
        self._save_playlist_detach_state()
        
        # Close detached playlist window if it exists
        if self.playlist_detached and hasattr(self, 'detached_playlist_window') and self.detached_playlist_window:
            try:
                self.detached_playlist_window.close()
            except Exception as e:
                logger.debug(f"Error closing detached playlist window: {e}")
        
        self.save_settings()
        self.playlist_manager.save_playlist()
        event.accept()


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def check_python_version():
    """Check if Python version matches requirements."""
    version = sys.version_info[:3]
    if version != REQUIRED_PYTHON_VERSION:
        print(f"\n{'='*60}")
        print(f"ERROR: Python version mismatch!")
        print(f"{'='*60}")
        print(f"Required: {'.'.join(map(str, REQUIRED_PYTHON_VERSION))}")
        print(f"Current: {'.'.join(map(str, version))}")
        print(f"\nPlease install Python {'.'.join(map(str, REQUIRED_PYTHON_VERSION))}")
        print(f"{'='*60}\n")
        input("Press Enter to exit...")
        sys.exit(1)

def check_and_install_dependencies():
    """Check if dependencies are installed, install if missing."""
    missing = []
    
    try:
        import PyQt6
    except ImportError:
        missing.append("PyQt6")
    
    try:
        from PyQt6.QtWebEngineWidgets import QWebEngineView
    except ImportError:
        missing.append("PyQt6-WebEngine")
    
    if missing:
        print(f"\nMissing dependencies: {', '.join(missing)}")
        print("Attempting to install automatically...\n")
        
        requirements_file = Path(__file__).parent / "requirements.txt"
        if requirements_file.exists():
            try:
                result = subprocess.run(
                    [sys.executable, "-m", "pip", "install", "-r", str(requirements_file)],
                    check=False
                )
                if result.returncode == 0:
                    print("Dependencies installed successfully!\n")
                    # Re-import to verify
                    import importlib
                    importlib.invalidate_caches()
                else:
                    print("Failed to install dependencies automatically.")
                    print("Please run: pip install -r requirements.txt")
                    input("Press Enter to exit...")
                    sys.exit(1)
            except Exception as e:
                print(f"Error installing dependencies: {e}")
                print("Please run: pip install -r requirements.txt")
                input("Press Enter to exit...")
                sys.exit(1)
        else:
            print("requirements.txt not found!")
            print("Please install dependencies manually.")
            input("Press Enter to exit...")
            sys.exit(1)


# ============================================================================
# MAIN FUNCTION
# ============================================================================

def main():
    """Main entry point - simplified like downloader for Windows 10 compatibility."""
    # Set up global exception handler for runtime crashes
    def global_exception_handler(exc_type, exc_value, exc_traceback):
        """Handle unhandled exceptions that occur during runtime."""
        if issubclass(exc_type, KeyboardInterrupt):
            # Allow keyboard interrupt to work normally
            sys.__excepthook__(exc_type, exc_value, exc_traceback)
            return
        
        import traceback
        error_msg = ''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
        
        # Log to file
        try:
            script_dir = Path(__file__).parent if __file__ else Path.cwd()
            logs_dir = script_dir / "Logs"
            logs_dir.mkdir(exist_ok=True)
            crash_log_file = logs_dir / "crash_log.txt"
            import time
            with open(crash_log_file, 'a', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write(f"RUNTIME CRASH - {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("=" * 80 + "\n")
                f.write(error_msg)
                f.write("=" * 80 + "\n\n")
            
            # Also log via logger if available
            logger.error(f"Unhandled exception: {exc_type.__name__}: {exc_value}", exc_info=(exc_type, exc_value, exc_traceback))
        except Exception as log_error:
            print(f"Warning: Could not write to crash log: {log_error}", file=sys.stderr)
        
        # Print to console
        print("=" * 60, file=sys.stderr)
        print("RUNTIME CRASH - Bandcamp Player", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        print(error_msg, file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        try:
            print(f"\nError has been saved to: {crash_log_file}", file=sys.stderr)
        except:
            print("\nError has been saved to: Logs/crash_log.txt", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        
        # Try to show error dialog if Qt is available
        try:
            from PyQt6.QtWidgets import QApplication, QMessageBox
            app = QApplication.instance()
            if app:
                msg_box = QMessageBox()
                msg_box.setIcon(QMessageBox.Icon.Critical)
                msg_box.setWindowTitle("Runtime Crash")
                msg_box.setText(f"Bandcamp Player crashed:\n\n{exc_type.__name__}: {exc_value}")
                msg_box.setDetailedText(error_msg)
                msg_box.exec()
        except Exception:
            pass  # Qt not available or error showing dialog
        
        # Keep console open on Windows so user can read error
        if sys.platform == "win32":
            try:
                input("\nPress Enter to exit...")
            except:
                import time
                time.sleep(5)  # Wait so user can read error
        
        # Call default exception handler
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
    
    # Install global exception handler
    sys.excepthook = global_exception_handler
    
    # Ensure we're running from the script's directory (fixes Windows 10 issue)
    try:
        if hasattr(sys, 'frozen'):
            script_dir = Path(sys.executable).resolve().parent
        elif __file__:
            script_dir = Path(__file__).resolve().parent
        else:
            script_dir = Path(os.getcwd())
        
        if os.getcwd() != str(script_dir):
            try:
                os.chdir(str(script_dir))
            except OSError:
                pass  # Continue even if directory change fails
    except Exception:
        pass  # Continue even if directory setup fails
    
    # Check Python version
    try:
        check_python_version()
    except (SystemExit, Exception):
        if sys.platform == "win32":
            input("Press Enter to exit...")
        sys.exit(1)
    
    # Check and install dependencies if not running from launcher
    launcher_mode = os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1'
    if not launcher_mode:
        try:
            check_and_install_dependencies()
        except (SystemExit, Exception):
            if sys.platform == "win32":
                input("Press Enter to exit...")
            sys.exit(1)
    
    launcher_version = os.environ.get('BANDCAMP_PLAYER_LAUNCHER_VERSION', 'Unknown')
    
    # Create QApplication - do this FIRST like downloader does with Tk
    try:
        app = QApplication(sys.argv)
        app.setApplicationName("Bandcamp Player")
        app.setOrganizationName("Bandcamp Tools")
    except Exception as e:
        print(f"Failed to initialize Qt: {e}")
        if sys.platform == "win32":
            input("Press Enter to exit...")
        sys.exit(1)
    
    # Create window - console handling will be done INSIDE PlayerWindow.__init__
    # This matches the downloader pattern where console is handled after GUI creation
    try:
        window = PlayerWindow()
        
        if launcher_mode:
            window.setWindowTitle(f"Bandcamp Player (Launcher v{launcher_version})")
        
        # Install media key event filter for WM_APPCOMMAND and custom AutoHotkey messages
        if sys.platform == 'win32' and _HAS_CTYPES:
            media_key_filter = MediaKeyEventFilter()
            media_key_filter.setCallbacks(
                next_callback=window._trigger_next_track,
                prev_callback=window._trigger_previous_track
            )
            app.installNativeEventFilter(media_key_filter)
            window.media_key_filter = media_key_filter  # Keep reference to prevent garbage collection
            window.media_next_callback = window._trigger_next_track  # Store for IPC
            window.media_prev_callback = window._trigger_previous_track  # Store for IPC
        
        # Defer non-critical initialization until after window is ready
        QTimer.singleShot(0, window.deferred_init)
        
        sys.exit(app.exec())
    except Exception as e:
        # Show error dialog if possible
        try:
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Icon.Critical)
            msg_box.setWindowTitle("Error")
            msg_box.setText(f"Failed to start Bandcamp Player:\n\n{str(e)}")
            import traceback
            msg_box.setDetailedText(traceback.format_exc())
            msg_box.exec()
        except:
            print(f"Failed to start Bandcamp Player:\n\n{str(e)}")
            import traceback
            traceback.print_exc()
            if sys.platform == "win32":
                input("Press Enter to exit...")
        if not launcher_mode:
            sys.exit(1)
        else:
            raise


# ============================================================================
# NANO PLAYER WINDOW CLASS
# ============================================================================

class NanoPlayerWindow(QDialog):
    """Super compact nano player window that appears when main window is minimized."""
    
    def __init__(self, parent_window):
        super().__init__(None)  # No parent - separate top-level window
        self.parent_window = parent_window
        
        # Flag to track if one-time resize trick has been done
        self._one_time_resize_done = False
        
        # Window setup
        self.setWindowTitle("Nano Player")
        self.setModal(False)
        self.setMinimumSize(510, 50)  # Minimum width 510px, height will be determined by content
        self.setMaximumSize(16777215, 100)  # Maximum height ~100px (controls + progress bar)
        
        # Frameless window (no rounded corners as requested)
        flags = Qt.WindowType.FramelessWindowHint | Qt.WindowType.Window
        # Always-on-top will be controlled by pin button (independent of main window)
        self.nano_always_on_top = parent_window.settings.get("nano_always_on_top", True)  # Default to enabled
        if self.nano_always_on_top:
            flags |= Qt.WindowType.WindowStaysOnTopHint
        self.setWindowFlags(flags)
        
        # Set window icon if available
        if hasattr(parent_window, 'app_icon') and parent_window.app_icon:
            self.setWindowIcon(parent_window.app_icon)
        
        # Load saved position and size
        saved_pos = parent_window.settings.get("nano_player_position", None)
        saved_size = parent_window.settings.get("nano_player_size", "510x50")
        
        if saved_pos and isinstance(saved_pos, (list, tuple)) and len(saved_pos) == 2:
            self.move(saved_pos[0], saved_pos[1])
        else:
            # Center on screen if no saved position
            screen = QApplication.primaryScreen()
            if screen:
                screen_geometry = screen.availableGeometry()
                self.move(
                    (screen_geometry.width() - 510) // 2,
                    (screen_geometry.height() - 50) // 2
                )
        
        # Parse saved size
        try:
            if 'x' in saved_size:
                size_parts = saved_size.split('x')
                if len(size_parts) == 2:
                    width = int(size_parts[0])
                    height = int(size_parts[1])
                    if width >= 510 and height >= 50:
                        self.resize(width, height)
                    else:
                        self.resize(510, 50)
                else:
                    self.resize(510, 50)
            else:
                self.resize(510, 50)
        except Exception:
            self.resize(510, 50)
        
        # Initialize resize-related attributes BEFORE setup_ui to ensure they exist
        # Track drag state
        self._drag_position = None
        
        # Track resize state ('left', 'right', or None)
        self._resize_edge = None
        self._resize_start_pos = None
        self._resize_start_geometry = None
        
        # Resize edge detection threshold (pixels from edge) - initialize early
        self._resize_threshold = 5
        
        # Window snapping and docking
        self._snap_threshold = 20  # Same as main window
        self._docked_edge = None  # 'top', 'bottom', or None
        self._docked_y_position = None  # Y position when docked
        
        # Autohide when docked
        self.nano_autohide_when_docked = parent_window.settings.get("nano_autohide_when_docked", False)
        # Autohide sensitivity (pixels from edge) - default to 5px, will be clamped to valid range when needed
        self.nano_autohide_sensitivity = parent_window.settings.get("nano_autohide_sensitivity", 5)
        # Ensure sensitivity is within valid range (5px minimum)
        self.nano_autohide_sensitivity = max(5, self.nano_autohide_sensitivity)
        self._autohide_timer = QTimer(self)
        self._autohide_timer.timeout.connect(self._check_autohide)
        self._autohide_timer.setInterval(100)  # Check every 100ms
        self._is_autohidden = False
        self._context_menu = None  # Track context menu to prevent autohide when open
        self._autohide_cooldown = False  # Prevent autohide from triggering immediately after window is shown
        
        # Create transparent hover area widget for hotspot (similar to archived address bar implementation)
        # Create as a top-level window that stays on top and is frameless
        # Use Tool window type so it doesn't appear in taskbar but can receive mouse events
        self._autohide_hover_area = QWidget()
        self._autohide_hover_area.setWindowFlags(
            Qt.WindowType.FramelessWindowHint | 
            Qt.WindowType.WindowStaysOnTopHint |
            Qt.WindowType.Tool  # Tool windows don't appear in taskbar but can receive events
        )
        self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground, True)
        self._autohide_hover_area.setStyleSheet("background-color: transparent;")
        self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
        self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_ShowWithoutActivating, True)  # Don't steal focus
        self._autohide_hover_area.hide()  # Hidden by default
        
        # Mouse enter/leave events for hover area
        def hover_area_enter(event):
            if self.nano_autohide_when_docked and self._docked_edge and self._is_autohidden:
                self.show()
                self._is_autohidden = False
                # Hide hover area when window is shown
                self._autohide_hover_area.hide()
        
        def hover_area_leave(event):
            if self.nano_autohide_when_docked and self._docked_edge and not self._is_autohidden:
                # Small delay before hiding to prevent flicker
                QTimer.singleShot(150, lambda: self._check_autohide_after_leave())
        
        self._autohide_hover_area.enterEvent = hover_area_enter
        self._autohide_hover_area.leaveEvent = hover_area_leave
        
        # Initialize resize edge widgets to None (will be created after UI setup)
        self._left_resize_edge = None
        self._right_resize_edge = None
        
        # Setup UI
        self.setup_ui()
        
        # Install event filter for window snapping and drag handling
        self.installEventFilter(self)
        
        # Create invisible resize edge widgets (left and right) - must be after UI setup and _resize_threshold is set
        self._create_resize_edges()
        
        # Enable drag-and-drop on the window
        self.setAcceptDrops(True)
        
        # Track if dragging over album button for visual feedback
        self._dragging_over_album_btn = False
        
        # Enable drag-and-drop on album button and install event filter
        if hasattr(self, 'album_menu_btn'):
            self.album_menu_btn.setAcceptDrops(True)
            self.album_menu_btn.installEventFilter(self)
        
        # TODO: Add all controls, menus, progress bar, etc.
    
    def setup_ui(self):
        """Setup the nano player UI."""
        # Main horizontal layout: cover art on left, controls/progress on right
        main_layout = QHBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Cover art display (left side, spans both rows)
        self.cover_art_label = QLabel()
        self.cover_art_label.setFixedWidth(50)  # Fixed width, height will match window height
        self.cover_art_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.cover_art_label.setStyleSheet("""
            QLabel {
                background-color: #1a1a1a;
                border: none;
            }
        """)
        self.cover_art_label.setScaledContents(True)  # Scale image to fit
        # Install event filter to allow dragging from cover art
        self.cover_art_label.installEventFilter(self)
        main_layout.addWidget(self.cover_art_label)
        
        # Right side: controls and progress bar
        right_layout = QVBoxLayout()
        # Reduced margins: left margin matches where controls start, right margin minimal
        # Top and bottom margins kept for visual spacing
        right_layout.setContentsMargins(5, 2, 3, 2)  # Left margin aligns with cover art spacing
        right_layout.setSpacing(0)  # No spacing between controls and progress bar
        
        # Controls row
        controls_row = QHBoxLayout()
        controls_row.setSpacing(1)  # Compact spacing for consistent button layout
        controls_row.setContentsMargins(0, 0, 0, 0)  # No margins since parent layout has them
        
        # Button style (matches playlist title bar buttons exactly)
        button_style = """
            QPushButton {
                background-color: transparent;
                color: #e0e0e0;
                border: none;
                font-size: 11px;
                padding: 2px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
            }
            QPushButton:checked {
                color: #4a90e2;
                background-color: #3a3a3a;
                border: 1px solid #4a90e2;
                border-radius: 3px;
            }
        """
        
        # Previous album button
        self.prev_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-backward', color='#e0e0e0')
            if icon:
                self.prev_album_btn.setIcon(icon)
            else:
                self.prev_album_btn.setText("")
        else:
            self.prev_album_btn.setText("")
        self.prev_album_btn.setToolTip("Previous album")
        self.prev_album_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.prev_album_btn.setStyleSheet(button_style)
        self.prev_album_btn.clicked.connect(self._on_prev_album)
        controls_row.addWidget(self.prev_album_btn)
        
        # Previous track button
        self.prev_track_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('backward', color='#e0e0e0')
            if icon:
                self.prev_track_btn.setIcon(icon)
            else:
                self.prev_track_btn.setText("")
        else:
            self.prev_track_btn.setText("")
        self.prev_track_btn.setToolTip("Previous Track")
        self.prev_track_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.prev_track_btn.setStyleSheet(button_style)
        self.prev_track_btn.clicked.connect(self._on_prev_track)
        controls_row.addWidget(self.prev_track_btn)
        
        # Play/Pause button
        self.play_pause_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('play', color='#e0e0e0')
            if icon:
                self.play_pause_btn.setIcon(icon)
            else:
                self.play_pause_btn.setText("")
        else:
            self.play_pause_btn.setText("")
        self.play_pause_btn.setToolTip("Play/Pause")
        self.play_pause_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.play_pause_btn.setStyleSheet(button_style)
        self.play_pause_btn.clicked.connect(self._on_play_pause)
        controls_row.addWidget(self.play_pause_btn)
        
        # Next track button
        self.next_track_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('forward', color='#e0e0e0')
            if icon:
                self.next_track_btn.setIcon(icon)
            else:
                self.next_track_btn.setText("")
        else:
            self.next_track_btn.setText("")
        self.next_track_btn.setToolTip("Next Track")
        self.next_track_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.next_track_btn.setStyleSheet(button_style)
        self.next_track_btn.clicked.connect(self._on_next_track)
        controls_row.addWidget(self.next_track_btn)
        
        # Next album button
        self.next_album_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('step-forward', color='#e0e0e0')
            if icon:
                self.next_album_btn.setIcon(icon)
            else:
                self.next_album_btn.setText("")
        else:
            self.next_album_btn.setText("")
        self.next_album_btn.setToolTip("Next album")
        self.next_album_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.next_album_btn.setStyleSheet(button_style)
        self.next_album_btn.clicked.connect(self._on_next_album)
        controls_row.addWidget(self.next_album_btn)
        
        controls_row.addSpacing(1)  # Consistent spacing between button groups
        
        # Shuffle button
        self.shuffle_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('random', color='#a0a0a0')
            if icon:
                self.shuffle_btn.setIcon(icon)
            else:
                self.shuffle_btn.setText("")
        else:
            self.shuffle_btn.setText("")
        self.shuffle_btn.setToolTip("Shuffle: Off")
        self.shuffle_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.shuffle_btn.setCheckable(True)
        self.shuffle_btn.setStyleSheet(button_style)
        self.shuffle_btn.clicked.connect(self._on_shuffle)
        controls_row.addWidget(self.shuffle_btn)
        
        # Repeat button (match playlist title bar exactly)
        self.repeat_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.repeat', color='#a0a0a0')  # Use same icon as playlist
            if icon:
                self.repeat_btn.setIcon(icon)
            else:
                self.repeat_btn.setText("")
        else:
            self.repeat_btn.setText("")
        self.repeat_btn.setToolTip("Repeat: Off")
        self.repeat_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.repeat_btn.setCheckable(True)
        self.repeat_btn.setStyleSheet(button_style)
        self.repeat_btn.clicked.connect(self._on_repeat)
        controls_row.addWidget(self.repeat_btn)
        
        controls_row.addSpacing(1)  # Consistent spacing between button groups
        
        # Volume button (will show popup like main interface)
        self.volume_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('volume-up', color='#e0e0e0')
            if icon:
                self.volume_btn.setIcon(icon)
            else:
                self.volume_btn.setText("")
        else:
            self.volume_btn.setText("")
        self.volume_btn.setToolTip("Volume")
        self.volume_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.volume_btn.setStyleSheet(button_style)
        self.volume_btn.clicked.connect(self._on_volume_click)
        controls_row.addWidget(self.volume_btn)
        
        controls_row.addSpacing(1)  # Reduced spacing between volume and track list
        
        # Artist - Track menu button (expandable)
        self.track_menu_btn = QPushButton()
        self.track_menu_btn.setText("Artist - Track")
        self.track_menu_btn.setToolTip("Select Track")
        # Set minimum width explicitly (not in stylesheet to avoid conflicts)
        self.track_menu_btn.setMinimumWidth(80)
        # Width will be set to fixed value based on text in _update_button_widths()
        # Set size policy to fixed - width will be set based on text content
        self.track_menu_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.track_menu_btn.setStyleSheet(button_style + """
            QPushButton {
                text-align: left;
                padding: 2px 0 2px 6px;
                font-size: 11px;
            }
        """)
        # Create a custom button that clips text cleanly without elision
        # We'll override the paint event to draw text and clip it to button bounds
        def paint_with_clipping(event):
            painter = QPainter(self.track_menu_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            option = QStyleOptionButton()
            self.track_menu_btn.initStyleOption(option)
            # Draw button background and bevel
            self.track_menu_btn.style().drawControl(QStyle.ControlElement.CE_PushButtonBevel, option, painter, self.track_menu_btn)
            # Clip to button rectangle to hide overflow cleanly (no "..." elision)
            painter.setClipRect(self.track_menu_btn.rect())
            # Draw text without elision - use the button's font with correct size
            text_rect = self.track_menu_btn.rect().adjusted(6, 2, -1, -2)  # Left padding 6px, right padding 1px (minimal)
            text = self.track_menu_btn.text()
            font = self.track_menu_btn.font()
            font.setPixelSize(11)  # Match time label font size
            painter.setFont(font)
            painter.setPen(QColor("#e0e0e0"))
            # Draw full text - it will be cleanly clipped by setClipRect if it overflows (no "...")
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, text)
        self.track_menu_btn.paintEvent = paint_with_clipping
        self.track_menu_btn.clicked.connect(self._show_track_menu)
        # Track button will be added to bottom_row instead (between progress bar and time label)
        # Don't add to controls_row here
        
        # Album menu button (expandable) - moved to top row where track button originally was
        self.album_menu_btn = QPushButton()
        self.album_menu_btn.setText("Album")
        self.album_menu_btn.setToolTip("Select Album")
        # Set minimum width explicitly (not in stylesheet to avoid conflicts)
        self.album_menu_btn.setMinimumWidth(60)
        # Width will be set to fixed value based on text in _update_button_widths()
        # Set size policy to fixed - width will be set based on text content
        self.album_menu_btn.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        album_btn_style = button_style + """
            QPushButton {
                text-align: left;
                padding: 2px 0 2px 6px;
                font-size: 11px;
            }
        """
        self.album_menu_btn.setStyleSheet(album_btn_style)
        # Store original style for drag feedback
        self._original_album_btn_style = album_btn_style
        # Create a custom button that clips text cleanly without elision
        # We'll override the paint event to draw text and clip it to button bounds
        def paint_with_clipping(event):
            painter = QPainter(self.album_menu_btn)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            option = QStyleOptionButton()
            self.album_menu_btn.initStyleOption(option)
            # Draw button background and bevel
            self.album_menu_btn.style().drawControl(QStyle.ControlElement.CE_PushButtonBevel, option, painter, self.album_menu_btn)
            # Clip to button rectangle to hide overflow cleanly (no "..." elision)
            painter.setClipRect(self.album_menu_btn.rect())
            # Draw text without elision - use the button's font with correct size
            text_rect = self.album_menu_btn.rect().adjusted(6, 2, -1, -2)  # Left padding 6px, right padding 1px (minimal)
            text = self.album_menu_btn.text()
            font = self.album_menu_btn.font()
            font.setPixelSize(11)  # Match time label font size
            painter.setFont(font)
            painter.setPen(QColor("#e0e0e0"))
            # Draw full text - it will be cleanly clipped by setClipRect if it overflows (no "...")
            painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, text)
        self.album_menu_btn.paintEvent = paint_with_clipping
        self.album_menu_btn.clicked.connect(self._show_album_menu)
        # Enable context menu on right-click
        self.album_menu_btn.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.album_menu_btn.customContextMenuRequested.connect(self._show_album_context_menu)
        # Album button should be added to controls_row (top row) where track button originally was
        # Add it BEFORE stretch and window controls
        controls_row.addWidget(self.album_menu_btn, 0)  # No stretch - fixed width based on text
        
        # Add flexible space between album list and window controls
        controls_row.addStretch(1)
        
        # Create a container widget for the three right buttons with shared background
        # This will cover album list text if it extends past them (same as elapsed time)
        self.right_buttons_container = QWidget()
        # Use Expanding horizontal policy so it extends to the right edge
        self.right_buttons_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        # Set background color to cover text underneath and to the right
        self.right_buttons_container.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border-radius: 2px;
            }
        """)
        # Use a timer to extend container width after layout updates to cover right margin area
        # This ensures the background covers any text that might peek out past the buttons
        def extend_container_width():
            container = self.right_buttons_container
            if not container:
                return
            parent_widget = container.parent()
            if parent_widget:
                # Get the main widget (right_layout's parent - the nano window itself)
                main_widget = parent_widget.parent()
                if main_widget:
                    # Calculate desired width: extend all the way to the right edge
                    container_geo = container.geometry()
                    # Map container's position to main widget coordinates
                    container_left_in_main = container.mapTo(main_widget, container_geo.topLeft())
                    main_right = main_widget.width()
                    # Extend all the way to the right edge (accounting for right_layout's 3px right margin)
                    # Add extra safety margin to ensure we cover any text sliver
                    desired_width = main_right - container_left_in_main.x() - 3 + 10  # -3 for margin, +10 for safety
                    if desired_width > container_geo.width():
                        # Set minimum width to ensure container extends to cover the area
                        container.setMinimumWidth(desired_width)
        # Store the function for later use
        self._extend_container_width = extend_container_width
        # Call after a short delay to ensure layout is done
        QTimer.singleShot(10, extend_container_width)
        # Also call on resize events
        original_resize_event = self.right_buttons_container.resizeEvent
        def extended_resize_event(event):
            if original_resize_event:
                original_resize_event(event)
            QTimer.singleShot(10, extend_container_width)
        self.right_buttons_container.resizeEvent = extended_resize_event
        right_buttons_layout = QHBoxLayout(self.right_buttons_container)
        # Left padding increased to add space between tracklist and pin button
        # Right margin 0 to extend all the way to the right edge
        # This ensures the background covers any text that might peek out
        right_buttons_layout.setContentsMargins(8, 0, 0, 0)  # Left padding 8px (increased from 4px), extend to right edge
        right_buttons_layout.setSpacing(1)  # Spacing between buttons
        right_buttons_layout.setAlignment(Qt.AlignmentFlag.AlignLeft)  # Align buttons to the left
        
        # Pin button (always on top) - match main interface icon
        self.pin_btn = QPushButton()
        self.pin_btn.setToolTip("Pin to Top")
        self.pin_btn.setCheckable(True)
        self.pin_btn.setChecked(self.nano_always_on_top)
        self.pin_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.pin_btn.setStyleSheet(button_style)
        # Set icon color based on initial state
        if HAS_QT_AWESOME:
            icon_color = '#4a90e2' if self.nano_always_on_top else '#a0a0a0'
            icon = get_icon('thumbtack', color=icon_color)  # Match main interface
            if icon:
                self.pin_btn.setIcon(icon)
            else:
                self.pin_btn.setText("")
        else:
            self.pin_btn.setText("")
        self.pin_btn.clicked.connect(self._on_pin_toggle)
        right_buttons_layout.addWidget(self.pin_btn)
        
        # Minimize button
        self.minimize_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('minus', color='#e0e0e0')
            if icon:
                self.minimize_btn.setIcon(icon)
            else:
                self.minimize_btn.setText("")
        else:
            self.minimize_btn.setText("")
        self.minimize_btn.setToolTip("Minimize")
        self.minimize_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.minimize_btn.setStyleSheet(button_style)
        self.minimize_btn.clicked.connect(self.showMinimized)
        right_buttons_layout.addWidget(self.minimize_btn)
        
        # Restore button
        self.restore_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('ei.chevron-up', color='#e0e0e0')
            if icon:
                self.restore_btn.setIcon(icon)
            else:
                self.restore_btn.setText("")
        else:
            self.restore_btn.setText("")
        self.restore_btn.setToolTip("Restore Main Window")
        self.restore_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.restore_btn.setStyleSheet(button_style)
        self.restore_btn.clicked.connect(self._on_restore)
        right_buttons_layout.addWidget(self.restore_btn)
        
        # Close button
        self.close_btn = QPushButton()
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                self.close_btn.setIcon(icon)
            else:
                self.close_btn.setText("")
        else:
            self.close_btn.setText("")
        self.close_btn.setToolTip("Close")
        self.close_btn.setFixedSize(22, 22)  # Match playlist title bar
        self.close_btn.setStyleSheet(button_style)
        self.close_btn.clicked.connect(self.close)
        right_buttons_layout.addWidget(self.close_btn)
        
        # Add the container to the controls row (will render on top of tracklist text)
        # Use stretch factor 0 but allow it to expand to fill remaining space to right edge
        controls_row.addWidget(self.right_buttons_container, 0)  # Will extend to right edge
        
        right_layout.addLayout(controls_row)
        
        # Bottom row: progress bar (only under control buttons) and album button
        bottom_row = QHBoxLayout()
        bottom_row.setSpacing(4)  # Spacing between progress bar and album button
        # Match controls_row margins (0, 0, 0, 0) - no margins since parent right_layout has them
        bottom_row.setContentsMargins(0, 0, 0, 0)
        # Align to left - no stretch before first widget
        bottom_row.setAlignment(Qt.AlignmentFlag.AlignLeft)
        
        # Progress bar (below controls only, 5px height, clickable and draggable)
        # Width will be constrained to match control buttons width
        self.progress_bar = QSlider(Qt.Orientation.Horizontal)
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(1000)  # Use 1000 for smoother seeking
        self.progress_bar.setValue(0)
        self.progress_bar.setFixedHeight(5)
        # Make progress bar taller for easier interaction (but visually 5px)
        self.progress_bar.setMinimumHeight(12)  # Larger hit area for easier clicking/dragging
        self.progress_bar.setStyleSheet("""
            QSlider::groove:horizontal {
                background: #3a3a3a;
                height: 5px;
                border-radius: 2px;
            }
            QSlider::handle:horizontal {
                background: #4a90e2;
                width: 8px;
                height: 5px;
                border-radius: 2px;
                margin: 0;
            }
            QSlider::sub-page:horizontal {
                background: #4a90e2;
                border-radius: 2px;
            }
        """)
        self.progress_bar.sliderPressed.connect(self._on_progress_pressed)
        self.progress_bar.sliderReleased.connect(self._on_progress_released)
        self.progress_bar.valueChanged.connect(self._on_progress_changed)
        self._progress_dragging = False
        # Install event filter on progress bar to prevent window dragging when interacting with it
        self.progress_bar.installEventFilter(self)
        # Progress bar should only span the width of control buttons (8 buttons * 22px + spacing)
        # Approximate: 8 buttons * 22px = 176px, plus spacing between them
        # We'll let it size naturally but constrain it - use fixed width based on button count
        # Calculate: 8 buttons (prev album, prev track, play, next track, next album, shuffle, repeat, volume)
        # = 8 * 22 = 176px, plus 7 * 1px spacing = 7px, total ~183px
        # But we need to account for margins too - let's use a more flexible approach
        # Set size policy to Fixed width, but we'll update it dynamically
        self.progress_bar.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        # Store reference to calculate width later
        self._control_buttons_width = None
        bottom_row.addWidget(self.progress_bar, 0)  # No stretch - fixed width
        
        # Track menu button (expandable) - in bottom row after progress bar, before time label
        # Add track button here (swapped from top row)
        bottom_row.addWidget(self.track_menu_btn, 0)  # No stretch - fixed width based on text
        
        # Add flexible space between track list and time label
        bottom_row.addStretch(1)
        
        # Create a container widget for the time label with shared background
        # This will cover track list text if it extends past the time label
        self.time_label_container = QWidget()
        # Use Expanding horizontal policy so it extends to the right edge
        self.time_label_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        # Set background color to cover text underneath and to the right
        self.time_label_container.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                border-radius: 2px;
            }
        """)
        # Use a timer to extend container width after layout updates to cover right margin area
        # This ensures the background covers any text that might peek out past the time label
        def extend_time_container_width():
            container = self.time_label_container
            if not container:
                return
            parent_widget = container.parent()
            if parent_widget:
                # Get the main widget (right_layout's parent - the nano window itself)
                main_widget = parent_widget.parent()
                if main_widget:
                    # Calculate desired width: extend all the way to the right edge
                    container_geo = container.geometry()
                    # Map container's position to main widget coordinates
                    container_left_in_main = container.mapTo(main_widget, container_geo.topLeft())
                    main_right = main_widget.width()
                    # Extend all the way to the right edge (accounting for right_layout's 3px right margin)
                    # Add extra safety margin to ensure we cover any text sliver (increased from 10 to 15 for better coverage)
                    desired_width = main_right - container_left_in_main.x() - 3 + 15  # -3 for margin, +15 for safety
                    # Always set minimum width to ensure container extends to cover the area (even if current width is larger)
                    container.setMinimumWidth(desired_width)
        # Store the function for later use
        self._extend_time_container_width = extend_time_container_width
        # Call after a short delay to ensure layout is done
        QTimer.singleShot(10, extend_time_container_width)
        # Also call on resize events
        original_time_resize_event = self.time_label_container.resizeEvent
        def extended_time_resize_event(event):
            if original_time_resize_event:
                original_time_resize_event(event)
            QTimer.singleShot(10, extend_time_container_width)
        self.time_label_container.resizeEvent = extended_time_resize_event
        time_label_layout = QHBoxLayout(self.time_label_container)
        # Right margin 0 to extend all the way to the right edge
        # This ensures the background covers any text that might peek out
        time_label_layout.setContentsMargins(0, 0, 0, 0)  # No margins - extend to right edge
        time_label_layout.setSpacing(0)
        time_label_layout.setAlignment(Qt.AlignmentFlag.AlignRight)  # Align time label to the right
        
        # Time display (clickable to cycle modes) - fixed width, positioned on right side of container
        self.time_label = QLabel("00:00/00:00")
        self.time_label.setStyleSheet("""
            QLabel {
                color: #e0e0e0;
                font-size: 11px;
                padding: 2px 2px 2px 4px;
                background-color: transparent;
                border-radius: 2px;
            }
            QLabel:hover {
                background-color: #3a3a3a;
                border-radius: 2px;
            }
        """)
        # Calculate minimum width based on text content - measure longest possible format
        font_metrics = QFontMetrics(self.time_label.font())
        # Measure both formats to ensure enough width: "00:00/00:00" and "-00:00/00:00" (for remaining time)
        text_width1 = font_metrics.horizontalAdvance("00:00/00:00")
        text_width2 = font_metrics.horizontalAdvance("-00:00/00:00")
        max_text_width = max(text_width1, text_width2)
        # Add padding: left 4px + right 2px = 6px total
        time_label_width = max_text_width + 6
        self.time_label.setMinimumWidth(time_label_width)  # Text + padding
        self.time_label.setMaximumWidth(time_label_width)  # Fixed width based on content
        self.time_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self.time_label.setCursor(Qt.CursorShape.PointingHandCursor)
        self.time_label.mousePressEvent = self._on_time_label_clicked
        # Time display mode: 0 = elapsed/total, 1 = elapsed/remaining
        self.time_display_mode = self.parent_window.settings.get('nano_time_display_mode', 0)
        time_label_layout.addWidget(self.time_label)  # Add time label to container layout
        bottom_row.addWidget(self.time_label_container, 0)  # Add container to bottom row - expands to right edge
        
        right_layout.addLayout(bottom_row)
        
        # Add right layout to main layout
        main_layout.addLayout(right_layout)
        
        # Network manager for loading cover art images
        self.network_manager = QNetworkAccessManager(self)
        self.network_manager.finished.connect(self._on_cover_art_loaded)
        
        # Track current cover art URL to avoid reloading same image
        self._current_cover_art_url = None
        
        # Store current track and album info for highlighting
        self._current_track_number = None
        self._current_album_name = None
        
        # Set initial cover art height
        if hasattr(self, 'cover_art_label'):
            self.cover_art_label.setFixedHeight(self.height())
        
        # Set background color to match main window/playlist title bar
        self.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
                border: 1px solid #1a1a1a;
            }
        """)
        
        # Setup update timer for track info and time
        self.update_timer = QTimer(self)
        self.update_timer.timeout.connect(self._update_track_info)
        self.update_timer.start(500)  # Update every 500ms
        
        # Initial cover art update
        QTimer.singleShot(1000, self._update_cover_art)  # Update after a short delay
        
        # Initial update
        QTimer.singleShot(100, self._update_track_info)
        
        # Sync shuffle and repeat buttons after a delay to ensure playlist_sidebar is initialized
        # This is especially important when starting in nano mode
        QTimer.singleShot(200, self._sync_shuffle_repeat_buttons)
        QTimer.singleShot(500, self._sync_shuffle_repeat_buttons)  # Retry after a bit more time
    
    def _perform_one_time_resize_trick(self):
        """
        Force layout activation to ensure button geometries are correctly calculated.
        The issue is that when the window first shows, the layout hasn't finished
        calculating sizes for expanding widgets, so button.rect() in paintEvent is wrong.
        Activating the layout forces Qt to calculate all widget sizes immediately.
        """
        # Safety check: only do this once
        if self._one_time_resize_done:
            return
        
        # Check if user is currently resizing - if so, abort immediately
        if self._resize_edge is not None:
            # User is resizing, don't interfere - mark as done so we don't try again
            self._one_time_resize_done = True
            return
        
        # Mark as done immediately to prevent any retries
        self._one_time_resize_done = True
        
        # Only proceed if window is visible and has valid size
        if not self.isVisible() or self.width() <= 0:
            return
        
        try:
            # Force layout to activate - this calculates all widget sizes immediately
            layout = self.layout()
            if layout:
                # activate() forces Qt to calculate and assign sizes to all widgets
                layout.activate()
            
            # Now that layout is activated, update button widths based on calculated sizes
            self._update_button_widths()
            
            # Force buttons to repaint with their now-correct geometries
            if hasattr(self, 'track_menu_btn'):
                self.track_menu_btn.update()
            if hasattr(self, 'album_menu_btn'):
                self.album_menu_btn.update()
            
        except Exception as e:
            logger.debug(f"Error in one-time layout activation: {e}")
    
    def _create_resize_edges(self):
        """Create invisible edge widgets for resize detection."""
        # Ensure _resize_threshold exists before using it
        if not hasattr(self, '_resize_threshold') or self._resize_threshold is None:
            self._resize_threshold = 5  # Default value
        
        try:
            # Left edge widget
            self._left_resize_edge = QWidget(self)
            self._left_resize_edge.setFixedWidth(self._resize_threshold)
            self._left_resize_edge.setCursor(Qt.CursorShape.SizeHorCursor)
            self._left_resize_edge.setStyleSheet("background-color: transparent;")
            self._left_resize_edge.installEventFilter(self)
            self._left_resize_edge.raise_()  # Raise to top so it's always accessible
            
            # Right edge widget
            self._right_resize_edge = QWidget(self)
            self._right_resize_edge.setFixedWidth(self._resize_threshold)
            self._right_resize_edge.setCursor(Qt.CursorShape.SizeHorCursor)
            self._right_resize_edge.setStyleSheet("background-color: transparent;")
            self._right_resize_edge.installEventFilter(self)
            self._right_resize_edge.raise_()  # Raise to top so it's always accessible
            
            # Position edge widgets (will be updated on resize)
            self._update_resize_edge_positions()
        except Exception as e:
            logger.error(f"Error creating resize edges: {e}")
            # Ensure attributes exist even if creation fails
            if not hasattr(self, '_left_resize_edge'):
                self._left_resize_edge = None
            if not hasattr(self, '_right_resize_edge'):
                self._right_resize_edge = None
    
    def _update_resize_edge_positions(self):
        """Update positions of resize edge widgets."""
        if hasattr(self, '_left_resize_edge') and self._left_resize_edge and hasattr(self, '_resize_threshold'):
            self._left_resize_edge.setGeometry(0, 0, self._resize_threshold, self.height())
        if hasattr(self, '_right_resize_edge') and self._right_resize_edge and hasattr(self, '_resize_threshold'):
            self._right_resize_edge.setGeometry(self.width() - self._resize_threshold, 0, self._resize_threshold, self.height())
    
    def _update_button_widths(self):
        """Update track and album button widths based on text content and available space."""
        if not hasattr(self, 'track_menu_btn'):
            return
        
        # Calculate available space (window width minus fixed elements and margins)
        window_width = self.width()
        # If window width is not valid yet, skip (will be called again when window is shown)
        if window_width <= 0:
            return
        # Account for layout margins (left: 5, right: 3) and contents margins (left: 5, right: 3)
        available_width = window_width - 5 - 3 - 5 - 3  # = window_width - 16
        
        # Calculate fixed widths for top row (controls_row)
        # Navigation buttons: 5 buttons * 22px = 110px
        # Spacing between nav buttons: 4 * 1px = 4px (reduced spacing)
        # Shuffle, repeat, volume: 3 * 22px = 66px
        # Spacing: 2 * 1px = 2px (reduced spacing)
        # Additional spacing: 1px (after volume, before track button)
        left_controls_width = 110 + 4 + 66 + 2 + 1  # = 183px
        # Pin, minimize, restore, close: 4 * 22px = 88px
        # Spacing between right buttons: 3 * 1px = 3px (reduced spacing)
        right_buttons_width = 88 + 3  # = 91px
        
        # Measure track button text width
        track_text = self.track_menu_btn.text()
        font_metrics = QFontMetrics(self.track_menu_btn.font())
        track_text_width = font_metrics.horizontalAdvance(track_text)
        # Add padding (left: 6px, no right padding)
        track_text_width_with_padding = track_text_width + 6
        
        # Calculate maximum width for track button - allow it to get closer to right buttons
        # Use minimal gap (1px) to allow more text to be visible while still preventing overlap
        max_track_width = available_width - left_controls_width - right_buttons_width - 1  # Subtract right buttons width + minimal gap
        
        # Set fixed width for track button based on text
        # Use text elision if text is too long to prevent any overflow
        track_width = max(track_text_width_with_padding, 80)  # Minimum 80px
        # Limit to max width - if text is too long, it will be elided
        track_width = min(track_width, max_track_width)  # Don't exceed calculated max
        self.track_menu_btn.setFixedWidth(track_width)
        self.track_menu_btn.updateGeometry()
        
        # Update album button width (bottom row - after progress bar)
        if hasattr(self, 'album_menu_btn'):
            # Album button is in bottom row, fixed width based on text
            # Calculate maximum width to prevent overflow past time label (same approach as track button)
            album_text = self.album_menu_btn.text()
            font_metrics = QFontMetrics(self.album_menu_btn.font())
            album_text_width = font_metrics.horizontalAdvance(album_text)
            # Add padding: left 6px + right 1px (minimal, matching track button)
            album_text_width_with_padding = album_text_width + 7
            
            # Calculate maximum width for album button - prevent it from extending past time label
            # Progress bar width matches control buttons width (same as left_controls_width)
            progress_bar_width = left_controls_width  # Progress bar matches control buttons width
            
            # Time label width: measure longest possible format
            if hasattr(self, 'time_label'):
                time_font_metrics = QFontMetrics(self.time_label.font())
                time_text_width1 = time_font_metrics.horizontalAdvance("00:00/00:00")
                time_text_width2 = time_font_metrics.horizontalAdvance("-00:00/00:00")
                max_time_width = max(time_text_width1, time_text_width2) + 12  # +12 for padding
            else:
                max_time_width = 80  # Fallback estimate
            
            # Spacing: progress bar to album button (4px), minimal gap before time label (1px)
            spacing_between = 4  # Spacing between progress bar and album button
            minimal_gap = 1  # Minimal gap before time label to prevent overlap
            # Calculate max album width: available width - progress bar - time label - spacing - minimal gap
            max_album_width = available_width - progress_bar_width - max_time_width - spacing_between - minimal_gap
            
            # Set fixed width for album button based on text
            # Limit to max width - text will be clipped by paint event if too long (same as track button)
            album_width = max(album_text_width_with_padding, 60)  # Minimum 60px
            # Limit to max width - if text is too long, it will be clipped
            album_width = min(album_width, max_album_width)  # Don't exceed calculated max
            
            self.album_menu_btn.setFixedWidth(album_width)
        self.album_menu_btn.updateGeometry()
    
    def showEvent(self, event):
        """Handle window show event - update cover art height."""
        super().showEvent(event)
        if hasattr(self, 'cover_art_label'):
            self.cover_art_label.setFixedHeight(self.height())
        
        # Force layout activation FIRST to ensure all widget sizes are calculated
        # This is critical - without this, expanding widgets (like our buttons) may have
        # incorrect rect() values in their paint events
        layout = self.layout()
        if layout:
            layout.activate()  # Force layout to calculate all widget sizes immediately
        
        # Use processEvents to ensure window has valid size before calculating
        QApplication.processEvents()
        
        # Now update button widths based on the activated layout
        self._update_button_widths()
        
        # Update container widths to cover text overflow (after layout is activated)
        if hasattr(self, '_extend_container_width'):
            QTimer.singleShot(50, self._extend_container_width)
        if hasattr(self, '_extend_time_container_width'):
            QTimer.singleShot(50, self._extend_time_container_width)
        
        # Update progress bar width after layout is activated
        QTimer.singleShot(50, self._update_progress_bar_width)
        
        # Also trigger one-time layout activation after a short delay as backup
        # This ensures buttons get correct geometry even if timing is off
        if not self._one_time_resize_done:
            QTimer.singleShot(100, self._perform_one_time_resize_trick)
        
        # Update cover art when window is shown
        QTimer.singleShot(500, self._update_cover_art)
    
    def _update_progress_bar_width(self):
        """Update progress bar width to match control buttons width exactly."""
        if not hasattr(self, 'progress_bar') or not hasattr(self, 'prev_album_btn'):
            return
        
        try:
            # Calculate width of all control buttons (8 buttons: prev album, prev track, play, next track, next album, shuffle, repeat, volume)
            # Measure the actual rendered width from first button to last button
            if (hasattr(self, 'volume_btn') and self.volume_btn.isVisible() and 
                hasattr(self, 'prev_album_btn') and self.prev_album_btn.isVisible()):
                # Get the right edge of the volume button (including its width)
                volume_right = self.volume_btn.geometry().right()
                # Get the left edge of the first button (prev_album_btn)
                prev_left = self.prev_album_btn.geometry().left()
                # Calculate exact width from first button left to last button right
                # The geometry() returns positions relative to the parent widget
                # Since both controls_row and bottom_row are in right_layout, they should align
                buttons_width = volume_right - prev_left
                if buttons_width > 0:
                    self.progress_bar.setFixedWidth(buttons_width)
                    # Force update to ensure it takes effect
                    self.progress_bar.updateGeometry()
                    return
        except Exception as e:
            logger.debug(f"Error calculating progress bar width from geometry: {e}")
        
        # Fallback: use calculated width based on button sizes
        # 8 buttons * 22px = 176px
        # 7 spaces * 1px = 7px  
        # Total: 183px
        buttons_width = 8 * 22 + 7 * 1
        self.progress_bar.setFixedWidth(buttons_width)
        self.progress_bar.updateGeometry()
    
    def resizeEvent(self, event):
        """Handle window resize - update edge widget positions."""
        super().resizeEvent(event)
        self._update_resize_edge_positions()
        # Ensure edge widgets stay on top after resize
        if hasattr(self, '_left_resize_edge') and self._left_resize_edge:
            self._left_resize_edge.raise_()
        if hasattr(self, '_right_resize_edge') and self._right_resize_edge:
            self._right_resize_edge.raise_()
        # Update button widths based on text content
        self._update_button_widths()
        # Update progress bar width to match control buttons (with small delay to ensure geometry is ready)
        QTimer.singleShot(10, self._update_progress_bar_width)
        # Also update album button width after progress bar is updated (to account for time label)
        QTimer.singleShot(20, self._update_button_widths)
        # Update cover art height to match window height
        if hasattr(self, 'cover_art_label'):
            self.cover_art_label.setFixedHeight(self.height())
        # Update container widths to cover text overflow (with delay to ensure geometry is ready)
        if hasattr(self, '_extend_container_width'):
            QTimer.singleShot(10, self._extend_container_width)
        if hasattr(self, '_extend_time_container_width'):
            QTimer.singleShot(10, self._extend_time_container_width)
        # Force layout update (don't call processEvents() here to avoid conflicts with manual resize)
        if hasattr(self, 'track_menu_btn') and hasattr(self, 'album_menu_btn'):
            self.updateGeometry()
    
    def eventFilter(self, obj, event):
        """Handle events for window dragging, snapping, album menu delete key, and drag-and-drop."""
        # Handle drag-and-drop on album button
        if hasattr(self, 'album_menu_btn') and obj == self.album_menu_btn:
            if event.type() == QEvent.Type.DragEnter:
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                    # Add visual feedback (highlight)
                    self._dragging_over_album_btn = True
                    # Update button style to show highlight
                    highlight_style = self._original_album_btn_style + """
                        QPushButton {
                            background-color: #3a5a7a !important;
                        }
                        QPushButton:hover {
                            background-color: #4a6a8a !important;
                        }
                    """
                    self.album_menu_btn.setStyleSheet(highlight_style)
                    self.album_menu_btn.update()
                    return True
                else:
                    event.ignore()
                    return True
            elif event.type() == QEvent.Type.DragMove:
                # Keep accepting while dragging over button
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                    return True
                else:
                    event.ignore()
                    return True
            elif event.type() == QEvent.Type.DragLeave:
                # Remove visual feedback
                self._dragging_over_album_btn = False
                # Restore original style (remove highlight)
                if hasattr(self, '_original_album_btn_style'):
                    self.album_menu_btn.setStyleSheet(self._original_album_btn_style)
                self.album_menu_btn.update()
                return True
            elif event.type() == QEvent.Type.Drop:
                # Extract all URLs
                urls = []
                if event.mimeData().hasUrls():
                    url_list = event.mimeData().urls()
                    urls = [url.toString() for url in url_list]
                elif event.mimeData().hasText():
                    text = event.mimeData().text().strip()
                    if text:
                        lines = [line.strip() for line in text.split('\n') if line.strip()]
                        urls = lines
                
                if not urls:
                    event.ignore()
                    # Remove visual feedback
                    self._dragging_over_album_btn = False
                    if hasattr(self, '_original_album_btn_style'):
                        self.album_menu_btn.setStyleSheet(self._original_album_btn_style)
                    self.album_menu_btn.update()
                    return True
                
                # Process all URLs - add to playlist
                if self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
                    added_count = 0
                    skipped_count = 0
                    existing_urls = [item.get("url") if isinstance(item, dict) else item 
                                    for item in self.parent_window.playlist_manager.playlist]
                    
                    for url in urls:
                        # Try to resolve redirects
                        resolved = None
                        if self.parent_window and hasattr(self.parent_window, 'resolve_url_redirects'):
                            resolved = self.parent_window.resolve_url_redirects(url)
                        
                        if resolved:
                            url = resolved
                        
                        # Normalize URL
                        url = url.strip().rstrip('/')
                        if not url.startswith(('http://', 'https://')):
                            url = 'https://' + url
                        
                        # Only add if it's a Bandcamp URL and not already in playlist
                        if 'bandcamp.com' in url.lower():
                            if url not in existing_urls:
                                self.parent_window.playlist_manager.add_url(url)
                                added_count += 1
                                existing_urls.append(url)
                            else:
                                skipped_count += 1
                        else:
                            skipped_count += 1
                    
                    # Save playlist after adding all URLs
                    if added_count > 0:
                        self.parent_window.playlist_manager.save_playlist()
                        if hasattr(self.parent_window, 'update_playlist_display'):
                            self.parent_window.update_playlist_display()
                    
                    # Show feedback message
                    if len(urls) > 1:
                        msg = QMessageBox(self)
                        msg.setWindowTitle("Add URLs")
                        if added_count > 0 and skipped_count > 0:
                            msg.setText(f"Added {added_count} URL(s) to playlist.\nSkipped {skipped_count} (duplicates or invalid).")
                        elif added_count > 0:
                            msg.setText(f"Added {added_count} URL(s) to playlist.")
                        else:
                            msg.setText("No URLs added. All were duplicates or invalid.")
                        msg.setStyleSheet("""
                            QMessageBox {
                                background-color: #2b2b2b;
                                color: #e0e0e0;
                            }
                            QMessageBox QLabel {
                                color: #e0e0e0;
                                background-color: transparent;
                            }
                            QMessageBox QPushButton {
                                background-color: #3a3a3a;
                                color: #e0e0e0;
                                border: 1px solid #4a4a4a;
                                border-radius: 4px;
                                padding: 5px 15px;
                                min-width: 60px;
                            }
                            QMessageBox QPushButton:hover {
                                background-color: #4a4a4a;
                            }
                        """)
                        msg.exec()
                    elif len(urls) == 1:
                        # Single URL - show tooltip feedback
                        if added_count > 0:
                            message = "URL added to playlist"
                        else:
                            message = "URL not added (duplicate or invalid)"
                        global_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().center())
                        QToolTip.showText(global_pos, message, self.album_menu_btn, QRect(), 2000)
                
                # Remove visual feedback
                self._dragging_over_album_btn = False
                if hasattr(self, '_original_album_btn_style'):
                    self.album_menu_btn.setStyleSheet(self._original_album_btn_style)
                self.album_menu_btn.update()
                
                event.acceptProposedAction()
                return True
        
        # Handle delete key in album menu
        if hasattr(self, '_album_list') and obj == self._album_list and event.type() == QEvent.Type.KeyPress:
            if event.key() == Qt.Key.Key_Delete:
                selected_items = self._album_list.selectedItems()
                if selected_items:
                    for item in selected_items:
                        url = item.data(Qt.ItemDataRole.UserRole)
                        if url and self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
                            self.parent_window.playlist_manager.remove_url(url)
                        row = self._album_list.row(item)
                        self._album_list.takeItem(row)
                    return True
        
        # Prevent window dragging when interacting with progress bar
        if hasattr(self, 'progress_bar') and obj == self.progress_bar:
            # Let the slider handle all its own events
            return False
        
        # Handle dragging from cover art label
        if hasattr(self, 'cover_art_label') and obj == self.cover_art_label:
            if event.type() == QEvent.Type.MouseButtonPress:
                if event.button() == Qt.MouseButton.LeftButton:
                    # Start dragging from cover art
                    self._drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                    return True
            elif event.type() == QEvent.Type.MouseMove:
                # Handle dragging
                if self._drag_position is not None and event.buttons() == Qt.MouseButton.LeftButton:
                    new_pos = event.globalPosition().toPoint() - self._drag_position
                    
                    # If docked, check if user is trying to drag away (undock)
                    if self._docked_edge and self._docked_y_position is not None:
                        screen = QApplication.primaryScreen()
                        if screen:
                            screen_geometry = screen.availableGeometry()
                            # Check if intended Y position is far enough from edge to undock
                            should_undock = False
                            if self._docked_edge == 'top':
                                if abs(new_pos.y() - screen_geometry.top()) > self._snap_threshold * 2:
                                    should_undock = True
                            elif self._docked_edge == 'bottom':
                                window_height = self.height()
                                if abs(new_pos.y() + window_height - screen_geometry.bottom()) > self._snap_threshold * 2:
                                    should_undock = True
                            
                            if should_undock:
                                # Undock and allow normal movement
                                self._undock()
                                self.move(new_pos)
                                # Check for snapping (which may dock again)
                                self._check_snap_to_edges()
                            else:
                                # Still docked - constrain to horizontal movement only
                                self.move(new_pos.x(), self._docked_y_position)
                        else:
                            # No screen info - just constrain to horizontal
                            self.move(new_pos.x(), self._docked_y_position)
                    else:
                        # Normal dragging - allow both X and Y movement
                        self.move(new_pos)
                        # Check for snapping (which may dock)
                        self._check_snap_to_edges()
                    return True
            elif event.type() == QEvent.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    self._drag_position = None
                    return True
            return False
        
        # Handle resize edge widgets (check if they exist first and are not None)
        if (hasattr(self, '_left_resize_edge') and self._left_resize_edge is not None and
            hasattr(self, '_right_resize_edge') and self._right_resize_edge is not None and
            (obj == self._left_resize_edge or obj == self._right_resize_edge)):
            if event.type() == QEvent.Type.MouseButtonPress:
                if event.button() == Qt.MouseButton.LeftButton:
                    # Determine which edge
                    edge = 'left' if obj == self._left_resize_edge else 'right'
                    self._resize_edge = edge
                    self._resize_start_pos = event.globalPosition().toPoint()
                    self._resize_start_geometry = self.frameGeometry()
                    return True
            elif event.type() == QEvent.Type.MouseMove:
                # Cursor is already set on the edge widgets, but handle resize if dragging
                if self._resize_edge is not None and self._resize_start_pos is not None and self._resize_start_geometry is not None:
                    if event.buttons() == Qt.MouseButton.LeftButton:
                        current_pos = event.globalPosition().toPoint()
                        delta_x = current_pos.x() - self._resize_start_pos.x()
                        
                        if self._resize_edge == 'left':
                            # Resize from left edge
                            new_width = self._resize_start_geometry.width() - delta_x
                            new_x = self._resize_start_geometry.x() + delta_x
                            
                            # Enforce minimum width
                            if new_width < self.minimumWidth():
                                new_width = self.minimumWidth()
                                new_x = self._resize_start_geometry.x() + self._resize_start_geometry.width() - new_width
                            
                            # Update window geometry
                            self.setGeometry(new_x, self._resize_start_geometry.y(), new_width, self._resize_start_geometry.height())
                        elif self._resize_edge == 'right':
                            # Resize from right edge
                            new_width = self._resize_start_geometry.width() + delta_x
                            
                            # Enforce minimum width
                            if new_width < self.minimumWidth():
                                new_width = self.minimumWidth()
                            
                            # Update window geometry (x stays the same, only width changes)
                            self.setGeometry(self._resize_start_geometry.x(), self._resize_start_geometry.y(), new_width, self._resize_start_geometry.height())
                        
                        return True
            elif event.type() == QEvent.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    self._resize_edge = None
                    self._resize_start_pos = None
                    self._resize_start_geometry = None
                    return True
            return False
        
        # Handle window dragging and snapping
        if obj == self:
            # Handle mouse events for dragging
            if event.type() == QEvent.Type.MouseButtonPress:
                if event.button() == Qt.MouseButton.LeftButton:
                    # Check if click is on a button, slider, or label - don't drag in that case
                    # EXCEPT: allow dragging from cover art label
                    click_pos = event.position().toPoint()
                    child = self.childAt(click_pos)
                    
                    # Walk up the widget hierarchy to check if we're clicking on a control
                    widget = child
                    while widget:
                        # Allow dragging from cover art label
                        if hasattr(self, 'cover_art_label') and widget == self.cover_art_label:
                            # Start dragging from cover art
                            self._drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                            return True
                        if isinstance(widget, (QPushButton, QSlider, QLabel, QListWidget)):
                            # Click is on a control (but not cover art) - don't start dragging
                            return False
                        widget = widget.parentWidget() if hasattr(widget, 'parentWidget') else None
                    
                    # Not on a control - start dragging
                    self._drag_position = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                    return True
            elif event.type() == QEvent.Type.MouseMove:
                
                # Handle dragging
                if self._drag_position is not None:
                    # Once dragging has started, continue dragging regardless of what widget we're over
                    # (only check on press, not during move)
                    new_pos = event.globalPosition().toPoint() - self._drag_position
                    
                    # If docked, check if user is trying to drag away (undock)
                    if self._docked_edge and self._docked_y_position is not None:
                        screen = QApplication.primaryScreen()
                        if screen:
                            screen_geometry = screen.availableGeometry()
                            # Check if intended Y position is far enough from edge to undock
                            should_undock = False
                            if self._docked_edge == 'top':
                                if abs(new_pos.y() - screen_geometry.top()) > self._snap_threshold * 2:
                                    should_undock = True
                            elif self._docked_edge == 'bottom':
                                window_height = self.height()
                                if abs(new_pos.y() + window_height - screen_geometry.bottom()) > self._snap_threshold * 2:
                                    should_undock = True
                            
                            if should_undock:
                                # Undock and allow normal movement
                                self._undock()
                                self.move(new_pos)
                                # Check for snapping (which may dock again)
                                self._check_snap_to_edges()
                            else:
                                # Still docked - constrain to horizontal movement only
                                self.move(new_pos.x(), self._docked_y_position)
                        else:
                            # No screen info - just constrain to horizontal
                            self.move(new_pos.x(), self._docked_y_position)
                    else:
                        # Normal dragging - allow both X and Y movement
                        self.move(new_pos)
                        # Check for snapping (which may dock)
                        self._check_snap_to_edges()
                    return True
            elif event.type() == QEvent.Type.MouseButtonRelease:
                if event.button() == Qt.MouseButton.LeftButton:
                    self._drag_position = None
                    self._resize_edge = None
                    self._resize_start_pos = None
                    self._resize_start_geometry = None
                    self.setCursor(Qt.CursorShape.ArrowCursor)
                    return True
            elif event.type() == QEvent.Type.Leave:
                # Reset cursor when mouse leaves window (if not actively resizing)
                if self._resize_edge is None:
                    self.setCursor(Qt.CursorShape.ArrowCursor)
                return False
        
        return super().eventFilter(obj, event)
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event on the nano player window"""
        # Only accept if it's a URL or text (not web content)
        if event.mimeData().hasUrls() or event.mimeData().hasText():
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def dropEvent(self, event: QDropEvent):
        """Handle drop event on the nano player window - load first URL"""
        # Check if drop is over album button - if so, let it handle it
        if hasattr(self, 'album_menu_btn'):
            pos = event.position().toPoint()
            album_btn_rect = self.album_menu_btn.geometry()
            if album_btn_rect.contains(pos):
                # Let album button handle it
                return
        
        # Extract first URL
        url = None
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if urls:
                url = urls[0].toString()
        elif event.mimeData().hasText():
            text = event.mimeData().text().strip()
            if text:
                lines = [line.strip() for line in text.split('\n') if line.strip()]
                if lines:
                    url = lines[0]
        
        if not url:
            event.ignore()
            return
        
        # Validate URL before processing
        # Try to resolve redirects if it's not already a Bandcamp URL
        resolved_url = None
        if self.parent_window and hasattr(self.parent_window, 'resolve_url_redirects'):
            resolved_url = self.parent_window.resolve_url_redirects(url)
        
        if resolved_url:
            url = resolved_url
        
        # Check if it's a Bandcamp URL
        if 'bandcamp.com' not in url.lower():
            # Not a Bandcamp URL - show message
            QMessageBox.warning(self, "Invalid URL", "Please enter a Bandcamp URL")
            event.ignore()
            return
        
        # Process URL using parent window's handler (same as main window)
        if self.parent_window:
            self.parent_window._handle_global_drop(url)
        
        event.acceptProposedAction()
    
    def contextMenuEvent(self, event):
        """Handle right-click context menu on nano player."""
        menu = QMenu(self)
        self._context_menu = menu  # Store reference to prevent autohide
        
        # Paste URL
        paste_url_action = QAction("Paste URL", self)
        if HAS_QT_AWESOME:
            icon = get_icon('paste', color='#e0e0e0')
            if icon:
                paste_url_action.setIcon(icon)
        else:
            paste_url_action.setText(" Paste URL")
        paste_url_action.triggered.connect(lambda: self.parent_window.on_paste_url() if self.parent_window else None)
        menu.addAction(paste_url_action)
        
        menu.addSeparator()
        
        # Get current page URL for "Open in Browser" and "Copy URL"
        current_url = None
        if self.parent_window and hasattr(self.parent_window, 'web_view') and self.parent_window.web_view:
            current_url = self.parent_window.web_view.url().toString()
        
        if current_url and current_url != "about:blank":
            # Open in Browser
            open_browser_action = QAction("Open in Browser", self)
            if HAS_QT_AWESOME:
                icon = get_icon('external-link-alt', color='#e0e0e0')
                if icon:
                    open_browser_action.setIcon(icon)
            else:
                open_browser_action.setText(" Open in Browser")
            open_browser_action.triggered.connect(lambda: QDesktopServices.openUrl(QUrl(current_url)))
            menu.addAction(open_browser_action)
            
            # Copy URL
            copy_url_action = QAction("Copy URL", self)
            if HAS_QT_AWESOME:
                icon = get_icon('copy', color='#e0e0e0')
                if icon:
                    copy_url_action.setIcon(icon)
            else:
                copy_url_action.setText(" Copy URL")
            def copy_url_with_feedback():
                QApplication.clipboard().setText(current_url)
                global_pos = self.mapToGlobal(self.rect().center())
                QToolTip.showText(global_pos, "URL copied", self, QRect(), 1500)
            copy_url_action.triggered.connect(copy_url_with_feedback)
            menu.addAction(copy_url_action)
            
            menu.addSeparator()
        
        # Autohide Nano when Docked (only enabled when docked)
        autohide_action = QAction("Autohide Nano when Docked", self)
        autohide_action.setCheckable(True)
        autohide_action.setChecked(self.nano_autohide_when_docked)
        autohide_action.setEnabled(self._docked_edge is not None)
        def toggle_autohide():
            self.nano_autohide_when_docked = not self.nano_autohide_when_docked
            if self.nano_autohide_when_docked and self._docked_edge:
                self._autohide_timer.start()
                # Initially hide window after a short delay
                QTimer.singleShot(500, lambda: self._initial_autohide())
            else:
                self._autohide_timer.stop()
                # Hide hover area if it exists (legacy, not used anymore)
                if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
                    self._autohide_hover_area.hide()
                if self._is_autohidden:
                    # Restore window position
                    if hasattr(self, '_autohide_saved_pos') and self._autohide_saved_pos:
                        self.move(self._autohide_saved_pos)
                        self._autohide_saved_pos = None
                    self.show()
                    self._is_autohidden = False
        autohide_action.triggered.connect(toggle_autohide)
        menu.addAction(autohide_action)
        
        # Autohide Sensitivity submenu (only enabled when docked and autohide is enabled)
        sensitivity_menu = QMenu("Autohide Sensitivity", self)
        sensitivity_menu.setStyleSheet(menu.styleSheet())
        sensitivity_menu.setEnabled(self._docked_edge is not None and self.nano_autohide_when_docked)
        
        # Get current player height for "Player Height" option
        player_height = self.height() if self.height() > 0 else 50
        
        # Preset options
        presets = [
            ("5px", 5),
            ("10px", 10),
            ("20px", 20),
            ("50px", 50),
            (f"Player Height ({player_height}px)", player_height)
        ]
        
        for preset_name, preset_value in presets:
            preset_action = QAction(preset_name, self)
            preset_action.setCheckable(True)
            preset_action.setChecked(abs(self.nano_autohide_sensitivity - preset_value) < 1)  # Check if within 1px
            def set_sensitivity(value):
                self.nano_autohide_sensitivity = value
                # Clamp to valid range (5px to player height)
                max_sensitivity = self.height() if self.height() > 0 else 200
                self.nano_autohide_sensitivity = max(5, min(self.nano_autohide_sensitivity, max_sensitivity))
                self.parent_window.settings['nano_autohide_sensitivity'] = self.nano_autohide_sensitivity
                self.parent_window.save_settings()
                # Update hover area with new sensitivity
                self._update_autohide_hover_area()
            preset_action.triggered.connect(lambda checked, val=preset_value: set_sensitivity(val))
            sensitivity_menu.addAction(preset_action)
        
        sensitivity_menu.addSeparator()
        
        # Custom option
        custom_action = QAction("Custom...", self)
        def show_custom_dialog():
            dialog = QDialog(self)
            dialog.setWindowTitle("Autohide Sensitivity")
            dialog.setModal(True)
            dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                }
                QLabel {
                    color: #e0e0e0;
                }
                QSlider::groove:horizontal {
                    border: 1px solid #4a4a4a;
                    height: 8px;
                    background: #3a3a3a;
                    border-radius: 4px;
                }
                QSlider::handle:horizontal {
                    background: #4a90e2;
                    border: 1px solid #3a7bc8;
                    width: 18px;
                    height: 18px;
                    margin: -5px 0;
                    border-radius: 9px;
                }
                QSlider::handle:horizontal:hover {
                    background: #5aa0f2;
                }
                QPushButton {
                    background-color: #3a3a3a;
                    color: #e0e0e0;
                    border: 1px solid #4a4a4a;
                    border-radius: 4px;
                    padding: 6px 20px;
                    min-width: 60px;
                }
                QPushButton:hover {
                    background-color: #4a4a4a;
                }
                QPushButton:pressed {
                    background-color: #2a2a2a;
                }
            """)
            
            layout = QVBoxLayout(dialog)
            layout.setSpacing(15)
            layout.setContentsMargins(20, 20, 20, 20)
            
            # Label showing current value
            value_label = QLabel(f"Sensitivity: {self.nano_autohide_sensitivity}px")
            value_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            value_label.setStyleSheet("font-size: 14px; font-weight: bold;")
            layout.addWidget(value_label)
            
            # Slider
            slider = QSlider(Qt.Orientation.Horizontal)
            # Calculate max sensitivity: use current player height or 200px, whichever is larger
            current_player_height = self.height() if self.height() > 0 else 50
            max_sensitivity = max(current_player_height, self.nano_autohide_sensitivity, 200)  # At least 200px max
            slider.setMinimum(5)
            slider.setMaximum(max_sensitivity)
            # Clamp current value to valid range
            current_value = max(5, min(self.nano_autohide_sensitivity, max_sensitivity))
            slider.setValue(current_value)
            slider.setTickPosition(QSlider.TickPosition.TicksBelow)
            tick_interval = max(5, max_sensitivity // 20)  # Reasonable tick interval
            slider.setTickInterval(tick_interval)
            
            def update_label(value):
                value_label.setText(f"Sensitivity: {value}px")
            
            slider.valueChanged.connect(update_label)
            layout.addWidget(slider)
            
            # Info label
            info_label = QLabel(f"Range: 5px - {max_sensitivity}px\nAdjust how much of the player acts as a hotspot.\nLower values = smaller hotspot (less blocking).")
            info_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            info_label.setStyleSheet("color: #a0a0a0; font-size: 11px;")
            layout.addWidget(info_label)
            
            # Buttons
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            button_layout.addWidget(cancel_btn)
            
            ok_btn = QPushButton("OK")
            ok_btn.setDefault(True)
            def apply_sensitivity():
                self.nano_autohide_sensitivity = slider.value()
                self.parent_window.settings['nano_autohide_sensitivity'] = self.nano_autohide_sensitivity
                self.parent_window.save_settings()
                # Update hover area with new sensitivity
                self._update_autohide_hover_area()
                dialog.accept()
            ok_btn.clicked.connect(apply_sensitivity)
            button_layout.addWidget(ok_btn)
            
            layout.addLayout(button_layout)
            
            dialog.resize(300, 150)
            dialog.exec()
        
        custom_action.triggered.connect(show_custom_dialog)
        sensitivity_menu.addAction(custom_action)
        
        # Add sensitivity submenu
        sensitivity_action = menu.addMenu(sensitivity_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('sliders-h', color='#e0e0e0')
            if icon:
                sensitivity_action.setIcon(icon)
        
        menu.addSeparator()
        
        # Autoplay
        autoplay_action = QAction("Autoplay", self)
        autoplay_action.setCheckable(True)
        if self.parent_window:
            autoplay_action.setChecked(self.parent_window.autoplay)
            def toggle_autoplay():
                if self.parent_window:
                    self.parent_window.autoplay = not self.parent_window.autoplay
                    self.parent_window.autoplay_action.setChecked(self.parent_window.autoplay)
                    self.parent_window.save_settings()
            autoplay_action.triggered.connect(toggle_autoplay)
        menu.addAction(autoplay_action)
        
        # Autoplay on Startup
        autoplay_on_startup_action = QAction("Autoplay on Startup", self)
        autoplay_on_startup_action.setCheckable(True)
        if self.parent_window:
            autoplay_on_startup_action.setChecked(self.parent_window.autoplay_on_startup)
            def toggle_autoplay_on_startup():
                if self.parent_window:
                    self.parent_window.autoplay_on_startup = not self.parent_window.autoplay_on_startup
                    self.parent_window.autoplay_on_startup_action.setChecked(self.parent_window.autoplay_on_startup)
                    self.parent_window.save_settings()
            autoplay_on_startup_action.triggered.connect(toggle_autoplay_on_startup)
        menu.addAction(autoplay_on_startup_action)
        
        # Style the menu
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #4a4a4a;
                border-radius: 4px;
                padding: 4px;
            }
            QMenu::item {
                padding: 6px 20px 6px 30px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #3a3a3a;
            }
            QMenu::item:disabled {
                color: #666666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #4a4a4a;
                margin: 4px 0;
            }
        """)
        
        menu.exec(event.globalPos())
        # Clear menu reference after it closes
        self._context_menu = None
    
    def _check_snap_to_edges(self):
        """Check if window should snap to top or bottom edge of screen, and handle docking."""
        # If already docked, don't check for snapping (allow smooth dragging)
        if self._docked_edge:
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        screen_geometry = screen.availableGeometry()
        window_geometry = self.frameGeometry()
        
        # Calculate distances to edges
        dist_to_top = abs(window_geometry.top() - screen_geometry.top())
        dist_to_bottom = abs(window_geometry.bottom() - screen_geometry.bottom())
        
        # Check which edge is closer and snap to it if within threshold
        if dist_to_top < self._snap_threshold and dist_to_top <= dist_to_bottom:
            # Snap to top edge
            self.move(window_geometry.left(), screen_geometry.top())
            # Dock to top edge
            self._docked_edge = 'top'
            self._docked_y_position = screen_geometry.top()
            # Start autohide timer if enabled (but don't trigger immediately)
            if self.nano_autohide_when_docked:
                self._autohide_timer.start()
                # Don't call _initial_autohide immediately - let showEvent set cooldown first
                # The timer will handle autohide after cooldown expires
        elif dist_to_bottom < self._snap_threshold:
            # Snap to bottom edge
            self.move(window_geometry.left(), screen_geometry.bottom() - window_geometry.height())
            # Dock to bottom edge
            self._docked_edge = 'bottom'
            self._docked_y_position = screen_geometry.bottom() - window_geometry.height()
            # Start autohide timer if enabled (but don't trigger immediately)
            if self.nano_autohide_when_docked:
                self._autohide_timer.start()
                # Don't call _initial_autohide immediately - let showEvent set cooldown first
                # The timer will handle autohide after cooldown expires
    
    def _initial_autohide(self):
        """Initially move window off-screen when autohide is enabled after docking."""
        # Don't autohide if we're in cooldown (window was just shown)
        if self._autohide_cooldown:
            return
        
        if self._docked_edge and self.nano_autohide_when_docked and not self._is_autohidden:
            # Small delay to let user see the window first, then show only a sliver at the edge
            if self.isVisible():
                # Save current position (ensure it's a valid QPoint)
                current_pos = self.pos()
                if current_pos is not None:
                    self._autohide_saved_pos = current_pos
                # Move window so only a small sliver (3px) is visible at the docked edge
                screen = QApplication.primaryScreen()
                if screen:
                    screen_geometry = screen.geometry()
                    window_height = self.height()
                    sliver_size = 2  # Show 1px sliver at the edge
                    
                    if self._docked_edge == 'top':
                        # Position so only top 3px is visible
                        self.move(self.x(), screen_geometry.top() - window_height + sliver_size)
                    elif self._docked_edge == 'bottom':
                        # Position so only bottom 3px is visible
                        self.move(self.x(), screen_geometry.bottom() - sliver_size)
                self._is_autohidden = True
                # Hide cover art when autohidden so only interface color shows in sliver
                if hasattr(self, 'cover_art_label') and self.cover_art_label:
                    self.cover_art_label.hide()
    
    def _undock(self):
        """Undock window from edge."""
        self._docked_edge = None
        self._docked_y_position = None
        self._autohide_timer.stop()
        # Hide hover area
        if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
            self._autohide_hover_area.hide()
        # Restore window position if it was autohidden
        if self._is_autohidden:
            if hasattr(self, '_autohide_saved_pos') and self._autohide_saved_pos:
                self.move(self._autohide_saved_pos)
                self._autohide_saved_pos = None
            self.show()
            self._is_autohidden = False
    
    def _update_autohide_hover_area(self):
        """Update the autohide hover area position and size based on docking state."""
        if not hasattr(self, '_autohide_hover_area') or not self._autohide_hover_area:
            return
        
        if not self._docked_edge or not self.nano_autohide_when_docked:
            self._autohide_hover_area.hide()
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        screen_geometry = screen.availableGeometry()
        
        # Position hover area at the screen edge (top or bottom)
        # The hover area is only as tall as the sensitivity setting
        if self._docked_edge == 'top':
            # Position at top of screen, full width, height = sensitivity
            self._autohide_hover_area.setGeometry(
                screen_geometry.left(),
                screen_geometry.top(),
                screen_geometry.width(),
                self.nano_autohide_sensitivity
            )
        elif self._docked_edge == 'bottom':
            # Position at bottom of screen, full width, height = sensitivity
            self._autohide_hover_area.setGeometry(
                screen_geometry.left(),
                screen_geometry.bottom() - self.nano_autohide_sensitivity,
                screen_geometry.width(),
                self.nano_autohide_sensitivity
            )
        
        # Show hover area when autohide is enabled and window is hidden
        # Also show it initially when docked (will hide when window is shown)
        if self._is_autohidden or not self.isVisible():
            # Make sure it's shown and can receive mouse events
            self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, False)
            # Show and raise the hover area
            self._autohide_hover_area.show()
            self._autohide_hover_area.raise_()
            # Ensure it's on top and can receive events
            self._autohide_hover_area.setWindowState(Qt.WindowState.WindowNoState)
            # Force update to ensure it's visible
            self._autohide_hover_area.update()
            # Process events to ensure widget is shown and positioned
            QApplication.processEvents()
        else:
            # Hide hover area when window is visible (mouse over window keeps it visible)
            self._autohide_hover_area.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._autohide_hover_area.hide()
    
    def _check_autohide_after_leave(self):
        """Check if window should hide after mouse leaves hover area."""
        if not self._docked_edge or not self.nano_autohide_when_docked:
            return
        
        # Don't autohide if context menu is open
        if self._context_menu and self._context_menu.isVisible():
            return
        
        # Check if mouse is over the window or menu
        global_pos = QCursor.pos()
        window_geometry = self.frameGeometry()
        mouse_over_window = window_geometry.contains(global_pos)
        
        mouse_over_menu = False
        if self._context_menu:
            menu_geometry = self._context_menu.geometry()
            mouse_over_menu = menu_geometry.contains(global_pos)
        
        # Only hide if mouse is not over window or menu
        if not mouse_over_window and not mouse_over_menu:
            if not self._is_autohidden and self.isVisible():
                self.hide()
                self._is_autohidden = True
                # Update hover area to show it
                self._update_autohide_hover_area()
    
    def _check_autohide(self):
        """Check if window should show/hide based on mouse position relative to screen edge.
        
        Uses a simple timer-based approach that checks if mouse is within sensitivity
        pixels of the docked screen edge.
        """
        if not self._docked_edge or not self.nano_autohide_when_docked:
            return
        
        # Don't autohide if context menu is open
        if self._context_menu and self._context_menu.isVisible():
            return
        
        # Don't autohide if we're in cooldown (window was just shown)
        if self._autohide_cooldown:
            return
        
        screen = QApplication.primaryScreen()
        if not screen:
            return
        
        # Get global mouse position and screen geometry
        # Use geometry() not availableGeometry() to get full screen including taskbar area
        global_pos = QCursor.pos()
        screen_geometry = screen.geometry()  # Full screen geometry
        window_geometry = self.frameGeometry()
        
        # Check if mouse is over the window
        mouse_over_window = window_geometry.contains(global_pos)
        
        # Check if mouse is over the menu (additional safety check)
        mouse_over_menu = False
        if self._context_menu:
            menu_geometry = self._context_menu.geometry()
            mouse_over_menu = menu_geometry.contains(global_pos)
        
        # Check if mouse is within sensitivity pixels of the docked screen edge
        # This checks the actual screen edge, not the window position
        mouse_near_edge = False
        if self._docked_edge == 'top':
            # Check if mouse Y is within sensitivity pixels of top edge of screen
            # screen_geometry.top() is the top of the screen
            mouse_near_edge = global_pos.y() <= screen_geometry.top() + self.nano_autohide_sensitivity
        elif self._docked_edge == 'bottom':
            # Check if mouse Y is within sensitivity pixels of bottom edge of screen
            # screen_geometry.bottom() is the bottom of the screen
            mouse_near_edge = global_pos.y() >= screen_geometry.bottom() - self.nano_autohide_sensitivity
        
        # Show window if mouse is near edge, over window, or over menu
        if mouse_near_edge or mouse_over_window or mouse_over_menu:
            if self._is_autohidden:
                # Restore window position (move back on-screen)
                if hasattr(self, '_autohide_saved_pos') and self._autohide_saved_pos is not None:
                    self.move(self._autohide_saved_pos)
                    self._autohide_saved_pos = None
                else:
                    # If no saved position, restore to docked position
                    if self._docked_edge == 'top' and self._docked_y_position is not None:
                        self.move(self.x(), self._docked_y_position)
                    elif self._docked_edge == 'bottom' and self._docked_y_position is not None:
                        self.move(self.x(), self._docked_y_position)
                self.show()
                self._is_autohidden = False
                # Show cover art when window is restored
                if hasattr(self, 'cover_art_label') and self.cover_art_label:
                    self.cover_art_label.show()
                # Hide hover area if it exists
                if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
                    self._autohide_hover_area.hide()
        else:
            # Move window so only a small sliver is visible at the docked edge (keeps it in taskbar)
            if not self._is_autohidden and self.isVisible():
                # Save current position (ensure it's a valid QPoint)
                current_pos = self.pos()
                if current_pos is not None:
                    self._autohide_saved_pos = current_pos
                # Move window so only a small sliver (3px) is visible at the docked edge
                screen_geometry = screen.geometry()
                window_height = self.height()
                sliver_size = 2  # Show 1px sliver at the edge
                
                if self._docked_edge == 'top':
                    # Position so only top 3px is visible
                    self.move(self.x(), screen_geometry.top() - window_height + sliver_size)
                elif self._docked_edge == 'bottom':
                    # Position so only bottom 3px is visible
                    self.move(self.x(), screen_geometry.bottom() - sliver_size)
                self._is_autohidden = True
                # Hide cover art when autohidden so only interface color shows in sliver
                if hasattr(self, 'cover_art_label') and self.cover_art_label:
                    self.cover_art_label.hide()
    
    def _on_prev_album(self):
        """Handle previous album button click."""
        if self.parent_window and hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
            self.parent_window.playlist_sidebar.load_previous_album()
    
    def _on_prev_track(self):
        """Handle previous track button click."""
        if self.parent_window:
            self.parent_window._trigger_previous_track()
    
    def _on_play_pause(self):
        """Handle play/pause button click."""
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        # Get saved track number if available (for resuming playback on the same track)
        saved_track_number = None
        if self.parent_window and hasattr(self.parent_window, 'settings'):
            saved_track_number = self.parent_window.settings.get("last_played_track_number")
            if saved_track_number is not None:
                try:
                    saved_track_number = int(saved_track_number)
                except (ValueError, TypeError):
                    saved_track_number = None
        
        # Toggle play/pause via JavaScript with support for loading saved track or first track if needed
        js_code = f"""
        (function() {{
            var audio = document.querySelector('audio');
            
            // If audio exists and is ready, toggle play/pause
            if (audio && audio.readyState >= 2) {{  // HAVE_CURRENT_DATA or higher
                if (audio.paused) {{
                    var playPromise = audio.play();
                    if (playPromise !== undefined) {{
                        playPromise.catch(function(error) {{
                            console.log('Bandcamp Player: audio.play() failed, trying fallback:', error);
                            // Fallback to clicking play button
                            var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                            if (playBtn) {{
                                playBtn.click();
                            }}
                        }});
                    }}
                }} else {{
                    audio.pause();
                }}
                return;
            }}
            
            // If audio exists but not ready, try clicking play button
            if (audio) {{
                var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                if (playBtn) {{
                    playBtn.click();
                    return;
                }}
            }}
            
            // No audio or play button found - need to load track
            // Check if this is a single track page
            var isSingleTrackPage = window.location.href.indexOf('/track/') !== -1;
            var player = document.querySelector('#player');
            
            if (isSingleTrackPage && player) {{
                // For singles, try to find and click the play button directly
                var playBtn = player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"], button[aria-label*="play"], button[aria-label*="Play"]');
                if (playBtn && playBtn.offsetParent !== null) {{
                    playBtn.click();
                    return;
                }}
            }}
            
            // For albums, try clicking the saved track number or first track
            // Use a function with retry logic to wait for tracklist to be ready
            function loadTrackWithRetry(retryCount) {{
                retryCount = retryCount || 0;
                var maxRetries = 10;
                var retryDelay = 100;
                
                var tracklist = document.querySelector('#tracklist');
                if (!tracklist && retryCount < maxRetries) {{
                    // Tracklist not ready yet, retry
                    setTimeout(function() {{
                        loadTrackWithRetry(retryCount + 1);
                    }}, retryDelay);
                    return;
                }}
                
                if (!tracklist) {{
                    // Tracklist not found after retries, use fallback
                    var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                    if (playBtn) {{
                        playBtn.click();
                    }}
                    return;
                }}
                
                var targetTrack = null;
                var savedTrackNum = {saved_track_number if saved_track_number is not None else 'null'};
                
                // Try to find saved track number first (if available)
                if (savedTrackNum !== null && savedTrackNum > 0) {{
                    targetTrack = tracklist.querySelector('li.track[data-num="' + savedTrackNum + '"]');
                    // If saved track not found or not playable, fall back to first track
                    if (targetTrack) {{
                        var isPlayable = targetTrack.classList.contains('playable') || 
                                        targetTrack.classList.contains('has-audio') ||
                                        targetTrack.querySelector('.info') !== null;
                        if (!isPlayable) {{
                            targetTrack = null;
                        }}
                    }}
                }}
                
                // If no saved track or saved track not found, use first track
                if (!targetTrack) {{
                    // Find first track - try data-num="1" first, then fall back to first .track element
                    targetTrack = tracklist.querySelector('li.track[data-num="1"]');
                    if (!targetTrack) {{
                        // Fallback: get first track element
                        var tracks = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                        if (tracks.length > 0) {{
                            targetTrack = tracks[0];
                        }}
                    }}
                }}
                
                if (targetTrack) {{
                    var infoDiv = targetTrack.querySelector('.info');
                    
                    // Step 1: Click target track to load it
                    if (infoDiv) {{
                        infoDiv.click();
                    }} else {{
                        targetTrack.click();
                    }}
                    
                    // Step 2: Wait for track to load, then try to play
                    setTimeout(function() {{
                        var audioElement = document.querySelector('audio');
                        if (audioElement) {{
                            var playPromise = audioElement.play();
                            if (playPromise !== undefined) {{
                                playPromise.catch(function(error) {{
                                    // Fallback: try play button
                                    var player = document.querySelector('#player');
                                    var playBtn = player ? player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]') : null;
                                    if (playBtn && playBtn.offsetParent !== null) {{
                                        playBtn.click();
                                    }}
                                }});
                            }}
                        }} else {{
                            // Audio not found yet, try play button
                            var player = document.querySelector('#player');
                            var playBtn = player ? player.querySelector('.playbutton, .play-button, button[title*="play"], button[title*="Play"]') : null;
                            if (playBtn && playBtn.offsetParent !== null) {{
                                playBtn.click();
                            }}
                        }}
                    }}, 800); // Wait 800ms for track to load
                    return;
                }} else {{
                    // No track found, use fallback
                    var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
                    if (playBtn) {{
                        playBtn.click();
                    }}
                }}
            }}
            
            // Start loading track with retry
            loadTrackWithRetry();
            
            // Final fallback: try to find any play button
            var playBtn = document.querySelector('button[aria-label*="Play"], button[aria-label*="play"], .playbutton, .play-button');
            if (playBtn) {{
                playBtn.click();
            }}
        }})();
        """
        self.parent_window.web_view.page().runJavaScript(js_code)
    
    def _on_next_track(self):
        """Handle next track button click."""
        if self.parent_window:
            self.parent_window._trigger_next_track()
    
    def _on_next_album(self):
        """Handle next album button click."""
        if self.parent_window and hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
            self.parent_window.playlist_sidebar.load_next_album()
    
    def _on_shuffle(self):
        """Handle shuffle button toggle."""
        try:
            if (self.parent_window and 
                hasattr(self.parent_window, 'playlist_sidebar') and 
                self.parent_window.playlist_sidebar and
                hasattr(self.parent_window.playlist_sidebar, 'toggle_shuffle')):
                # Toggle shuffle in playlist sidebar (cycles through modes)
                self.parent_window.playlist_sidebar.toggle_shuffle()
                # Update button state from the actual state (not button, which might be stale)
                shuffle_mode = getattr(self.parent_window.playlist_sidebar, 'shuffle_mode', 0)
                if hasattr(self, 'shuffle_btn') and self.shuffle_btn:
                    is_active = shuffle_mode > 0
                    self.shuffle_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button
                    tooltip = self.parent_window.playlist_sidebar.shuffle_btn.toolTip()
                    self.shuffle_btn.setToolTip(tooltip)
                    # Update icon based on mode
                    if HAS_QT_AWESOME:
                        if shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            self.shuffle_btn.setIcon(icon)
        except (AttributeError, RuntimeError) as e:
            logger.warning(f"Error toggling shuffle in nano player: {e}")
    
    def _on_repeat(self):
        """Handle repeat button toggle."""
        try:
            if (self.parent_window and 
                hasattr(self.parent_window, 'playlist_sidebar') and 
                self.parent_window.playlist_sidebar and
                hasattr(self.parent_window.playlist_sidebar, 'toggle_repeat')):
                # Toggle repeat in playlist sidebar (cycles through modes)
                self.parent_window.playlist_sidebar.toggle_repeat()
                # Update button state from the actual state (not button, which might be stale)
                repeat_mode = getattr(self.parent_window.playlist_sidebar, 'repeat_mode', 0)
                if hasattr(self, 'repeat_btn') and self.repeat_btn:
                    is_active = repeat_mode > 0
                    self.repeat_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button
                    tooltip = self.parent_window.playlist_sidebar.repeat_btn.toolTip()
                    self.repeat_btn.setToolTip(tooltip)
                    # Update icon based on mode
                    if HAS_QT_AWESOME:
                        if repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            self.repeat_btn.setIcon(icon)
        except (AttributeError, RuntimeError) as e:
            logger.warning(f"Error toggling repeat in nano player: {e}")
    
    def _on_volume_click(self):
        """Handle volume button click - show volume popup."""
        if self.parent_window:
            self.parent_window.show_volume_control(auto_hide=True, delay_ms=1200)
    
    def _show_track_menu(self):
        """Show track menu with tracks from current album (read-only, double-click to play)."""
        # Create a dialog-based menu (like playlist) for resizable list
        if not hasattr(self, '_track_menu_dialog') or not self._track_menu_dialog:
            self._track_menu_dialog = QDialog(self)
            self._track_menu_dialog.setWindowTitle("Tracks")
            self._track_menu_dialog.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Popup)
            self._track_menu_dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    border: 1px solid #3a3a3a;
                }
            """)
            
            layout = QVBoxLayout(self._track_menu_dialog)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setSpacing(0)
            
            # List widget for tracks (read-only)
            self._track_list = QListWidget()
            self._track_list.setStyleSheet("""
                QListWidget {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: none;
                    font-size: 11px;
                }
                QListWidget::item {
                    padding: 2px 8px;
                    border: none;
                }
                QListWidget::item:selected {
                    background-color: #4a90e2;
                    color: #ffffff;
                }
                QListWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """)
            # Use NoSelection mode - we handle highlighting via custom delegate (blue text for current track)
            self._track_list.setSelectionMode(QListWidget.SelectionMode.NoSelection)
            self._track_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # Hide horizontal scrollbar
            self._track_list.itemClicked.connect(self._on_track_clicked)
            
            # Set custom delegate for highlighting current track (use NanoMenuDelegate for nano mode)
            track_delegate = NanoMenuDelegate()
            self._track_list.setItemDelegate(track_delegate)
            
            # Set minimum/maximum constraints (actual height will be calculated based on items)
            self._track_list.setMinimumHeight(100)
            self._track_list.setMaximumHeight(600)
            # Don't set fixed height here - will be calculated based on items
            
            # Make dialog resizable
            self._track_menu_dialog.setMinimumSize(200, 100)
            self._track_menu_dialog.setMaximumSize(400, 600)
            # Don't set initial size here - will be calculated based on items
            
            layout.addWidget(self._track_list)
            
            # Track resize events to save height (allow list to resize with dialog)
            def on_track_menu_resize(event):
                if self._track_menu_dialog and self._track_list:
                    new_height = self._track_menu_dialog.height()
                    # Update list height to match dialog (resize, not fixed)
                    self._track_list.resize(self._track_list.width(), new_height - 2)  # Account for borders
                    if self.parent_window:
                        self.parent_window.settings['nano_track_menu_height'] = new_height
                        self.parent_window.save_settings()
                super(QDialog, self._track_menu_dialog).resizeEvent(event)
            
            self._track_menu_dialog.resizeEvent = on_track_menu_resize
        
        # Populate tracks
        self._track_list.clear()
        
        if self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            js_code = """
            (function() {
                // Helper function to clean track title - removes time patterns, lyrics text, and extra whitespace
                function cleanTrackTitle(text) {
                    if (!text) return '';
                    // Remove all time patterns (not just at end) - matches patterns like "00:00", "03:33", "00:00 03:33"
                    // Pattern: optional whitespace, digits, colon, digits, optional colon and digits, optional whitespace
                    text = text.replace(/\\s*\\d{1,2}:\\d{2}(?::\\d{2})?\\s*/g, ' ');
                    // Remove "lyrics" text (case-insensitive) - can appear anywhere
                    text = text.replace(/\\s*lyrics\\s*/gi, ' ');
                    // Remove any leading/trailing numbers with periods (like "01. " or "1. ")
                    text = text.replace(/^\\d+\\.\\s*/, '');
                    // Clean up multiple spaces and trim
                    text = text.replace(/\\s+/g, ' ').trim();
                    return text;
                }
                
                var tracks = [];
                // Use the same method as autoplay - find tracks via #tracklist
                var tracklist = document.querySelector('#tracklist');
                if (tracklist) {
                    // Get all tracks - same selectors as autoplay uses
                    var trackElements = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                    
                    trackElements.forEach(function(trackEl, index) {
                        // Get track number from data-num attribute if available
                        var trackNum = trackEl.getAttribute('data-num');
                        var trackIndex = trackNum ? parseInt(trackNum) - 1 : index; // data-num is 1-based
                        
                        // Get track title - look for .info div first (same as autoplay clicks)
                        var infoDiv = trackEl.querySelector('.info');
                        var title = null;
                        
                        if (infoDiv) {
                            // Get title from .info div - look for title span or text
                            var titleSpan = infoDiv.querySelector('.title, span.title, a.title');
                            if (titleSpan) {
                                title = titleSpan.textContent.trim();
                                title = cleanTrackTitle(title);
                            } else {
                                // Get text from info div, but exclude time/duration
                                var infoText = infoDiv.textContent.trim();
                                title = cleanTrackTitle(infoText);
                            }
                        }
                        
                        // Fallback: look for .track-title or similar
                        if (!title || title.length === 0) {
                            var titleEl = trackEl.querySelector('.track-title, .track_title, .title');
                            if (titleEl) {
                                title = titleEl.textContent.trim();
                                title = cleanTrackTitle(title);
                            }
                        }
                        
                        // Fallback: get text from track element, clean it up
                        if (!title || title.length === 0) {
                            var clone = trackEl.cloneNode(true);
                            var playBtn = clone.querySelector('.playbutton, button');
                            if (playBtn) playBtn.remove();
                            // Remove time elements if they exist
                            var timeEls = clone.querySelectorAll('.time, .duration, [class*="time"], [class*="duration"]');
                            timeEls.forEach(function(el) { el.remove(); });
                            title = clone.textContent.trim();
                            title = cleanTrackTitle(title);
                        }
                        
                        // Final fallback
                        if (!title || title.length === 0) {
                            title = 'Track ' + (trackIndex + 1);
                        }
                        
                        tracks.push({index: trackIndex, title: title, dataNum: trackNum});
                    });
                }
                return tracks;
            })();
            """
            def on_tracks_received(result):
                if result and isinstance(result, list):
                    self._track_data = {}  # Store track index mapping
                    for track_info in result:
                        track_index = track_info.get('index', 0)
                        track_title = track_info.get('title', 'Track')
                        data_num = track_info.get('dataNum')
                        # Store both index and dataNum for reliable track selection
                        track_data = {'index': track_index, 'dataNum': data_num}
                        
                        # Format display text: "01. Track Name" (zero-padded track number with period)
                        # Use data_num if available (1-based), otherwise use track_index + 1
                        if data_num:
                            track_num = int(data_num)
                        else:
                            track_num = track_index + 1  # Convert 0-based index to 1-based
                        display_text = f"{track_num:02d}. {track_title}"
                        
                        item = QListWidgetItem(display_text)
                        item.setData(Qt.ItemDataRole.UserRole, track_data)
                        # Initialize current marker to False (don't highlight by default)
                        item.setData(Qt.ItemDataRole.UserRole + 1, False)
                        self._track_list.addItem(item)
                        self._track_data[track_index] = track_title
                    
                    # Clear any default selection (Qt may auto-select first item)
                    self._track_list.clearSelection()
                    self._track_list.setCurrentItem(None)
                    
                    # Highlight current track after items are added (only if we have current track info)
                    if self._current_track_number is not None:
                        self._highlight_current_track()
                    
                    # Calculate ideal height based on number of items
                    item_count = len(result)
                    if item_count > 0:
                        # Force layout update to ensure items are rendered
                        self._track_list.updateGeometry()
                        QApplication.processEvents()
                        
                        # Calculate actual item height from the first item if available
                        if self._track_list.item(0):
                            # Get the visual item height (size hint)
                            item_height = self._track_list.sizeHintForRow(0)
                            if item_height <= 0:
                                # Fallback: estimate item height: padding (4px top + 4px bottom) + font height (~11px) = ~19px per item
                                item_height = 19
                        else:
                            # Fallback: estimate item height
                            item_height = 19
                        # Add 2px for borders
                        ideal_height = item_count * item_height + 2
                        
                        # Get screen/viewport bounds
                        btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
                        screen = QApplication.primaryScreen()
                        if screen:
                            screen_geometry = screen.availableGeometry()
                            # Calculate max available height based on button position
                            # Try upward first (above button)
                            space_above = btn_pos.y() - screen_geometry.top()
                            # Try downward (below button)
                            space_below = screen_geometry.bottom() - btn_pos.y()
                            # Use the larger space, but be more generous with margins (only -5px instead of -10px)
                            # This allows the menu to grow larger to show more items
                            max_available_height = min(max(space_above, space_below) - 5, 600)  # -5 for minimal margins
                            
                            # Set height to fit items - prioritize showing all items
                            # Use ideal height if it fits in viewport, otherwise use max available
                            if ideal_height <= max_available_height:
                                # All items fit - use ideal height
                                dialog_height = ideal_height
                            else:
                                # Too many items - use max available (but still try to show as many as possible)
                                dialog_height = max_available_height
                            # Cap at maximum height (600) and ensure minimum height (100)
                            dialog_height = min(dialog_height, 600)
                            dialog_height = max(dialog_height, 100)
                            
                            # Update dialog and list heights
                            self._track_menu_dialog.resize(250, dialog_height)
                            # Set height but allow resizing (use resize instead of setFixedHeight)
                            self._track_list.resize(self._track_list.width(), dialog_height - 2)  # Account for borders
                            
                            # Check if opening upward would go off screen
                            if btn_pos.y() - dialog_height < screen_geometry.top():
                                # Not enough room above - open downward
                                dialog_y = btn_pos.y() + 2
                            else:
                                # Open upward (above button)
                                dialog_y = btn_pos.y() - dialog_height - 2
                            self._track_menu_dialog.move(btn_pos.x(), dialog_y)
                        else:
                            # Fallback: use ideal height or max
                            dialog_height = min(ideal_height, 600)
                            dialog_height = max(dialog_height, 100)
                            self._track_menu_dialog.resize(250, dialog_height)
                            self._track_list.setFixedHeight(dialog_height - 2)
                            self._track_menu_dialog.move(btn_pos.x(), btn_pos.y() - dialog_height - 2)
                    else:
                        # No tracks - use default height
                        btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
                        self._track_menu_dialog.move(btn_pos.x(), btn_pos.y() - self._track_menu_dialog.height() - 2)
                    
                    self._track_menu_dialog.exec()
                else:
                    # No tracks found
                    item = QListWidgetItem("No tracks available")
                    item.setFlags(Qt.ItemFlag.NoItemFlags)
                    self._track_list.addItem(item)
                    btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
                    self._track_menu_dialog.move(btn_pos.x(), btn_pos.y() + 2)
                    self._track_menu_dialog.exec()
            
            self.parent_window.web_view.page().runJavaScript(js_code, on_tracks_received)
        else:
            item = QListWidgetItem("No tracks available")
            item.setFlags(Qt.ItemFlag.NoItemFlags)
            self._track_list.addItem(item)
            # Show dialog - open upward by default, downward if near top of screen
            btn_pos = self.track_menu_btn.mapToGlobal(self.track_menu_btn.rect().bottomLeft())
            screen = QApplication.primaryScreen()
            if screen:
                screen_geometry = screen.availableGeometry()
                dialog_height = self._track_menu_dialog.height()
                # Check if opening upward would go off screen
                if btn_pos.y() - dialog_height < screen_geometry.top():
                    # Not enough room above - open downward
                    dialog_y = btn_pos.y() + 2
                else:
                    # Open upward (above button)
                    dialog_y = btn_pos.y() - dialog_height - 2
                self._track_menu_dialog.move(btn_pos.x(), dialog_y)
            else:
                # Fallback: open upward
                self._track_menu_dialog.move(btn_pos.x(), btn_pos.y() - self._track_menu_dialog.height() - 2)
            self._track_menu_dialog.exec()
    
    def _on_track_clicked(self, item):
        """Handle track click - play the selected track using same method as autoplay."""
        track_data = item.data(Qt.ItemDataRole.UserRole)
        if track_data is not None and self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            # Get track index and data-num if available
            track_index = track_data if isinstance(track_data, int) else track_data.get('index', 0)
            data_num = track_data.get('dataNum') if isinstance(track_data, dict) else None
            
            # Use the same method as autoplay - find track via #tracklist and click .info div
            if data_num:
                # Use data-num attribute to find the track (more reliable)
                js_code = f"""
                (function() {{
                    var tracklist = document.querySelector('#tracklist');
                    if (tracklist) {{
                        // Find track by data-num attribute (same as autoplay)
                        var trackEl = tracklist.querySelector('li.track[data-num="{data_num}"]');
                        if (!trackEl) {{
                            // Fallback: get by index
                            var tracks = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                            if (tracks.length > {track_index}) {{
                                trackEl = tracks[{track_index}];
                            }}
                        }}
                        
                        if (trackEl) {{
                            // Use same method as autoplay - click .info div first
                            var infoDiv = trackEl.querySelector('.info');
                            if (infoDiv) {{
                                console.log('Bandcamp Player: Clicking track .info div (track {track_index + 1})');
                                infoDiv.click();
                            }} else {{
                                console.log('Bandcamp Player: Clicking track element (track {track_index + 1})');
                                trackEl.click();
                            }}
                        }}
                    }}
                }})();
                """
            else:
                # Fallback: use index
                js_code = f"""
                (function() {{
                    var tracklist = document.querySelector('#tracklist');
                    if (tracklist) {{
                        var tracks = tracklist.querySelectorAll('li.track.playable, li.track.has-audio, li.track');
                        if (tracks.length > {track_index}) {{
                            var trackEl = tracks[{track_index}];
                            // Use same method as autoplay - click .info div first
                            var infoDiv = trackEl.querySelector('.info');
                            if (infoDiv) {{
                                console.log('Bandcamp Player: Clicking track .info div (track {track_index + 1})');
                                infoDiv.click();
                            }} else {{
                                console.log('Bandcamp Player: Clicking track element (track {track_index + 1})');
                                trackEl.click();
                            }}
                        }}
                    }}
                }})();
                """
            self.parent_window.web_view.page().runJavaScript(js_code)
            self._track_menu_dialog.close()
    
    def _show_album_context_menu(self, position):
        """Show playlist menu on right-click of album button."""
        if not self.parent_window or not hasattr(self.parent_window, 'playlist_sidebar') or not self.parent_window.playlist_sidebar:
            return
        
        # Access playlist sidebar methods
        playlist_sidebar = self.parent_window.playlist_sidebar
        
        # Create menu using the same method as playlist sidebar
        menu = QMenu(self)
        
        # Apply dark theme styling to match the rest of the app
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
            QMenu::item:disabled {
                color: #666;
            }
            QMenu::separator {
                height: 1px;
                background-color: #3a3a3a;
                margin: 4px 8px;
            }
        """)
        
        # Show currently loaded playlist at the top (inactive, blue text)
        current_playlist_name = self.parent_window.playlist_manager.get_current_playlist_name()
        
        # Use QWidgetAction to create a styled label
        current_playlist_widget = QWidget()
        current_playlist_layout = QHBoxLayout(current_playlist_widget)
        current_playlist_layout.setContentsMargins(20, 6, 20, 6)
        current_playlist_label = QLabel(f"Current: {current_playlist_name}")
        current_playlist_label.setStyleSheet("color: #4a90e2; font-weight: normal;")
        current_playlist_layout.addWidget(current_playlist_label)
        
        current_playlist_action = QWidgetAction(self)
        current_playlist_action.setDefaultWidget(current_playlist_widget)
        current_playlist_action.setEnabled(False)
        menu.addAction(current_playlist_action)
        
        menu.addSeparator()
        
        # Save Playlist (updates current)
        save_action = QAction("Save Playlist", self)
        if HAS_QT_AWESOME:
            icon = get_icon('save', color='#e0e0e0')
            if icon:
                save_action.setIcon(icon)
        else:
            save_action.setText(" Save Playlist")
        save_action.triggered.connect(playlist_sidebar.save_current_playlist)
        menu.addAction(save_action)
        
        # Save Playlist As...
        save_as_action = QAction("Save Playlist As...", self)
        if HAS_QT_AWESOME:
            icon = get_icon('save', color='#e0e0e0')
            if icon:
                save_as_action.setIcon(icon)
        else:
            save_as_action.setText(" Save As...")
        save_as_action.triggered.connect(playlist_sidebar.save_playlist_as)
        menu.addAction(save_as_action)
        
        menu.addSeparator()
        
        # Load Playlist (submenu with available playlists)
        load_menu = QMenu("Load Playlist", self)
        load_menu.setStyleSheet(menu.styleSheet())
        
        # Get list of available playlists
        playlists = self.parent_window.playlist_manager.list_playlist_files()
        current_playlist_name = self.parent_window.playlist_manager.get_current_playlist_name()
        
        if playlists:
            for playlist_info in playlists:
                playlist_name = playlist_info["name"]
                playlist_file = playlist_info["file"]
                
                # Create action for this playlist
                playlist_action = QAction(playlist_name, self)
                # Mark current playlist with checkmark
                if playlist_name == current_playlist_name:
                    playlist_action.setText(f" {playlist_name}")
                    playlist_action.setEnabled(False)  # Disable current playlist
                playlist_action.triggered.connect(
                    lambda checked, file=playlist_file: playlist_sidebar.load_playlist_from_file(str(file))
                )
                load_menu.addAction(playlist_action)
        
        # Also check for old lowercase "default.json" and offer to migrate it
        old_default_file = self.parent_window.playlist_manager.playlists_dir / "default.json"
        if old_default_file.exists():
            # Check if Default.json already exists
            default_file = self.parent_window.playlist_manager.playlists_dir / "Default.json"
            if not default_file.exists():
                # Offer to migrate
                migrate_action = QAction("default (migrate to Default)", self)
                migrate_action.triggered.connect(
                    lambda: playlist_sidebar.migrate_default_playlist()
                )
                load_menu.addAction(migrate_action)
        else:
            # No playlists found
            no_playlists_action = QAction("No playlists found", self)
            no_playlists_action.setEnabled(False)
            load_menu.addAction(no_playlists_action)
        
        # Add Load Playlist submenu
        load_action = menu.addMenu(load_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('folder-open', color='#e0e0e0')
            if icon:
                load_action.setIcon(icon)
        else:
            load_action.setText(" Load Playlist")
        
        # Delete Playlist (submenu with available playlists)
        delete_menu = QMenu("Delete Playlist", self)
        delete_menu.setStyleSheet(menu.styleSheet())
        
        # Get list of available playlists
        playlists = self.parent_window.playlist_manager.list_playlist_files()
        current_playlist_name = self.parent_window.playlist_manager.get_current_playlist_name()
        
        if playlists:
            for playlist_info in playlists:
                playlist_name = playlist_info["name"]
                playlist_file = playlist_info["file"]
                
                # Create action for this playlist
                playlist_action = QAction(playlist_name, self)
                # Disable if it's the only playlist (can't delete the last playlist)
                if len(playlists) == 1:
                    playlist_action.setEnabled(False)
                    playlist_action.setText(f"{playlist_name} (cannot delete only playlist)")
                playlist_action.triggered.connect(
                    lambda checked, name=playlist_name: playlist_sidebar.delete_playlist(name)
                )
                delete_menu.addAction(playlist_action)
        else:
            # No playlists found
            no_playlists_action = QAction("No playlists found", self)
            no_playlists_action.setEnabled(False)
            delete_menu.addAction(no_playlists_action)
        
        # Add Delete Playlist submenu
        delete_action = menu.addMenu(delete_menu)
        if HAS_QT_AWESOME:
            icon = get_icon('trash', color='#e0e0e0')
            if icon:
                delete_action.setIcon(icon)
        else:
            delete_action.setText(" Delete Playlist")
        
        menu.addSeparator()
        
        # Export Playlist URLs
        export_action = QAction("Export Playlist URLs", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file-export', color='#e0e0e0')
            if icon:
                export_action.setIcon(icon)
        else:
            export_action.setText(" Export Playlist URLs")
        export_action.triggered.connect(playlist_sidebar.export_playlist_urls)
        menu.addAction(export_action)
        
        # Import Playlist URLs
        import_action = QAction("Import Playlist URLs", self)
        if HAS_QT_AWESOME:
            icon = get_icon('file-import', color='#e0e0e0')
            if icon:
                import_action.setIcon(icon)
        else:
            import_action.setText(" Import Playlist URLs")
        import_action.triggered.connect(playlist_sidebar.import_playlist_urls)
        menu.addAction(import_action)
        
        menu.addSeparator()
        
        # Clear Playlist
        clear_action = QAction("Clear Playlist", self)
        if HAS_QT_AWESOME:
            icon = get_icon('trash', color='#e0e0e0')
            if icon:
                clear_action.setIcon(icon)
        else:
            clear_action.setText(" Clear Playlist")
        clear_action.triggered.connect(playlist_sidebar.clear_playlist)
        menu.addAction(clear_action)
        
        menu.addSeparator()
        
        # Close Menu
        close_menu_action = QAction("Close Menu", self)
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                close_menu_action.setIcon(icon)
        else:
            close_menu_action.setText(" Close Menu")
        close_menu_action.triggered.connect(lambda: menu.close())
        menu.addAction(close_menu_action)
        
        # Show menu at button position
        global_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().bottomLeft())
        menu.exec(global_pos)
    
    def _show_album_menu(self):
        """Show album menu with playlist contents (full features: rearrange, delete, drag, double-click to load)."""
        # Create a dialog-based menu (like playlist) for resizable list with full features
        if not hasattr(self, '_album_menu_dialog') or not self._album_menu_dialog:
            self._album_menu_dialog = QDialog(self)
            self._album_menu_dialog.setWindowTitle("Playlist")
            self._album_menu_dialog.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Popup)
            self._album_menu_dialog.setStyleSheet("""
                QDialog {
                    background-color: #2b2b2b;
                    border: 1px solid #3a3a3a;
                }
            """)
            
            layout = QVBoxLayout(self._album_menu_dialog)
            layout.setContentsMargins(0, 0, 0, 0)
            layout.setSpacing(0)
            
            # List widget for playlist (full features)
            self._album_list = QListWidget()
            self._album_list.setStyleSheet("""
                QListWidget {
                    background-color: #2b2b2b;
                    color: #e0e0e0;
                    border: none;
                    font-size: 11px;
                }
                QListWidget::item {
                    padding: 2px 8px;
                    border: none;
                }
                QListWidget::item:selected {
                    background-color: #4a90e2;
                    color: #ffffff;
                }
                QListWidget::item:hover {
                    background-color: #3a3a3a;
                }
            """)
            self._album_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
            self._album_list.setDragDropMode(QListWidget.DragDropMode.InternalMove)
            self._album_list.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)  # Hide horizontal scrollbar
            self._album_list.itemClicked.connect(self._on_album_clicked)
            
            # Set custom delegate for highlighting current album (blue text, no background)
            album_delegate = NanoMenuDelegate()
            self._album_list.setItemDelegate(album_delegate)
            
            # Enable drag and drop (internal move + external URLs)
            self._album_list.setAcceptDrops(True)
            self._album_list.setDefaultDropAction(Qt.DropAction.MoveAction)
            self._album_list.setDragDropMode(QListWidget.DragDropMode.InternalMove)
            
            # Override drag/drop events to handle URLs
            original_drag_enter = self._album_list.dragEnterEvent
            original_drop = self._album_list.dropEvent
            
            def drag_enter_event(event):
                if event.mimeData().hasUrls() or event.mimeData().hasText():
                    event.acceptProposedAction()
                else:
                    if original_drag_enter:
                        original_drag_enter(event)
            
            def drop_event(event):
                if event.mimeData().hasUrls():
                    urls = event.mimeData().urls()
                    for url in urls:
                        url_str = url.toString()
                        if 'bandcamp.com' in url_str.lower() and self.parent_window:
                            if hasattr(self.parent_window, 'playlist_manager'):
                                self.parent_window.playlist_manager.add_url(url_str)
                                # Add to list
                                display_text = self.parent_window.playlist_manager.get_url_display_text(url_str)
                                if not display_text:
                                    display_text = url_str.split('/')[-1] if '/' in url_str else url_str
                                item = QListWidgetItem(display_text)
                                item.setData(Qt.ItemDataRole.UserRole, url_str)
                                self._album_list.addItem(item)
                    event.acceptProposedAction()
                elif event.mimeData().hasText():
                    text = event.mimeData().text().strip()
                    lines = [line.strip() for line in text.split('\n') if line.strip()]
                    for line in lines:
                        if 'bandcamp.com' in line.lower() and self.parent_window:
                            if hasattr(self.parent_window, 'playlist_manager'):
                                self.parent_window.playlist_manager.add_url(line)
                                # Add to list
                                display_text = self.parent_window.playlist_manager.get_url_display_text(line)
                                if not display_text:
                                    display_text = line.split('/')[-1] if '/' in line else line
                                item = QListWidgetItem(display_text)
                                item.setData(Qt.ItemDataRole.UserRole, line)
                                self._album_list.addItem(item)
                    event.acceptProposedAction()
                else:
                    if original_drop:
                        original_drop(event)
            
            self._album_list.dragEnterEvent = drag_enter_event
            self._album_list.dropEvent = drop_event
            
            # Set minimum/maximum constraints (actual height will be calculated based on items)
            self._album_list.setMinimumHeight(100)
            self._album_list.setMaximumHeight(600)
            # Don't set fixed height here - will be calculated based on items
            
            # Make dialog resizable
            self._album_menu_dialog.setMinimumSize(200, 100)
            self._album_menu_dialog.setMaximumSize(400, 600)
            # Don't set initial size here - will be calculated based on items
            
            layout.addWidget(self._album_list)
            
            # Connect signals for reordering
            self._album_list.model().rowsMoved.connect(self._on_playlist_reordered)
            
            # Enable delete key
            self._album_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
            self._album_list.customContextMenuRequested.connect(self._show_album_list_context_menu)
            
            # Track resize events to save height (allow list to resize with dialog)
            def on_album_menu_resize(event):
                if self._album_menu_dialog and self._album_list:
                    new_height = self._album_menu_dialog.height()
                    # Update list height to match dialog (resize, not fixed)
                    self._album_list.resize(self._album_list.width(), new_height - 2)  # Account for borders
                    if self.parent_window:
                        self.parent_window.settings['nano_album_menu_height'] = new_height
                        self.parent_window.save_settings()
                super(QDialog, self._album_menu_dialog).resizeEvent(event)
            
            self._album_menu_dialog.resizeEvent = on_album_menu_resize
            
            # Install event filter for delete key
            self._album_list.installEventFilter(self)
        
        # Populate playlist
        self._album_list.clear()
        
        if self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
            playlist = self.parent_window.playlist_manager.get_playlist()
            for url in playlist:
                # Get display text - check metadata first, then fall back to URL parsing
                display_text = None
                if hasattr(self.parent_window.playlist_manager, 'get_url_metadata'):
                    stored_metadata = self.parent_window.playlist_manager.get_url_metadata(url)
                    if stored_metadata:
                        display_text = stored_metadata
                
                # Fall back to URL parsing if no stored metadata
                if not display_text:
                    # Use the main window's extract_artist_album_from_url method which correctly
                    # extracts artist from subdomain and album/track from path
                    if self.parent_window and hasattr(self.parent_window, 'extract_artist_album_from_url'):
                        display_text = self.parent_window.extract_artist_album_from_url(url)
                    
                    # Final fallback if extraction failed
                    if not display_text:
                        try:
                            from urllib.parse import urlparse
                            parsed = urlparse(url)
                            path_parts = [p for p in parsed.path.strip('/').split('/') if p]
                            if len(path_parts) >= 2 and path_parts[0] in ['album', 'track']:
                                # Format: album/album-name or track/track-name
                                # Extract artist from subdomain
                                hostname = parsed.hostname or ""
                                artist = None
                                if ".bandcamp.com" in hostname.lower():
                                    subdomain = hostname.lower().replace(".bandcamp.com", "")
                                    if "-" in subdomain:
                                        artist = " ".join(word.capitalize() for word in subdomain.split("-"))
                                    else:
                                        import re
                                        words = re.findall(r'[a-z]+|[A-Z][a-z]*', subdomain)
                                        if len(words) > 1:
                                            artist = " ".join(word.capitalize() for word in words)
                                        else:
                                            # Single word (all lowercase or no camelCase) - try to split on common word endings
                                            common_endings = ['pony', 'ponies', 'music', 'records', 'label', 'band', 'group', 'crew', 'team', 'sound', 'audio', 'tunes', 'tracks']
                                            subdomain_lower = subdomain.lower()
                                            for ending in common_endings:
                                                if subdomain_lower.endswith(ending) and len(subdomain_lower) > len(ending):
                                                    # Split before the ending
                                                    prefix = subdomain_lower[:-len(ending)]
                                                    if len(prefix) > 0:
                                                        # Capitalize both parts
                                                        artist = f"{prefix.capitalize()} {ending.capitalize()}"
                                                        break
                                            
                                            # Final fallback: just capitalize the first letter
                                            if not artist:
                                                artist = subdomain.capitalize()
                                
                                name = path_parts[1]
                                name = " ".join(word.capitalize() for word in name.split("-"))
                                if artist:
                                    display_text = f"{artist} - {name}"
                                else:
                                    display_text = name
                            elif len(path_parts) == 1:
                                display_text = path_parts[0].replace('-', ' ').title()
                            else:
                                display_text = url.split('/')[-1] if '/' in url else url
                        except Exception:
                            display_text = url.split('/')[-1] if '/' in url else url
                
                item = QListWidgetItem(display_text)
                item.setData(Qt.ItemDataRole.UserRole, url)
                # Initialize current marker to False (don't highlight by default)
                item.setData(Qt.ItemDataRole.UserRole + 1, False)
                self._album_list.addItem(item)
        
        # Clear any default selection (Qt may auto-select first item)
        self._album_list.clearSelection()
        
        # Highlight current album after items are added (match by URL)
        self._highlight_current_album()
        
        # Calculate ideal height based on number of items
        item_count = self._album_list.count()
        if item_count > 0:
            # Force layout update to ensure items are rendered
            self._album_list.updateGeometry()
            QApplication.processEvents()
            
            # Calculate actual item height from the first item if available
            if self._album_list.item(0):
                # Get the visual item height (size hint)
                item_height = self._album_list.sizeHintForRow(0)
                if item_height <= 0:
                    # Fallback: estimate item height: padding (4px top + 4px bottom) + font height (~11px) = ~19px per item
                    item_height = 19
            else:
                # Fallback: estimate item height
                item_height = 19
            # Add 2px for borders
            ideal_height = item_count * item_height + 2
            
            # Get screen/viewport bounds
            btn_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().bottomLeft())
            screen = QApplication.primaryScreen()
            if screen:
                screen_geometry = screen.availableGeometry()
                # Calculate max available height based on button position
                # For album list (bottom row), prioritize using maximum available space
                # Try upward first (above button) - this is usually much larger for bottom row buttons
                space_above = btn_pos.y() - screen_geometry.top()
                # Try downward (below button) - usually small for bottom row buttons
                space_below = screen_geometry.bottom() - btn_pos.y()
                # For bottom row buttons, space_above is usually much larger, so prioritize it
                # Use the larger space, with minimal margins to maximize available space
                max_available_height = min(max(space_above, space_below) - 2, 600)  # -2 for very minimal margins
                
                # Set height to fit items - prioritize showing all items
                # For album list, if ideal_height is reasonable (under 600px), use it regardless of viewport
                # This allows the menu to grow to show all items, opening upward if needed
                if ideal_height <= 600:
                    # Use ideal height to show all items (will open upward if needed)
                    dialog_height = ideal_height
                else:
                    # Too many items - use max available, but still try to maximize
                    dialog_height = max_available_height
                # Cap at maximum height (600) and ensure minimum height (100)
                dialog_height = min(dialog_height, 600)
                dialog_height = max(dialog_height, 100)
                
                # Update dialog and list heights
                self._album_menu_dialog.resize(250, dialog_height)
                # Set height but allow resizing (use resize instead of setFixedHeight)
                self._album_list.resize(self._album_list.width(), dialog_height - 2)  # Account for borders
                # Force geometry update
                self._album_menu_dialog.updateGeometry()
                self._album_list.updateGeometry()
                
                # Check if opening upward would go off screen
                if btn_pos.y() - dialog_height < screen_geometry.top():
                    # Not enough room above - open downward
                    dialog_y = btn_pos.y() + 2
                else:
                    # Open upward (above button)
                    dialog_y = btn_pos.y() - dialog_height - 2
                self._album_menu_dialog.move(btn_pos.x(), dialog_y)
            else:
                # Fallback: use ideal height or max
                dialog_height = min(ideal_height, 600)
                dialog_height = max(dialog_height, 100)
                self._album_menu_dialog.resize(250, dialog_height)
                self._album_list.setFixedHeight(dialog_height - 2)
                self._album_menu_dialog.updateGeometry()
                self._album_list.updateGeometry()
                self._album_menu_dialog.move(btn_pos.x(), btn_pos.y() - dialog_height - 2)
        else:
            # Empty playlist - use default height
            item = QListWidgetItem("Playlist is empty")
            item.setFlags(Qt.ItemFlag.NoItemFlags)
            self._album_list.addItem(item)
            btn_pos = self.album_menu_btn.mapToGlobal(self.album_menu_btn.rect().bottomLeft())
            self._album_menu_dialog.move(btn_pos.x(), btn_pos.y() - self._album_menu_dialog.height() - 2)
        
        self._album_menu_dialog.exec()
    
    def _on_playlist_reordered(self, parent, start, end, destination, row):
        """Handle playlist reordering in album menu."""
        if not self.parent_window or not hasattr(self.parent_window, 'playlist_manager'):
            return
        
        # Get new order from list widget
        new_order = []
        for i in range(self._album_list.count()):
            item = self._album_list.item(i)
            if item:
                url = item.data(Qt.ItemDataRole.UserRole)
                if url:
                    new_order.append(url)
        
        # Update playlist order
        if new_order:
            self.parent_window.playlist_manager.reorder_playlist(new_order)
    
    def _on_album_clicked(self, item):
        """Handle album click - load the selected album."""
        url = item.data(Qt.ItemDataRole.UserRole)
        if url and self.parent_window:
            self.parent_window.load_url(url)
            self._album_menu_dialog.close()
    
    def _highlight_current_track(self):
        """Highlight the currently playing track in the track list menu."""
        if not hasattr(self, '_track_list') or not self._track_list:
            return
        
        # Use stored current track number
        current_track_num = self._current_track_number
        if current_track_num is None:
            # Fallback: try to extract from button text
            track_btn_text = self.track_menu_btn.text()
            if track_btn_text and track_btn_text != "Artist - Track":
                try:
                    # Track button format is "01. Track Name" or "01. Track Name (Artist)"
                    track_num_str = track_btn_text.split('.')[0].strip()
                    current_track_num = int(track_num_str)
                except (ValueError, IndexError):
                    return
            else:
                return
        
        # Clear all items' current marker
        for i in range(self._track_list.count()):
            item = self._track_list.item(i)
            if item:
                item.setData(Qt.ItemDataRole.UserRole + 1, False)
        
        # Find and highlight the matching track
        for i in range(self._track_list.count()):
            item = self._track_list.item(i)
            if item:
                # Get track data to check track number
                track_data = item.data(Qt.ItemDataRole.UserRole)
                if track_data:
                    # Check if this item matches the current track number
                    data_num = track_data.get('dataNum') if isinstance(track_data, dict) else None
                    track_index = track_data.get('index', 0) if isinstance(track_data, dict) else track_data
                    
                    # Match by data_num (preferred) or by index
                    item_track_num = None
                    if data_num:
                        try:
                            item_track_num = int(data_num)
                        except (ValueError, TypeError):
                            pass
                    
                    if item_track_num is None:
                        # Fallback: use index + 1 (convert 0-based to 1-based)
                        item_track_num = track_index + 1
                    
                    if item_track_num == current_track_num:
                        # This is the current track - highlight it
                        item.setData(Qt.ItemDataRole.UserRole + 1, True)
                        # Scroll to make it visible
                        self._track_list.scrollToItem(item, QListWidget.ScrollHint.EnsureVisible)
                        break
    
    def _highlight_current_album(self):
        """Highlight the currently playing album in the album list menu by matching URL."""
        if not hasattr(self, '_album_list') or not self._album_list:
            return
        
        # Get current URL from parent window's web view
        current_url = None
        if self.parent_window and hasattr(self.parent_window, 'web_view') and self.parent_window.web_view:
            current_url = self.parent_window.web_view.url().toString()
        
        # Fallback: try to get from settings
        if not current_url and self.parent_window:
            current_url = self.parent_window.settings.get("last_played_url")
        
        if not current_url:
                return
        
        # Normalize URL for comparison (same logic as playlist sidebar)
        def normalize_url(u):
            if not u:
                return ""
            u = u.strip().rstrip('/')
            if u.startswith('http://'):
                u = 'https://' + u[7:]
            return u.lower()
        
        normalized_current_url = normalize_url(current_url)
        
        # Clear all items' current marker
        for i in range(self._album_list.count()):
            item = self._album_list.item(i)
            if item:
                item.setData(Qt.ItemDataRole.UserRole + 1, False)
        
        # Find and highlight the matching album by URL
        for i in range(self._album_list.count()):
            item = self._album_list.item(i)
            if item:
                item_url = item.data(Qt.ItemDataRole.UserRole)
                if item_url:
                    # Normalize item URL for comparison
                    normalized_item_url = normalize_url(item_url)
                    
                    # Match by normalized URL
                    if normalized_item_url == normalized_current_url:
                        # This is the current album - highlight it
                        item.setData(Qt.ItemDataRole.UserRole + 1, True)
                        # Clear selection state to prevent white outline
                        item.setSelected(False)
                        # Force repaint
                        self._album_list.update()
                        # Scroll to make it visible
                        self._album_list.scrollToItem(item, QListWidget.ScrollHint.EnsureVisible)
                        break
    
    def _on_time_label_clicked(self, event):
        """Handle time label click - cycle between display modes."""
        # Cycle between modes: 0 = elapsed/total, 1 = elapsed/remaining
        self.time_display_mode = (self.time_display_mode + 1) % 2
        
        # Save preference
        if self.parent_window:
            self.parent_window.settings['nano_time_display_mode'] = self.time_display_mode
            self.parent_window.save_settings()
        
        # Trigger immediate update to show new mode
        self._update_track_info()
    
    def _show_album_list_context_menu(self, position):
        """Show context menu for album list (delete option)."""
        item = self._album_list.itemAt(position)
        if not item:
            return
        
        menu = QMenu(self)
        menu.setStyleSheet("""
            QMenu {
                background-color: #2b2b2b;
                color: #e0e0e0;
                border: 1px solid #3a3a3a;
                border-radius: 4px;
                padding: 2px;
            }
            QMenu::item {
                padding: 6px 20px;
                border-radius: 2px;
            }
            QMenu::item:selected {
                background-color: #4a90e2;
                color: #ffffff;
            }
        """)
        
        delete_action = QAction("Delete", self)
        if HAS_QT_AWESOME:
            icon = get_icon('times', color='#e0e0e0')
            if icon:
                delete_action.setIcon(icon)
        delete_action.triggered.connect(lambda: self._delete_selected_albums())
        menu.addAction(delete_action)
        
        menu.exec(self._album_list.mapToGlobal(position))
    
    def _delete_selected_albums(self):
        """Delete selected albums from playlist."""
        selected_items = self._album_list.selectedItems()
        if not selected_items:
            return
        
        for item in selected_items:
            url = item.data(Qt.ItemDataRole.UserRole)
            if url and self.parent_window and hasattr(self.parent_window, 'playlist_manager'):
                self.parent_window.playlist_manager.remove_url(url)
            row = self._album_list.row(item)
            self._album_list.takeItem(row)
    
    def _on_album_selected(self, url):
        """Handle album selection from menu - load the selected album."""
        if self.parent_window:
            self.parent_window.load_url(url)
    
    def _on_pin_toggle(self):
        """Handle pin button toggle - toggle always on top."""
        self.nano_always_on_top = self.pin_btn.isChecked()
        if self.parent_window:
            self.parent_window.settings['nano_always_on_top'] = self.nano_always_on_top
            self.parent_window.save_settings()
        
        # Update window flags
        flags = Qt.WindowType.FramelessWindowHint | Qt.WindowType.Window
        if self.nano_always_on_top:
            flags |= Qt.WindowType.WindowStaysOnTopHint
        self.setWindowFlags(flags)
        self.show()  # Must show again after changing window flags
        
        # Update icon color (match main interface)
        if HAS_QT_AWESOME:
            icon_color = '#4a90e2' if self.nano_always_on_top else '#a0a0a0'
            icon = get_icon('thumbtack', color=icon_color)  # Match main interface
            if icon:
                self.pin_btn.setIcon(icon)
    
    def _on_restore(self):
        """Handle restore button click - restore main window."""
        logger.debug("Nano player restore button clicked")
        if self.parent_window:
            # Directly call _exit_nano_mode to ensure it's called
            # (showNormal() might not trigger changeEvent if window is hidden, not minimized)
            if hasattr(self.parent_window, '_main_window_hidden_for_nano') and self.parent_window._main_window_hidden_for_nano:
                logger.debug("Calling _exit_nano_mode from restore button")
                self.parent_window._exit_nano_mode()
            else:
                logger.debug("Not in nano mode, using showNormal() fallback")
                # Fallback: try showNormal() if not in nano mode
                self.parent_window.showNormal()
                self.parent_window.raise_()
                self.parent_window.activateWindow()
    
    def _on_progress_pressed(self):
        """Handle progress bar press - start dragging."""
        self._progress_dragging = True
    
    def _on_progress_released(self):
        """Handle progress bar release - seek to position."""
        self._progress_dragging = False
        if self.parent_window and self.parent_window.web_view and self.parent_window.web_view.page():
            # Get current duration and calculate seek position
            js_code = """
            (function() {
                var audio = document.querySelector('audio');
                if (audio && audio.duration) {
                    return audio.duration;
                }
                return 0;
            })();
            """
            def on_duration_received(duration):
                if duration and duration > 0:
                    # Calculate seek position from slider value (0-1000)
                    slider_value = self.progress_bar.value()
                    seek_seconds = (slider_value / 1000.0) * duration
                    # Seek to position
                    seek_js = f"""
                    (function() {{
                        var audio = document.querySelector('audio');
                        if (audio) {{
                            audio.currentTime = {seek_seconds};
                        }}
                    }})();
                    """
                    self.parent_window.web_view.page().runJavaScript(seek_js)
            
            self.parent_window.web_view.page().runJavaScript(js_code, on_duration_received)
    
    def _on_progress_changed(self, value):
        """Handle progress bar value change (only update if not dragging)."""
        # This is called during dragging, but we only seek on release
        # So we don't need to do anything here
        pass
    
    def _update_cover_art(self):
        """Update cover art display by fetching image URL from page."""
        if not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            return
        
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        # JavaScript to get cover art image URL
        js_code = """
        (function() {
            try {
                var albumArt = document.querySelector('#tralbum-art-carousel');
                if (!albumArt) {
                    return null;
                }
                
                // Find the visible/active image
                var visibleImg = null;
                
                // Method 1: Look for active carousel item
                var activeItem = albumArt.querySelector('.carousel-item.active, [class*="active"]');
                if (activeItem) {
                    visibleImg = activeItem.querySelector('img');
                }
                
                // Method 2: Find visible image
                if (!visibleImg) {
                    var allImgs = albumArt.querySelectorAll('img');
                    for (var i = 0; i < allImgs.length; i++) {
                        var img = allImgs[i];
                        var style = window.getComputedStyle(img);
                        if (style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {
                            var rect = img.getBoundingClientRect();
                            if (rect && rect.width > 0 && rect.height > 0) {
                                visibleImg = img;
                                break;
                            }
                        }
                    }
                }
                
                // Method 3: Fallback to first image
                if (!visibleImg) {
                    visibleImg = albumArt.querySelector('img');
                }
                
                if (!visibleImg) {
                    return null;
                }
                
                // Get image URL - try multiple sources
                var imgSrc = null;
                
                // Method 1: Try data-src (lazy loading)
                imgSrc = visibleImg.getAttribute('data-src') || visibleImg.getAttribute('data-lazy-src');
                
                // Method 2: Try srcset for higher resolution
                if (!imgSrc) {
                    var srcset = visibleImg.getAttribute('srcset');
                    if (srcset) {
                        var srcsetParts = srcset.split(',').map(function(s) { return s.trim(); });
                        if (srcsetParts.length > 0) {
                            var lastEntry = srcsetParts[srcsetParts.length - 1];
                            imgSrc = lastEntry.split(/\\s+/)[0];
                        }
                    }
                }
                
                // Method 3: Use current src
                if (!imgSrc) {
                    imgSrc = visibleImg.src || visibleImg.getAttribute('src');
                }
                
                return imgSrc;
            } catch (e) {
                console.log('Bandcamp Player: Error getting cover art URL:', e);
                return null;
            }
        })();
        """
        
        def on_url_received(url):
            if url and hasattr(self, 'cover_art_label') and self.cover_art_label:
                # Only update if URL has changed
                current_url = getattr(self, '_current_cover_art_url', None)
                if url != current_url:
                    self._current_cover_art_url = url
                    self._load_cover_art_image(url)
        
        self.parent_window.web_view.page().runJavaScript(js_code, on_url_received)
    
    def _load_cover_art_image(self, url):
        """Load cover art image from URL."""
        if not url or not hasattr(self, 'cover_art_label') or not self.cover_art_label:
            return
        
        try:
            request = QNetworkRequest(QUrl(url))
            reply = self.network_manager.get(request)
            reply.setProperty('url', url)  # Store URL for verification
        except Exception as e:
            logger.debug(f"Error loading cover art: {e}")
    
    def _on_cover_art_loaded(self, reply):
        """Handle cover art image loaded."""
        try:
            if reply.error() == QNetworkReply.NetworkError.NoError:
                url = reply.property('url')
                # Verify URL matches current (in case multiple requests)
                if url and hasattr(self, '_current_cover_art_url') and url == self._current_cover_art_url:
                    data = reply.readAll()
                    pixmap = QPixmap()
                    if pixmap.loadFromData(data):
                        if hasattr(self, 'cover_art_label') and self.cover_art_label:
                            self.cover_art_label.setPixmap(pixmap)
            reply.deleteLater()
        except Exception as e:
            logger.debug(f"Error processing cover art: {e}")
            if hasattr(reply, 'deleteLater'):
                reply.deleteLater()
    
    def _update_track_info(self):
        """Update track info, time display, and progress bar."""
        # Safety check - don't update if window is being destroyed
        if not self or not self.isVisible():
            return
        
        if not self.parent_window or not self.parent_window.web_view or not self.parent_window.web_view.page():
            return
        
        js_code = """
        (function() {
            var info = {};
            
            // Get artist and track
            var artistEl = document.querySelector('.tralbum-artist');
            var albumEl = document.querySelector('.tralbum-name');
            
            // Try multiple selectors to get the track title and track number
            var trackEl = null;
            var trackNumber = null;
            // Method 1: Look for track title span (not track number)
            var currentTrack = document.querySelector('.current-track');
            if (currentTrack) {
                // Find track number span
                var trackNumEl = currentTrack.querySelector('.track-number, .track-num');
                if (trackNumEl) {
                    trackNumber = trackNumEl.textContent.trim();
                    // Remove any non-digit characters, keep just the number
                    trackNumber = trackNumber.replace(/[^\\d]/g, '');
                }
                // If no track number class, try to find it in spans
                if (!trackNumber) {
                    var spans = currentTrack.querySelectorAll('span');
                    for (var i = 0; i < spans.length; i++) {
                        var span = spans[i];
                        var text = span.textContent.trim();
                        // Check if this span is just a number (likely track number)
                        if (/^\\d+$/.test(text)) {
                            trackNumber = text;
                            break;
                        }
                    }
                }
                // Find span that's not the track number (the actual track title)
                var spans = currentTrack.querySelectorAll('span');
                for (var i = 0; i < spans.length; i++) {
                    var span = spans[i];
                    var classes = span.className || '';
                    var text = span.textContent.trim();
                    // Skip track number spans
                    if (!classes.includes('track-number') && 
                        !classes.includes('track-num') && 
                        text && 
                        text.length > 0 &&
                        !/^\\d+$/.test(text)) {  // Not just a number
                        trackEl = span;
                        break;
                    }
                }
            }
            // Method 2: Fallback to .track-title
            if (!trackEl) {
                trackEl = document.querySelector('.track-title');
            }
            // Method 3: Fallback to any span in .current-track (last resort)
            if (!trackEl && currentTrack) {
                trackEl = currentTrack.querySelector('span:not(.track-number):not(.track-num)');
            }
            
            if (artistEl) {
                var artistText = artistEl.textContent.trim();
                info.artist = artistText.replace(/^by\\s+/i, '');
            }
            if (trackEl) {
                var trackText = trackEl.textContent.trim();
                // Remove track number if it's at the start (e.g., "1. Track Name" -> "Track Name")
                trackText = trackText.replace(/^\\d+\\.?\\s*/, '');
                info.track = trackText;
            }
            // Store track number if found
            if (trackNumber) {
                info.trackNumber = trackNumber;
            }
            if (albumEl) {
                info.album = albumEl.textContent.trim();
            }
            
            // Get time info
            var audio = document.querySelector('audio');
            if (audio) {
                info.isPlaying = !audio.paused;
                info.currentTime = audio.currentTime || 0;
                info.duration = audio.duration || 0;
            }
            
            return info;
        })();
        """
        
        def on_info_received(result):
            if not result:
                return
            
            # Update track menu button text (full text, no truncation - will expand with button)
            artist = result.get('artist', '')
            track = result.get('track', '')
            track_number = result.get('trackNumber', '')
            
            # Format: 01. Track Name (Artist) (zero-padded track number with period)
            if track_number and artist and track:
                try:
                    # Convert to int and format with zero-padding (01, 02, etc.)
                    track_num = int(track_number)
                    formatted_number = f"{track_num:02d}"
                    display_text = f"{formatted_number}. {track} ({artist})"
                except (ValueError, TypeError):
                    # If conversion fails, use track_number as-is with period
                    display_text = f"{track_number}. {track} ({artist})"
            elif track_number and track:
                try:
                    # Track number but no artist
                    track_num = int(track_number)
                    formatted_number = f"{track_num:02d}"
                    display_text = f"{formatted_number}. {track}"
                except (ValueError, TypeError):
                    display_text = f"{track_number}. {track}"
            elif artist and track:
                display_text = f"{track} ({artist})"
            elif track:
                display_text = track
            else:
                display_text = "Artist - Track"
            
            self.track_menu_btn.setText(display_text)
            
            # Update album menu button text (full text, no truncation - will expand with button)
            album = result.get('album', '')
            if album:
                self.album_menu_btn.setText(album)
                self._current_album_name = album  # Store for highlighting
            else:
                self.album_menu_btn.setText("Album")
                self._current_album_name = None
            
            # Store current track number for highlighting and persistence
            if track_number:
                try:
                    new_track_num = int(track_number)
                    track_changed = (self._current_track_number != new_track_num)
                    
                    # During startup with autoplay enabled, don't overwrite saved track number
                    # until after autoplay has loaded the correct track
                    should_update_track_number = True
                    if self.parent_window:
                        # Check if this is a startup load with autoplay enabled
                        is_startup = getattr(self.parent_window, '_is_startup_load', False)
                        autoplay_on_startup = getattr(self.parent_window, 'autoplay_on_startup', False)
                        saved_track = self.parent_window.settings.get("last_played_track_number")
                        
                        # If startup + autoplay enabled + we have a saved track + detected track is different
                        # Don't update yet - wait for autoplay to load the correct track
                        if is_startup and autoplay_on_startup and saved_track is not None:
                            try:
                                saved_track_int = int(saved_track)
                                if new_track_num != saved_track_int:
                                    # This is likely the initial page load showing track 1 before autoplay
                                    # Don't overwrite the saved track number yet
                                    should_update_track_number = False
                                    logger.debug(f"Nano player: Skipping track number update during startup (detected {new_track_num}, saved {saved_track_int})")
                            except (ValueError, TypeError):
                                pass  # If saved track isn't a valid int, proceed with update
                    
                    if should_update_track_number:
                        self._current_track_number = new_track_num
                        # Also update parent window's track number for persistence
                        if self.parent_window:
                            self.parent_window._current_track_number = self._current_track_number
                            # Save settings immediately when track number changes (regardless of autoplay settings)
                            if track_changed:
                                self.parent_window.save_settings()
                except (ValueError, TypeError):
                    self._current_track_number = None
                    if self.parent_window:
                        self.parent_window._current_track_number = None
            else:
                self._current_track_number = None
                if self.parent_window:
                    self.parent_window._current_track_number = None
            
            # Update button widths based on new text content
            self._update_button_widths()
            # Force button update to ensure new text is displayed immediately
            if hasattr(self, 'track_menu_btn') and self.track_menu_btn:
                self.track_menu_btn.update()
                self.track_menu_btn.updateGeometry()
            if hasattr(self, 'album_menu_btn') and self.album_menu_btn:
                self.album_menu_btn.update()
                self.album_menu_btn.updateGeometry()
            # Force layout update
            QApplication.processEvents()
            
            # Update cover art
            self._update_cover_art()
            
            # Update highlighting in menus if they're open
            if hasattr(self, '_track_list') and self._track_list and self._track_list.count() > 0:
                self._highlight_current_track()
            if hasattr(self, '_album_list') and self._album_list and self._album_list.count() > 0:
                self._highlight_current_album()
            
            # Update time display based on current mode
            current_time = result.get('currentTime', 0)
            duration = result.get('duration', 0)
            if duration > 0:
                current_mins = int(current_time // 60)
                current_secs = int(current_time % 60)
                
                if self.time_display_mode == 0:
                    # Mode 0: elapsed / total
                    total_mins = int(duration // 60)
                    total_secs = int(duration % 60)
                    self.time_label.setText(f"{current_mins:02d}:{current_secs:02d}/{total_mins:02d}:{total_secs:02d}")
                else:
                    # Mode 1: elapsed / remaining
                    remaining = duration - current_time
                    remaining_mins = int(remaining // 60)
                    remaining_secs = int(remaining % 60)
                    self.time_label.setText(f"{current_mins:02d}:{current_secs:02d}/-{remaining_mins:02d}:{remaining_secs:02d}")
            else:
                self.time_label.setText("00:00/00:00")
            
            # Update progress bar (only if not dragging)
            if not self._progress_dragging and duration > 0:
                progress_value = int((current_time / duration) * 1000)
                self.progress_bar.setValue(progress_value)
            
            # Update play/pause button icon
            is_playing = result.get('isPlaying', False)
            if HAS_QT_AWESOME:
                icon_name = 'pause' if is_playing else 'play'
                icon = get_icon(icon_name, color='#e0e0e0')
                if icon:
                    self.play_pause_btn.setIcon(icon)
                else:
                    self.play_pause_btn.setText("" if is_playing else "")
            else:
                self.play_pause_btn.setText("" if is_playing else "")
            
            # Sync shuffle and repeat button states
            self._sync_shuffle_repeat_buttons()
        
        self.parent_window.web_view.page().runJavaScript(js_code, on_info_received)
    
    def _sync_shuffle_repeat_buttons(self):
        """Sync shuffle and repeat button states from playlist_sidebar (with defensive checks)."""
        try:
            if (self.parent_window and 
                hasattr(self.parent_window, 'playlist_sidebar') and 
                self.parent_window.playlist_sidebar and
                hasattr(self.parent_window.playlist_sidebar, 'shuffle_mode') and
                hasattr(self.parent_window.playlist_sidebar, 'repeat_mode')):
                
                # Sync shuffle button
                if hasattr(self, 'shuffle_btn') and self.shuffle_btn:
                    shuffle_mode = getattr(self.parent_window.playlist_sidebar, 'shuffle_mode', 0)
                    # Always sync, not just if different (ensures correct state on startup)
                    self.shuffle_btn.blockSignals(True)
                    is_active = shuffle_mode > 0
                    self.shuffle_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button
                    if hasattr(self.parent_window.playlist_sidebar, 'shuffle_btn'):
                        tooltip = self.parent_window.playlist_sidebar.shuffle_btn.toolTip()
                    else:
                        tooltip = f"Shuffle: {'On' if is_active else 'Off'}"
                    self.shuffle_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            self.shuffle_btn.setIcon(icon)
                    self.shuffle_btn.blockSignals(False)
                
                # Sync repeat button
                if hasattr(self, 'repeat_btn') and self.repeat_btn:
                    repeat_mode = getattr(self.parent_window.playlist_sidebar, 'repeat_mode', 0)
                    # Always sync, not just if different (ensures correct state on startup)
                    self.repeat_btn.blockSignals(True)
                    is_active = repeat_mode > 0
                    self.repeat_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button
                    if hasattr(self.parent_window.playlist_sidebar, 'repeat_btn'):
                        tooltip = self.parent_window.playlist_sidebar.repeat_btn.toolTip()
                    else:
                        tooltip = "Repeat: Off"
                    self.repeat_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            self.repeat_btn.setIcon(icon)
                    self.repeat_btn.blockSignals(False)
                    
                    # Sync repeat overlay (for mode 3 - "1" overlay)
                    self._update_repeat_overlay_nano(repeat_mode)
                
                # Also sync detached playlist buttons if they exist
                if hasattr(self.parent_window, '_detached_repeat_btn') and self.parent_window._detached_repeat_btn:
                    repeat_mode = getattr(self.parent_window.playlist_sidebar, 'repeat_mode', 0)
                    self.parent_window._detached_repeat_btn.blockSignals(True)
                    is_active = repeat_mode > 0
                    self.parent_window._detached_repeat_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button
                    if hasattr(self.parent_window.playlist_sidebar, 'repeat_btn'):
                        tooltip = self.parent_window.playlist_sidebar.repeat_btn.toolTip()
                    else:
                        tooltip = "Repeat: Off"
                    self.parent_window._detached_repeat_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if repeat_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.repeat', color=icon_color)
                        elif repeat_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.heart', color=icon_color)
                        if icon:
                            self.parent_window._detached_repeat_btn.setIcon(icon)
                    self.parent_window._detached_repeat_btn.blockSignals(False)
                    # Update overlay for detached repeat button (for mode 3 - "1" overlay)
                    if hasattr(self.parent_window, '_update_detached_repeat_overlay'):
                        QTimer.singleShot(0, lambda: self.parent_window._update_detached_repeat_overlay(repeat_mode))
                
                if hasattr(self.parent_window, '_detached_shuffle_btn') and self.parent_window._detached_shuffle_btn:
                    shuffle_mode = getattr(self.parent_window.playlist_sidebar, 'shuffle_mode', 0)
                    self.parent_window._detached_shuffle_btn.blockSignals(True)
                    is_active = shuffle_mode > 0
                    self.parent_window._detached_shuffle_btn.setChecked(is_active)
                    # Get tooltip from playlist sidebar button
                    if hasattr(self.parent_window.playlist_sidebar, 'shuffle_btn'):
                        tooltip = self.parent_window.playlist_sidebar.shuffle_btn.toolTip()
                    else:
                        tooltip = "Shuffle: Off"
                    self.parent_window._detached_shuffle_btn.setToolTip(tooltip)
                    if HAS_QT_AWESOME:
                        if shuffle_mode == 0:
                            icon_color = '#a0a0a0'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 1:
                            icon_color = '#4a90e2'
                            icon = get_icon('random', color=icon_color)
                        elif shuffle_mode == 2:
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.question', color=icon_color)
                        else:  # mode 3
                            icon_color = '#4a90e2'
                            icon = get_icon('ei.asl', color=icon_color)
                        if icon:
                            self.parent_window._detached_shuffle_btn.setIcon(icon)
                    self.parent_window._detached_shuffle_btn.blockSignals(False)
        except (AttributeError, RuntimeError) as e:
            # Playlist sidebar might be destroyed or in invalid state - ignore sync errors
            logger.debug(f"Nano player sync error (non-critical): {e}")
            pass
    
    def _update_repeat_overlay_nano(self, repeat_mode):
        """Update overlay on nano player repeat button based on mode:
        - Mode 3 (Track): "1" overlay (white)
        - Other modes: no overlay
        """
        if not hasattr(self, 'repeat_btn') or not self.repeat_btn:
            return
        
        # Remove existing overlay if it exists
        if hasattr(self, '_repeat_overlay_label_nano') and self._repeat_overlay_label_nano is not None:
            try:
                self._repeat_overlay_label_nano.deleteLater()
            except (AttributeError, RuntimeError):
                pass  # Label might already be deleted
            self._repeat_overlay_label_nano = None
        
        # Show overlay only for mode 3 ("1")
        if repeat_mode == 3:
            # Create overlay label
            from PyQt6.QtWidgets import QLabel
            from PyQt6.QtCore import Qt
            
            # Set overlay text to "1" for mode 3
            overlay_text = "1"
            
            # Set overlay color: white for mode 3 (track)
            overlay_color = 'white'
            
            # Create overlay as child of button's parent widget to ensure it's on top
            # Get the button's parent widget (the container)
            button_parent = self.repeat_btn.parent()
            if button_parent:
                self._repeat_overlay_label_nano = QLabel(overlay_text, button_parent)
            else:
                # Fallback to button itself if no parent
                self._repeat_overlay_label_nano = QLabel(overlay_text, self.repeat_btn)
            
            self._repeat_overlay_label_nano.setAlignment(Qt.AlignmentFlag.AlignCenter)
            # Make overlay transparent to mouse events so clicks pass through to button
            self._repeat_overlay_label_nano.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
            self._repeat_overlay_label_nano.setStyleSheet(f"""
                QLabel {{
                    background-color: transparent;
                    color: {overlay_color};
                    font-weight: bold;
                    font-size: 11px;
                    border: none;
                }}
            """)
            # Position will be updated when button is shown/resized
            # Use a method to update position
            def update_overlay_position():
                if hasattr(self, '_repeat_overlay_label_nano') and self._repeat_overlay_label_nano and self.repeat_btn:
                    try:
                        # Get button position relative to its parent widget
                        btn_pos = self.repeat_btn.pos()
                        btn_size = self.repeat_btn.size()
                        overlay_size = 12  # Smaller overlay to ensure it stays within button bounds
                        # Calculate position relative to button's parent, centered on button
                        x = btn_pos.x() + (btn_size.width() - overlay_size) // 2
                        y = btn_pos.y() + (btn_size.height() - overlay_size) // 2
                        # Ensure overlay stays within button bounds
                        x = max(btn_pos.x(), min(x, btn_pos.x() + btn_size.width() - overlay_size))
                        y = max(btn_pos.y(), min(y, btn_pos.y() + btn_size.height() - overlay_size))
                        self._repeat_overlay_label_nano.setGeometry(x, y, overlay_size, overlay_size)
                        self._repeat_overlay_label_nano.show()
                        self._repeat_overlay_label_nano.raise_()
                    except (RuntimeError, AttributeError):
                        pass  # Button or overlay might have been deleted
            
            # Update position immediately and on button resize
            QTimer.singleShot(0, update_overlay_position)
            # Also update when button is resized (if button has resizeEvent, we'd need to override it)
            # Use multiple delays to ensure button is fully rendered and positioned
            QTimer.singleShot(50, update_overlay_position)
            QTimer.singleShot(100, update_overlay_position)
            QTimer.singleShot(200, update_overlay_position)
        else:
            # Ensure overlay is removed for other modes
            if hasattr(self, '_repeat_overlay_label_nano') and self._repeat_overlay_label_nano:
                self._repeat_overlay_label_nano.hide()
        
    def showEvent(self, event):
        """Handle window show event - update hover area if needed."""
        super().showEvent(event)
        # Ensure window stays in taskbar (Window flag should keep it there)
        # No need to change flags - they're already set correctly in __init__
        # Update repeat overlay when window is shown (in case mode changed while hidden)
        if hasattr(self, 'parent_window') and self.parent_window:
            if hasattr(self.parent_window, 'playlist_sidebar') and self.parent_window.playlist_sidebar:
                repeat_mode = getattr(self.parent_window.playlist_sidebar, 'repeat_mode', 0)
                if hasattr(self, '_update_repeat_overlay_nano'):
                    self._update_repeat_overlay_nano(repeat_mode)
        
        # Reset autohidden state when window is shown
        self._is_autohidden = False
        # Show cover art when window is shown (in case it was hidden during autohide)
        if hasattr(self, 'cover_art_label') and self.cover_art_label:
            self.cover_art_label.show()
        
        # Check if window is off-screen or in sliver position (was autohidden) and restore to valid position
        screen = QApplication.primaryScreen()
        if screen:
            screen_geometry = screen.geometry()
            current_pos = self.pos()
            window_height = self.height()
            sliver_size = 2
            
            # Check if window is way off-screen (more than 1000px to the right) OR in sliver position
            is_off_screen = current_pos.x() > screen_geometry.right() + 1000
            is_in_sliver = False
            
            # Check if window is in sliver position (only 1px visible at edge)
            if self._docked_edge == 'top':
                # Window is in sliver if it's positioned so only top 1px is visible
                expected_sliver_y = screen_geometry.top() - window_height + sliver_size
                is_in_sliver = abs(current_pos.y() - expected_sliver_y) < 5  # Allow 5px tolerance
            elif self._docked_edge == 'bottom':
                # Window is in sliver if it's positioned so only bottom 1px is visible
                expected_sliver_y = screen_geometry.bottom() - sliver_size
                is_in_sliver = abs(current_pos.y() - expected_sliver_y) < 5  # Allow 5px tolerance
            
            if is_off_screen or is_in_sliver:
                # Window is off-screen or in sliver position, restore to docked position or saved position
                if hasattr(self, '_autohide_saved_pos') and self._autohide_saved_pos is not None:
                    self.move(self._autohide_saved_pos)
                    self._autohide_saved_pos = None
                elif self._docked_edge and self._docked_y_position is not None:
                    # Restore to docked position
                    if self._docked_edge == 'top':
                        self.move(self.x(), screen_geometry.top())
                    elif self._docked_edge == 'bottom':
                        self.move(self.x(), screen_geometry.bottom() - self.height())
                else:
                    # No saved position and not docked - restore to a visible position
                    # Use saved position from settings or default position
                    if self.parent_window:
                        saved_pos = self.parent_window.settings.get("nano_player_position", None)
                        if saved_pos and len(saved_pos) == 2:
                            self.move(saved_pos[0], saved_pos[1])
                        else:
                            # Default to center of screen
                            self.move(
                                screen_geometry.center().x() - self.width() // 2,
                                screen_geometry.center().y() - self.height() // 2
                            )
        
        # Clear any saved position (window is now visible, don't restore old position)
        if hasattr(self, '_autohide_saved_pos'):
            self._autohide_saved_pos = None
        
        # Check if window is at a screen edge and should be docked (only if not already docked)
        # Use a small delay to ensure window geometry is fully calculated
        if not self._docked_edge:
            def check_dock_on_startup():
                screen = QApplication.primaryScreen()
                if not screen:
                    return
                
                screen_geometry = screen.availableGeometry()
                window_geometry = self.frameGeometry()
                
                # Calculate distances to edges
                dist_to_top = abs(window_geometry.top() - screen_geometry.top())
                dist_to_bottom = abs(window_geometry.bottom() - screen_geometry.bottom())
                
                # Check which edge is closer and dock to it if within threshold
                if dist_to_top < self._snap_threshold and dist_to_top <= dist_to_bottom:
                    # Dock to top edge
                    self.move(window_geometry.left(), screen_geometry.top())
                    self._docked_edge = 'top'
                    self._docked_y_position = screen_geometry.top()
                    # Start autohide timer if enabled
                    if self.nano_autohide_when_docked:
                        self._autohide_timer.start()
                elif dist_to_bottom < self._snap_threshold:
                    # Dock to bottom edge
                    self.move(window_geometry.left(), screen_geometry.bottom() - window_geometry.height())
                    self._docked_edge = 'bottom'
                    self._docked_y_position = screen_geometry.bottom() - window_geometry.height()
                    # Start autohide timer if enabled
                    if self.nano_autohide_when_docked:
                        self._autohide_timer.start()
            
            # Small delay to ensure window geometry is fully calculated
            QTimer.singleShot(100, check_dock_on_startup)
        
        # Set cooldown to prevent autohide from triggering immediately after window is shown
        # Use longer cooldown (2 seconds) to ensure window stays visible
        self._autohide_cooldown = True
        QTimer.singleShot(2000, lambda: setattr(self, '_autohide_cooldown', False))  # 2 second cooldown
        
        if self._docked_edge and self.nano_autohide_when_docked and not self._is_autohidden:
            # Hide hover area when window is shown
            if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
                self._autohide_hover_area.hide()
    
    def _save_nano_position(self):
        """Save nano player position and size to settings."""
        if not self.parent_window:
            return
        
        try:
            # Save position
            pos = self.pos()
            self.parent_window.settings['nano_player_position'] = [pos.x(), pos.y()]
            
            # Save size
            size = self.size()
            self.parent_window.settings['nano_player_size'] = f"{size.width()}x{size.height()}"
            
            # Save autohide settings
            self.parent_window.settings['nano_autohide_when_docked'] = self.nano_autohide_when_docked
            self.parent_window.settings['nano_autohide_sensitivity'] = self.nano_autohide_sensitivity
            
            self.parent_window.save_settings()
        except Exception as e:
            logger.debug(f"Error saving nano player position: {e}")
    
    def moveEvent(self, event):
        """Handle window move event - save position when moved."""
        super().moveEvent(event)
        # Save position when window is moved (debounced to avoid too many saves)
        if not hasattr(self, '_position_save_timer'):
            self._position_save_timer = QTimer(self)
            self._position_save_timer.setSingleShot(True)
            self._position_save_timer.timeout.connect(self._save_nano_position)
        
        # Debounce saves - only save after 500ms of no movement
        self._position_save_timer.stop()
        self._position_save_timer.start(500)
    
    def hideEvent(self, event):
        """Handle window hide event - show hover area if autohidden, and save position."""
        super().hideEvent(event)
        if self._docked_edge and self.nano_autohide_when_docked and self._is_autohidden:
            # Show hover area when window is hidden
            self._update_autohide_hover_area()
        
        # Save position when hidden (e.g., when switching back to main interface)
        self._save_nano_position()
    
    def closeEvent(self, event):
        """Handle window close - save position and size, and close entire app."""
        # Clean up hover area
        if hasattr(self, '_autohide_hover_area') and self._autohide_hover_area:
            self._autohide_hover_area.hide()
            self._autohide_hover_area.deleteLater()
            self._autohide_hover_area = None
        
        # Save position before closing
        self._save_nano_position()
        
        # Close entire app (same as close on main window)
        if self.parent_window:
            self.parent_window.close()
        
        super().closeEvent(event)


if __name__ == "__main__":
    # CRITICAL: Allocate console FIRST on Windows (before any other operations)
    # This is essential for Windows 10 when double-clicking .py files
    # Double-clicking may use pythonw.exe (no console), causing silent failures
    # BUT: Skip console allocation in launcher mode (console is intentionally freed)
    _console_allocated = False
    launcher_mode = os.environ.get('BANDCAMP_PLAYER_LAUNCHER') == '1'
    
    if sys.platform == "win32" and not launcher_mode:
        try:
            import ctypes
            kernel32 = ctypes.windll.kernel32
            user32 = ctypes.windll.user32
            
            # Check if we have a console window
            hwnd = kernel32.GetConsoleWindow()
            
            # If no console exists, try to allocate one
            # This happens when double-clicking .py files on Windows 10
            # or when using pythonw.exe
            if not hwnd:
                # FreeConsole first if attached to parent console
                try:
                    kernel32.FreeConsole()
                except:
                    pass
                
                # Allocate a new console
                if kernel32.AllocConsole():
                    _console_allocated = True
                    # Redirect stdout/stderr to the new console
                    import msvcrt
                    import io
                    try:
                        # Reopen stdout/stderr
                        sys.stdout = io.TextIOWrapper(io.BufferedWriter(io.FileIO(1, 'wb')), encoding='utf-8', line_buffering=True)
                        sys.stderr = io.TextIOWrapper(io.BufferedWriter(io.FileIO(2, 'wb')), encoding='utf-8', line_buffering=True)
                    except:
                        # Fallback: use CONOUT$
                        try:
                            sys.stdout = open('CONOUT$', 'w', encoding='utf-8')
                            sys.stderr = open('CONOUT$', 'w', encoding='utf-8')
                        except:
                            pass  # If even this fails, continue anyway
                    
                    # Show the console window
                    hwnd = kernel32.GetConsoleWindow()
                    if hwnd:
                        user32.ShowWindow(hwnd, 1)  # SW_SHOWNORMAL
                        # Print a message so user knows console is available
                        print("Bandcamp Player - Console allocated for error messages", file=sys.stderr)
        except Exception:
            pass  # Continue even if console allocation fails
    
    # CRITICAL: Change to script directory (after console is available for errors)
    # This is essential for Windows 10 when double-clicking .py files
    # The working directory might not be the script's directory
    try:
        if hasattr(sys, 'frozen'):
            # Running as compiled executable
            script_dir = Path(sys.executable).resolve().parent
        elif __file__:
            # Running as script - use __file__ to get script directory
            script_dir = Path(__file__).resolve().parent
        else:
            # Fallback to current directory
            script_dir = Path(os.getcwd())
        
        # Change to script directory if we're not already there
        current_dir = Path(os.getcwd()).resolve()
        if current_dir != script_dir:
            os.chdir(str(script_dir))
            # Use print instead of logger since logger might not be initialized yet
            try:
                logger.debug(f"Changed working directory from {current_dir} to {script_dir}")
            except:
                pass  # Logger not initialized yet - that's okay
    except Exception as e:
        # Log but continue - some operations might still work
        try:
            logger.warning(f"Could not change to script directory: {e}")
        except:
            # Logger not initialized - print to stderr as fallback
            try:
                print(f"Warning: Could not change to script directory: {e}", file=sys.stderr)
            except:
                pass  # Even stderr might not be available
    
    # CRITICAL for Windows 10: Ensure we have a way to show errors
    # If running with pythonw.exe (no console), we need Qt available to show error dialogs
    _error_dialog_available = False
    try:
        from PyQt6.QtWidgets import QApplication, QMessageBox
        _error_dialog_available = True
    except:
        pass  # Qt not available yet - will try again later
    
    # Wrap everything in try-except to catch import errors and early crashes
    # This is critical for Windows 10 where errors might be silent
    try:
        # Try to run main()
        main()
    except KeyboardInterrupt:
        sys.exit(0)
    except SystemExit:
        raise  # Re-raise SystemExit
    except ImportError as e:
        # Import errors are critical - show immediately
        import traceback
        error_msg = f"Import error: {str(e)}\n\nThis usually means a required module is missing.\n\n{traceback.format_exc()}"
        
        # Try to show error dialog
        try:
            if not _error_dialog_available:
                from PyQt6.QtWidgets import QApplication, QMessageBox
                app = QApplication.instance()
                if app is None:
                    app = QApplication(sys.argv)
                _error_dialog_available = True
            
            if _error_dialog_available:
                msg_box = QMessageBox()
                msg_box.setIcon(QMessageBox.Icon.Critical)
                msg_box.setWindowTitle("Import Error")
                msg_box.setText(f"Failed to import required module:\n\n{str(e)}\n\nPlease install dependencies:\npip install -r requirements.txt")
                msg_box.setDetailedText(traceback.format_exc())
                msg_box.exec()
        except:
            # Fallback to console/file
            pass
        
        # Also try to save to file and print
        try:
            script_dir = Path(__file__).parent if __file__ else Path.cwd()
            logs_dir = script_dir / "Logs"
            logs_dir.mkdir(exist_ok=True)
            error_log_file = logs_dir / "crash_log.txt"
            import time
            with open(error_log_file, 'a', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write(f"IMPORT ERROR - {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("=" * 80 + "\n")
                f.write(error_msg + "\n")
                f.write("=" * 80 + "\n\n")
        except:
            pass
        
        # Print to console if available
        try:
            print("=" * 60, file=sys.stderr)
            print("IMPORT ERROR - Bandcamp Player Failed to Start", file=sys.stderr)
            print("=" * 60, file=sys.stderr)
            print(error_msg, file=sys.stderr)
            print("=" * 60, file=sys.stderr)
        except:
            pass
        
        # Keep console open on Windows so user can read error
        if sys.platform == "win32":
            try:
                input("\nPress Enter to exit...")
            except:
                import time
                time.sleep(5)  # Wait so user can read error
        
        sys.exit(1)
    except Exception as e:
        # Catch ALL other errors including import errors
        import traceback
        error_msg = f"Fatal error: {str(e)}\n\n{traceback.format_exc()}"
        
        # Save error to log file
        try:
            script_dir = Path(__file__).parent if __file__ else Path.cwd()
            logs_dir = script_dir / "Logs"
            logs_dir.mkdir(exist_ok=True)
            error_log_file = logs_dir / "crash_log.txt"
            import time
            with open(error_log_file, 'a', encoding='utf-8') as f:
                f.write("=" * 80 + "\n")
                f.write(f"STARTUP CRASH - {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("=" * 80 + "\n")
                f.write(error_msg + "\n")
                f.write("=" * 80 + "\n\n")
        except Exception as log_error:
            print(f"Warning: Could not write to crash log: {log_error}", file=sys.stderr)
        
        # Always print to console first (Windows 10 visibility)
        print("=" * 60, file=sys.stderr)
        print("FATAL ERROR - Bandcamp Player Failed to Start", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        print(error_msg, file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        try:
            print(f"\nError has been saved to: {error_log_file}", file=sys.stderr)
        except:
            print("\nError has been saved to: Logs/crash_log.txt", file=sys.stderr)
        print("=" * 60, file=sys.stderr)
        
        # Try to show error dialog if Qt is available
        try:
            from PyQt6.QtWidgets import QApplication, QMessageBox
            app = QApplication.instance()
            if app is None:
                app = QApplication(sys.argv)
            
            msg_box = QMessageBox()
            msg_box.setIcon(QMessageBox.Icon.Critical)
            msg_box.setWindowTitle("Fatal Error")
            msg_box.setText(f"Failed to start Bandcamp Player:\n\n{str(e)}")
            msg_box.setDetailedText(traceback.format_exc())
            msg_box.exec()
        except Exception:
            # Qt not available - console message already printed above
            pass
        
        # Keep console open on Windows so user can read error
        if sys.platform == "win32":
            try:
                input("\nPress Enter to exit...")
            except:
                import time
                time.sleep(5)  # Wait so user can read error
        
        sys.exit(1)
